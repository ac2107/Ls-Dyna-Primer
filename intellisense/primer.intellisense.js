var Accelerometer = function() {
    /// <signature>
    /// <summary>Create a new Seatbelt Accelerometer object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that accelerometer will be created in</param>
    /// <param name="sbacid" type="Number" optional="false">Accelerometer number. Also see the label property which is an alternative name for this.</param>
    /// <param name="nid1" type="Number" optional="false">Node number 1</param>
    /// <param name="nid2" type="Number" optional="false">Node number 2</param>
    /// <param name="nid3" type="Number" optional="false">Node number 3</param>
    /// <param name="igrav" type="Number" optional="true">Gravitational acceleration due to body force loads is included in acceleration output if igrav is 0, removed if igrav is 1.</param>
    /// <param name="intopt" type="Number" optional="true">Integration option; velocities are integrated from global accelerations and transformed into local system if intopt is 0, they are integrated directly from local accelerations if intopt is 1.</param>
    /// <param name="mass" type="Number" optional="true">Optional added mass for accelerometer</param>
    /// <returns type="Accelerometer"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the accelerometer</field>
    /// <field name='exists' static='false' type='Boolean'>true if accelerometer exists, false if referred to but not defined. (read only)</field>
    /// <field name='igrav' static='false' type='Number'>Gravitational acceleration due to body force loads is included in acceleration output if igrav is 0, removed if igrav is 1.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the accelerometer is in.</field>
    /// <field name='intopt' static='false' type='Number'>Integration option; velocities are integrated from global accelerations and transformed into local system if intopt is 0, they are integrated directly from local accelerations if intopt is 1.</field>
    /// <field name='label' static='false' type='Number'>Accelerometer number. Also see the sbacid property which is an alternative name for this.</field>
    /// <field name='mass' static='false' type='Number'>Optional added mass for accelerometer</field>
    /// <field name='model' static='false' type='Number'>The Model number that the accelerometer is in.</field>
    /// <field name='nid1' static='false' type='Number'>Node number 1</field>
    /// <field name='nid2' static='false' type='Number'>Node number 2</field>
    /// <field name='nid3' static='false' type='Number'>Node number 3</field>
    /// <field name='sbacid' static='false' type='Number'>Accelerometer number. Also see the label property which is an alternative name for this.</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the accelerometer (0-100) 0% is opaque, 100% is transparent.</field>
}

Accelerometer.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the accelerometer</summary>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the accelerometers in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all accelerometers will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged accelerometers in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged accelerometers will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the accelerometers that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the accelerometer is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Accelerometer.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the accelerometer.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the accelerometer</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the accelerometer.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Accelerometer"/>
    /// </signature>
}

Accelerometer.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a accelerometer.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the accelerometer will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Accelerometer"/>
    /// </signature>
}

Accelerometer.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for accelerometer. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for accelerometer. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the accelerometer colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the accelerometer.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Accelerometer.First = function() {
    /// <signature>
    /// <summary>Returns the first accelerometer in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first accelerometer in</param>
    /// <returns type="Accelerometer"/>
    /// </signature>
}

Accelerometer.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free accelerometer label in the model. Also see Accelerometer.LastFreeLabel(), Accelerometer.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free accelerometer label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Accelerometer.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the accelerometers in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all accelerometers will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the accelerometers</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the accelerometer is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the accelerometer</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Accelerometer.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each accelerometer in the model. Note that ForEach has been designed to make looping over accelerometers as fast as possible and so has some limitations. Firstly, a single temporary Accelerometer object is created and on each function call it is updated with the current accelerometer data. This means that you should not try to store the Accelerometer object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new accelerometers inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all accelerometers are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each accelerometer</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Accelerometer objects for all of the accelerometers in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get accelerometers from</param>
    /// <returns type="Array" elementType="Accelerometer"/>
    /// </signature>
}

Accelerometer.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Accelerometer objects for all of the flagged accelerometers in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get accelerometers from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the accelerometers that you want to retrieve</param>
    /// <returns type="Array" elementType="Accelerometer"/>
    /// </signature>
}

Accelerometer.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Accelerometer object for a accelerometer ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the accelerometer in</param>
    /// <param name="number" type="Number" optional="false">number of the accelerometer you want the Accelerometer object for</param>
    /// <returns type="Accelerometer"/>
    /// </signature>
}

Accelerometer.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Accelerometer property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Accelerometer.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">accelerometer property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Accelerometer.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this accelerometer (*ELEMENT_SEATBELT_ACCELEROMETER) Note that a carriage return is not added. See also Accelerometer.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Accelerometer.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the accelerometer. Note that a carriage return is not added. See also Accelerometer.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Accelerometer.Last = function() {
    /// <signature>
    /// <summary>Returns the last accelerometer in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last accelerometer in</param>
    /// <returns type="Accelerometer"/>
    /// </signature>
}

Accelerometer.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free accelerometer label in the model. Also see Accelerometer.FirstFreeLabel(), Accelerometer.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free accelerometer label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Accelerometer.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next accelerometer in the model.</summary>
    /// <returns type="Accelerometer"/>
    /// </signature>
}

Accelerometer.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) accelerometer label in the model. Also see Accelerometer.FirstFreeLabel(), Accelerometer.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free accelerometer label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Accelerometer.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a accelerometer.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only accelerometers from that model can be picked. If the argument is a Flag then only accelerometers that are flagged with limit can be selected. If omitted, or null, any accelerometers from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Accelerometer"/>
    /// </signature>
}

Accelerometer.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous accelerometer in the model.</summary>
    /// <returns type="Accelerometer"/>
    /// </signature>
}

Accelerometer.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the accelerometers in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all accelerometers will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged accelerometers in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged accelerometers will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the accelerometers that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select accelerometers using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting accelerometers</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only accelerometers from that model can be selected. If the argument is a Flag then only accelerometers that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any accelerometers can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Accelerometer.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the accelerometer.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the accelerometer</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the accelerometer. The accelerometer will be sketched until you either call Accelerometer.Unsketch(), Accelerometer.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the accelerometer is sketched. If omitted redraw is true. If you want to sketch several accelerometers and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged accelerometers in the model. The accelerometers will be sketched until you either call Accelerometer.Unsketch(), Accelerometer.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged accelerometers will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the accelerometers that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the accelerometers are sketched. If omitted redraw is true. If you want to sketch flagged accelerometers several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of accelerometers in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing accelerometers should be counted. If false or omitted referenced but undefined accelerometers will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Accelerometer.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the accelerometer</summary>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the accelerometers in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all accelerometers will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged accelerometers in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged accelerometers will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the accelerometers that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the accelerometers in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all accelerometers will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the accelerometers</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the accelerometer.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the accelerometer is unsketched. If omitted redraw is true. If you want to unsketch several accelerometers and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all accelerometers.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all accelerometers will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the accelerometers are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged accelerometers in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all accelerometers will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the accelerometers that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the accelerometers are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Accelerometer"/>
    /// </signature>
}

Accelerometer.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for accelerometer. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Accelerometer.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this accelerometer.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Accelerometer.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the accelerometer data in keyword format. Note that this contains the keyword header and the keyword cards. See also Accelerometer.Keyword() and Accelerometer.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Airbag = function() {
    /// <signature>
    /// <summary>Create a new Airbag object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that airbag will be created in</param>
    /// <param name="type" type="String" optional="false">Airbag type. Can be Airbag.SIMPLE_PRESSURE_VOLUME, Airbag.SIMPLE_AIRBAG_MODEL, Airbag.ADIABATIC_GAS_MODEL, Airbag.WANG_NEFSKE, Airbag.WANG_NEFSKE_JETTING, Airbag.WANG_NEFSKE_MULTIPLE_JETTING, Airbag.LOAD_CURVE, Airbag.LINEAR_FLUID, Airbag.HYBRID, Airbag.HYBRID_JETTING, Airbag.HYBRID_CHEMKIN, Airbag.ALE, Airbag.ADVANCED_ALE or Airbag.PARTICLE</param>
    /// <param name="sid" type="Number" optional="false">Set ID</param>
    /// <param name="sidtyp" type="Number" optional="true">Set type: segment/part set ID</param>
    /// <param name="abid" type="Number" optional="true">Airbag number</param>
    /// <param name="heading" type="String" optional="true">Airbag title</param>
    /// <returns type="Airbag"/>
    /// </signature>
    /// <field name='abid' static='false' type='Number'>Airbag number. Also see the label property which is an alternative name for this.</field>
    /// <field name='cols' static='false' type='Number'>The number of columns of data the airbag has (read only)</field>
    /// <field name='exists' static='false' type='Boolean'>true if airbag exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Boolean'>Turns _ID on or OFF</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the airbag is in.</field>
    /// <field name='label' static='false' type='Number'>Airbag number. Also see the abid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the airbag is in.</field>
    /// <field name='properties' static='false' type='Number'>The total number of properties that the airbag has</field>
    /// <field name='rows' static='false' type='Number'>The number of rows of data the airbag has (read only). This includes the _ID card if it is set.</field>
    /// <field name='title' static='false' type='String'>Airbag title</field>
    /// <field name='type' static='false' type='Number'>Airbag type. Can be Airbag.SIMPLE_PRESSURE_VOLUME, Airbag.SIMPLE_AIRBAG_MODEL, Airbag.ADIABATIC_GAS_MODEL, Airbag.WANG_NEFSKE, Airbag.WANG_NEFSKE_JETTING, Airbag.WANG_NEFSKE_MULTIPLE_JETTING, Airbag.LOAD_CURVE, Airbag.LINEAR_FLUID, Airbag.HYBRID, Airbag.HYBRID_JETTING, Airbag.HYBRID_CHEMKIN, Airbag.ALE, Airbag.ADVANCED_ALE or Airbag.PARTICLE</field>
    /// <field name='ADIABATIC_GAS_MODEL' static='true' type='Number'>Airbag adiabatic gas model type</field>
    /// <field name='ADVANCED_ALE' static='true' type='Number'>Airbag advanced ALE type</field>
    /// <field name='ALE' static='true' type='Number'>Airbag ALE type</field>
    /// <field name='HYBRID' static='true' type='Number'>Airbag hybrid type</field>
    /// <field name='HYBRID_CHEMKIN' static='true' type='Number'>Airbag hybrid chemkin type</field>
    /// <field name='HYBRID_JETTING' static='true' type='Number'>Airbag hybrid jetting type</field>
    /// <field name='LINEAR_FLUID' static='true' type='Number'>Airbag linear fluid type</field>
    /// <field name='LOAD_CURVE' static='true' type='Number'>Airbag load curve type</field>
    /// <field name='PARTICLE' static='true' type='Number'>Airbag particle type</field>
    /// <field name='SIMPLE_AIRBAG_MODEL' static='true' type='Number'>Airbag simple airbag model type</field>
    /// <field name='SIMPLE_PRESSURE_VOLUME' static='true' type='Number'>Airbag simple pressure volume type</field>
    /// <field name='WANG_NEFSKE' static='true' type='Number'>Airbag Wang Nefske type</field>
    /// <field name='WANG_NEFSKE_JETTING' static='true' type='Number'>Airbag Wang Nefske jetting type</field>
    /// <field name='WANG_NEFSKE_MULTIPLE_JETTING' static='true' type='Number'>Airbag Wang Nefske multiple jetting type</field>
}

Airbag.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the airbag.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the airbag</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the airbag.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Airbag"/>
    /// </signature>
}

Airbag.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an airbag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the airbag will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Airbag"/>
    /// </signature>
}

Airbag.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for airbag. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.First = function() {
    /// <signature>
    /// <summary>Returns the first airbag in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first airbag in</param>
    /// <returns type="Airbag"/>
    /// </signature>
}

Airbag.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free airbag label in the model. Also see Airbag.LastFreeLabel(), Airbag.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free airbag label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Airbag.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the airbags in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbags will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the airbags</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the airbag is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the airbag</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Airbag.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each airbag in the model. Note that ForEach has been designed to make looping over airbags as fast as possible and so has some limitations. Firstly, a single temporary Airbag object is created and on each function call it is updated with the current airbag data. This means that you should not try to store the Airbag object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new airbags inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbags are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each airbag</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Airbag objects for all of the airbags in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get airbags from</param>
    /// <returns type="Array" elementType="Airbag"/>
    /// </signature>
}

Airbag.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Airbag objects for all of the flagged airbags in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get airbags from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbags that you want to retrieve</param>
    /// <returns type="Array" elementType="Airbag"/>
    /// </signature>
}

Airbag.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Airbag object for a airbag ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the airbag in</param>
    /// <param name="number" type="Number" optional="false">number of the airbag you want the Airbag object for</param>
    /// <returns type="Airbag"/>
    /// </signature>
}

Airbag.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Airbag property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Airbag.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">airbag property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Airbag.prototype.GetPropertyByIndex = function() {
    /// <signature>
    /// <summary>Returns the value of property at index index for this Airbag object or null if no property exists.</summary>
    /// <param name="index" type="Number" optional="false">The index of the property value to retrieve. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for an airbag may not have adjacent indices.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Airbag.prototype.GetPropertyByName = function() {
    /// <signature>
    /// <summary>Returns the value of property string acronym for this Airbag object or null if no property exists.</summary>
    /// <param name="acronym" type="String" optional="false">The acronym of the property value to retrieve</param>
    /// <returns type="Number"/>
    /// </signature>
}

Airbag.prototype.GetPropertyByRowCol = function() {
    /// <signature>
    /// <summary>Returns the value of the property for row and col for this Airbag object or null if no property exists. Note that columns start at 0. Rows start at 1 if the _ID option is set, at 0 otherwise.</summary>
    /// <param name="row" type="Number" optional="false">The row of the property value to retrieve</param>
    /// <param name="col" type="Number" optional="false">The column of the property value to retrieve</param>
    /// <returns type="Number"/>
    /// </signature>
}

Airbag.prototype.GetPropertyNameForIndex = function() {
    /// <signature>
    /// <summary>Returns the name of the property at index index for this Airbag object or null if there is no property.</summary>
    /// <param name="index" type="Number" optional="false">The index of the property name to retrieve. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for an airbag may not have adjacent indices.</param>
    /// <returns type="String"/>
    /// </signature>
}

Airbag.prototype.GetPropertyNameForRowCol = function() {
    /// <signature>
    /// <summary>Returns the name of the property at row and col for this Airbag object or null if there is no property. Note that columns start at 0. Rows start at 1 if the _ID option is set, at 0 otherwise.</summary>
    /// <param name="row" type="Number" optional="false">The row of the property name to retrieve</param>
    /// <param name="col" type="Number" optional="false">The column of the property name to retrieve</param>
    /// <returns type="String"/>
    /// </signature>
}

Airbag.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this airbag (e.g. *AIRBAG_SIMPLE_PRESSURE_VOLUME, *AIRBAG_SIMPLE_AIRBAG_MODEL etc). Note that a carriage return is not added. See also Airbag.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Airbag.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the airbag. Note that a carriage return is not added. See also Airbag.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Airbag.Last = function() {
    /// <signature>
    /// <summary>Returns the last airbag in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last airbag in</param>
    /// <returns type="Airbag"/>
    /// </signature>
}

Airbag.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free airbag label in the model. Also see Airbag.FirstFreeLabel(), Airbag.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free airbag label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Airbag.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next airbag in the model.</summary>
    /// <returns type="Airbag"/>
    /// </signature>
}

Airbag.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) airbag label in the model. Also see Airbag.FirstFreeLabel(), Airbag.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free airbag label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Airbag.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous airbag in the model.</summary>
    /// <returns type="Airbag"/>
    /// </signature>
}

Airbag.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the airbags in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbags will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged airbags in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged airbags will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbags that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select airbags using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting airbags</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only airbags from that model can be selected. If the argument is a Flag then only airbags that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any airbags can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Airbag.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the airbag.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the airbag</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.SetPropertyByIndex = function() {
    /// <signature>
    /// <summary>Sets the value of property at index index for this Airbag object</summary>
    /// <param name="index" type="Number" optional="false">The index of the property value to set. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for an airbag may not have adjacent indices.</param>
    /// <param name="value" type="Number" optional="false">The value of the property to set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.SetPropertyByName = function() {
    /// <signature>
    /// <summary>Sets the value of property string acronym for this Airbag object</summary>
    /// <param name="acronym" type="String" optional="false">The acronym of the property value to set</param>
    /// <param name="value" type="Number" optional="false">The value of the property to set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.SetPropertyByRowCol = function() {
    /// <signature>
    /// <summary>Sets the value of the property for row and col for this Airbag object. Note that columns start at 0. Rows start at 1 if the _ID option is set, at 0 otherwise.</summary>
    /// <param name="row" type="Number" optional="false">The row of the property value to set</param>
    /// <param name="col" type="Number" optional="false">The column of the property value to set</param>
    /// <param name="value" type="Number" optional="false">The value of the property to set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the airbag. The airbag will be sketched until you either call Airbag.Unsketch(), Airbag.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag is sketched. If omitted redraw is true. If you want to sketch several airbags and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged airbags in the model. The airbags will be sketched until you either call Airbag.Unsketch(), Airbag.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged airbags will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbags that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbags are sketched. If omitted redraw is true. If you want to sketch flagged airbags several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of airbags in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing airbags should be counted. If false or omitted referenced but undefined airbags will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Airbag.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the airbags in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all airbags will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the airbags</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the airbag.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag is unsketched. If omitted redraw is true. If you want to unsketch several airbags and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all airbags.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbags will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbags are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged airbags in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbags will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbags that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbags are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Airbag"/>
    /// </signature>
}

Airbag.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for airbag. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Airbag.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this airbag.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Airbag.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the airbag data in keyword format. Note that this contains the keyword header and the keyword cards. See also Airbag.Keyword() and Airbag.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Attached = function() {
    /// <field name='SINGLE' static='true' type='Number'>Find attached option - find attached through single elements only</field>
    /// <field name='WHOLE' static='true' type='Number'>Find attached option - find through whole attached part</field>
}

Attached.Beam3rdNodes = function() {
    /// <signature>
    /// <summary>Sets the find attached option for beam 3rd nodes on or off</summary>
    /// <param name="Setting" type="Boolean" optional="false">If true beam 3rd nodes are considered for find attached, if false, they are not.</param>
    /// </signature>
}

Attached.BeamPid = function() {
    /// <signature>
    /// <summary>Sets the find attached option for beam pid on or off</summary>
    /// <param name="Setting" type="Boolean" optional="false">If true beam pid's are considered for find attached, if false, they are not.</param>
    /// </signature>
}

Attached.Deformable = function() {
    /// <signature>
    /// <summary>Sets the deformable option for find attached</summary>
    /// <param name="Setting" type="Number" optional="false">Option. Can be Attached.WHOLE, Attached.SINGLE</param>
    /// </signature>
}

Attached.FlagPart = function() {
    /// <signature>
    /// <summary>Sets an option to flag parts after a find attached if any elements within that part are flagged</summary>
    /// <param name="Setting" type="Boolean" optional="false">If true, parts are flagged after a find attached if any elements within that part are flagged, if false, they are not.</param>
    /// </signature>
}

Attached.Recursive = function() {
    /// <signature>
    /// <summary>Sets the find attached option for recursive on or off</summary>
    /// <param name="Setting" type="Boolean" optional="false">If true recursive is on, if false, it is off.</param>
    /// <param name="Number" type="Number" optional="true">Option to set the number of find attached iterations used when the recursive option is set.</param>
    /// </signature>
}

Attached.Rigid = function() {
    /// <signature>
    /// <summary>Sets the rigid option for find attached</summary>
    /// <param name="Setting" type="Number" optional="false">Option. Can be Attached.WHOLE, Attached.SINGLE</param>
    /// </signature>
}

Attached.SetEntity = function() {
    /// <signature>
    /// <summary>Sets entity to be on or off to find attached through.</summary>
    /// <param name="Type" type="String" optional="false">The type of the item to switch on or off (for a list of types see Appendix I of the PRIMER manual).</param>
    /// <param name="Setting" type="Boolean" optional="false">If true you turn the entity switch on, if false you turn it off.</param>
    /// </signature>
}

Attached.TiedContacts = function() {
    /// <signature>
    /// <summary>Sets the find attached option for tied contacts on or off</summary>
    /// <param name="Setting" type="Boolean" optional="false">If true tied contacts are considered for find attached, if false, they are not.</param>
    /// </signature>
}

var AxialForceBeam = function() {
    /// <signature>
    /// <summary>Create a new AxialForceBeam object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that axial force beam will be created in</param>
    /// <param name="bsid" type="Number" optional="false">BeamSet ID.</param>
    /// <param name="lcid" type="Number" optional="false">Loadcurve ID defining preload versus time.</param>
    /// <param name="scale" type="Number" optional="true">Scale factor on curve</param>
    /// <returns type="AxialForceBeam"/>
    /// </signature>
    /// <field name='bsid' static='false' type='Number'>Beam set ID.</field>
    /// <field name='exists' static='false' type='Boolean'>true if axial force beam exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Number'>ID of the axial force beam. Only used in Primer.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the axial force beam is in.</field>
    /// <field name='kbend' static='false' type='Number'>Bending stiffness flag.</field>
    /// <field name='lcid' static='false' type='Number'>Loadcurve ID.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the axial force beam is in.</field>
    /// <field name='scale' static='false' type='Number'>Scale factor on loadcurve.</field>
}

AxialForceBeam.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the axial force beam.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the axial force beam</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the axial force beam.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="AxialForceBeam"/>
    /// </signature>
}

AxialForceBeam.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for axial force beam. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.First = function() {
    /// <signature>
    /// <summary>Returns the first axial force beam in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first axial force beam in</param>
    /// <returns type="AxialForceBeam"/>
    /// </signature>
}

AxialForceBeam.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the axial force beams in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all axial force beams will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the axial force beams</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the axial force beam is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the axial force beam</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

AxialForceBeam.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each axial force beam in the model. Note that ForEach has been designed to make looping over axial force beams as fast as possible and so has some limitations. Firstly, a single temporary AxialForceBeam object is created and on each function call it is updated with the current axial force beam data. This means that you should not try to store the AxialForceBeam object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new axial force beams inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all axial force beams are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each axial force beam</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of AxialForceBeam objects for all of the axial force beams in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get axial force beams from</param>
    /// <returns type="Array" elementType="AxialForceBeam"/>
    /// </signature>
}

AxialForceBeam.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of AxialForceBeam objects for all of the flagged axial force beams in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get axial force beams from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the axial force beams that you want to retrieve</param>
    /// <returns type="Array" elementType="AxialForceBeam"/>
    /// </signature>
}

AxialForceBeam.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the AxialForceBeam object for a axial force beam ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the axial force beam in</param>
    /// <param name="number" type="Number" optional="false">number of the axial force beam you want the AxialForceBeam object for</param>
    /// <returns type="AxialForceBeam"/>
    /// </signature>
}

AxialForceBeam.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a AxialForceBeam property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the AxialForceBeam.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">axial force beam property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

AxialForceBeam.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this axial force beam (*INITIAL_AXIAL_FORCE_BEAM). Note that a carriage return is not added. See also AxialForceBeam.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

AxialForceBeam.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the axial force beam. Note that a carriage return is not added. See also AxialForceBeam.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

AxialForceBeam.Last = function() {
    /// <signature>
    /// <summary>Returns the last axial force beam in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last axial force beam in</param>
    /// <returns type="AxialForceBeam"/>
    /// </signature>
}

AxialForceBeam.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next axial force beam in the model.</summary>
    /// <returns type="AxialForceBeam"/>
    /// </signature>
}

AxialForceBeam.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous axial force beam in the model.</summary>
    /// <returns type="AxialForceBeam"/>
    /// </signature>
}

AxialForceBeam.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select axial force beams using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting axial force beams</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only axial force beams from that model can be selected. If the argument is a Flag then only axial force beams that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any axial force beams can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

AxialForceBeam.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the axial force beam.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the axial force beam</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the axial force beam. The axial force beam will be sketched until you either call AxialForceBeam.Unsketch(), AxialForceBeam.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the axial force beam is sketched. If omitted redraw is true. If you want to sketch several axial force beams and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged axial force beams in the model. The axial force beams will be sketched until you either call AxialForceBeam.Unsketch(), AxialForceBeam.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged axial force beams will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the axial force beams that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the axial force beams are sketched. If omitted redraw is true. If you want to sketch flagged axial force beams several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of axial force beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing axial force beams should be counted. If false or omitted referenced but undefined axial force beams will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

AxialForceBeam.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the axial force beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all axial force beams will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the axial force beams</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the axial force beam.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the axial force beam is unsketched. If omitted redraw is true. If you want to unsketch several axial force beams and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all axial force beams.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all axial force beams will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the axial force beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged axial force beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all axial force beams will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the axial force beams that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the axial force beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="AxialForceBeam"/>
    /// </signature>
}

AxialForceBeam.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for axial force beam. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

AxialForceBeam.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this axial force beam.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

AxialForceBeam.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the axial force data in keyword format. Note that this contains the keyword header and the keyword cards. See also AxialForceBeam.Keyword() and AxialForceBeam.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Beam = function() {
    /// <signature>
    /// <summary>Create a new Beam object. Use either 1, 2 or 3 nodes when creating a new beam.</summary>
    /// <param name="Model" type="Model" optional="false">Model that beam will be created in</param>
    /// <param name="eid" type="Number" optional="false">Beam number</param>
    /// <param name="pid" type="Number" optional="false">Part number</param>
    /// <param name="n1" type="Number" optional="false">Node number 1</param>
    /// <param name="n2" type="Number" optional="false">Node number 2 (optional)</param>
    /// <param name="n3" type="Number" optional="false">Node number 3 (optional)</param>
    /// <returns type="Beam"/>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>Coordinate system ID (_SCALAR)</field>
    /// <field name='cid_1' static='false' type='Number'>Coordinate system ID at node 1 (_SCALR)</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the beam</field>
    /// <field name='d1' static='false' type='Number'>Section parameter 1</field>
    /// <field name='d2' static='false' type='Number'>Section parameter 2</field>
    /// <field name='d3' static='false' type='Number'>Section parameter 3</field>
    /// <field name='d4' static='false' type='Number'>Section parameter 4</field>
    /// <field name='d5' static='false' type='Number'>Section parameter 5</field>
    /// <field name='d6' static='false' type='Number'>Section parameter 6</field>
    /// <field name='dofn1' static='false' type='Number'>Active degree of freedom at node 1 (_SCALAR)</field>
    /// <field name='dofn2' static='false' type='Number'>Active degree of freedom at node 2 (_SCALAR)</field>
    /// <field name='dofns' static='false' type='Number'>Active degrees of freedom at nodes 1 and 2 (_SCALR)</field>
    /// <field name='eid' static='false' type='Number'>Beam number. Also see the label property which is an alternative name for this.</field>
    /// <field name='elbow' static='false' type='Boolean'>If ELBOW option is set. Can be true or false</field>
    /// <field name='exists' static='false' type='Boolean'>true if beam exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the beam is in.</field>
    /// <field name='iner' static='false' type='Number'>Mass moment of inertia for beam</field>
    /// <field name='label' static='false' type='Number'>Beam number. Also see the eid property which is an alternative name for this.</field>
    /// <field name='local' static='false' type='Number'>Coordinate system option</field>
    /// <field name='mn' static='false' type='Number'>Middle Node for elbow beam</field>
    /// <field name='model' static='false' type='Number'>The Model number that the beam is in.</field>
    /// <field name='n1' static='false' type='Number'>Node number 1</field>
    /// <field name='n2' static='false' type='Number'>Node number 2</field>
    /// <field name='n3' static='false' type='Number'>Node number 3</field>
    /// <field name='nodes' static='false' type='Number'>Number of nodes beam has (read only)</field>
    /// <field name='offset' static='false' type='Number'>If _OFFSET option is set. Can be true or false</field>
    /// <field name='orientation' static='false' type='Number'>If _ORIENTATION option is set. Can be true or false</field>
    /// <field name='parm1' static='false' type='Number'>Thickness parameter 1</field>
    /// <field name='parm2' static='false' type='Number'>Thickness parameter 2</field>
    /// <field name='parm3' static='false' type='Number'>Thickness parameter 3</field>
    /// <field name='parm4' static='false' type='Number'>Thickness parameter 4</field>
    /// <field name='parm5' static='false' type='Number'>Thickness parameter 5</field>
    /// <field name='pid' static='false' type='Number'>Part number</field>
    /// <field name='pid1' static='false' type='Number'>Part number 1 for spotweld beam</field>
    /// <field name='pid2' static='false' type='Number'>Part number 2 for spotweld beam</field>
    /// <field name='pid_opt' static='false' type='Boolean'>If _PID option is set. Can be true or false</field>
    /// <field name='rr1' static='false' type='Number'>Rotational release code at node 1</field>
    /// <field name='rr2' static='false' type='Number'>Rotational release code at node 2</field>
    /// <field name='rt1' static='false' type='Number'>Translational release code at node 1</field>
    /// <field name='rt2' static='false' type='Number'>Translational release code at node 2</field>
    /// <field name='scalar' static='false' type='Boolean'>If _SCALAR option is set. Can be true or false</field>
    /// <field name='scalr' static='false' type='Boolean'>If _SCALR option is set. Can be true or false</field>
    /// <field name='section' static='false' type='Boolean'>If _SECTION option is set. Can be true or false</field>
    /// <field name='sn1' static='false' type='Number'>Scalar Node number 1</field>
    /// <field name='sn2' static='false' type='Number'>Scalar Node number 2</field>
    /// <field name='stype' static='false' type='String'>Section type</field>
    /// <field name='thickness' static='false' type='Boolean'>If _THICKNESS option is set. Can be true or false</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the beam (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='vol' static='false' type='Number'>Volume of beam</field>
    /// <field name='vx' static='false' type='Number'>Orientation vector X at node 1</field>
    /// <field name='vy' static='false' type='Number'>Orientation vector Y at node 1</field>
    /// <field name='vz' static='false' type='Number'>Orientation vector Z at node 1</field>
    /// <field name='warpage' static='false' type='Boolean'>If WARPAGE option is set. Can be true or false</field>
    /// <field name='wx1' static='false' type='Number'>Offset vector X at node 1</field>
    /// <field name='wx2' static='false' type='Number'>Offset vector X at node 2</field>
    /// <field name='wy1' static='false' type='Number'>Offset vector Y at node 1</field>
    /// <field name='wy2' static='false' type='Number'>Offset vector Y at node 2</field>
    /// <field name='wz1' static='false' type='Number'>Offset vector Z at node 1</field>
    /// <field name='wz2' static='false' type='Number'>Offset vector Z at node 2</field>
}

Beam.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the beam</summary>
    /// <returns type="null"/>
    /// </signature>
}

Beam.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all beams will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged beams will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the beams that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the beam is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Beam.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the beam.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the beam</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the beam.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Beam"/>
    /// </signature>
}

Beam.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a beam.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the beam will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Beam"/>
    /// </signature>
}

Beam.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.ElemCut = function() {
    /// <signature>
    /// <summary>Returns coordinates of the intersections between a beam and a database cross section.</summary>
    /// <param name="Database cross section label" type="Number" optional="false">The label of the database cross section.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Beam.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for beam. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for beam. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the beam colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the beam.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.FindBeamEnd_#deprecated = function() {
    /// <signature>
    /// <summary>Tidy memory allocation incurred by function which finds beams within a box. Now replaced by model member function Model.FindElemEnd()</summary>
    /// <returns type="null"/>
    /// </signature>
}

Beam.FindBeamInBox = function() {
    /// <signature>
    /// <summary>Returns an array of Beam objects for the beams within a box. This requires a previous (outside loop) call to function FindBeamInit() or m.FindElemInit() where the process is initialized for flagged beams in the model (typically all beams) and m.FindElemEnd() to close the process. Please note this function provides a list of all beams that could potentially be in the box (using computationally cheap bounding box comparison) it is not a rigorous test of whether the beam is actually in the box. See also Beam.FindBeamInit() See also Model.FindElemInit() See also Model.FindElemEnd()</summary>
    /// <param name="Model" type="Model" optional="false">Model designated model</param>
    /// <param name="xmin" type="Number" optional="false">Minimum bound in global x</param>
    /// <param name="xmax" type="Number" optional="false">Maximum bound in global x</param>
    /// <param name="ymin" type="Number" optional="false">Minimum bound in global y</param>
    /// <param name="ymax" type="Number" optional="false">Maximum bound in global y</param>
    /// <param name="zmin" type="Number" optional="false">Minimum bound in global z</param>
    /// <param name="zmax" type="Number" optional="false">Maximum bound in global z</param>
    /// <param name="bflag" type="Number" optional="true">Optional flag to restrict beams considered</param>
    /// <param name="bthick" type="Number" optional="true">Optional flag to consider thickness for beams</param>
    /// <returns type="Array" elementType="Beam"/>
    /// </signature>
}

Beam.FindBeamInit = function() {
    /// <signature>
    /// <summary>Initialize setup so that all flagged beams in model can be tested to see if they are within box. See also Beam.FindBeamInBox() See also Model.FindElemInit() See also Model.FindElemEnd()</summary>
    /// <param name="Model" type="Model" optional="false">Model in which beams have been flagged</param>
    /// <param name="flag" type="Flag" optional="true">Optional flag that has been set on the beams, if unsupplied all beams considered</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.First = function() {
    /// <signature>
    /// <summary>Returns the first beam in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first beam in</param>
    /// <returns type="Beam"/>
    /// </signature>
}

Beam.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free beam label in the model. Also see Beam.LastFreeLabel(), Beam.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free beam label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the beams in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all beams will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the beams</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the beam is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the beam</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Beam.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each beam in the model. Note that ForEach has been designed to make looping over beams as fast as possible and so has some limitations. Firstly, a single temporary Beam object is created and on each function call it is updated with the current beam data. This means that you should not try to store the Beam object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new beams inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all beams are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each beam</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Beam objects for all of the beams in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get beams from</param>
    /// <returns type="Array" elementType="Beam"/>
    /// </signature>
}

Beam.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Beam objects for all of the flagged beams in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get beams from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the beams that you want to retrieve</param>
    /// <returns type="Array" elementType="Beam"/>
    /// </signature>
}

Beam.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Beam object for a beam ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the beam in</param>
    /// <param name="number" type="Number" optional="false">number of the beam you want the Beam object for</param>
    /// <returns type="Beam"/>
    /// </signature>
}

Beam.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Beam property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Beam.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">beam property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Beam.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this beam (*BEAM, *BEAM_SCALAR or *BEAM_SCALAR_VALUE). Note that a carriage return is not added. See also Beam.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Beam.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the beam. Note that a carriage return is not added. See also Beam.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Beam.Last = function() {
    /// <signature>
    /// <summary>Returns the last beam in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last beam in</param>
    /// <returns type="Beam"/>
    /// </signature>
}

Beam.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free beam label in the model. Also see Beam.FirstFreeLabel(), Beam.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free beam label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next beam in the model.</summary>
    /// <returns type="Beam"/>
    /// </signature>
}

Beam.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) beam label in the model. Also see Beam.FirstFreeLabel(), Beam.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free beam label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a beam.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only beams from that model can be picked. If the argument is a Flag then only beams that are flagged with limit can be selected. If omitted, or null, any beams from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Beam"/>
    /// </signature>
}

Beam.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous beam in the model.</summary>
    /// <returns type="Beam"/>
    /// </signature>
}

Beam.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all beams will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged beams will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the beams that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.SectionFacePoints = function() {
    /// <signature>
    /// <summary>Returns the indices of the points for a faces to plot the true section of the beam. Note face numbers start at 0. Beam.SectionPoints must be called before this method.</summary>
    /// <param name="face" type="Number" optional="false">Face to get indices for</param>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.prototype.SectionFaces = function() {
    /// <signature>
    /// <summary>Returns the number of faces to plot the true section of the beam. Beam.SectionPoints must be called before this method.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.prototype.SectionPoints = function() {
    /// <signature>
    /// <summary>Returns the point coordinates to plot the true section of the beam. They are returned in a single array of numbers.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select beams using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting beams</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only beams from that model can be selected. If the argument is a Flag then only beams that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any beams can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the beam.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the beam</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the beam. The beam will be sketched until you either call Beam.Unsketch(), Beam.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the beam is sketched. If omitted redraw is true. If you want to sketch several beams and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged beams in the model. The beams will be sketched until you either call Beam.Unsketch(), Beam.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged beams will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the beams that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the beams are sketched. If omitted redraw is true. If you want to sketch flagged beams several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.TiedNodeCheck = function() {
    /// <signature>
    /// <summary>Checks if nodes of beam are tied by contact or directly attached (non-zero option1)</summary>
    /// <param name="Contact label" type="Number" optional="false">The label of the tied contact. If zero the tied contact is found for the beam by reverse lookup.</param>
    /// <param name="Flag" type="Flag" optional="false">flag bit</param>
    /// <param name="Option1" type="Number" optional="false">Directly tied node (logical OR) 0:NONE 1:NRB/C_EXNO 2:BEAM 4:SHELL 8:SOLID 16:TSHELL</param>
    /// <param name="Option2" type="Number" optional="false">0:No action 1:report error if directly attached node (acc. option1) also captured by contact</param>
    /// <returns type="String"/>
    /// </signature>
}

Beam.prototype.Timestep = function() {
    /// <signature>
    /// <summary>Calculates the timestep for the beam</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing beams should be counted. If false or omitted referenced but undefined beams will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Beam.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the beam</summary>
    /// <returns type="null"/>
    /// </signature>
}

Beam.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all beams will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged beams will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the beams that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all beams will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the beams</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the beam.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the beam is unsketched. If omitted redraw is true. If you want to unsketch several beams and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all beams.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all beams will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all beams will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the beams that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Beam"/>
    /// </signature>
}

Beam.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for beam. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Beam.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this beam.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Beam.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the beam data in keyword format. Note that this contains the keyword header and the keyword cards. See also Beam.Keyword() and Beam.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Belt = function() {
    /// <signature>
    /// <summary>Create a new Belt object.</summary>
    /// <param name="model" type="Model" optional="false">Model that the belt definition will be created in</param>
    /// <param name="id" type="Number" optional="false">Belt number</param>
    /// <param name="title" type="String" optional="true">Title for the belt</param>
    /// <param name="structural_type" type="String" optional="true">Seatbelt will be fitted around this entity type. This will trigger creation of sets as required. Type can be one of MODEL, DUMMY, PART, any ELEMENT subtype such as SHELL, or any SET subtype such as SET_PART. See Appendix I of the PRIMER manual for more information on PRIMER types</param>
    /// <param name="flag" type="Number" optional="true">Flag used to identify entities that the belt should fit around. This argument is ignored if structural_type is MODEL. Instead, the current model is used</param>
    /// <returns type="Belt"/>
    /// </signature>
    /// <field name='acuteAngle' static='false' type='Number'>Limiting angle to be considered "acute" (0 means 90)</field>
    /// <field name='curvature' static='false' type='Number'>Maximum permitted transverse belt curvature in degrees</field>
    /// <field name='elemSet' static='false' type='Number'>Set of shell or 2D seatbelt elements. Only created if the option to generate a contact for the belt is used (read only)</field>
    /// <field name='exists' static='false' type='Boolean'>true if belt exists, false if referred to but not defined. (read only)</field>
    /// <field name='friction' static='false' type='Number'>Transverse friction coefficient</field>
    /// <field name='id' static='false' type='Number'>Belt number. Also see the label property which is an alternative name for this.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the belt is in.</field>
    /// <field name='iterations' static='false' type='Number'>The number of fitting iterations between contact bucket resorts</field>
    /// <field name='label' static='false' type='Number'>Belt number. Also see the id property which is an alternative name for this.</field>
    /// <field name='length' static='false' type='Number'>The characteristic length of each belt element</field>
    /// <field name='meshSegs' static='false' type='Number'>Number of mesh segments defined (read only)</field>
    /// <field name='model' static='false' type='Number'>The Model number that the belt is in.</field>
    /// <field name='n2sContact' static='false' type='Number'>Nodes to Surface contact used between nodes on 1D belt elements and dummy structure. Only used if the option to create a contact between belt and dummy "structure" has been used (read only)</field>
    /// <field name='nodeSet' static='false' type='Number'>Set of all nodes in seatbelt. Only created if the option to generate a contact for the belt is used (read only)</field>
    /// <field name='nrbFirst' static='false' type='Number'>First nodal rigid body ID (read only)</field>
    /// <field name='nrbLast' static='false' type='Number'>Last nodal rigid body ID (read only)</field>
    /// <field name='nsboSet' static='false' type='Number'>Set of nodes on 1D seatbelt elements only. Only created if the option to generate a contact for the belt is used (read only)</field>
    /// <field name='overlap' static='false' type='Number'>Fraction by which facets are extended during contact checking to stop nodes "falling into gaps"</field>
    /// <field name='parts' static='false' type='Number'>Part set ID defining structure. Note that if you are creating the seatbelt definition from scratch in JavaScript you must define a shell, solid or thick shell set.</field>
    /// <field name='penetration' static='false' type='Number'>Maximum penetration distance considered for contact into solid and thick shell elements</field>
    /// <field name='pidShell' static='false' type='Number'>The part ID for any 2D seatbelt elements</field>
    /// <field name='pid_1d' static='false' type='Number'>The part ID for any 1D seatbelt elements</field>
    /// <field name='pid_2d' static='false' type='Number'>The part ID for any 2D seatbelt elements</field>
    /// <field name='points' static='false' type='Number'>Number of path points defined (read only)</field>
    /// <field name='projection' static='false' type='Number'>Initial projection distance by which belt path is "thrown outwards" at start of fitting</field>
    /// <field name='psiShell' static='false' type='Number'>Optional orthotropic angle for any shell elements</field>
    /// <field name='psi_2d' static='false' type='Number'>Optional orthotropic angle for any 2D seatbelt elements</field>
    /// <field name='retractorFirst' static='false' type='Number'>First retractor ID (read only)</field>
    /// <field name='retractorLast' static='false' type='Number'>Last retractor ID (read only)</field>
    /// <field name='rows' static='false' type='Number'>The number of rows of 2D elements across the belt</field>
    /// <field name='s2sContact' static='false' type='Number'>Surface to Surface contact used between shell/2D belt elements and dummy structure. Only used if the option to create a contact between belt and dummy "structure" has been used (read only)</field>
    /// <field name='seatbeltFirst' static='false' type='Number'>First 1D seatbelt ID (read only)</field>
    /// <field name='seatbeltLast' static='false' type='Number'>Last 1D seatbelt ID (read only)</field>
    /// <field name='segments' static='false' type='Number'>Segment set created for contact (read only)</field>
    /// <field name='shells' static='false' type='Number'>Shell set ID defining structure. Note that if you are creating the seatbelt definition from scratch in JavaScript you must define a shell, solid or thick shell set.</field>
    /// <field name='slen_1d' static='false' type='Number'>The initial slack length for any 1D seatbelt elements</field>
    /// <field name='slipringFirst' static='false' type='Number'>First slipring ID (read only)</field>
    /// <field name='slipringLast' static='false' type='Number'>Last slipring ID (read only)</field>
    /// <field name='solids' static='false' type='Number'>Solid set ID defining structure. Note that if you are creating the seatbelt definition from scratch in JavaScript you must define a shell, solid or thick shell set.</field>
    /// <field name='t1Shell' static='false' type='Number'>Optional thickness at n1 for any shell elements</field>
    /// <field name='t1_2d' static='false' type='Number'>Optional thickness at n1 for any 2D seatbelt elements</field>
    /// <field name='t2Shell' static='false' type='Number'>Optional thickness at n2 for any shell elements</field>
    /// <field name='t2_2d' static='false' type='Number'>Optional thickness at n2 for any 2D seatbelt elements</field>
    /// <field name='t3Shell' static='false' type='Number'>Optional thickness at n3 for any shell elements</field>
    /// <field name='t3_2d' static='false' type='Number'>Optional thickness at n3 for any 2D seatbelt elements</field>
    /// <field name='t4Shell' static='false' type='Number'>Optional thickness at n4 for any shell elements</field>
    /// <field name='t4_2d' static='false' type='Number'>Optional thickness at n4 for any 2D seatbelt elements</field>
    /// <field name='thickFactor' static='false' type='Number'>Factor used when thickFlag is 1</field>
    /// <field name='thickFlag' static='false' type='Number'>Thickness used during fitting: 0 (default)=use true thickness; 1=use true thickness x factor; 2=use neutral axis (no thickness)</field>
    /// <field name='thickness' static='false' type='Number'>The thickness of 2D belt elements</field>
    /// <field name='title' static='false' type='String'>Belt title.</field>
    /// <field name='tolerance' static='false' type='Number'>The convergence tolerance at which fitting halts</field>
    /// <field name='tshells' static='false' type='Number'>Thick shell set ID defining structure. Note that if you are creating the seatbelt definition from scratch in JavaScript you must define a shell, solid or thick shell set.</field>
    /// <field name='width' static='false' type='Number'>The overall belt width</field>
    /// <field name='xsectionFirst' static='false' type='Number'>First cross section ID (read only)</field>
    /// <field name='xsectionLast' static='false' type='Number'>Last cross section ID (read only)</field>
    /// <field name='B_POST_SLIPRING' static='true' type='Number'>There is a B-Post slipring at this point.</field>
    /// <field name='FIXED' static='true' type='Number'>Point is fixed</field>
    /// <field name='FREE_SLIPRING' static='true' type='Number'>There is a free (eg pelvis) slipring at this point.</field>
    /// <field name='INSERT_AFTER' static='true' type='Number'>Insert after given path point.</field>
    /// <field name='INSERT_BEFORE' static='true' type='Number'>Insert before given path point.</field>
    /// <field name='KNOWN' static='true' type='Number'>The belt path is known to pass through this point</field>
    /// <field name='MESH_2D_SLIPRING_SET_NODE' static='true' type='Number'>Set meshing start Labels for 2D slipring node sets</field>
    /// <field name='MESH_ALL' static='true' type='Number'>Set meshing start Labels for everything used in the seatbelt definition</field>
    /// <field name='MESH_NODE' static='true' type='Number'>Set meshing start Labels for nodes</field>
    /// <field name='MESH_NRBC' static='true' type='Number'>Set meshing start Labels for nodal rigid bodies</field>
    /// <field name='MESH_RETRACTOR' static='true' type='Number'>Set meshing start Labels for retractors</field>
    /// <field name='MESH_SEATBELT' static='true' type='Number'>Set meshing start Labels for seatbelt elements</field>
    /// <field name='MESH_SET_NODE' static='true' type='Number'>Set meshing start Labels for node sets</field>
    /// <field name='MESH_SET_PART' static='true' type='Number'>Set meshing start Labels for part sets</field>
    /// <field name='MESH_SET_SHELL' static='true' type='Number'>Set meshing start Labels for shell sets</field>
    /// <field name='MESH_SHELL' static='true' type='Number'>Set meshing start Labels for shells</field>
    /// <field name='MESH_SLIPRING' static='true' type='Number'>Set meshing start Labels for slipring elements</field>
    /// <field name='MESH_XSEC' static='true' type='Number'>Set meshing start Labels for Database cross sections</field>
    /// <field name='MSEG_B1_ONLY' static='true' type='Number'>Old style all 1D belt</field>
    /// <field name='MSEG_B2_ONLY' static='true' type='Number'>Old style all 2D belt</field>
    /// <field name='MSEG_BD_NEW' static='true' type='Number'>Indicates new mode. This must be set before any of the new style constants can be used</field>
    /// <field name='MSEG_CE_1D' static='true' type='Number'>New style 1D at centre</field>
    /// <field name='MSEG_E1_1D' static='true' type='Number'>New style 1D at end 1</field>
    /// <field name='MSEG_E1_2D' static='true' type='Number'>New style 2D at end 1</field>
    /// <field name='MSEG_E1_SH' static='true' type='Number'>New style shells at end 1</field>
    /// <field name='MSEG_E2_1D' static='true' type='Number'>New style 1D at end 2</field>
    /// <field name='MSEG_E2_2D' static='true' type='Number'>New style 2D at end 2</field>
    /// <field name='MSEG_E2_SH' static='true' type='Number'>New style shells at end 2</field>
    /// <field name='MSEG_MIX_SB1' static='true' type='Number'>Old style 1D at ends, shells in middle</field>
    /// <field name='MSEG_MIX_SB2' static='true' type='Number'>Old style 2D at ends, shells in middle</field>
    /// <field name='MSEG_SH_ONLY' static='true' type='Number'>Old style all shell belt</field>
    /// <field name='RETRACTOR' static='true' type='Number'>There is a retractor at this point</field>
    /// <field name='SLIPRING' static='true' type='Number'>There is a slipring at this point. (Deprecated from V12 onwards, use FREE_SLIPRING or B_POST_SLIPRING instead)</field>
    /// <field name='TWIST' static='true' type='Number'>Point has twist vectors or twist nodes defined</field>
    /// <field name='XSEC' static='true' type='Number'>There is a database cross section at this point</field>
}

Belt.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the belt</summary>
    /// <returns type="null"/>
    /// </signature>
}

Belt.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the belts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all belts will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged belts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged belts will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the belts that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the belt is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Belt.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the belt.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the belt</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the belt.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Belt"/>
    /// </signature>
}

Belt.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for belt. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.First = function() {
    /// <signature>
    /// <summary>Returns the first belt in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first belt in</param>
    /// <returns type="Belt"/>
    /// </signature>
}

Belt.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free belt label in the model. Also see Belt.LastFreeLabel(), Belt.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free belt label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Belt.prototype.Fit = function() {
    /// <signature>
    /// <summary>(Re)fits belt</summary>
    /// <returns type="null"/>
    /// </signature>
}

Belt.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the belts in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all belts will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the belts</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the belt is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the belt</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Belt.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each belt in the model. Note that ForEach has been designed to make looping over belts as fast as possible and so has some limitations. Firstly, a single temporary Belt object is created and on each function call it is updated with the current belt data. This means that you should not try to store the Belt object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new belts inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all belts are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each belt</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.Generate = function() {
    /// <signature>
    /// <summary>Generates belt mesh. Extracts and uses existing mesh properties when a mesh is present; inserts a default mesh otherwise.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Belt.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Belt objects for all of the belts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get belts from</param>
    /// <returns type="Array" elementType="Belt"/>
    /// </signature>
}

Belt.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Belt objects for all of the flagged belts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get belts from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the belts that you want to retrieve</param>
    /// <returns type="Array" elementType="Belt"/>
    /// </signature>
}

Belt.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Belt object for a belt ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the belt in</param>
    /// <param name="number" type="Number" optional="false">number of the belt you want the Belt object for</param>
    /// <returns type="Belt"/>
    /// </signature>
}

Belt.prototype.GetMesh = function() {
    /// <signature>
    /// <summary>Returns the information for a belt mesh section (properties base_pt1, base_pt2, path_pt1, path_pt2, mode, lb1, lb2). See Belt.SetMesh() for more information on supported properties. Must be preceded by a call to Belt.Generate().</summary>
    /// <param name="index" type="Number" optional="false">The index of the mesh section you want the information for. Note that mesh segments start at 0, not 1. 0 &lt;= index &lt; meshSegs</param>
    /// <returns type="Object"/>
    /// </signature>
}

Belt.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Belt property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Belt.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">belt property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Belt.prototype.GetPoint = function() {
    /// <signature>
    /// <summary>Returns the information for a path point (properties fixity, x, y, z, node, trx1, try1, trz1, tnx1, tny1, tnz1, tnode1, trx2, try2, trz2, tnx2, tny2, tnz2, tnode2). Properties fixity, x, y, z and node will always be returned. Twist properties trx1, try1, trz1, tnx1, tny1, tnz1, tnode1, trx2, try2, trz2, tnx2, tny2, tnz2 and tnode2 will only be returned if defined for the point.</summary>
    /// <param name="index" type="Number" optional="false">The index of the path point you want the information for. Note that path points start at 0, not 1. 0 &lt;= index &lt; points</param>
    /// <returns type="Object"/>
    /// </signature>
}

Belt.prototype.InsertPoint = function() {
    /// <signature>
    /// <summary>Inserts a path point before/after an existing one. Subsequent path points will be moved 'up' as required.</summary>
    /// <param name="index" type="Number" optional="false">The index of an existing path point. Note that path points start at 0, not 1. 0 &lt;= index &lt; points</param>
    /// <param name="position" type="Number" optional="false">Do we want to insert before or after the path point denoted by index? The position can be Belt.INSERT_AFTER or Belt.INSERT_BEFORE</param>
    /// <param name="data" type="Object" optional="false">Object containing the path point data.</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.Last = function() {
    /// <signature>
    /// <summary>Returns the last belt in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last belt in</param>
    /// <returns type="Belt"/>
    /// </signature>
}

Belt.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free belt label in the model. Also see Belt.FirstFreeLabel(), Belt.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free belt label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Belt.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next belt in the model.</summary>
    /// <returns type="Belt"/>
    /// </signature>
}

Belt.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) belt label in the model. Also see Belt.FirstFreeLabel(), Belt.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free belt label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Belt.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a belt.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only belts from that model can be picked. If the argument is a Flag then only belts that are flagged with limit can be selected. If omitted, or null, any belts from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Belt"/>
    /// </signature>
}

Belt.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous belt in the model.</summary>
    /// <returns type="Belt"/>
    /// </signature>
}

Belt.prototype.RemovePoint = function() {
    /// <signature>
    /// <summary>Removes a path point from a belt</summary>
    /// <param name="index" type="Number" optional="false">The index of the path point you want to remove. Note that path points start at 0, not 1. 0 &lt;= index &lt; points</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the belts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all belts will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged belts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged belts will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the belts that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select belts using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting belts</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only belts from that model can be selected. If the argument is a Flag then only belts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any belts can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Belt.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the belt.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the belt</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.SetMesh = function() {
    /// <signature>
    /// <summary>Sets the data for various properties for a mesh section in a belt. Values for properties not invoked will be retained as is. Must be preceded by a call to Belt.Generate()</summary>
    /// <param name="index" type="Number" optional="false">The index of the mesh section</param>
    /// <param name="data" type="Object" optional="false">Object containing the mesh section data.</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.SetMeshingLabels = function() {
    /// <signature>
    /// <summary>Set the start labels for the entities created for a Seat Belt.</summary>
    /// <param name="entity_type" type="Number" optional="false">The Meshing label can be Belt.MESH_NODE,  Belt.MESH_SHELL, Belt.MESH_SET_NODE, Belt.MESH_SET_NODE, Belt.MESH_SEATBELT, Belt.MESH_NRBC, BELT.MESH_RETRACTOR, Belt.MESH_XSEC, Belt.MESH_SLIPRING, Belt.MESH_SET_PART, Belt.MESH_2D_SLIPRING_SET_NODE, Belt.MESH_ALL.</param>
    /// <param name="label_value" type="Number" optional="false">The intial label value to be assigned for the entity type.</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.SetPoint = function() {
    /// <signature>
    /// <summary>Sets the data for a path point in a belt</summary>
    /// <param name="index" type="Number" optional="false">The index of the path point you want to set. Note that path points start at 0, not 1. To add a new point use index points</param>
    /// <param name="data" type="Object" optional="false">Object containing the path point data.</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the belt. The belt will be sketched until you either call Belt.Unsketch(), Belt.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the belt is sketched. If omitted redraw is true. If you want to sketch several belts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged belts in the model. The belts will be sketched until you either call Belt.Unsketch(), Belt.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged belts will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the belts that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the belts are sketched. If omitted redraw is true. If you want to sketch flagged belts several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of belts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing belts should be counted. If false or omitted referenced but undefined belts will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Belt.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the belt</summary>
    /// <returns type="null"/>
    /// </signature>
}

Belt.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the belts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all belts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged belts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged belts will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the belts that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the belts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all belts will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the belts</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the belt.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the belt is unsketched. If omitted redraw is true. If you want to unsketch several belts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all belts.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all belts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the belts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged belts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all belts will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the belts that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the belts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Belt"/>
    /// </signature>
}

Belt.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for belt. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Belt.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this belt.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

var Box = function() {
    /// <signature>
    /// <summary>Create a new Box object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that box will be created in</param>
    /// <param name="bid" type="Number" optional="false">Box number</param>
    /// <param name="xmn" type="Number" optional="false">Minimum X coordinate</param>
    /// <param name="xmx" type="Number" optional="false">Maximum X coordinate</param>
    /// <param name="ymn" type="Number" optional="false">Minimum Y coordinate</param>
    /// <param name="ymx" type="Number" optional="false">Maximum Y coordinate</param>
    /// <param name="zmn" type="Number" optional="false">Minimum Z coordinate</param>
    /// <param name="zmx" type="Number" optional="false">Maximum Z coordinate</param>
    /// <param name="heading" type="String" optional="true">Title for the box</param>
    /// <returns type="Box"/>
    /// </signature>
    /// <field name='bid' static='false' type='Number'>Box number. Also see the label property which is an alternative name for this.</field>
    /// <field name='brmax' static='false' type='Number'>Maximum mesh size in 3D tetrahedron adaptivity</field>
    /// <field name='brmin' static='false' type='Number'>Minimum mesh size in 3D tetrahedron adaptivity</field>
    /// <field name='cid' static='false' type='Number'>Optional coordinate system ID for tubular drawbead</field>
    /// <field name='cx' static='false' type='Number'>X coordinate of offset vector to local origin</field>
    /// <field name='cy' static='false' type='Number'>Y coordinate of offset vector to local origin</field>
    /// <field name='cz' static='false' type='Number'>Z coordinate of offset vector to local origin</field>
    /// <field name='exists' static='false' type='Boolean'>true if box exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>Box heading</field>
    /// <field name='idir' static='false' type='Number'>Direction of tooling movement. 1: x-direction, 2: y-direction, 3: z-direction</field>
    /// <field name='iflag' static='false' type='Number'>Element protection flag. 0: elements inside, 1: elements outside box cannot be coarsened.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the box is in.</field>
    /// <field name='label' static='false' type='Number'>Box number. Also see the bid property which is an alternative name for this.</field>
    /// <field name='lcid' static='false' type='Number'>Load curve ID to describe motion value versus time</field>
    /// <field name='level' static='false' type='Number'>Maximum number of refinement levels for elements contained in box</field>
    /// <field name='lidx' static='false' type='Number'>Box movement in global X axis or by node. The ndid property is an alternative name for this.</field>
    /// <field name='lidy' static='false' type='Number'>Box movement in global Y axis</field>
    /// <field name='lidz' static='false' type='Number'>Box movement in global Z axis</field>
    /// <field name='local' static='false' type='Boolean'>Turns _LOCAL on or off</field>
    /// <field name='model' static='false' type='Number'>The Model number that the box is in.</field>
    /// <field name='ndid' static='false' type='Number'>Box movement in global X axis or by node. The lidx property is an alternative name for this.</field>
    /// <field name='nid' static='false' type='Number'>Referential nodal ID for vd = 2</field>
    /// <field name='option' static='false' type='Number'>The box option. Can be Box.BOX, Box.BOX_ADAPTIVE, Box.BOX_COARSEN, Box.BOX_DRAWBEAD or Box.BOX_SPH.</field>
    /// <field name='pid_adaptive' static='false' type='Number'>Part ID for Box.BOX_ADAPTIVE option</field>
    /// <field name='pid_drawbead' static='false' type='Number'>Part ID of blank for Box.BOX_DRAWBEAD option</field>
    /// <field name='radius' static='false' type='Number'>Radius of tube centered around draw bead</field>
    /// <field name='sid' static='false' type='Number'>Part set, part or node set defining the nodal points along draw bead</field>
    /// <field name='stype' static='false' type='Number'>Set type for stype. 2: part set ID, 3: part ID, 4: node set ID</field>
    /// <field name='vd' static='false' type='Number'>Velocity/Displacement flag. 0: velocity, 1: displacement, 2: referential node</field>
    /// <field name='vid' static='false' type='Number'>Vector ID of DOF</field>
    /// <field name='xmn' static='false' type='Number'>Minimum X coordinate</field>
    /// <field name='xmx' static='false' type='Number'>Maximum X coordinate</field>
    /// <field name='xv' static='false' type='Number'>Local V vector X coordinate</field>
    /// <field name='xx' static='false' type='Number'>Local X vector X coordinate</field>
    /// <field name='ymn' static='false' type='Number'>Minimum Y coordinate</field>
    /// <field name='ymx' static='false' type='Number'>Maximum Y coordinate</field>
    /// <field name='yv' static='false' type='Number'>Local V vector Y coordinate</field>
    /// <field name='yx' static='false' type='Number'>Local X vector Y coordinate</field>
    /// <field name='zmn' static='false' type='Number'>Minimum Z coordinate</field>
    /// <field name='zmx' static='false' type='Number'>Maximum Z coordinate</field>
    /// <field name='zv' static='false' type='Number'>Local V vector Z coordinate</field>
    /// <field name='zx' static='false' type='Number'>Local X vector Z coordinate</field>
    /// <field name='BOX' static='true' type='Number'>Box is *DEFINE_BOX.</field>
    /// <field name='BOX_ADAPTIVE' static='true' type='Number'>Box is *DEFINE_BOX_ADAPTIVE.</field>
    /// <field name='BOX_COARSEN' static='true' type='Number'>Box is *DEFINE_BOX_COARSEN.</field>
    /// <field name='BOX_DRAWBEAD' static='true' type='Number'>Box is *DEFINE_BOX_DRAWBEAD.</field>
    /// <field name='BOX_SPH' static='true' type='Number'>Box is *DEFINE_BOX_SPH.</field>
}

Box.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the box</summary>
    /// <returns type="null"/>
    /// </signature>
}

Box.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boxs will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the box is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Box.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the box.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the box</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the box.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Box"/>
    /// </signature>
}

Box.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a box.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the box will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Box"/>
    /// </signature>
}

Box.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for box. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.First = function() {
    /// <signature>
    /// <summary>Returns the first box in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first box in</param>
    /// <returns type="Box"/>
    /// </signature>
}

Box.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free box label in the model. Also see Box.LastFreeLabel(), Box.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free box label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Box.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the boxs in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the boxs</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the box is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the box</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Box.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each box in the model. Note that ForEach has been designed to make looping over boxs as fast as possible and so has some limitations. Firstly, a single temporary Box object is created and on each function call it is updated with the current box data. This means that you should not try to store the Box object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boxs inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each box</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Box objects for all of the boxs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boxs from</param>
    /// <returns type="Array" elementType="Box"/>
    /// </signature>
}

Box.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Box objects for all of the flagged boxs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boxs from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to retrieve</param>
    /// <returns type="Array" elementType="Box"/>
    /// </signature>
}

Box.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Box object for a box ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the box in</param>
    /// <param name="number" type="Number" optional="false">number of the box you want the Box object for</param>
    /// <returns type="Box"/>
    /// </signature>
}

Box.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Box property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Box.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">box property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Box.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this box (*DEFINE_BOX). Note that a carriage return is not added. See also Box.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Box.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the box. Note that a carriage return is not added. See also Box.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Box.Last = function() {
    /// <signature>
    /// <summary>Returns the last box in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last box in</param>
    /// <returns type="Box"/>
    /// </signature>
}

Box.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free box label in the model. Also see Box.FirstFreeLabel(), Box.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free box label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Box.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next box in the model.</summary>
    /// <returns type="Box"/>
    /// </signature>
}

Box.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) box label in the model. Also see Box.FirstFreeLabel(), Box.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free box label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Box.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a box.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boxs from that model can be picked. If the argument is a Flag then only boxs that are flagged with limit can be selected. If omitted, or null, any boxs from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Box"/>
    /// </signature>
}

Box.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous box in the model.</summary>
    /// <returns type="Box"/>
    /// </signature>
}

Box.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boxs will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select boxs using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting boxs</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boxs from that model can be selected. If the argument is a Flag then only boxs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boxs can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Box.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the box.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the box</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the box. The box will be sketched until you either call Box.Unsketch(), Box.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the box is sketched. If omitted redraw is true. If you want to sketch several boxs and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged boxs in the model. The boxs will be sketched until you either call Box.Unsketch(), Box.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boxs will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boxs are sketched. If omitted redraw is true. If you want to sketch flagged boxs several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing boxs should be counted. If false or omitted referenced but undefined boxs will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Box.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the box</summary>
    /// <returns type="null"/>
    /// </signature>
}

Box.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged boxs will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all boxs will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the boxs</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the box.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the box is unsketched. If omitted redraw is true. If you want to unsketch several boxs and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all boxs.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boxs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boxs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Box"/>
    /// </signature>
}

Box.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for box. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Box.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this box.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Box.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the box data in keyword format. Note that this contains the keyword header and the keyword cards. See also Box.Keyword() and Box.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Check = function() {
    /// <field name='BLACK' static='true' type='Number'>Colour black</field>
    /// <field name='BLUE' static='true' type='Number'>Colour blue</field>
    /// <field name='CYAN' static='true' type='Number'>Colour cyan</field>
    /// <field name='DARKBLUE' static='true' type='Number'>Colour dark blue</field>
    /// <field name='DARKGREEN' static='true' type='Number'>Colour dark green</field>
    /// <field name='DARKGREY' static='true' type='Number'>Colour dark grey</field>
    /// <field name='DARKRED' static='true' type='Number'>Colour dark red</field>
    /// <field name='ERROR' static='true' type='Number'>Dashboard check gave error(s)</field>
    /// <field name='GREEN' static='true' type='Number'>Colour green</field>
    /// <field name='GREY' static='true' type='Number'>Colour grey</field>
    /// <field name='LIGHTGREY' static='true' type='Number'>Colour light grey</field>
    /// <field name='MAGENTA' static='true' type='Number'>Colour magenta</field>
    /// <field name='OK' static='true' type='Number'>Dashboard check status OK</field>
    /// <field name='ORANGE' static='true' type='Number'>Colour orange</field>
    /// <field name='RED' static='true' type='Number'>Colour red</field>
    /// <field name='UNKNOWN' static='true' type='Number'>Dashboard check status unknown (not run)</field>
    /// <field name='WARNING' static='true' type='Number'>Dashboard check gave warning(s)</field>
    /// <field name='WHITE' static='true' type='Number'>Colour white</field>
    /// <field name='YELLOW' static='true' type='Number'>Colour yellow</field>
}

Check.AddDashboardComment = function() {
    /// <signature>
    /// <summary>Adds a comment for a user dashboard check. Multiple comments can be added. Call this function as many times as required.  This function should only be called from a user JavaScript dashboard script.</summary>
    /// <param name="comment" type="String" optional="false">The comment to add.</param>
    /// <returns type="null"/>
    /// </signature>
}

Check.AddDashboardHealth = function() {
    /// <signature>
    /// <summary>Allows the user to add the value of model health based on the other dashboard results  This function should only be called from model_health.config.js which should be placed with the other user defined dashboard scripts.</summary>
    /// <param name="model health" type="String" optional="false">Text which will be displayed on the dashboard panel and the summary files.</param>
    /// <param name="Health text colour" type="Number" optional="true">Colour of the model health text. The default colour is Black.</param>
    /// <param name="Health button colour" type="Number" optional="true">Colour of the model health button. The default colour is dark grey.</param>
    /// <returns type="null"/>
    /// </signature>
}

Check.Error = function() {
    /// <signature>
    /// <summary>Adds a custom error. This function should only be called from a custom JavaScript check script. See the details in the Check class for how to do this.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Check.GetAllDashboards = function() {
    /// <signature>
    /// <summary>Returns data from all the dashboards that are defined.  This function should only be called from model_health.config.js which should be placed with the other user defined dashboard scripts.  The dashboard properties are:  result (Overall result of the dashboard) title (dashboard title) message1 (First message of the dashboard) message2 (Second message of the dashboard) comments (Array of comments on the dashboard) </summary>
    /// <returns type="Array" elementType="dashboard"/>
    /// </signature>
}

Check.KeyoutHook = function() {
    /// <signature>
    /// <summary>Used to proceed with or abort the keyout operation (LS-DYNA output) from the keyout_hook.js script. The current hooks are launched just before the keyout operation from the model write tab, writing from the dialogue box and during keyout from the include tree. Please look at the example_keyout_script.js for an example of its usage.</summary>
    /// <param name="interrupt flag" type="Boolean" optional="false">If this flag is set to true then keyout is aborted else keyout proceeds as usual.</param>
    /// <returns type="null"/>
    /// </signature>
}

Check.SetDashboardMessage = function() {
    /// <signature>
    /// <summary>Adds a message for a user dashboard check. Each dashboard can currently show two messages. This function should only be called from a user JavaScript dashboard script.</summary>
    /// <param name="first" type="String" optional="false">The first message to add.</param>
    /// <param name="second" type="String" optional="true">The second message to add.</param>
    /// <returns type="null"/>
    /// </signature>
}

Check.SetDashboardStatus = function() {
    /// <signature>
    /// <summary>Sets the status of a user dashboard check. This function should only be called from a user JavaScript dashboard script.</summary>
    /// <param name="status" type="Number" optional="false">The status. Can be Check.OK, Check.WARNING, Check.ERROR or Check.UNKNOWN.</param>
    /// <returns type="null"/>
    /// </signature>
}

Check.Warning = function() {
    /// <signature>
    /// <summary>Adds a custom warning. This function should only be called from a custom JavaScript check script. See the details in the Check class for how to do this.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

var Colour = function() {
    /// <field name='ASSEMBLY' static='true' type='Number'>Base colour on assembly</field>
    /// <field name='BACKGROUND' static='true' type='Number'>Background colour</field>
    /// <field name='BLACK' static='true' type='Number'>Colour black</field>
    /// <field name='BLUE' static='true' type='Number'>Colour blue</field>
    /// <field name='CYAN' static='true' type='Number'>Colour cyan</field>
    /// <field name='DARK_ORANGE' static='true' type='Number'>Colour dark orange</field>
    /// <field name='DEFAULT' static='true' type='Number'>Default colour for objects</field>
    /// <field name='GREEN' static='true' type='Number'>Colour green</field>
    /// <field name='GREEN_CYAN' static='true' type='Number'>Colour green/cyan</field>
    /// <field name='GREY' static='true' type='Number'>Colour grey</field>
    /// <field name='INCLUDE' static='true' type='Number'>Base colour on include file</field>
    /// <field name='LIGHT_BLUE' static='true' type='Number'>Colour light blue</field>
    /// <field name='MAGENTA' static='true' type='Number'>Colour magenta</field>
    /// <field name='MATERIAL' static='true' type='Number'>For elements with part IDs base colour on material ID</field>
    /// <field name='MEDIUM_BLUE' static='true' type='Number'>Colour medium blue</field>
    /// <field name='MODEL' static='true' type='Number'>Base colour on model</field>
    /// <field name='NOT_BACKGROUND' static='true' type='Number'>Not the background colour</field>
    /// <field name='ORANGE' static='true' type='Number'>Colour orange</field>
    /// <field name='PART' static='true' type='Number'>For elements with part IDs base colour on part ID</field>
    /// <field name='RED' static='true' type='Number'>Colour red</field>
    /// <field name='RED_MAGENTA' static='true' type='Number'>Colour red/magenta</field>
    /// <field name='SECTION' static='true' type='Number'>For elements with part IDs base colour on section ID</field>
    /// <field name='SKETCH' static='true' type='Number'>Sketch colour</field>
    /// <field name='TEXT' static='true' type='Number'>Text colour</field>
    /// <field name='WHITE' static='true' type='Number'>Colour white</field>
    /// <field name='YELLOW' static='true' type='Number'>Colour yellow</field>
    /// <field name='YELLOW_GREEN' static='true' type='Number'>Colour yellow/green</field>
}

Colour.RGB = function() {
    /// <signature>
    /// <summary>Creates a colour from red, green and blue components</summary>
    /// <param name="red" type="Number" optional="false">red component of colour (0-255).</param>
    /// <param name="green" type="Number" optional="false">green component of colour (0-255).</param>
    /// <param name="blue" type="Number" optional="false">blue component of colour (0-255).</param>
    /// <returns type="Number"/>
    /// </signature>
}

var ConnectionProperties = function() {
    /// <signature>
    /// <summary>Create a new  *DEFINE_CONNECTION_PROPERTIES object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that *DEFINE_CONNECTION_PROPERTIES will be created in</param>
    /// <param name="con_id" type="Number" optional="false">*DEFINE_CONNECTION_PROPERTIES id.</param>
    /// <param name="heading" type="String" optional="true">Title for the *DEFINE_CONNECTION_PROPERTIES</param>
    /// <returns type="ConnectionProperties"/>
    /// </signature>
    /// <field name='add' static='false' type='Number'>To _ADD case's parent definition</field>
    /// <field name='areaeq' static='false' type='Number'>Area equation number.</field>
    /// <field name='con_id' static='false' type='Number'>*DEFINE_CONNECTION_PROPERTIES id.</field>
    /// <field name='d_dg_pr' static='false' type='Number'>Default damage parameter.</field>
    /// <field name='d_dg_prf' static='false' type='Number'>Default damage parameter(function if proprul == 2).</field>
    /// <field name='d_etan' static='false' type='Number'>Default tangent modulus.</field>
    /// <field name='d_etanf' static='false' type='Number'>Default tangent modulus(function if proprul == 2).</field>
    /// <field name='d_exsb' static='false' type='Number'>Default bending stress exponent.</field>
    /// <field name='d_exsbf' static='false' type='Number'>Default bending stress exponent(function if proprul == 2).</field>
    /// <field name='d_exsn' static='false' type='Number'>Default normal stress exponent.</field>
    /// <field name='d_exsnf' static='false' type='Number'>Default normal stress exponent(function if proprul == 2).</field>
    /// <field name='d_exss' static='false' type='Number'>Default shear stress exponent.</field>
    /// <field name='d_exssf' static='false' type='Number'>Default shear stress exponent(function if proprul == 2).</field>
    /// <field name='d_gfad' static='false' type='Number'>Default fading energy.</field>
    /// <field name='d_gfadf' static='false' type='Number'>Default fading energy(function if proprul == 2).</field>
    /// <field name='d_lcsb' static='false' type='Number'>Default LC of bending stress scale factor wrt strain rate.</field>
    /// <field name='d_lcsn' static='false' type='Number'>Default LC of normal stress scale factor wrt strain rate.</field>
    /// <field name='d_lcss' static='false' type='Number'>Default LC of shear stress scale factor wrt strain rate.</field>
    /// <field name='d_rank' static='false' type='Number'>Default rank value.</field>
    /// <field name='d_sb' static='false' type='Number'>Default bending strength.</field>
    /// <field name='d_sbf' static='false' type='Number'>Default bending strength(function if proprul == 2).</field>
    /// <field name='d_sclmrr' static='false' type='Number'>Default scaling factor for torsional moment in failure function.</field>
    /// <field name='d_sigy' static='false' type='Number'>Default yield stress.</field>
    /// <field name='d_sigyf' static='false' type='Number'>Default yield stress(function if proprul == 2).</field>
    /// <field name='d_sn' static='false' type='Number'>Default normal strength.</field>
    /// <field name='d_snf' static='false' type='Number'>Default normal strength(function if proprul == 2).</field>
    /// <field name='d_ss' static='false' type='Number'>Default shear strength.</field>
    /// <field name='d_ssf' static='false' type='Number'>Default shear strength(function if proprul == 2).</field>
    /// <field name='dg_typ' static='false' type='Number'>Damage type.</field>
    /// <field name='exists' static='false' type='Boolean'>true if *DEFINE_CONNECTION_PROPERTIES exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>The title of the *DEFINE_CONNECTION_PROPERTIES or the empty string if _TITLE is not set</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the *DEFINE_CONNECTION_PROPERTIES is in.</field>
    /// <field name='moarfl' static='false' type='Number'>Modelled area flag.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the *DEFINE_CONNECTION_PROPERTIES is in.</field>
    /// <field name='proprul' static='false' type='Number'>Property rule number.</field>
}

ConnectionProperties.prototype.AddMaterialDataLine = function() {
    /// <signature>
    /// <summary>Allows user to add material data line in *DEFINE_CONNECTION_PROPERTIES.</summary>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the *DEFINE_CONNECTION_PROPERTIES.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the *DEFINE_CONNECTION_PROPERTIES</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the *DEFINE_CONNECTION_PROPERTIES.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a *DEFINE_CONNECTION_PROPERTIES.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the *DEFINE_CONNECTION_PROPERTIES will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for *DEFINE_CONNECTION_PROPERTIES. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.First = function() {
    /// <signature>
    /// <summary>Returns the first *DEFINE_CONNECTION_PROPERTIES in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first *DEFINE_CONNECTION_PROPERTIES in</param>
    /// <returns type="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free *DEFINE_CONNECTION_PROPERTIES label in the model. Also see ConnectionProperties.LastFreeLabel(), ConnectionProperties.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free *DEFINE_CONNECTION_PROPERTIES label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConnectionProperties.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the *DEFINE_CONNECTION_PROPERTIESs in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *DEFINE_CONNECTION_PROPERTIESs will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the *DEFINE_CONNECTION_PROPERTIESs</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the *DEFINE_CONNECTION_PROPERTIES is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the *DEFINE_CONNECTION_PROPERTIES</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

ConnectionProperties.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each *DEFINE_CONNECTION_PROPERTIES in the model. Note that ForEach has been designed to make looping over *DEFINE_CONNECTION_PROPERTIESs as fast as possible and so has some limitations. Firstly, a single temporary ConnectionProperties object is created and on each function call it is updated with the current *DEFINE_CONNECTION_PROPERTIES data. This means that you should not try to store the ConnectionProperties object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new *DEFINE_CONNECTION_PROPERTIESs inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all *DEFINE_CONNECTION_PROPERTIESs are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each *DEFINE_CONNECTION_PROPERTIES</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of ConnectionProperties objects for all of the *DEFINE_CONNECTION_PROPERTIESs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get *DEFINE_CONNECTION_PROPERTIESs from</param>
    /// <returns type="Array" elementType="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of ConnectionProperties objects for all of the flagged *DEFINE_CONNECTION_PROPERTIESs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get *DEFINE_CONNECTION_PROPERTIESs from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *DEFINE_CONNECTION_PROPERTIESs that you want to retrieve</param>
    /// <returns type="Array" elementType="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the ConnectionProperties object for a *DEFINE_CONNECTION_PROPERTIES ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the *DEFINE_CONNECTION_PROPERTIES in</param>
    /// <param name="number" type="Number" optional="false">number of the *DEFINE_CONNECTION_PROPERTIES you want the ConnectionProperties object for</param>
    /// <returns type="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.prototype.GetMaterialDataLine = function() {
    /// <signature>
    /// <summary>Returns the material data at given row in *DEFINE_CONNECTION_PROPERTIES.</summary>
    /// <param name="row" type="Number" optional="false">Material data row number, eg. for first material data, row = 0</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

ConnectionProperties.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a ConnectionProperties property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ConnectionProperties.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">*DEFINE_CONNECTION_PROPERTIES property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

ConnectionProperties.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this *DEFINE_CONNECTION_PROPERTIES Note that a carriage return is not added. See also ConnectionProperties.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ConnectionProperties.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the *DEFINE_CONNECTION_PROPERTIES. Note that a carriage return is not added. See also ConnectionProperties.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ConnectionProperties.Last = function() {
    /// <signature>
    /// <summary>Returns the last *DEFINE_CONNECTION_PROPERTIES in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last *DEFINE_CONNECTION_PROPERTIES in</param>
    /// <returns type="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free *DEFINE_CONNECTION_PROPERTIES label in the model. Also see ConnectionProperties.FirstFreeLabel(), ConnectionProperties.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free *DEFINE_CONNECTION_PROPERTIES label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConnectionProperties.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next *DEFINE_CONNECTION_PROPERTIES in the model.</summary>
    /// <returns type="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) *DEFINE_CONNECTION_PROPERTIES label in the model. Also see ConnectionProperties.FirstFreeLabel(), ConnectionProperties.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free *DEFINE_CONNECTION_PROPERTIES label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConnectionProperties.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous *DEFINE_CONNECTION_PROPERTIES in the model.</summary>
    /// <returns type="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.prototype.RemoveMaterialDataLine = function() {
    /// <signature>
    /// <summary>Allows user to remove material data line in *DEFINE_CONNECTION_PROPERTIES.</summary>
    /// <param name="row" type="Number" optional="false">Material data row number, eg. for first material data, row = 0</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the *DEFINE_CONNECTION_PROPERTIESs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *DEFINE_CONNECTION_PROPERTIESs will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged *DEFINE_CONNECTION_PROPERTIESs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged *DEFINE_CONNECTION_PROPERTIESs will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *DEFINE_CONNECTION_PROPERTIESs that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select *DEFINE_CONNECTION_PROPERTIESs using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting *DEFINE_CONNECTION_PROPERTIESs</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only *DEFINE_CONNECTION_PROPERTIESs from that model can be selected. If the argument is a Flag then only *DEFINE_CONNECTION_PROPERTIESs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any *DEFINE_CONNECTION_PROPERTIESs can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConnectionProperties.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the *DEFINE_CONNECTION_PROPERTIES.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the *DEFINE_CONNECTION_PROPERTIES</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.prototype.SetMaterialDataLine = function() {
    /// <signature>
    /// <summary>Allows user to set fields for material data line at given row in *DEFINE_CONNECTION_PROPERTIES.</summary>
    /// <param name="row" type="Number" optional="false">Material data row number, eg. for first material data, row = 0</param>
    /// <param name="mid" type="Number" optional="false">Material ID</param>
    /// <param name="sigy" type="Number" optional="true">Default yield stress</param>
    /// <param name="etan" type="Number" optional="true">Default tangent modulus</param>
    /// <param name="dg_pr" type="Number" optional="true">Default damage parameter</param>
    /// <param name="rank" type="Number" optional="true">Default rank value</param>
    /// <param name="sn" type="Number" optional="true">Default normal strength</param>
    /// <param name="sb" type="Number" optional="true">Default bending strength</param>
    /// <param name="ss" type="Number" optional="true">Default shear strength</param>
    /// <param name="exsn" type="Number" optional="true">Default normal stress exponent</param>
    /// <param name="exsb" type="Number" optional="true">Default bending stress exponent</param>
    /// <param name="exss" type="Number" optional="true">Default shear stress exponent</param>
    /// <param name="lcsn" type="Number" optional="true">Default LC of normal stress scale factor wrt strain rate</param>
    /// <param name="lcsb" type="Number" optional="true">Default LC of bending stress scale factor wrt strain rate</param>
    /// <param name="lcss" type="Number" optional="true">Default LC of shear stress scale factor wrt strain rate</param>
    /// <param name="gfad" type="Number" optional="true">Default fading energy</param>
    /// <param name="sclmrr" type="Number" optional="true">Default scaling factor for torsional moment in failure function</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of *DEFINE_CONNECTION_PROPERTIESs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing *DEFINE_CONNECTION_PROPERTIESs should be counted. If false or omitted referenced but undefined *DEFINE_CONNECTION_PROPERTIESs will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConnectionProperties.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the *DEFINE_CONNECTION_PROPERTIESs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all *DEFINE_CONNECTION_PROPERTIESs will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the *DEFINE_CONNECTION_PROPERTIESs</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="ConnectionProperties"/>
    /// </signature>
}

ConnectionProperties.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for *DEFINE_CONNECTION_PROPERTIES. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

ConnectionProperties.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this *DEFINE_CONNECTION_PROPERTIES.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

ConnectionProperties.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the connection_properties data in keyword format. Note that this contains the keyword header and the keyword cards. See also ConnectionProperties.Keyword() and ConnectionProperties.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var ConstructionStages = function() {
    /// <signature>
    /// <summary>Create a new ConstructionStages object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that *DEFINE_CONSTRUCTION_STAGES will be created in</param>
    /// <param name="Stage ID" type="Number" optional="false">ConstructionStages id.</param>
    /// <param name="heading" type="String" optional="true">Title for the *DEFINE_CONSTRUCTION_STAGES</param>
    /// <returns type="ConstructionStages"/>
    /// </signature>
    /// <field name='ate' static='false' type='Number'>Analysis time at end of stage.</field>
    /// <field name='atr' static='false' type='Number'>Analysis time duration of stage.</field>
    /// <field name='ats' static='false' type='Number'>Analysis time at start of stage.</field>
    /// <field name='exists' static='false' type='Boolean'>true if *DEFINE_CONSTRUCTION_STAGES exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>The title of the *DEFINE_CONSTRUCTION_STAGES or the empty string if _TITLE is not set</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the *DEFINE_CONSTRUCTION_STAGES is in.</field>
    /// <field name='istage' static='false' type='Number'>ConstructionStages number. The label is an alternative name for this.</field>
    /// <field name='ivel0' static='false' type='Number'>Flag to set velocities to zero at start of stage.</field>
    /// <field name='label' static='false' type='Number'>ConstructionStages number. The istage is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the *DEFINE_CONSTRUCTION_STAGES is in.</field>
    /// <field name='rte' static='false' type='Number'>Real time at end of stage.</field>
    /// <field name='rts' static='false' type='Number'>Real time at start of stage.</field>
}

ConstructionStages.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the *DEFINE_CONSTRUCTION_STAGES.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the *DEFINE_CONSTRUCTION_STAGES</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the *DEFINE_CONSTRUCTION_STAGES.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a *DEFINE_CONSTRUCTION_STAGES.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the *DEFINE_CONSTRUCTION_STAGES will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for *DEFINE_CONSTRUCTION_STAGES. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.First = function() {
    /// <signature>
    /// <summary>Returns the first *DEFINE_CONSTRUCTION_STAGES in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first *DEFINE_CONSTRUCTION_STAGES in</param>
    /// <returns type="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free *DEFINE_CONSTRUCTION_STAGES label in the model. Also see ConstructionStages.LastFreeLabel(), ConstructionStages.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free *DEFINE_CONSTRUCTION_STAGES label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConstructionStages.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the *DEFINE_CONSTRUCTION_STAGESs in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *DEFINE_CONSTRUCTION_STAGESs will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the *DEFINE_CONSTRUCTION_STAGESs</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the *DEFINE_CONSTRUCTION_STAGES is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the *DEFINE_CONSTRUCTION_STAGES</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

ConstructionStages.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each *DEFINE_CONSTRUCTION_STAGES in the model. Note that ForEach has been designed to make looping over *DEFINE_CONSTRUCTION_STAGESs as fast as possible and so has some limitations. Firstly, a single temporary ConstructionStages object is created and on each function call it is updated with the current *DEFINE_CONSTRUCTION_STAGES data. This means that you should not try to store the ConstructionStages object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new *DEFINE_CONSTRUCTION_STAGESs inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all *DEFINE_CONSTRUCTION_STAGESs are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each *DEFINE_CONSTRUCTION_STAGES</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of ConstructionStages objects for all of the *DEFINE_CONSTRUCTION_STAGESs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get *DEFINE_CONSTRUCTION_STAGESs from</param>
    /// <returns type="Array" elementType="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of ConstructionStages objects for all of the flagged *DEFINE_CONSTRUCTION_STAGESs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get *DEFINE_CONSTRUCTION_STAGESs from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *DEFINE_CONSTRUCTION_STAGESs that you want to retrieve</param>
    /// <returns type="Array" elementType="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the ConstructionStages object for a *DEFINE_CONSTRUCTION_STAGES ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the *DEFINE_CONSTRUCTION_STAGES in</param>
    /// <param name="number" type="Number" optional="false">number of the *DEFINE_CONSTRUCTION_STAGES you want the ConstructionStages object for</param>
    /// <returns type="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a ConstructionStages property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ConstructionStages.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">*DEFINE_CONSTRUCTION_STAGES property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

ConstructionStages.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this *DEFINE_CONSTRUCTION_STAGES. Note that a carriage return is not added. See also ConstructionStages.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ConstructionStages.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the *DEFINE_CONSTRUCTION_STAGES. Note that a carriage return is not added. See also ConstructionStages.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ConstructionStages.Last = function() {
    /// <signature>
    /// <summary>Returns the last *DEFINE_CONSTRUCTION_STAGES in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last *DEFINE_CONSTRUCTION_STAGES in</param>
    /// <returns type="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free *DEFINE_CONSTRUCTION_STAGES label in the model. Also see ConstructionStages.FirstFreeLabel(), ConstructionStages.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free *DEFINE_CONSTRUCTION_STAGES label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConstructionStages.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next *DEFINE_CONSTRUCTION_STAGES in the model.</summary>
    /// <returns type="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) *DEFINE_CONSTRUCTION_STAGES label in the model. Also see ConstructionStages.FirstFreeLabel(), ConstructionStages.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free *DEFINE_CONSTRUCTION_STAGES label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConstructionStages.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous *DEFINE_CONSTRUCTION_STAGES in the model.</summary>
    /// <returns type="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the *DEFINE_CONSTRUCTION_STAGESs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *DEFINE_CONSTRUCTION_STAGESs will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged *DEFINE_CONSTRUCTION_STAGESs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged *DEFINE_CONSTRUCTION_STAGESs will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *DEFINE_CONSTRUCTION_STAGESs that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select *DEFINE_CONSTRUCTION_STAGESs using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting *DEFINE_CONSTRUCTION_STAGESs</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only *DEFINE_CONSTRUCTION_STAGESs from that model can be selected. If the argument is a Flag then only *DEFINE_CONSTRUCTION_STAGESs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any *DEFINE_CONSTRUCTION_STAGESs can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConstructionStages.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the *DEFINE_CONSTRUCTION_STAGES.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the *DEFINE_CONSTRUCTION_STAGES</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of *DEFINE_CONSTRUCTION_STAGESs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing *DEFINE_CONSTRUCTION_STAGESs should be counted. If false or omitted referenced but undefined *DEFINE_CONSTRUCTION_STAGESs will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ConstructionStages.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the *DEFINE_CONSTRUCTION_STAGESs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all *DEFINE_CONSTRUCTION_STAGESs will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the *DEFINE_CONSTRUCTION_STAGESs</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="ConstructionStages"/>
    /// </signature>
}

ConstructionStages.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for *DEFINE_CONSTRUCTION_STAGES. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

ConstructionStages.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this *DEFINE_CONSTRUCTION_STAGES.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

ConstructionStages.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the construction stages data in keyword format. Note that this contains the keyword header and the keyword cards. See also ConstructionStages.Keyword() and ConstructionStages.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Contact = function() {
    /// <signature>
    /// <summary>Create a new Contact object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that Contact will be created in</param>
    /// <param name="type" type="String" optional="false">Type of contact</param>
    /// <param name="id" type="Number" optional="true">Contact number</param>
    /// <param name="heading" type="String" optional="true">Title for the Contact</param>
    /// <returns type="Contact"/>
    /// </signature>
    /// <field name='a' static='false' type='Number'>Loadcurve ID for a</field>
    /// <field name='algo' static='false' type='Number'>contact algorithm</field>
    /// <field name='alpha' static='false' type='Number'>Key amplitude parameter A</field>
    /// <field name='b' static='false' type='Number'>Loadcurve ID for b</field>
    /// <field name='bc_flg' static='false' type='Number'>boundary condition flag</field>
    /// <field name='beta' static='false' type='Number'>Key amplitude parameter B</field>
    /// <field name='bsort' static='false' type='Number'>Loadcurve for #cycles between bucket sorts</field>
    /// <field name='bt' static='false' type='Number'>Contact birth time</field>
    /// <field name='bucket' static='false' type='Number'>Bucket sorting frequency</field>
    /// <field name='c' static='false' type='Number'>Loadcurve ID for c</field>
    /// <field name='check_mode' static='false' type='Number'>Checking mode on the pen check edit panel. (Can be Contact.MPP_METHOD, Contact.MPP_METHOD or Contact.SMP_METHOD)</field>
    /// <field name='chksegs' static='false' type='Number'>Special check for inverted elements</field>
    /// <field name='cid' static='false' type='Number'>Contact number (identical to label.</field>
    /// <field name='cid_rcf' static='false' type='Number'>Coordinate system ID to output rcforc force resultants and ncforc data in a local system</field>
    /// <field name='cideta' static='false' type='Number'>Curve ID for the viscosity</field>
    /// <field name='cidmu' static='false' type='Number'>Curve ID for the coefficient of friction</field>
    /// <field name='close' static='false' type='Number'>Surface closeness parameter</field>
    /// <field name='cn' static='false' type='Number'>Normal stiffness</field>
    /// <field name='cn_1' static='false' type='Number'>Normal stiffness</field>
    /// <field name='contact_penchk_dup_shells' static='false' type='Number'>Shell treatment on the pen check edit panel. (Can be Contact.SHELL_AUTO, Contact.SHELL_AUTO or Contact.SHELL_THIN or Contact.SHELL_THICK)</field>
    /// <field name='cparm8' static='false' type='Number'>Exclude beam to beam contact flag</field>
    /// <field name='cparm8smp' static='false' type='Number'>Spotweld beam flag for SMP</field>
    /// <field name='ct2cn' static='false' type='Number'>Ratio of tangential stiffness to normal stiffness</field>
    /// <field name='ct2cn_1' static='false' type='Number'>Ratio of tangential to normal stiff</field>
    /// <field name='d' static='false' type='Number'>Loadcurve ID for d</field>
    /// <field name='d_comp' static='false' type='Number'>Composite film thickness</field>
    /// <field name='dbdth' static='false' type='Number'>Draw bead depth</field>
    /// <field name='dbinr' static='false' type='Number'>2dbinr - Flag to include 2d belt elements in contact (note properties cannot start with a number, so 2 has been removed).</field>
    /// <field name='dbpid' static='false' type='Number'>optional Part ID</field>
    /// <field name='dc' static='false' type='Number'>Exponential decay coeff</field>
    /// <field name='depth' static='false' type='Number'>Loadcurve for search depth in automatic contact</field>
    /// <field name='dfscl' static='false' type='Number'>Scale factor on lcidrf</field>
    /// <field name='dnlscl' static='false' type='Number'>Distance for nonlinear force scaling</field>
    /// <field name='dprfac' static='false' type='Number'>Depth of penetration reduction factor</field>
    /// <field name='dt' static='false' type='Number'>Contact death time</field>
    /// <field name='dtpchk' static='false' type='Number'>Time interval between penetration reports</field>
    /// <field name='dtstif' static='false' type='Number'>Timestep used in stiffness calc</field>
    /// <field name='eloff' static='false' type='Number'>optional element id offset</field>
    /// <field name='eraten' static='false' type='Number'>Normal energy release rate used in damage calculation</field>
    /// <field name='erates' static='false' type='Number'>Shear energy release rate used in damage calculation</field>
    /// <field name='erosop' static='false' type='Number'>Erosion/interior node option</field>
    /// <field name='exists' static='false' type='Boolean'>true if contact exists, false if referred to but not defined. (read only)</field>
    /// <field name='fcm' static='false' type='Number'>Force calculation method</field>
    /// <field name='fd' static='false' type='Number'>Dynamic coeff of friction</field>
    /// <field name='flangl' static='false' type='Number'>Angle tolerance in radians for feature lines option in smooth contact</field>
    /// <field name='fnlscl' static='false' type='Number'>Scale factor for nonlinear force scaling</field>
    /// <field name='formula' static='false' type='Number'>formula id</field>
    /// <field name='frad' static='false' type='Number'>Radiation conductance across gap</field>
    /// <field name='frcfrq' static='false' type='Number'>#cycles between penalty force updates</field>
    /// <field name='fricsf' static='false' type='Number'>Scale factor for frictional stiffness</field>
    /// <field name='fs' static='false' type='Number'>Static coeff of friction</field>
    /// <field name='fsf' static='false' type='Number'>Coulomb friction scale factor</field>
    /// <field name='fstol' static='false' type='Number'>Tolerance for determining flat segments.</field>
    /// <field name='ftorq' static='false' type='Number'>Beam torsional force computation flag</field>
    /// <field name='ftoslv' static='false' type='Number'>Fraction of sliding friction energy partitioned to slave surface</field>
    /// <field name='grpable' static='false' type='Number'>Experimental contact algorithm</field>
    /// <field name='h0' static='false' type='Number'>Heat transfer coefficient</field>
    /// <field name='hclose' static='false' type='Number'>Thermal contact conductivity</field>
    /// <field name='heading' static='false' type='String'>Contact heading</field>
    /// <field name='i2d3d' static='false' type='Number'>Segment searching option</field>
    /// <field name='iadj' static='false' type='Number'>Adjacent matl treatment for solids</field>
    /// <field name='icor' static='false' type='Number'>coefficient of restitution expressed as a percentage</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not</field>
    /// <field name='igap' static='false' type='Number'>Implicit convergence flag</field>
    /// <field name='ignore' static='false' type='Number'>Ignore initial pens in automatic types</field>
    /// <field name='ignroff' static='false' type='Number'>Flag to ignore the thickness offset for shells in the calculation of the shell contact penetration depth.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the contact is in.</field>
    /// <field name='inititer' static='false' type='Number'>Number of iterations for initial penetration checking</field>
    /// <field name='ipback' static='false' type='Number'>Create backup penalty tied contact</field>
    /// <field name='isym' static='false' type='Number'>Symmetry plane option</field>
    /// <field name='isym_1' static='false' type='Number'>Symmetry plane option</field>
    /// <field name='k' static='false' type='Number'>Conductivity of gap fluid</field>
    /// <field name='kpf' static='false' type='Number'>Kinematic partition factor</field>
    /// <field name='label' static='false' type='Number'>Contact number.</field>
    /// <field name='lcbucket' static='false' type='Number'>Bucket sorting frequency loadcurve ID</field>
    /// <field name='lceps' static='false' type='Number'>Loadcurve ID for plastic strain vs. parametric coord</field>
    /// <field name='lceps2' static='false' type='Number'>Loadcurve ID for plastic strain vs. parametric coord (elements moved &gt; offset)</field>
    /// <field name='lcfdt' static='false' type='Number'>Loadcurve ID for dynamic friction vs. temp</field>
    /// <field name='lcfst' static='false' type='Number'>Loadcurve ID for static friction vs. temp</field>
    /// <field name='lch' static='false' type='Number'>Loadcurve ID for lch</field>
    /// <field name='lcid' static='false' type='Number'>Loadcurve ID for Force vs penetration curve</field>
    /// <field name='lcid1' static='false' type='Number'>Loadcurve ID for Dyn rel stiffness</field>
    /// <field name='lcid2' static='false' type='Number'>Loadcurve ID for Transient stiffness</field>
    /// <field name='lcidab' static='false' type='Number'>Loadcurve ID for airbag thickness vs time</field>
    /// <field name='lcidnf' static='false' type='Number'>Loadcurve ID for Normal force per unit length</field>
    /// <field name='lcidrf' static='false' type='Number'>Loadcurve ID for Force due to bending per unit length</field>
    /// <field name='lmax' static='false' type='Number'>Max size for thermal contact</field>
    /// <field name='lmin' static='false' type='Number'>Critical gap size</field>
    /// <field name='maxpar' static='false' type='Number'>Max parametric coord overlap</field>
    /// <field name='mboxid' static='false' type='Number'>Master box id</field>
    /// <field name='mes' static='false' type='Number'>Shear force exponent</field>
    /// <field name='model' static='false' type='Number'>The Model number that the contact is in.</field>
    /// <field name='mpp' static='false' type='Boolean'>true if _MPP option is set, false if not</field>
    /// <field name='mpr' static='false' type='Number'>Master side printout flag</field>
    /// <field name='msid' static='false' type='Number'>Master set id</field>
    /// <field name='mst' static='false' type='Number'>Optional master side shell thickness</field>
    /// <field name='mstyp' static='false' type='Number'>Master set type</field>
    /// <field name='mtcj' static='false' type='Number'>The method option for the gap function</field>
    /// <field name='nen' static='false' type='Number'>Normal force exponent</field>
    /// <field name='nfls' static='false' type='Number'>Normal failure stress</field>
    /// <field name='nhv' static='false' type='Number'>Number of history variables</field>
    /// <field name='nmhis' static='false' type='Number'>Number of material history variables</field>
    /// <field name='ns2track' static='false' type='Number'>Number of segments to track per slave node</field>
    /// <field name='ntprm' static='false' type='Number'>Number of user tied weld parameters</field>
    /// <field name='numint' static='false' type='Number'>#int points along drawbead</field>
    /// <field name='offset' static='false' type='Number'>Flag for offset treatment. This is only valid for *CONTACT_AUTOMATIC(_ONE_WAY)_SURFACE_TO_SURFACE_TIEBREAK_USER and should not be confused with the 'offset' property for other contact types.</field>
    /// <field name='offset_1' static='false' type='Number'>distance offset</field>
    /// <field name='offset_flag' static='false' type='Number'>_OFFSET option. (Can be Contact.NO_OFFSET, Contact.SIMPLE_OFFSET, Contact.CONSTR_OFFSET or Contact.BEAM_OFFSET)</field>
    /// <field name='option' static='false' type='Number'>Response option</field>
    /// <field name='option_1' static='false' type='Number'>User tiebreak type</field>
    /// <field name='param' static='false' type='Number'>Critical distance</field>
    /// <field name='parmax' static='false' type='Number'>The parametric extension distance for contact segments</field>
    /// <field name='penchk' static='false' type='Number'>Penetration search flag</field>
    /// <field name='penmax' static='false' type='Number'>Max pen distance for "old" types 3, 5, 10</field>
    /// <field name='pensf' static='false' type='Number'>Ignore penetration scale factor</field>
    /// <field name='pstiff' static='false' type='Number'>Flag to choose the method for calculating the penalty stiffness</field>
    /// <field name='q2tri' static='false' type='Number'>Split quads into 2 trias</field>
    /// <field name='region' static='false' type='Number'>Region to limit contact volume</field>
    /// <field name='sbopt' static='false' type='Number'>segment based contact option</field>
    /// <field name='sboxid' static='false' type='Number'>Slave box id</field>
    /// <field name='sfls' static='false' type='Number'>Shear failure stress</field>
    /// <field name='sfm' static='false' type='Number'>Scale factor on master penalty stiffness</field>
    /// <field name='sfmt' static='false' type='Number'>Scale factor on true master shell thickness</field>
    /// <field name='sfnbr' static='false' type='Number'>Scale factor for neighbour segment contact</field>
    /// <field name='sfs' static='false' type='Number'>Scale factor on slave penalty stiffness</field>
    /// <field name='sfst' static='false' type='Number'>Scale factor on true slave shell thickness</field>
    /// <field name='sharec' static='false' type='Number'>Shared constraint flag</field>
    /// <field name='shledg' static='false' type='Number'>Edge shape for shells when measuring penetration</field>
    /// <field name='shlthk' static='false' type='Number'>Thickness consideration flag</field>
    /// <field name='sldstf' static='false' type='Number'>Optional solid stiffness</field>
    /// <field name='sldthk' static='false' type='Number'>Optional solid thickness</field>
    /// <field name='snlog' static='false' type='Number'>Shooting node logic flag</field>
    /// <field name='sofscl' static='false' type='Number'>Soft constraint scale factor</field>
    /// <field name='soft' static='false' type='Number'>Soft constraint flag</field>
    /// <field name='spr' static='false' type='Number'>Slave side printout flag</field>
    /// <field name='srnde' static='false' type='Number'>Flag for non-extended exterior shell edges</field>
    /// <field name='ssid' static='false' type='Number'>Slave set id</field>
    /// <field name='sst' static='false' type='Number'>Optional slave side shell thickness</field>
    /// <field name='sstyp' static='false' type='Number'>Slave set type</field>
    /// <field name='tblcid' static='false' type='Number'>Loadcurve ID for stress vs gap post failure</field>
    /// <field name='tcso' static='false' type='Number'>Segment treatment only flag</field>
    /// <field name='temp' static='false' type='Number'>Minimum temperature required.</field>
    /// <field name='tfail' static='false' type='Number'>Tensile traction for failure</field>
    /// <field name='thermal' static='false' type='Boolean'>If _THERMAL option is set. Can be true or false</field>
    /// <field name='thkoff' static='false' type='Number'>flag for thickness offset</field>
    /// <field name='thkopt' static='false' type='Number'>Thickness option for "old" types 3, 5, 10</field>
    /// <field name='tiedid' static='false' type='Number'>Incremental displacement update for tied contacts</field>
    /// <field name='tscale' static='false' type='Number'></field>
    /// <field name='tsvx' static='false' type='Number'>X component of the free sliding direction T</field>
    /// <field name='tsvy' static='false' type='Number'>Y component of the free sliding direction T</field>
    /// <field name='tsvz' static='false' type='Number'>Z component of the free sliding direction T</field>
    /// <field name='type' static='false' type='String'>Contact type ("AUTOMATIC_GENERAL", "SINGLE_SURFACE" etc).</field>
    /// <field name='up1' static='false' type='Number'>User parameter</field>
    /// <field name='up10' static='false' type='Number'>User parameter</field>
    /// <field name='up11' static='false' type='Number'>User parameter</field>
    /// <field name='up12' static='false' type='Number'>User parameter</field>
    /// <field name='up13' static='false' type='Number'>User parameter</field>
    /// <field name='up14' static='false' type='Number'>User parameter</field>
    /// <field name='up15' static='false' type='Number'>User parameter</field>
    /// <field name='up16' static='false' type='Number'>User parameter</field>
    /// <field name='up2' static='false' type='Number'>User parameter</field>
    /// <field name='up3' static='false' type='Number'>User parameter</field>
    /// <field name='up4' static='false' type='Number'>User parameter</field>
    /// <field name='up5' static='false' type='Number'>User parameter</field>
    /// <field name='up6' static='false' type='Number'>User parameter</field>
    /// <field name='up7' static='false' type='Number'>User parameter</field>
    /// <field name='up8' static='false' type='Number'>User parameter</field>
    /// <field name='up9' static='false' type='Number'>User parameter</field>
    /// <field name='us' static='false' type='Number'>Optional unloading stiffness</field>
    /// <field name='vc' static='false' type='Number'>Coeff for viscous friction</field>
    /// <field name='vdc' static='false' type='Number'>Visous damping coefficient</field>
    /// <field name='vsf' static='false' type='Number'>Viscous friction scale factor</field>
    /// <field name='BEAM_OFFSET' static='true' type='Number'>Adds _BEAM_OFFSET option</field>
    /// <field name='CONSTR_OFFSET' static='true' type='Number'>Adds _CONSTRAINED_OFFSET option</field>
    /// <field name='CROSSED_EDGES' static='true' type='Number'>Return crossed edges in Contact.Interactions()</field>
    /// <field name='MPP_METHOD' static='true' type='Number'>Launches the penetration edit panel with the MPP methodology turned on</field>
    /// <field name='MPP_MODE' static='true' type='Number'>MPP penetration check mode</field>
    /// <field name='NO_OFFSET' static='true' type='Number'>No offset option added.</field>
    /// <field name='PENETRATIONS' static='true' type='Number'>Return penetrations in Contact.Interactions()</field>
    /// <field name='SHELL_AUTO' static='true' type='Number'>Launches the penetration edit panel with Automatic shell treatment of duplicate shells.</field>
    /// <field name='SHELL_THICK' static='true' type='Number'>Launches the penetration edit panel with the thickest always option for duplicate shells.</field>
    /// <field name='SHELL_THIN' static='true' type='Number'>Launches the penetration edit panel with the thinnest always option for duplicate shells.</field>
    /// <field name='SIMPLE_OFFSET' static='true' type='Number'>Adds _OFFSET option</field>
    /// <field name='SMP_METHOD' static='true' type='Number'>Launches the penetration edit panel with the SMP methodology turned on</field>
    /// <field name='SMP_MODE' static='true' type='Number'>SMP penetration check mode</field>
}

Contact.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the contact</summary>
    /// <returns type="null"/>
    /// </signature>
}

Contact.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the contacts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contacts will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged contacts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged contacts will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contacts that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the contact is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Contact.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the contact.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the contact</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.Constrained = function() {
    /// <signature>
    /// <summary>see if tied/spotweld contact uses constrained formulation</summary>
    /// <param name="connection" type="Boolean" optional="false">if true will only consider conntacts used for primer connections</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Contact.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the contact.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Contact"/>
    /// </signature>
}

Contact.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a contact.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the contact will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Contact"/>
    /// </signature>
}

Contact.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for contact. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.FindInteractions_#deprecated = function() {
    /// <signature>
    /// <summary>Use Contact.Interactions() instead.</summary>
    /// </signature>
}

Contact.First = function() {
    /// <signature>
    /// <summary>Returns the first contact in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first contact in</param>
    /// <returns type="Contact"/>
    /// </signature>
}

Contact.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free contact label in the model. Also see Contact.LastFreeLabel(), Contact.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free contact label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Contact.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the contacts in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contacts will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the contacts</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the contact is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the contact</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Contact.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each contact in the model. Note that ForEach has been designed to make looping over contacts as fast as possible and so has some limitations. Firstly, a single temporary Contact object is created and on each function call it is updated with the current contact data. This means that you should not try to store the Contact object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new contacts inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all contacts are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each contact</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Contact objects for all of the contacts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get contacts from</param>
    /// <returns type="Array" elementType="Contact"/>
    /// </signature>
}

Contact.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Contact objects for all of the flagged contacts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get contacts from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contacts that you want to retrieve</param>
    /// <returns type="Array" elementType="Contact"/>
    /// </signature>
}

Contact.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Contact object for a contact ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the contact in</param>
    /// <param name="number" type="Number" optional="false">number of the contact you want the Contact object for</param>
    /// <returns type="Contact"/>
    /// </signature>
}

Contact.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Contact property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Contact.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">contact property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Contact.prototype.Interactions = function() {
    /// <signature>
    /// <summary>Returns an array of objects describing the interactions which can either be penetrations (slave nodes that are tied to or penetrate elements in the contact) or crossed edges (contact segments that cross).</summary>
    /// <param name="type" type="Number" optional="true">What type of interactions to return. Can be bitwise code of Contact.PENETRATIONS to return penetrations and Contact.CROSSED_EDGES to return crossed edges. If omitted penetrations will be returned.</param>
    /// <returns type="Array" elementType="Object"/>
    /// </signature>
}

Contact.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this Contact (*BOUNDARY_PRESCRIBED_MOTION_xxxx). Note that a carriage return is not added. See also Contact.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Contact.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the Contact. Note that a carriage return is not added. See also Contact.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Contact.Last = function() {
    /// <signature>
    /// <summary>Returns the last contact in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last contact in</param>
    /// <returns type="Contact"/>
    /// </signature>
}

Contact.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free contact label in the model. Also see Contact.FirstFreeLabel(), Contact.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free contact label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Contact.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next contact in the model.</summary>
    /// <returns type="Contact"/>
    /// </signature>
}

Contact.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) contact label in the model. Also see Contact.FirstFreeLabel(), Contact.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free contact label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Contact.prototype.PenCheck = function() {
    /// <signature>
    /// <summary>Flags nodes that penetrate (or tie) in contact</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to be set on penetrating (or tied) node.</param>
    /// <param name="eflag" type="Number" optional="false">Optional flag for elements. If supplied, node will be flagged only if it penetrates (or ties to) an element that is flagged. Node and element flag may be the same.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Contact.prototype.PenCheckEdit = function() {
    /// <signature>
    /// <summary>launches the interactive edit panel for penetration check on the con</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <param name="check_mode" type="Number" optional="true">Check mode. Can be Model.MPP_MODE or Model.SMP_MODE. Default is set to the oa pref contact_check_mode</param>
    /// <param name="mpp_threshold" type="Number" optional="true">Can set the MPP threshold, by default this is set to the oa pref contact_mpp_penetration_threshold</param>
    /// <param name="report_crossed_3d_elems" type="Boolean" optional="true">Can set the value of reporting crossed elements to TRUE or FALSE, by default this is set to the oa pref report_crossed_3d_elems</param>
    /// <param name="contact_penchk_dup_shells" type="Number" optional="true">Duplicate shell treatment Can be Model.SHELL_AUTO, Model.SHELL_THICK or Model.SHELL_THIN. Default is set to the oa pref contact_penchk_dup_shells</param>
    /// </signature>
}

Contact.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a contact.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only contacts from that model can be picked. If the argument is a Flag then only contacts that are flagged with limit can be selected. If omitted, or null, any contacts from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Contact"/>
    /// </signature>
}

Contact.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous contact in the model.</summary>
    /// <returns type="Contact"/>
    /// </signature>
}

Contact.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the contacts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contacts will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged contacts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged contacts will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contacts that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select contacts using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting contacts</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only contacts from that model can be selected. If the argument is a Flag then only contacts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any contacts can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Contact.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the contact.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the contact</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the contact. The contact will be sketched until you either call Contact.Unsketch(), Contact.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contact is sketched. If omitted redraw is true. If you want to sketch several contacts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged contacts in the model. The contacts will be sketched until you either call Contact.Unsketch(), Contact.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged contacts will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contacts that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contacts are sketched. If omitted redraw is true. If you want to sketch flagged contacts several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.StatusCheck = function() {
    /// <signature>
    /// <summary>Checks sliding contact for crossed edges and penetrations</summary>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Contact.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of contacts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing contacts should be counted. If false or omitted referenced but undefined contacts will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Contact.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the contact</summary>
    /// <returns type="null"/>
    /// </signature>
}

Contact.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the contacts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contacts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged contacts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged contacts will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contacts that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the contacts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all contacts will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the contacts</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the contact.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contact is unsketched. If omitted redraw is true. If you want to unsketch several contacts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all contacts.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contacts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contacts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged contacts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contacts will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contacts that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contacts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Contact"/>
    /// </signature>
}

Contact.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for contact. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Contact.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this contact.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Contact.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the Contact data in keyword format. Note that this contains the keyword header and the keyword cards. See also Contact.Keyword() and Contact.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var ContactGuidedCable = function() {
    /// <signature>
    /// <summary>Create a new ContactGuidedCable object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that ContactGuidedCable will be created in</param>
    /// <param name="ptype" type="Number" optional="false">Specify the type of ContactGuidedCable (Can be ContactGuidedCable.PART or ContactGuidedCable.SET_PART</param>
    /// <param name="nsid" type="Number" optional="false">Node Set ID that guides the 1D elements.</param>
    /// <param name="pid" type="Number" optional="false">Part ID or Part Set ID</param>
    /// <param name="soft" type="Number" optional="true">Flag for soft constraint option. Set to 1 for soft constraint.</param>
    /// <param name="ssfac" type="Number" optional="true">Stiffness scale factor for penalty stiffness value. The default value is unity. This applies to SOFT set to 0 and 1.</param>
    /// <param name="fric" type="Number" optional="true">Contact friction.</param>
    /// <param name="cid" type="Number" optional="true">ContactGuidedCable number (Same as label).</param>
    /// <param name="heading" type="String" optional="true">ContactGuidedCable heading (Same as title).</param>
    /// <returns type="ContactGuidedCable"/>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>ContactGuidedCable number.</field>
    /// <field name='exists' static='false' type='Boolean'>true if ContactGuidedCable exists, false if referred to but not defined. (read only)</field>
    /// <field name='fric' static='false' type='Number'>Contact friction.</field>
    /// <field name='heading' static='false' type='String'>ContactGuidedCable heading</field>
    /// <field name='id' static='false' type='Boolean'>TRUE if _ID option is set, FALSE if not</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the ContactGuidedCable is in.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the contact guided_cable is in.</field>
    /// <field name='nsid' static='false' type='Number'>Node Set ID that guides the 1D elements.</field>
    /// <field name='pid' static='false' type='Number'>Part ID or Part Set ID</field>
    /// <field name='ptype' static='false' type='Number'>The Contact Part type. Can be ContactGuidedCable.PART or ContactGuidedCable.SET_PART.</field>
    /// <field name='soft' static='false' type='Number'>Flag for soft constraint option. Set to 1 for soft constraint.</field>
    /// <field name='ssfac' static='false' type='Number'>Stiffness scale factor for penalty stiffness value. The default value is unity. This applies to SOFT set to 0 and 1.</field>
    /// <field name='PART' static='true' type='Number'>CONTACT is *CONTACT_GUIDED_CABLE.</field>
    /// <field name='SET_PART' static='true' type='Number'>CONTACT is *CONTACT_GUIDED_CABLE_SET.</field>
}

ContactGuidedCable.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the contact guided_cable</summary>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the contact guided_cables in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contact guided_cables will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged contact guided_cables in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged contact guided_cables will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contact guided_cables that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the contact guided_cable is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

ContactGuidedCable.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the contact guided_cable.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the contact guided_cable</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the contact guided_cable.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for contact guided_cable. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.First = function() {
    /// <signature>
    /// <summary>Returns the first contact guided_cable in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first contact guided_cable in</param>
    /// <returns type="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free contact guided_cable label in the model. Also see ContactGuidedCable.LastFreeLabel(), ContactGuidedCable.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free contact guided_cable label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ContactGuidedCable.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the contact guided_cables in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contact guided_cables will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the contact guided_cables</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the contact guided_cable is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the contact guided_cable</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

ContactGuidedCable.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each contact guided_cable in the model. Note that ForEach has been designed to make looping over contact guided_cables as fast as possible and so has some limitations. Firstly, a single temporary ContactGuidedCable object is created and on each function call it is updated with the current contact guided_cable data. This means that you should not try to store the ContactGuidedCable object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new contact guided_cables inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all contact guided_cables are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each contact guided_cable</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of ContactGuidedCable objects for all of the contact guided_cables in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get contact guided_cables from</param>
    /// <returns type="Array" elementType="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of ContactGuidedCable objects for all of the flagged contact guided_cables in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get contact guided_cables from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contact guided_cables that you want to retrieve</param>
    /// <returns type="Array" elementType="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the ContactGuidedCable object for a contact guided_cable ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the contact guided_cable in</param>
    /// <param name="number" type="Number" optional="false">number of the contact guided_cable you want the ContactGuidedCable object for</param>
    /// <returns type="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a ContactGuidedCable property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ContactGuidedCable.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">contact guided_cable property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

ContactGuidedCable.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this ContactGuidedCable (*contact_guided_cable). Note that a carriage return is not added. See also ContactGuidedCable.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ContactGuidedCable.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the ContactGuidedCable. Note that a carriage return is not added. See also ContactGuidedCable.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ContactGuidedCable.Last = function() {
    /// <signature>
    /// <summary>Returns the last contact guided_cable in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last contact guided_cable in</param>
    /// <returns type="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free contact guided_cable label in the model. Also see ContactGuidedCable.FirstFreeLabel(), ContactGuidedCable.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free contact guided_cable label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ContactGuidedCable.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next contact guided_cable in the model.</summary>
    /// <returns type="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) contact guided_cable label in the model. Also see ContactGuidedCable.FirstFreeLabel(), ContactGuidedCable.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free contact guided_cable label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ContactGuidedCable.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a contact guided_cable.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only contact guided_cables from that model can be picked. If the argument is a Flag then only contact guided_cables that are flagged with limit can be selected. If omitted, or null, any contact guided_cables from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous contact guided_cable in the model.</summary>
    /// <returns type="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the contact guided_cables in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contact guided_cables will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged contact guided_cables in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged contact guided_cables will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contact guided_cables that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select contact guided_cables using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting contact guided_cables</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only contact guided_cables from that model can be selected. If the argument is a Flag then only contact guided_cables that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any contact guided_cables can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ContactGuidedCable.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the contact guided_cable.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the contact guided_cable</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the contact guided_cable. The contact guided_cable will be sketched until you either call ContactGuidedCable.Unsketch(), ContactGuidedCable.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contact guided_cable is sketched. If omitted redraw is true. If you want to sketch several contact guided_cables and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged contact guided_cables in the model. The contact guided_cables will be sketched until you either call ContactGuidedCable.Unsketch(), ContactGuidedCable.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged contact guided_cables will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contact guided_cables that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contact guided_cables are sketched. If omitted redraw is true. If you want to sketch flagged contact guided_cables several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of contact guided_cables in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing contact guided_cables should be counted. If false or omitted referenced but undefined contact guided_cables will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ContactGuidedCable.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the contact guided_cable</summary>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the contact guided_cables in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contact guided_cables will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged contact guided_cables in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged contact guided_cables will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contact guided_cables that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the contact guided_cables in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all contact guided_cables will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the contact guided_cables</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the contact guided_cable.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contact guided_cable is unsketched. If omitted redraw is true. If you want to unsketch several contact guided_cables and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all contact guided_cables.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contact guided_cables will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contact guided_cables are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged contact guided_cables in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all contact guided_cables will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the contact guided_cables that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the contact guided_cables are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="ContactGuidedCable"/>
    /// </signature>
}

ContactGuidedCable.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for contact guided_cable. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

ContactGuidedCable.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this contact guided_cable.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

ContactGuidedCable.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the ContactGuidedCable data in keyword format. Note that this contains the keyword header and the keyword cards. See also ContactGuidedCable.Keyword() and ContactGuidedCable.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Control = function() {
    /// <field name='a' static='false' type='Number'>Load curve ID for the a coefficient used in the formula</field>
    /// <field name='aafac' static='false' type='Number'>ALE advection factor</field>
    /// <field name='absol' static='false' type='Number'>Terminate based on absolute total displacement in the Euclidean norm.</field>
    /// <field name='abstol' static='false' type='Number'>absolute convergence tol</field>
    /// <field name='abstol_1' static='false' type='Number'>Absolute convergence tolerance</field>
    /// <field name='accel' static='false' type='Number'>gravity</field>
    /// <field name='accuracy' static='false' type='Object'>*CONTROL_ACCURACY card</field>
    /// <field name='acoustic' static='false' type='Object'>*CONTROL_ACOUSTIC card</field>
    /// <field name='adapstep' static='false' type='Object'>*CONTROL_ADAPSTEP card</field>
    /// <field name='adaptive' static='false' type='Object'>*CONTROL_ADAPTIVE card</field>
    /// <field name='adaptive_curve' static='false' type='Object'>*CONTROL_ADAPTIVE_CURVE card</field>
    /// <field name='adatims' static='false' type='Number'>Total number of adaptive steps during the forming simulation</field>
    /// <field name='adpass' static='false' type='Number'>1 or 2 pass adaptivity flag</field>
    /// <field name='adpctl' static='false' type='Number'>Adaptivity error tolerance in degrees for activating fusion</field>
    /// <field name='adpene' static='false' type='Number'>Nodal penetration at which to refine elem</field>
    /// <field name='adperr' static='false' type='Number'>Options for recovery techniques and error estimators</field>
    /// <field name='adpfreq' static='false' type='Number'>Time interval between refinements</field>
    /// <field name='adpopt' static='false' type='Number'>Adaptive options</field>
    /// <field name='adpsize' static='false' type='Number'>Min element edge size for adaptivity</field>
    /// <field name='adpth' static='false' type='Number'>Absolute shell thickness below which remeshing should begin</field>
    /// <field name='adptol' static='false' type='Number'>Adaptive error tolerance (degrees)</field>
    /// <field name='afac' static='false' type='Number'>Smoothing weight factor: simple average</field>
    /// <field name='air_p' static='false' type='Number'>Pressure of atmospheric air</field>
    /// <field name='air_ro' static='false' type='Number'>Density of atmospheric air</field>
    /// <field name='airbag' static='false' type='Object'>*CONTROL_AIRBAG card</field>
    /// <field name='al_fe' static='false' type='String'>A=Aluminium blank, F=steel</field>
    /// <field name='al_fe_1' static='false' type='String'>A=Aluminium blank, F=steel</field>
    /// <field name='ale' static='false' type='Object'>*CONTROL_ALE card</field>
    /// <field name='algo' static='false' type='Number'>Contact algorithm type</field>
    /// <field name='alpha' static='false' type='Number'>Composite time integration constant</field>
    /// <field name='amax' static='false' type='Number'>Maximum allowable acceleration</field>
    /// <field name='amax_1' static='false' type='Number'>Maximum allowable acceleration</field>
    /// <field name='anamsg' static='false' type='Number'>Flag to turn off printing of pore air analysis status message</field>
    /// <field name='ang' static='false' type='Number'>contact angle</field>
    /// <field name='angle' static='false' type='Number'>Permitted angle between neighbours</field>
    /// <field name='arcalf' static='false' type='Number'>relative influence predictor step</field>
    /// <field name='arcctl' static='false' type='Number'>Arc length controlling node ID</field>
    /// <field name='arcdir' static='false' type='Number'>Arc length controlling node direction</field>
    /// <field name='arcdmp' static='false' type='Number'>Arc length damping option</field>
    /// <field name='arclen' static='false' type='Number'>Arc length size</field>
    /// <field name='arcmth' static='false' type='Number'>Arc length method</field>
    /// <field name='arcpsi' static='false' type='Number'>relative influence load/time parameter</field>
    /// <field name='arctim' static='false' type='Number'>initiation time</field>
    /// <field name='atype' static='false' type='Number'>Analysis type</field>
    /// <field name='atype_1' static='false' type='Number'>Thermal analysis type</field>
    /// <field name='autospc' static='false' type='Number'>AUTOSPC switch</field>
    /// <field name='autotol' static='false' type='Number'>AUTOSPC tolerance</field>
    /// <field name='awgt' static='false' type='Number'>weight factor</field>
    /// <field name='b' static='false' type='Number'>Load curve ID for the b coefficient used in the formula</field>
    /// <field name='bc_flg' static='false' type='Number'>Thermal boundary condition flag</field>
    /// <field name='bckmth' static='false' type='Number'>Method to extract buckling modes</field>
    /// <field name='beamin' static='false' type='Number'>Flag for aligning beam dynamics</field>
    /// <field name='begtim' static='false' type='Number'>start time</field>
    /// <field name='beta' static='false' type='Number'>Newmark time integration constant</field>
    /// <field name='bfac' static='false' type='Number'>Smoothing weight factor: volume weighting</field>
    /// <field name='binary' static='false' type='Number'>flag to set _BINARY option</field>
    /// <field name='birth' static='false' type='Number'>birth time</field>
    /// <field name='blank' static='false' type='Number'>Part (stype=0) or part set (stype=1) ID for blank</field>
    /// <field name='blkid' static='false' type='Number'>Part (stype=0) or part set (stype=1) ID that defines the blank</field>
    /// <field name='bmsid' static='false' type='Number'>beam set for convert to hex assembly</field>
    /// <field name='bndflx' static='false' type='Number'>Multi-Material ALE group set if positive or -1</field>
    /// <field name='bndl' static='false' type='Number'>Part that defines the lower binder</field>
    /// <field name='bndu' static='false' type='Number'>Part that defines the upper binder</field>
    /// <field name='boxid' static='false' type='Number'>Box limiting application</field>
    /// <field name='bt' static='false' type='Number'>Birth time</field>
    /// <field name='btype' static='false' type='Number'>beam bulk viscosity type</field>
    /// <field name='bulk_viscosity' static='false' type='Object'>*CONTROL_BULK_VISCOSITY card</field>
    /// <field name='bwc' static='false' type='Number'>Warping stiffness flag for Belytschko-Tsay shells</field>
    /// <field name='c' static='false' type='Number'>Load curve ID for the c coefficient used in the formula</field>
    /// <field name='cap' static='false' type='Number'>dry/wet particle flag</field>
    /// <field name='cbirth' static='false' type='Number'>Birth time for adaptive fusion</field>
    /// <field name='cdeath' static='false' type='Number'>Death time for adaptive fusion</field>
    /// <field name='cdetol' static='false' type='Number'>Tolerance for output of *DEFINE_CURVE discretization warnings</field>
    /// <field name='center' static='false' type='Number'>Centre frequency</field>
    /// <field name='cfac' static='false' type='Number'>Smoothing weight factor: isoparametric</field>
    /// <field name='cgtol' static='false' type='Number'>Convergence tolerance for iterative solver</field>
    /// <field name='charlen' static='false' type='Number'>Max flange height</field>
    /// <field name='check' static='false' type='Object'>*CONTROL_CHECK card</field>
    /// <field name='checkr' static='false' type='Number'>Parameter for ALE pressure locking</field>
    /// <field name='cid' static='false' type='Number'>ID of coordinate system (only for the LOCAL option)</field>
    /// <field name='cid_1' static='false' type='Number'>coordinate system id</field>
    /// <field name='cnla' static='false' type='Number'>Limit angle for corner nodes</field>
    /// <field name='cnstn' static='false' type='Number'>Consistent tangent stiffness flag</field>
    /// <field name='cntco' static='false' type='Number'>include shell ref surface offset</field>
    /// <field name='coarsen' static='false' type='Object'>*CONTROL_COARSEN card</field>
    /// <field name='coefficients' static='false' type='Number'>Number of coefficients for SPECIFIC and FREQUENCY_RANGE options</field>
    /// <field name='conmax' static='false' type='Number'>damping factor</field>
    /// <field name='consty' static='false' type='Number'>Consistency (Accuracy) flag</field>
    /// <field name='cont' static='false' type='Number'>Particle approx method</field>
    /// <field name='contact' static='false' type='Object'>*CONTROL_CONTACT card</field>
    /// <field name='conv' static='false' type='Number'>conduction factor</field>
    /// <field name='coupling' static='false' type='Object'>*CONTROL_COUPLING card</field>
    /// <field name='cp' static='false' type='Number'>Heat Capacity. Constant float value if CPTYP = 0,  Curve ID if CPTYP = 1.</field>
    /// <field name='cpchk' static='false' type='Number'>Contact penetration check flag</field>
    /// <field name='cpm' static='false' type='Object'>*CONTROL_CPM card</field>
    /// <field name='cpmerr' static='false' type='Number'>Disable/enable error checking</field>
    /// <field name='cpmmf' static='false' type='Number'>Flag to consider airbag system velocity</field>
    /// <field name='cptyp' static='false' type='Number'>Type of CP. Valid values: 0-Constant, 1-Temperature vs Heat Capacity Curve.</field>
    /// <field name='cpu' static='false' type='Object'>*CONTROL_CPU card</field>
    /// <field name='cputim' static='false' type='Number'>Max permitted cpu time</field>
    /// <field name='cstyp6' static='false' type='Number'>Coord sys for type 6 element</field>
    /// <field name='cweight' static='false' type='Number'>Element cost scale factor for element in contact</field>
    /// <field name='cx' static='false' type='Number'>X component of centre of most-bent location</field>
    /// <field name='cy' static='false' type='Number'>Y component of centre of most-bent location</field>
    /// <field name='cz' static='false' type='Number'>Z component of centre of most-bent location</field>
    /// <field name='d' static='false' type='Number'>Explicit accuracy parameter</field>
    /// <field name='d3itctl' static='false' type='Number'>D3ITER database control</field>
    /// <field name='d3plot' static='false' type='Number'>Number of output states in the D3PLOT database</field>
    /// <field name='d3plt' static='false' type='Number'>Number of output states in the D3PLOT database</field>
    /// <field name='d3trace' static='false' type='Number'>Flag for writing out d3plot state</field>
    /// <field name='dampf' static='false' type='Number'>Modal damping coefficient</field>
    /// <field name='datum' static='false' type='Number'>Z elevation of datum</field>
    /// <field name='dc' static='false' type='Number'>Exponential decay coefficient</field>
    /// <field name='dcp' static='false' type='Number'>Divergence control parameter</field>
    /// <field name='dct' static='false' type='Number'>Default continuum treatment</field>
    /// <field name='dctol' static='false' type='Number'>Displacement convergence tolerance</field>
    /// <field name='death' static='false' type='Number'>death time</field>
    /// <field name='debug' static='false' type='Object'>*CONTROL_DEBUG card</field>
    /// <field name='defgeo' static='false' type='Number'>Geometry for decomposition</field>
    /// <field name='delfr' static='false' type='Number'>delete shells where neighbours fail</field>
    /// <field name='delta1' static='false' type='Number'>Terminate based on rel total displacement in max norm</field>
    /// <field name='deltau' static='false' type='Number'>Terminate based on rel total displacement in Euclidean norm</field>
    /// <field name='demden' static='false' type='Number'>Output DEM density data to d3plot database</field>
    /// <field name='density' static='false' type='Number'>Density</field>
    /// <field name='density_1' static='false' type='Number'>Density</field>
    /// <field name='deriv' static='false' type='Number'>Time integration type</field>
    /// <field name='dfac' static='false' type='Number'>Smoothing weight factor: equipotential</field>
    /// <field name='dfactr' static='false' type='Number'>Incremental increase in factin</field>
    /// <field name='dfric' static='false' type='Number'>Default dynamic coefficient of friction</field>
    /// <field name='dieid' static='false' type='Number'>Part that defines the die</field>
    /// <field name='direct' static='false' type='Number'>Number of automatically determined directions</field>
    /// <field name='discrete_element' static='false' type='Object'>*CONTROL_DISCRETE_ELEMENT card</field>
    /// <field name='dist' static='false' type='Number'>Distance tolerance for auto-SPC along flange roots</field>
    /// <field name='diverg' static='false' type='Number'>Divergence flag</field>
    /// <field name='dmpmas' static='false' type='Number'>Mass proportional damping constant in Rayleigh damping</field>
    /// <field name='dmpstf' static='false' type='Number'>Stiffness proportional damping constant in Rayleigh damping</field>
    /// <field name='dmtol' static='false' type='Number'>Maximum displacement convergence tolerance</field>
    /// <field name='dnorm' static='false' type='Number'>Displacement norm for convergence test</field>
    /// <field name='dof1' static='false' type='Number'>Applicable degrees-of-freedom for excitation input</field>
    /// <field name='dof2' static='false' type='Number'>Applicable degrees-of-freedom for response output</field>
    /// <field name='dordel' static='false' type='Number'>Dormant part treatment in d3plot file</field>
    /// <field name='dpwmax' static='false' type='Number'>Max rate of change of pwp water head (m/s)</field>
    /// <field name='drcm' static='false' type='Number'>Drilling rotation constraint method</field>
    /// <field name='drcmth' static='false' type='Number'>drilling rotation constraint method.</field>
    /// <field name='drcprm' static='false' type='Number'>Drilling rotation constraint parameter</field>
    /// <field name='drcpsid' static='false' type='Number'>part set for drilling rotation constraint method.</field>
    /// <field name='drcpsrm' static='false' type='Number'>drilling rotation constraint parameter.</field>
    /// <field name='drfctr' static='false' type='Number'>Dyn relaxation factor</field>
    /// <field name='drpset' static='false' type='Number'>Part set used to check for convergence</field>
    /// <field name='drterm' static='false' type='Number'>Optional DR termination time</field>
    /// <field name='drtol' static='false' type='Number'>Convergence tolerance</field>
    /// <field name='dt' static='false' type='Number'>Death time</field>
    /// <field name='dt0' static='false' type='Number'>initial time step size</field>
    /// <field name='dt0_1' static='false' type='Number'>Initial timestep for implicit analysis</field>
    /// <field name='dt2ms' static='false' type='Number'>Timestep for mass scaling</field>
    /// <field name='dt2msf' static='false' type='Number'>Scale factor for initial timestep size to determine min permitted time step size</field>
    /// <field name='dt2mslc' static='false' type='Number'>Loadcurve: DT2MS vs time</field>
    /// <field name='dt_1' static='false' type='Number'>Death time</field>
    /// <field name='dt_cycle' static='false' type='Number'>Flag for output option (time interval or cycle number)</field>
    /// <field name='dt_cycle_1' static='false' type='Number'>Flag for output option (time interval or cycle number)</field>
    /// <field name='dtemp' static='false' type='Number'>Max delta temp permitted before timestep decrease, of LC of dt vs time if -ve</field>
    /// <field name='dtexp' static='false' type='Number'>time in explicit before switch</field>
    /// <field name='dtfac' static='false' type='Number'>Time step factor.</field>
    /// <field name='dtinit' static='false' type='Number'>Initial timestep size</field>
    /// <field name='dtmax' static='false' type='Number'>Maximum allowable timestep. Loadcurve if negative</field>
    /// <field name='dtmin' static='false' type='Number'>Minimum allowable timestep</field>
    /// <field name='dtmin_1' static='false' type='Number'>timestep size for remesh</field>
    /// <field name='dtmin_2' static='false' type='Number'>Scale factor on initial dt size for termination</field>
    /// <field name='dtmufac' static='false' type='Number'>Scale time step called DTMU</field>
    /// <field name='dtout' static='false' type='Number'>Time interval between outputs. Constant float value if DTOUTYP = 0,  Curve ID if DTOUTYP = 1.</field>
    /// <field name='dtout_1' static='false' type='Number'>Modal dynamics output interval</field>
    /// <field name='dtoutyp' static='false' type='Number'>Type of DTOUT. Valid values: 0-Constant, 1-Time vs DTOUT Curve.</field>
    /// <field name='dtvf' static='false' type='Number'>Time interval between view factor updates</field>
    /// <field name='dvid' static='false' type='Number'>Not used</field>
    /// <field name='dynamic_relaxation' static='false' type='Object'>*CONTROL_DYNAMIC_RELAXATION card</field>
    /// <field name='e' static='false' type='Number'>Youngs modulus</field>
    /// <field name='e_1' static='false' type='Number'>Youngs modulus</field>
    /// <field name='ebc' static='false' type='Number'>Automatic Euler boundary condition</field>
    /// <field name='ecdt' static='false' type='Number'>Timestep override for eroding contacts</field>
    /// <field name='ectol' static='false' type='Number'>Energy convergence tolerance</field>
    /// <field name='edc' static='false' type='Number'>Default exponential decay coefficient</field>
    /// <field name='edttl' static='false' type='Number'>Convergence tolerance on auto control</field>
    /// <field name='efac' static='false' type='Number'>Smoothing weight factor: equipotential</field>
    /// <field name='efg' static='false' type='Object'>*CONTROL_EFG card</field>
    /// <field name='efg_1' static='false' type='Number'>efg keyword option</field>
    /// <field name='eigmth' static='false' type='Number'>Eigenvalue extraction method</field>
    /// <field name='emtol' static='false' type='Number'>Maximum energy convergence tolerance</field>
    /// <field name='emxdmp' static='false' type='Number'>Flag for dumping elemental stiffness and mass matrices</field>
    /// <field name='end' static='false' type='Number'>End time for smoothing</field>
    /// <field name='endcyc' static='false' type='Number'>Termination cycle #</field>
    /// <field name='endeng' static='false' type='Number'>%age change in energy for termination</field>
    /// <field name='endmas' static='false' type='Number'>%age change in mass for termination</field>
    /// <field name='endtim' static='false' type='Number'>Termination time</field>
    /// <field name='energy' static='false' type='Object'>*CONTROL_ENERGY card</field>
    /// <field name='engout' static='false' type='Number'>Flag to output contact sliding energy densities for mortar contact</field>
    /// <field name='enmass' static='false' type='Number'>Treatment of mass of eroded nodes</field>
    /// <field name='eocs' static='false' type='Number'>Elout coordinate system option</field>
    /// <field name='epsmx' static='false' type='Number'>Max effective plastic strain, beyond which elements are deleted</field>
    /// <field name='eqheat' static='false' type='Number'>Mechanical equivelent of heat (J/Nm etc). Loadcurve if negative</field>
    /// <field name='erode' static='false' type='Number'>Erosion flag for solids &amp; shells @ DTMIN</field>
    /// <field name='esort' static='false' type='Number'>Degenerate shell sorting flag (was ITRIST)</field>
    /// <field name='esort_1' static='false' type='Number'>Automatic sort of tetra &amp; penta flag</field>
    /// <field name='eterm' static='false' type='Number'>Event termination time</field>
    /// <field name='eterm_1' static='false' type='Number'>event time termination</field>
    /// <field name='etflag' static='false' type='Number'>Flag for interpretation of time</field>
    /// <field name='etol' static='false' type='Number'>Error tolerance in the IMLM</field>
    /// <field name='evdump' static='false' type='Number'>Flag for writing eigenvalues and eigenvectors</field>
    /// <field name='exacc' static='false' type='Number'>Explicit accuracy parameter</field>
    /// <field name='excl' static='false' type='Number'>.eq.1 if excl above</field>
    /// <field name='exists' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_1' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_10' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_100' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_101' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_102' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_103' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_104' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_105' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_106' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_107' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_108' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_109' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_11' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_110' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_111' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_112' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_113' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_114' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_115' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_116' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_117' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_118' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_119' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_12' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_120' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_13' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_14' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_15' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_16' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_17' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_18' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_19' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_2' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_20' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_21' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_22' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_23' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_24' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_25' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_26' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_27' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_28' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_29' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_3' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_30' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_31' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_32' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_33' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_34' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_35' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_36' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_37' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_38' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_39' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_4' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_40' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_41' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_42' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_43' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_44' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_45' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_46' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_47' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_48' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_49' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_5' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_50' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_51' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_52' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_53' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_54' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_55' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_56' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_57' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_58' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_59' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_6' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_60' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_61' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_62' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_63' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_64' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_65' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_66' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_67' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_68' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_69' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_7' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_70' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_71' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_72' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_73' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_74' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_75' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_76' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_77' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_78' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_79' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_8' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_80' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_81' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_82' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_83' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_84' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_85' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_86' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_87' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_88' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_89' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_9' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_90' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_91' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_92' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_93' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_94' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_95' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_96' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_97' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_98' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='exists_99' static='false' type='Boolean'>true if control card exists</field>
    /// <field name='explicit_thermal' static='false' type='Object'>*CONTROL_EXPLICIT_THERMAL_PROPERTIES card</field>
    /// <field name='explicit_thermal_ale_coupling' static='false' type='Object'>*CONTROL_EXPLICIT_THERMAL_ALE_COUPLING card</field>
    /// <field name='explicit_thermal_boundary' static='false' type='Object'>*CONTROL_EXPLICIT_THERMAL_BOUNDARY card</field>
    /// <field name='explicit_thermal_contact' static='false' type='Object'>*CONTROL_EXPLICIT_THERMAL_CONTACT card</field>
    /// <field name='explicit_thermal_initial' static='false' type='Object'>*CONTROL_EXPLICIT_THERMAL_INITIAL card</field>
    /// <field name='explicit_thermal_output' static='false' type='Object'>*CONTROL_EXPLICIT_THERMAL_OUTPUT card</field>
    /// <field name='explicit_thermal_solver' static='false' type='Object'>*CONTROL_EXPLICIT_THERMAL_SOLVER card</field>
    /// <field name='explosive_shadow' static='false' type='Object'>*CONTROL_EXPLOSIVE_SHADOW card</field>
    /// <field name='f_936' static='false' type='Number'>Internal flag to set 936 compatibility</field>
    /// <field name='fact' static='false' type='Number'>default stiffness/gravity factor</field>
    /// <field name='factin' static='false' type='Number'>Initial relaxation factor for contact force</field>
    /// <field name='filename' static='false' type='String'>Target mesh file in keyword format</field>
    /// <field name='filename2' static='false' type='String'>Constraint modes file name</field>
    /// <field name='filename_1' static='false' type='String'>Eigen modes file name</field>
    /// <field name='flipx' static='false' type='Number'>Flag to flip X coords</field>
    /// <field name='flipy' static='false' type='Number'>Flag to flip Y coords</field>
    /// <field name='flipz' static='false' type='Number'>Flag to flip Z coords</field>
    /// <field name='fmatrix' static='false' type='Number'>calculation method for deformation gradient</field>
    /// <field name='fmax' static='false' type='Number'>Maximum frequency for FRF output</field>
    /// <field name='fmax_1' static='false' type='Number'>max seepage factor</field>
    /// <field name='fmax_2' static='false' type='Number'>Maximum factor on seepage calc</field>
    /// <field name='fmin' static='false' type='Number'>Minimum frequency for FRF output</field>
    /// <field name='fmin_1' static='false' type='Number'>min seepage factor</field>
    /// <field name='fmin_2' static='false' type='Number'>Minimum factor on seepage calc</field>
    /// <field name='fnmax' static='false' type='Number'>Optional maximum natural frequency</field>
    /// <field name='follow' static='false' type='Number'>Part for tool to follow</field>
    /// <field name='form' static='false' type='Number'>Element formulation to use.</field>
    /// <field name='form_1' static='false' type='Number'>particle theory</field>
    /// <field name='forming_bestfit' static='false' type='Object'>*CONTROL_FORMING_CONTROL_FORMING_BESTFIT card</field>
    /// <field name='forming_initial_thickness' static='false' type='Object'>*CONTROL_FORMING_INITIAL_THICKNESS card</field>
    /// <field name='forming_maxid' static='false' type='Object'>*CONTROL_FORMING_MAXID card</field>
    /// <field name='forming_position' static='false' type='Object'>*CONTROL_FORMING_POSITION card</field>
    /// <field name='forming_pre_bending' static='false' type='Object'>*CONTROL_FORMING_PRE_BENDING card</field>
    /// <field name='forming_projection' static='false' type='Object'>*CONTROL_FORMING_PROJECTION card</field>
    /// <field name='forming_remove_adaptive_constraints' static='false' type='Object'>*CONTROL_FORMING_REMOVE_ADAPTIVE_CONSTRAINTS card</field>
    /// <field name='forming_shell_to_tshell' static='false' type='Object'>*CONTROL_FORMING_SHELL_TO_TSHELL card</field>
    /// <field name='forming_stoning' static='false' type='Object'>*CONTROL_FORMING_STONING card</field>
    /// <field name='forming_strain_ratio_smooth' static='false' type='Object'>*CONTROL_FORMING_STRAIN_RATIO_SMOOTH card</field>
    /// <field name='forming_template' static='false' type='Object'>*CONTROL_FORMING_TEMPLATE card</field>
    /// <field name='forming_toleranc' static='false' type='Object'>*CONTROL_FORMING_TOLERANC card</field>
    /// <field name='forming_travel' static='false' type='Object'>*CONTROL_FORMING_TRAVEL card</field>
    /// <field name='forming_trim_merge' static='false' type='Object'>*CONTROL_FORMING_TRIM_MERGE card</field>
    /// <field name='forming_trimming_solid_refinement' static='false' type='Object'>*CONTROL_FORMING_TRIMMING_SOLID_REFINEMENT card</field>
    /// <field name='forming_unflanging' static='false' type='Object'>*CONTROL_FORMING_UNFLANGING card</field>
    /// <field name='forming_user' static='false' type='Object'>*CONTROL_FORMING_USER card</field>
    /// <field name='formula' static='false' type='Number'>Formula that defines the contact heat conductance as a function of temperature and pressure</field>
    /// <field name='frad' static='false' type='Number'>Radiation factor between the contact surfaces</field>
    /// <field name='frceng' static='false' type='Number'>Flag to calculate internal friction energy</field>
    /// <field name='freq' static='false' type='Number'>Time interval between redecomposition</field>
    /// <field name='frequency_domain' static='false' type='Object'>*CONTROL_FREQUENCY_DOMAIN card</field>
    /// <field name='frequency_range' static='false' type='Boolean'>If FREQUENCY_RANGE option is used</field>
    /// <field name='frequency_response_function' static='false' type='Object'>*CONTROL_FREQUENCY_RESPONSE_FUNCTION card</field>
    /// <field name='frfreq' static='false' type='Number'>Output frequency for failed element report</field>
    /// <field name='fricd' static='false' type='Number'>Dynamic coefficient of friction</field>
    /// <field name='fricr' static='false' type='Number'>rolling friction coefficient</field>
    /// <field name='frics' static='false' type='Number'>friction coefficient</field>
    /// <field name='fs' static='false' type='Number'>Friction coefficient</field>
    /// <field name='fs_1' static='false' type='Number'>Friction coefficient</field>
    /// <field name='ftall' static='false' type='Number'>output contact forces to rcforc</field>
    /// <field name='ftied' static='false' type='Number'>Analysis type</field>
    /// <field name='ftoslv' static='false' type='Number'>Fraction of sliding friction energy partitioned to the slave surface</field>
    /// <field name='fwork' static='false' type='Number'>Fraction of mechanical heat converted into heat</field>
    /// <field name='fwork_1' static='false' type='Number'>Fraction of mechanical work converted into heat</field>
    /// <field name='gamma' static='false' type='Number'>liquid surface tension</field>
    /// <field name='gamma_1' static='false' type='Number'>Newmark time integration constant</field>
    /// <field name='gap' static='false' type='Number'>parameter affecting spatial limit of liquid bridge</field>
    /// <field name='gap_1' static='false' type='Number'>Minimum gap</field>
    /// <field name='gap_2' static='false' type='Number'>Home gap between rigid tools</field>
    /// <field name='gap_3' static='false' type='Number'>Min distance between tool and target in the home position</field>
    /// <field name='gap_4' static='false' type='Number'>Minimum gap between tools</field>
    /// <field name='gapm' static='false' type='Number'>Gap distance between two open ends of a trim loop curve in the model</field>
    /// <field name='gaponly' static='false' type='Number'>Separation distance calculation flag</field>
    /// <field name='gjadstf' static='false' type='Number'>Joint rotational stiffness</field>
    /// <field name='gjadvsc' static='false' type='Number'>Joint rotational damping</field>
    /// <field name='gmdt' static='false' type='Number'>output interval for *INTERFACE_SSI_AUX</field>
    /// <field name='gpt' static='false' type='Number'>#gauss points in solids</field>
    /// <field name='grav' static='false' type='Number'>Gravitational acceleration for Ro.g.h</field>
    /// <field name='grp' static='false' type='Number'>GROUPABLE algorithm options</field>
    /// <field name='h0' static='false' type='Number'>Heat transfer conductance for closed gaps</field>
    /// <field name='hcmax' static='false' type='Number'>Mid-point relative Euclidian residual norm max tolerance</field>
    /// <field name='hcmin' static='false' type='Number'>Mid-point relative Euclidian residual norm min tolerance</field>
    /// <field name='hgen' static='false' type='Number'>Hourglass energy calc flag</field>
    /// <field name='hisnout' static='false' type='Number'>Flag to invoke output of extra history variable names</field>
    /// <field name='hmmax' static='false' type='Number'>Mid-point relative maximum residual norm max tolerance</field>
    /// <field name='hmmin' static='false' type='Number'>Mid-point relative maximum residual norm min tolerance</field>
    /// <field name='hnrmax' static='false' type='Number'>Mid-point absolute Nodal Rotational norm tolerance</field>
    /// <field name='hntmax' static='false' type='Number'>Mid-point absolute Nodal Translational norm tolerance</field>
    /// <field name='hourglass' static='false' type='Object'>*CONTROL_HOURGLASS card</field>
    /// <field name='hrrmax' static='false' type='Number'>Mid-point absolute Rigid body Rotational norm tolerance</field>
    /// <field name='hrtmax' static='false' type='Number'>Mid-point absolute Rigid body Translational norm tolerance</field>
    /// <field name='hsort' static='false' type='Number'>Not used</field>
    /// <field name='iaat' static='false' type='Number'>interactive adaptivity adjustable tolerance</field>
    /// <field name='iacc' static='false' type='Number'>Implicit accuracy flag</field>
    /// <field name='iaccop' static='false' type='Number'>Flag for accels in d3thdt to be averaged</field>
    /// <field name='iadpcl' static='false' type='Number'>Fission level that fusion will start at</field>
    /// <field name='iadpe90' static='false' type='Number'>Maximum no. of elements covering 90degree of radii</field>
    /// <field name='iadpgh' static='false' type='Number'>Fiffion flag for neighbour splitting</field>
    /// <field name='ialedr' static='false' type='Number'>Include ALE computations in the dynamic relaxation analysis</field>
    /// <field name='ias' static='false' type='Number'>Artificial stabilization flag</field>
    /// <field name='iat' static='false' type='Number'>interactive adaptivity</field>
    /// <field name='iat1' static='false' type='Number'>tolerance of shear distortion indicator for interactive adaptivity</field>
    /// <field name='iat2' static='false' type='Number'>tolerance of unbalanced nodal distribution indicator for interactive adaptivity</field>
    /// <field name='iat3' static='false' type='Number'>tolerance of volumetric change indicator for interactive adaptivity</field>
    /// <field name='iauto' static='false' type='Number'>Automatic timestep control flag. Loadcurve if negative</field>
    /// <field name='iavis' static='false' type='Number'>artificial viscosity formulation</field>
    /// <field name='ibase' static='false' type='Number'>Offset for numbering</field>
    /// <field name='ibeam' static='false' type='Number'>Beam element formulation for implicit</field>
    /// <field name='ibq' static='false' type='Number'>Default bulk viscosity type (m#PR035)</field>
    /// <field name='ibsf' static='false' type='Number'>Flag to invoke output of *SET_BEAM data</field>
    /// <field name='icoarse' static='false' type='Number'>On/Off flag</field>
    /// <field name='icoh' static='false' type='Number'>global flag for cohesive element deletion</field>
    /// <field name='icont' static='false' type='Number'>contact option</field>
    /// <field name='icov' static='false' type='Number'>Invokes the covariant formulation of Konyukhov and Schweizerhof</field>
    /// <field name='icrfile' static='false' type='Number'>Output node and element sets used in computing secforc data</field>
    /// <field name='icurv' static='false' type='Number'>number of elements along radius</field>
    /// <field name='icylin' static='false' type='Number'>Treatment of cylindrical joints</field>
    /// <field name='id' static='false' type='Number'>If less than 0 then Element ID if greater than 0 then  Set ID. Can be SOLID, SHELL, BEAM or THICK SHELL based on value of idtyp.</field>
    /// <field name='id1' static='false' type='Number'>Contact ID 1 to distrubute</field>
    /// <field name='id10' static='false' type='Number'>Contact ID 10 to distrubute</field>
    /// <field name='id11' static='false' type='Number'>Contact ID 11 to distrubute</field>
    /// <field name='id12' static='false' type='Number'>Contact ID 12 to distrubute</field>
    /// <field name='id13' static='false' type='Number'>Contact ID 13 to distrubute</field>
    /// <field name='id14' static='false' type='Number'>Contact ID 14 to distrubute</field>
    /// <field name='id15' static='false' type='Number'>Contact ID 15 to distrubute</field>
    /// <field name='id1_1' static='false' type='Number'>Contact ID 1 to distrubute</field>
    /// <field name='id2' static='false' type='Number'>Contact ID 2 to distrubute</field>
    /// <field name='id2_1' static='false' type='Number'>Contact ID 2 to distrubute</field>
    /// <field name='id3' static='false' type='Number'>Contact ID 3 to distrubute</field>
    /// <field name='id3_1' static='false' type='Number'>Contact ID 3 to distrubute</field>
    /// <field name='id4' static='false' type='Number'>Contact ID 4 to distrubute</field>
    /// <field name='id4_1' static='false' type='Number'>Contact ID 4 to distrubute</field>
    /// <field name='id5' static='false' type='Number'>Contact ID 5 to distrubute</field>
    /// <field name='id5_1' static='false' type='Number'>Contact ID 5 to distrubute</field>
    /// <field name='id6' static='false' type='Number'>Contact ID 6 to distrubute</field>
    /// <field name='id7' static='false' type='Number'>Contact ID 7 to distrubute</field>
    /// <field name='id8' static='false' type='Number'>Contact ID 8 to distrubute</field>
    /// <field name='id9' static='false' type='Number'>Contact ID 9 to distrubute</field>
    /// <field name='id_off' static='false' type='Number'>part id offset</field>
    /// <field name='ideb' static='false' type='Number'>Output internal debug message</field>
    /// <field name='idila' static='false' type='Number'>dilation param</field>
    /// <field name='idim' static='false' type='Number'>Space system flag</field>
    /// <field name='idpm' static='false' type='Number'>Part id for tool</field>
    /// <field name='idps' static='false' type='Number'>Part id for blank</field>
    /// <field name='idrflg' static='false' type='Number'>Stress initialisation flag</field>
    /// <field name='idsegb' static='false' type='Number'>Set id of the segments to be generated at the bottom layer</field>
    /// <field name='idsegt' static='false' type='Number'>Set id of the segments to be generated at the top layer</field>
    /// <field name='idset' static='false' type='Number'>Shell/Part set id</field>
    /// <field name='idtemp' static='false' type='Number'>Type of forming process</field>
    /// <field name='idtyp' static='false' type='Number'>Type of ID. Valid values: 1-Solid, 2-Shell, 3-Beam, 4-Thick shell .</field>
    /// <field name='ier' static='false' type='Number'>remeshing with element erosion</field>
    /// <field name='ierod' static='false' type='Number'>erosion option</field>
    /// <field name='ierode' static='false' type='Number'>output eroded energy</field>
    /// <field name='ietol' static='false' type='Number'>Terminate based on internal energy</field>
    /// <field name='ifast' static='false' type='Number'>Computing performance optimisation flag</field>
    /// <field name='ifit' static='false' type='Number'>Best fit flag</field>
    /// <field name='iflag' static='false' type='Number'>Consistent mass matrix flag</field>
    /// <field name='iflimit' static='false' type='Number'>Iteration limit for first phase of unfolding</field>
    /// <field name='iflush' static='false' type='Number'>i/o buffer flushing interval (t-steps)</field>
    /// <field name='iformat' static='false' type='Number'>Format for processing eigenmodes</field>
    /// <field name='ifsand' static='false' type='Number'>Flag for forming of sandwiched parts with adaptive blank mesh</field>
    /// <field name='ifset' static='false' type='Number'>Optional flag to define a node set to be included or excluded</field>
    /// <field name='igactc' static='false' type='Number'>option to use isogeometric shells for contact detection</field>
    /// <field name='iglst' static='false' type='Number'>glstat data flag</field>
    /// <field name='ignore' static='false' type='Number'>Ignore initial penetrations flag</field>
    /// <field name='ignore_1' static='false' type='Number'>Ignore penetration flag</field>
    /// <field name='igs' static='false' type='Number'>Geometric (initial stress) stiffness flag</field>
    /// <field name='ihdo' static='false' type='Number'>Method for calculating solid element time steps</field>
    /// <field name='ihq' static='false' type='Number'>Hourglass viscosity type</field>
    /// <field name='ikedit' static='false' type='Number'>Status report interval to d3hsp</field>
    /// <field name='ilevel' static='false' type='Number'>Adaptive refinement level</field>
    /// <field name='ilimit' static='false' type='Number'>Iteration limit between automatic stiffness reformations</field>
    /// <field name='ilinear' static='false' type='Number'>Unfolding algorithm selection flag</field>
    /// <field name='imascl' static='false' type='Number'>Flag for mass scaling for ALE parts</field>
    /// <field name='imass' static='false' type='Number'>Implicit analysis type</field>
    /// <field name='imass_1' static='false' type='Number'>Inertia switching flag</field>
    /// <field name='imerge' static='false' type='Number'>Activation flag</field>
    /// <field name='imflag' static='false' type='Number'>Implicit/explicit switching flag; loadcurve if negative</field>
    /// <field name='imform' static='false' type='Number'>Element formulation switching flag</field>
    /// <field name='imlm' static='false' type='Number'>Choice for matrix operation, linear solving and memory usage</field>
    /// <field name='implicit_auto' static='false' type='Object'>*CONTROL_IMPLICIT_AUTO card</field>
    /// <field name='implicit_buckle' static='false' type='Object'>*CONTROL_IMPLICIT_BUCKLE card</field>
    /// <field name='implicit_consistent_mass' static='false' type='Object'>*CONTROL_IMPLICIT_CONSISTENT_MASS card</field>
    /// <field name='implicit_dynamics' static='false' type='Object'>*CONTROL_IMPLICIT_DYNAMICS card</field>
    /// <field name='implicit_eigenvalue' static='false' type='Object'>*CONTROL_IMPLICIT_EIGENVALUE card</field>
    /// <field name='implicit_explicit_hybrid' static='false' type='Object'>*CONTROL_IMPLICIT_EXPLICT_HYBRID card</field>
    /// <field name='implicit_forming' static='false' type='Object'>*CONTROL_IMPLICIT_FORMING card</field>
    /// <field name='implicit_general' static='false' type='Object'>*CONTROL_IMPLICIT_GENERAL card</field>
    /// <field name='implicit_inertia_relief' static='false' type='Object'>*CONTROL_IMPLICIT_INERTIA_RELIEF card</field>
    /// <field name='implicit_joints' static='false' type='Object'>*CONTROL_IMPLICIT_JOINTS card</field>
    /// <field name='implicit_modal_dynamic' static='false' type='Object'>*CONTROL_IMPLICIT_MODAL_DYNAMIC card</field>
    /// <field name='implicit_modal_dynamic_damping' static='false' type='Object'>*CONTROL_IMPLICIT_MODAL_DYNAMIC_DAMPING card</field>
    /// <field name='implicit_modes' static='false' type='Object'>*CONTROL_IMPLICIT_MODES card</field>
    /// <field name='implicit_ordering' static='false' type='Object'>*CONTROL_IMPLICIT_ORDERING card</field>
    /// <field name='implicit_residual_vector' static='false' type='Object'>*CONTROL_IMPLICIT_RESIDUAL_VECTOR card</field>
    /// <field name='implicit_solution' static='false' type='Object'>*CONTROL_IMPLICIT_SOLUTION card</field>
    /// <field name='implicit_solver' static='false' type='Object'>*CONTROL_IMPLICIT_SOLVER card</field>
    /// <field name='implicit_stabilization' static='false' type='Object'>*CONTROL_IMPLICIT_STABILIZATION card</field>
    /// <field name='implicit_static_condensation' static='false' type='Object'>*CONTROL_IMPLICIT_STATIC_CONDENSATION card</field>
    /// <field name='implicit_termination' static='false' type='Object'>*CONTROL_IMPLICIT_TERMINATION card</field>
    /// <field name='imscl' static='false' type='Number'>Selective mass scaling. Part set if negative</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_1' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_10' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_100' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_101' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_102' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_103' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_104' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_105' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_106' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_107' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_108' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_109' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_11' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_110' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_111' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_112' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_113' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_114' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_115' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_116' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_117' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_118' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_119' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_12' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_120' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_13' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_14' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_15' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_16' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_17' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_18' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_19' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_2' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_20' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_21' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_22' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_23' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_24' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_25' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_26' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_27' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_28' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_29' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_3' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_30' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_31' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_32' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_33' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_34' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_35' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_36' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_37' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_38' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_39' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_4' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_40' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_41' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_42' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_43' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_44' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_45' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_46' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_47' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_48' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_49' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_5' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_50' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_51' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_52' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_53' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_54' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_55' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_56' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_57' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_58' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_59' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_6' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_60' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_61' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_62' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_63' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_64' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_65' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_66' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_67' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_68' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_69' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_7' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_70' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_71' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_72' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_73' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_74' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_75' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_76' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_77' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_78' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_79' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_8' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_80' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_81' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_82' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_83' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_84' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_85' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_86' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_87' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_88' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_89' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_9' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_90' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_91' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_92' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_93' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_94' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_95' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_96' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_97' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_98' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='include_99' static='false' type='Number'>The Include file number that the control card is in.</field>
    /// <field name='ini' static='false' type='Number'>bucket or global smoothing</field>
    /// <field name='inint' static='false' type='Number'>Factor needed for the estimation of maximum workspace used during initialization</field>
    /// <field name='inn' static='false' type='Number'>Invariant node numbering for shell element</field>
    /// <field name='insf' static='false' type='Number'>Flag to invoke output of *SET_NODE data</field>
    /// <field name='integ' static='false' type='Number'>Integration method</field>
    /// <field name='interm' static='false' type='Number'>Intermittent searching flag for old contacts</field>
    /// <field name='intgrd' static='false' type='Number'>Gauss/Lobatto intg rule switch</field>
    /// <field name='intperr' static='false' type='Number'>Flag for behavior in case of unwanted interp. or extrap. of initial stresses</field>
    /// <field name='ioflag' static='false' type='Number'>Flag to generate adaptive mesh</field>
    /// <field name='ioption' static='false' type='Number'>1:gravity 2:binder</field>
    /// <field name='ip1dblt' static='false' type='Number'>output of 1D seatbelt created for 2D seatbelt to sbtout</field>
    /// <field name='ipanelu' static='false' type='Number'>Number of strips in U direction</field>
    /// <field name='ipanelv' static='false' type='Number'>Number of strips in V direction</field>
    /// <field name='iparm1' static='false' type='Number'>Minimum block size for the Cholesky factorization (for eigmth=101) or Maximum number of iterations (for eigmth=102)</field>
    /// <field name='iparm1_1' static='false' type='Number'>Maximum number of iterations</field>
    /// <field name='iparm2' static='false' type='Number'>Maximum block size for the Cholesky factorization (for eigmth=101) or Block size (for eigmth=102)</field>
    /// <field name='iparm3' static='false' type='Number'>Node set ID</field>
    /// <field name='iparm4' static='false' type='Number'>MCMS minimum group/substructure size</field>
    /// <field name='ipcurv' static='false' type='Number'>output curve data flag</field>
    /// <field name='ipnint' static='false' type='Number'>Flag to print initial timesteps at cycle #1</field>
    /// <field name='iprtf' static='false' type='Number'>Print flag for RBDOUT and MATSUM files</field>
    /// <field name='irad' static='false' type='Number'>curve factor</field>
    /// <field name='irate' static='false' type='Number'>rate effect switch</field>
    /// <field name='ircnt' static='false' type='Number'>Lowest IRCNT modes</field>
    /// <field name='irefine' static='false' type='Number'>Flag to activate trimming of a multi-layer sandwiched part</field>
    /// <field name='ireflg' static='false' type='Number'>Uniform refinement level. Loadcurve if negative</field>
    /// <field name='irelal' static='false' type='Number'>Automatic control flag</field>
    /// <field name='iresvec' static='false' type='Number'>Converting the attachment modes to residual vectors flag</field>
    /// <field name='iresvec_1' static='false' type='Number'>Residual vector control flag</field>
    /// <field name='irevol' static='false' type='Number'>Treatment of revolute joints</field>
    /// <field name='irflag' static='false' type='Number'>Inertia relief flag</field>
    /// <field name='irgen' static='false' type='Number'>Initial reference geometry calc flag</field>
    /// <field name='irnxx' static='false' type='Number'>Hughes-Liu shell normal update option</field>
    /// <field name='irquad' static='false' type='Number'>intg rule</field>
    /// <field name='isdo' static='false' type='Number'>dt calc method for 4 noded shells</field>
    /// <field name='ishell' static='false' type='Number'>Shell element formulation for implicit</field>
    /// <field name='ishow' static='false' type='Number'>display option</field>
    /// <field name='islchk' static='false' type='Number'>Initial penetration check flag</field>
    /// <field name='isnan' static='false' type='Number'>Flag to check for a NaN in force and moment arrays</field>
    /// <field name='isolid' static='false' type='Number'>Solid element formulation for implicit</field>
    /// <field name='isolsf' static='false' type='Number'>Flag to invoke output of *SET_SOLID data</field>
    /// <field name='ispher' static='false' type='Number'>Treatment of spherical joints</field>
    /// <field name='ispline' static='false' type='Number'>kernel function</field>
    /// <field name='issf' static='false' type='Number'>Flag to invoke output of *SET_SHELL data</field>
    /// <field name='istab' static='false' type='Number'>stabilisation type</field>
    /// <field name='istif' static='false' type='Number'>Initial stiffness formulation flag</field>
    /// <field name='istone' static='false' type='Number'>Stoning calculation option</field>
    /// <field name='istupd' static='false' type='Number'>Shell thickness change option</field>
    /// <field name='isym' static='false' type='Number'>symmetry option. Node set if negative</field>
    /// <field name='isymp' static='false' type='Number'>percentage of sph</field>
    /// <field name='iteopt' static='false' type='Number'>Optimum equilibrium iteration count per timestep</field>
    /// <field name='itewin' static='false' type='Number'>Allowable iteration window (no. of iterations)</field>
    /// <field name='ithcnt' static='false' type='Number'>thermal contact heat transfer mode</field>
    /// <field name='ithk' static='false' type='Number'>contact thickness option</field>
    /// <field name='ithoff' static='false' type='Number'>Flag for offsetting thermal contact surfaces for thick thermal shells</field>
    /// <field name='ithoff_1' static='false' type='Number'>Flag for offsetting thermal contact surfaces for thick thermal shells</field>
    /// <field name='itime' static='false' type='Number'>Treatment of "Real time" on *DEFIN_CONSTRUCTION_STAGES</field>
    /// <field name='itriopt' static='false' type='Number'>Refinement option for enclosed area of trim curve</field>
    /// <field name='its' static='false' type='Number'>Initial thermal timestep</field>
    /// <field name='its_1' static='false' type='Number'>Initial thermal time step size</field>
    /// <field name='itsflg' static='false' type='Number'>initial transverse shear stress</field>
    /// <field name='itshell' static='false' type='Number'>Thick shell element formulation for implicit</field>
    /// <field name='itype' static='false' type='Number'>Set type</field>
    /// <field name='itype_1' static='false' type='Number'>Set type designation</field>
    /// <field name='itype_2' static='false' type='Number'>Hardware specific cost profile</field>
    /// <field name='itype_3' static='false' type='Number'>Database format</field>
    /// <field name='ivel' static='false' type='Number'>Velocity switching flag</field>
    /// <field name='ivolerr' static='false' type='Number'>Flag to check and report open edge of CV airbag</field>
    /// <field name='ivt' static='false' type='Number'>internal variable transfer in adaptive EFG</field>
    /// <field name='jntf' static='false' type='Number'>Generalized joint stiffness formulation</field>
    /// <field name='k' static='false' type='Number'>Strength coefficient for exponential hardening</field>
    /// <field name='k_1' static='false' type='Number'>Strength coefficient for exponential hardening</field>
    /// <field name='k_2' static='false' type='Number'>Thermal conductivity of fluid between the contact surfaces</field>
    /// <field name='kcycle' static='false' type='Number'>number of explicit cycles before switch</field>
    /// <field name='keepcs' static='false' type='Number'>keep contact segs of failed shells</field>
    /// <field name='ketol' static='false' type='Number'>Terminate based on kinetic energy</field>
    /// <field name='kfail' static='false' type='Number'>number of failed implicit attempts before switch</field>
    /// <field name='kxx' static='false' type='Number'>Heat conductivity matrix. Constant float value if respective KxxTYP = 0,  Curve ID if respective KxxTYP = 1.</field>
    /// <field name='kxxtyp' static='false' type='Number'>Types of Kxx. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve.</field>
    /// <field name='kxy' static='false' type='Number'>Heat conductivity matrix. Constant float value if respective KxyTYP = 0,  Curve ID if respective KxyTYP = 1.</field>
    /// <field name='kxytyp' static='false' type='Number'>Types of Kxy. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve.</field>
    /// <field name='kxz' static='false' type='Number'>Heat conductivity matrix. Constant float value if respective KxzTYP = 0,  Curve ID if respective KxzTYP = 1.</field>
    /// <field name='kxztyp' static='false' type='Number'>Types of Kxz. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve.</field>
    /// <field name='kyx' static='false' type='Number'>Heat conductivity matrix. Constant float value if respective KyxTYP = 0,  Curve ID if respective KyxTYP = 1.</field>
    /// <field name='kyxtyp' static='false' type='Number'>Types of Kyx. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve.</field>
    /// <field name='kyy' static='false' type='Number'>Heat conductivity matrix. Constant float value if respective KyyTYP = 0,  Curve ID if respective KyyTYP = 1.</field>
    /// <field name='kyytyp' static='false' type='Number'>Types of Kyy. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve.</field>
    /// <field name='kyz' static='false' type='Number'>Heat conductivity matrix. Constant float value if respective KyzTYP = 0,  Curve ID if respective KyzTYP = 1.</field>
    /// <field name='kyztyp' static='false' type='Number'>Types of Kyz. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve.</field>
    /// <field name='kzx' static='false' type='Number'>Heat conductivity matrix. Constant float value if respective KzxTYP = 0,  Curve ID if respective KzxTYP = 1.</field>
    /// <field name='kzxtyp' static='false' type='Number'>Types of Kzx. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve.</field>
    /// <field name='kzy' static='false' type='Number'>Heat conductivity matrix. Constant float value if respective KzyTYP = 0,  Curve ID if respective KzyTYP = 1.</field>
    /// <field name='kzytyp' static='false' type='Number'>Types of Kzy. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve.</field>
    /// <field name='kzz' static='false' type='Number'>Heat conductivity matrix. Constant float value if respective KzzTYP = 0,  Curve ID if respective KzzTYP = 1.</field>
    /// <field name='kzztyp' static='false' type='Number'>Types of Kzz. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve.</field>
    /// <field name='lamsht' static='false' type='Number'>Laminated shell theory update flag</field>
    /// <field name='lcacc' static='false' type='Number'>Flag to truncate curves: 0 = no truncation; otherwise = truncate</field>
    /// <field name='lcadp' static='false' type='Number'>Loadcurve: Adaptive interval vs time</field>
    /// <field name='lcdam' static='false' type='Number'>Loadcurve ID defining modal damping coefficient</field>
    /// <field name='lcdmu' static='false' type='Number'>Loadcurve for scaling friction forces</field>
    /// <field name='lcdmur' static='false' type='Number'>Loadcurve for scaling friction forces during dynamic relaxation</field>
    /// <field name='lcfdt' static='false' type='Number'>Load curve number for dynamic coefficient of friction as a function of temperature</field>
    /// <field name='lcfst' static='false' type='Number'>Load curve number for static coefficient of friction as a function of temperature</field>
    /// <field name='lch' static='false' type='Number'>Load curve ID for h (can be curve ID or function ID)</field>
    /// <field name='lcid' static='false' type='Number'>Load curve ID defining thickness vs distance</field>
    /// <field name='lcid_1' static='false' type='Number'>The Curve ID specifying Temperature vs Time.</field>
    /// <field name='lcint' static='false' type='Number'>Number of points in load curve discretization</field>
    /// <field name='lclvl' static='false' type='Number'>Loadcurve of maximum refinement level vs. time</field>
    /// <field name='lcpack' static='false' type='Number'>Matrix assembly package</field>
    /// <field name='lcs' static='false' type='Number'>Loadcurve: shear response vs. shell size</field>
    /// <field name='lcss' static='false' type='Number'>Loadcurve for stress-strain relationship</field>
    /// <field name='lcss_1' static='false' type='Number'>Loadcurve for stress-strain relationship</field>
    /// <field name='lct' static='false' type='Number'>Loadcurve: tension response vs. shell size</field>
    /// <field name='lctm' static='false' type='Number'>Loadcurve: Max timestep vs time</field>
    /// <field name='lcts' static='false' type='Number'>Loadcurve: timestep vs time</field>
    /// <field name='lctyp' static='false' type='Number'>Type of load curve</field>
    /// <field name='length' static='false' type='Number'>Length of the stone</field>
    /// <field name='length_1' static='false' type='String'>m = meter, mm = millimeter, cm = centimeter, in = inch, ft = foot</field>
    /// <field name='length_scale' static='false' type='Number'>Number of meters in the length unit for the input deck</field>
    /// <field name='lflag' static='false' type='Number'>Left end point finite flag</field>
    /// <field name='lftend' static='false' type='Number'>Left end point of interval</field>
    /// <field name='lmax' static='false' type='Number'>No thermal contact if gap is greater than this value</field>
    /// <field name='lmf' static='false' type='Number'>Switch explicit/implicit joint formulation</field>
    /// <field name='lmin' static='false' type='Number'>Minimum gap</field>
    /// <field name='lnorm' static='false' type='Number'>LCID that defines the function for normal stiffness vs norm pen ratio</field>
    /// <field name='local' static='false' type='Number'>Flag to activate an element csys. Valid values: 0-Vecids are considered in Global csys, 1-Vecids are considered in Local Csys.</field>
    /// <field name='lprint' static='false' type='Number'>Linear solver print flag</field>
    /// <field name='lsdir' static='false' type='Number'>search direction</field>
    /// <field name='lshear' static='false' type='Number'>LCID that defines the function for shear stiffness vs norm pen ratio</field>
    /// <field name='lsmtd' static='false' type='Number'>search method</field>
    /// <field name='lsolvr' static='false' type='Number'>Linear equation solver method</field>
    /// <field name='lstol' static='false' type='Number'>Line search convergence tolerance</field>
    /// <field name='lumpbc' static='false' type='Number'>lump boundary condition</field>
    /// <field name='lvlada' static='false' type='Number'>Maximum adaptive level</field>
    /// <field name='lvlada_1' static='false' type='Number'>Maximum adaptive level</field>
    /// <field name='macdvp' static='false' type='Boolean'>Acoustic nodal motions will be calculated or not.</field>
    /// <field name='mass' static='false' type='String'>kg = kilogram, g = gram, mg = milligram, lb = pound, slug = pound x sec2/foot, slinch = pound x sec2/inch, mtrc_ton = metric_ton</field>
    /// <field name='mass_scale' static='false' type='Number'>Number of kilograms in the mass unit for the input deck</field>
    /// <field name='maxel' static='false' type='Number'>Max number of elements for adaptivity</field>
    /// <field name='maxide' static='false' type='Number'>Element ID number</field>
    /// <field name='maxidn' static='false' type='Number'>Node ID number</field>
    /// <field name='maxitr' static='false' type='Number'>Maximum number of iterations</field>
    /// <field name='maxlvl' static='false' type='Number'>Max #refinement levels</field>
    /// <field name='maxref' static='false' type='Number'>Stiffness reformation limit per time step</field>
    /// <field name='maxv' static='false' type='Number'>max velocity</field>
    /// <field name='md_strs' static='false' type='Number'>Modal dynamic stress flag</field>
    /// <field name='mdflag' static='false' type='Number'>Modal dynamic flag</field>
    /// <field name='mdmax' static='false' type='Number'>Last mode employed in FRF computation</field>
    /// <field name='mdmin' static='false' type='Number'>First mode employed in FRF computation</field>
    /// <field name='mem' static='false' type='Number'>%age increase in memory for *MAT_NONLOCAL usage</field>
    /// <field name='memory' static='false' type='Number'>Memory limit beyond which adaptivity will cease</field>
    /// <field name='memory_1' static='false' type='Number'>memory alloc</field>
    /// <field name='metalf' static='false' type='Number'>metalforming option</field>
    /// <field name='meth' static='false' type='Number'>Advection method</field>
    /// <field name='method' static='false' type='Number'>Stoning method</field>
    /// <field name='mfrac' static='false' type='Number'>mass ratio gain required for remesh</field>
    /// <field name='midsf' static='false' type='Number'>Mid-plane position flag</field>
    /// <field name='minfo' static='false' type='Number'>Output penetration information</field>
    /// <field name='minmas' static='false' type='Number'>Factor of the minimum mass allowed in an element</field>
    /// <field name='miter' static='false' type='Number'>Plane stress plasticity option</field>
    /// <field name='mlkbag' static='false' type='Number'>Flag to invoke output of accumulated airbag mass leakage in ABSTAT</field>
    /// <field name='mm' static='false' type='Number'>monotonic mesh resizing</field>
    /// <field name='mmgpref' static='false' type='Number'>Selects the method that is used to include a reference pressure in a calculation involving ALE multi-material groups</field>
    /// <field name='mmm2d' static='false' type='Number'>Option for merging common boundaries of all adapted materials</field>
    /// <field name='mmset' static='false' type='Number'>The Multi-material Set ID.</field>
    /// <field name='mpn' static='false' type='Number'>Large mass added per node.</field>
    /// <field name='mpp_contact_groupable' static='false' type='Object'>*CONTROL_MPP_CONTACT_GROUPABLE card</field>
    /// <field name='mpp_decomposition_automatic' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_AUTOMATIC card</field>
    /// <field name='mpp_decomposition_bagref' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_BAGREF card</field>
    /// <field name='mpp_decomposition_check_speed' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_CHECK_SPEED card</field>
    /// <field name='mpp_decomposition_contact_isolate' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_CONTACT_ISOLATE card</field>
    /// <field name='mpp_decomposition_disable_unref_curves' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_DISABLE_UNREF_CURVES card</field>
    /// <field name='mpp_decomposition_distribute_ale_elements' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_DISTRIBUTE_ALE_ELEMENTS card</field>
    /// <field name='mpp_decomposition_distribute_sph_elements' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_DISTRIBUTE_SPH_ELEMENTS card</field>
    /// <field name='mpp_decomposition_elcost' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_ELCOST card</field>
    /// <field name='mpp_decomposition_file' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_FILE card</field>
    /// <field name='mpp_decomposition_method' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_METHOD card</field>
    /// <field name='mpp_decomposition_numproc' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_NUMPROC card</field>
    /// <field name='mpp_decomposition_outdecomp' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_OUTDECOMP card</field>
    /// <field name='mpp_decomposition_rcblog' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_RCBLOG card</field>
    /// <field name='mpp_decomposition_scale_contact_cost' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_SCALE_CONTACT_COST card</field>
    /// <field name='mpp_decomposition_scale_factor_sph' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_SCALE_FACTOR_SPH card</field>
    /// <field name='mpp_decomposition_show' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_SHOW card</field>
    /// <field name='mpp_decomposition_transformation' static='false' type='Object'>*CONTROL_MPP_DECOMPOSITION_TRANSFORMATION card</field>
    /// <field name='mpp_io_binoutonly' static='false' type='Object'>*CONTROL_MPP_IO_BINOUTONLY card</field>
    /// <field name='mpp_io_lstc_reduce' static='false' type='Object'>*CONTROL_MPP_IO_LSTC_REDUCE card</field>
    /// <field name='mpp_io_nod3dump' static='false' type='Object'>*CONTROL_MPP_IO_NOD3DUMP card</field>
    /// <field name='mpp_io_nodump' static='false' type='Object'>*CONTROL_MPP_IO_NODUMP card</field>
    /// <field name='mpp_io_nofail' static='false' type='Object'>*CONTROL_MPP_IO_NOFAIL card</field>
    /// <field name='mpp_io_nofull' static='false' type='Object'>*CONTROL_MPP_IO_NOFULL card</field>
    /// <field name='mpp_io_swapbytes' static='false' type='Object'>*CONTROL_MPP_IO_SWAPBYTES card</field>
    /// <field name='mpp_mat_model_driver' static='false' type='Object'>*CONTROL_MPP_MATERIAL_MODEL_DRIVER card</field>
    /// <field name='ms1st' static='false' type='Number'>Limit mass scaling to 1st timestep flag</field>
    /// <field name='msgflg' static='false' type='Number'>Option for printing detail message to d3msg</field>
    /// <field name='msglvl' static='false' type='Number'>Output message level</field>
    /// <field name='msgmax' static='false' type='Number'>max num messags</field>
    /// <field name='mstres' static='false' type='Number'>stress compute flag</field>
    /// <field name='mstrscl' static='false' type='Number'>Scaling for computing velocity</field>
    /// <field name='mtxdmp' static='false' type='Number'>flag to dump matrix</field>
    /// <field name='mtyp' static='false' type='Number'>Material type</field>
    /// <field name='mtype' static='false' type='Number'>Material type</field>
    /// <field name='mxdmp' static='false' type='Number'>Matrix dumping.</field>
    /// <field name='n' static='false' type='Number'>Refinement option</field>
    /// <field name='n1' static='false' type='Number'>Optional seed node ID 1</field>
    /// <field name='n1_1' static='false' type='Number'>Node (n1typ=0) / node set (n1typ=1) /segment set (n1typ=2) ID for excitation input</field>
    /// <field name='n1typ' static='false' type='Number'>Type of N1</field>
    /// <field name='n2' static='false' type='Number'>Optional seed node ID 2</field>
    /// <field name='n2_1' static='false' type='Number'>Node (n2typ=0) /node set (n2typ=1) /segment set (n2typ=2) ID for response output</field>
    /// <field name='n2typ' static='false' type='Number'>Type of N2</field>
    /// <field name='n3' static='false' type='Number'>Optional seed node ID 3</field>
    /// <field name='n4' static='false' type='Number'>Optional seed node ID 4</field>
    /// <field name='n5' static='false' type='Number'>Optional seed node ID 5</field>
    /// <field name='n6' static='false' type='Number'>Optional seed node ID 6</field>
    /// <field name='n7' static='false' type='Number'>Optional seed node ID 7</field>
    /// <field name='n8' static='false' type='Number'>Optional seed node ID 8</field>
    /// <field name='n_1' static='false' type='Number'>Exponent for exponential hardening</field>
    /// <field name='n_2' static='false' type='Number'>Exponent for exponential hardening</field>
    /// <field name='n_3' static='false' type='Number'>number of processors</field>
    /// <field name='nadv' static='false' type='Number'>Number of cycles between advections</field>
    /// <field name='name' static='false' type='String'>decomposition file</field>
    /// <field name='name_1' static='false' type='String'>decomposition method</field>
    /// <field name='name_2' static='false' type='String'>decomposition file</field>
    /// <field name='nb1' static='false' type='Number'>Start node ID on a flange root boundary</field>
    /// <field name='nb2' static='false' type='Number'>ID of a node in the middl of the flange root boundary</field>
    /// <field name='nb3' static='false' type='Number'>End node ID on a flange root boundary</field>
    /// <field name='nbkt' static='false' type='Number'>Number of Lagrangian cycles between bucket sort searches</field>
    /// <field name='nbuf' static='false' type='Number'>Asynchronous scheme and memory buffer option</field>
    /// <field name='ncbs' static='false' type='Number'>Number of cycles between particle sorting</field>
    /// <field name='ncdcf' static='false' type='Number'>Cycle number at which to evaluate DEFINE_CURVE_FUNCTION</field>
    /// <field name='ncfreq' static='false' type='Number'>Frequency of fission to fusion steps</field>
    /// <field name='ncpl' static='false' type='Number'>Number of Lagrangian cycles between coupling calculations</field>
    /// <field name='ncpmout' static='false' type='Number'>Control CPM output database to d3plot</field>
    /// <field name='ncpmts' static='false' type='Number'>Timestep size estimation</field>
    /// <field name='ncpu' static='false' type='Number'>#cpus to use</field>
    /// <field name='ncrb' static='false' type='Number'>Rebalancing frequency</field>
    /// <field name='ncycle' static='false' type='Number'>Number of cycle between checks of new contact.</field>
    /// <field name='ndamp' static='false' type='Number'>normal damping coefficient</field>
    /// <field name='ndouter' static='false' type='Number'>A node ID on the outer flange boundary</field>
    /// <field name='neecho' static='false' type='Number'>Print suppression during input: echo file</field>
    /// <field name='negev' static='false' type='Number'>Negative eigenvalue flag</field>
    /// <field name='neig' static='false' type='Number'>#eigenvalues to extract; loadcurve if negative</field>
    /// <field name='neig_1' static='false' type='Number'>Number of eigenmodes</field>
    /// <field name='neig_2' static='false' type='Number'>Number of eigenmodes to compute for the purpose of orthogonalizing the computed load</field>
    /// <field name='neig_3' static='false' type='Number'>Number of eigen values to compute.</field>
    /// <field name='newleg' static='false' type='Number'>New legends</field>
    /// <field name='nfail1' static='false' type='Number'>Flag for distorted 1 intg point shell check</field>
    /// <field name='nfail4' static='false' type='Number'>Flag for distorted 4 intg point shell check</field>
    /// <field name='nfreq' static='false' type='Number'>Number of frequencies for FRF output</field>
    /// <field name='niptets' static='false' type='Number'>#intg points for quadratic tets</field>
    /// <field name='nlnorm' static='false' type='Number'>non-linear convergence type</field>
    /// <field name='nlprint' static='false' type='Number'>non-linear solver print flag</field>
    /// <field name='nlq' static='false' type='Number'>Vector length</field>
    /// <field name='nlthpr' static='false' type='Number'>Thermal nonlinear printout level</field>
    /// <field name='nmdstr' static='false' type='Number'>Number of modes in modal stress/strain output</field>
    /// <field name='nmetis' static='false' type='Number'>Number of times to use Metis</field>
    /// <field name='nmneigh' static='false' type='Number'>memory alloc</field>
    /// <field name='nmode' static='false' type='Number'>number of buckling modes to calculate</field>
    /// <field name='node1' static='false' type='Number'>Tail node defining stone moving direction</field>
    /// <field name='node1_1' static='false' type='Number'>Head node defining stone moving direction</field>
    /// <field name='nonlocal' static='false' type='Object'>*CONTROL_NONLOCAL card</field>
    /// <field name='nopdel' static='false' type='Number'>Treatment of pressure loads on deleted elements</field>
    /// <field name='noption' static='false' type='Number'>Flag to turn on unfolding simulation</field>
    /// <field name='norbic' static='false' type='Number'>Circumvent rigid body inertia check</field>
    /// <field name='normk' static='false' type='Number'>scale factor for normal spring constant</field>
    /// <field name='nosol' static='false' type='Number'>flag for non-solution run</field>
    /// <field name='np2p' static='false' type='Number'>Number of cycles for repartition particles</field>
    /// <field name='npopt' static='false' type='Number'>Print suppression during input: printer file</field>
    /// <field name='nrcyck' static='false' type='Number'>#iterations between convergence checks</field>
    /// <field name='nrefup' static='false' type='Number'>Flag to update individual beam 3rd nodes</field>
    /// <field name='nrmst' static='false' type='Number'>Normal direction of tool</field>
    /// <field name='nrsst' static='false' type='Number'>Normal direction of blank</field>
    /// <field name='nrtol' static='false' type='Number'>Nodal rotational convergence tolerance</field>
    /// <field name='nsbcs' static='false' type='Number'>#cycles between 3D bucket sorts</field>
    /// <field name='nsbs' static='false' type='Number'>Number of steps in non-linear springback</field>
    /// <field name='nseed' static='false' type='Number'>#extra "seed" nodes below</field>
    /// <field name='nserod' static='false' type='Number'>erosion option</field>
    /// <field name='nsets' static='false' type='Number'>An optional node set ID of three nodes from the source mesh</field>
    /// <field name='nsett' static='false' type='Number'>An optional node set ID of three nodes from the target mesh</field>
    /// <field name='nsid' static='false' type='Number'>Node set ID of the nodes in the modal model that are subjected to loads</field>
    /// <field name='nsida' static='false' type='Number'>node set for attachment modes</field>
    /// <field name='nsidc' static='false' type='Number'>node set constraint modes</field>
    /// <field name='nsidebc' static='false' type='Number'>Optional excluded node set</field>
    /// <field name='nskip' static='false' type='Number'>Optional skipping scheme</field>
    /// <field name='nsmax' static='false' type='Number'>max number of implicit steps</field>
    /// <field name='nsmin' static='false' type='Number'>min number of implicit steps</field>
    /// <field name='nsolvr' static='false' type='Number'>Non-linear equation solver method</field>
    /// <field name='nstep' static='false' type='Number'>Consecutive implicit time steps</field>
    /// <field name='nttol' static='false' type='Number'>Nodal translational convergence tolerance</field>
    /// <field name='numrhs' static='false' type='Number'>#rh sides written</field>
    /// <field name='nunbend' static='false' type='Number'>Estimated number of unbending</field>
    /// <field name='omega' static='false' type='Number'>Relaxation parameter</field>
    /// <field name='opifs' static='false' type='Number'>Output interval for interface file</field>
    /// <field name='opt' static='false' type='Number'>Can be &lt;BLANK&gt; or _BINARY</field>
    /// <field name='optimpp' static='false' type='Number'>Optimize the MPP communications (Range 0/1)</field>
    /// <field name='option' static='false' type='Number'>Keyword option</field>
    /// <field name='order' static='false' type='Number'>Ordering option</field>
    /// <field name='order_1' static='false' type='Number'>Ordering option</field>
    /// <field name='orien' static='false' type='Number'>Automatic contact segment orientation flag</field>
    /// <field name='orient' static='false' type='Number'>Flag to set the global orientation of a forming contact</field>
    /// <field name='orthmd' static='false' type='Number'>Orthogonalise modes wrt each other</field>
    /// <field name='osu' static='false' type='Number'>Objective stress update for large timestep</field>
    /// <field name='output' static='false' type='Object'>*CONTROL_OUTPUT card</field>
    /// <field name='output_1' static='false' type='Number'>Output Flag</field>
    /// <field name='output_2' static='false' type='Boolean'>TRUE if _&lt;OPTION&gt; is OUTPUT.</field>
    /// <field name='output_3' static='false' type='Number'>Output flag for stresses</field>
    /// <field name='outseg' static='false' type='Number'>Spotweld output flag</field>
    /// <field name='overlap' static='false' type='Boolean'>Decompose the structure and ALE domains together?</field>
    /// <field name='para' static='false' type='Number'>Flag for parallel force assembly</field>
    /// <field name='parallel' static='false' type='Object'>*CONTROL_PARALLEL card</field>
    /// <field name='parallel_1' static='false' type='Number'>Option to force calculation of bonded DES</field>
    /// <field name='partm' static='false' type='Number'>Use global mass matrix for mass distribution</field>
    /// <field name='partset' static='false' type='Number'>The Part Set ID.</field>
    /// <field name='partset_1' static='false' type='Number'>The Part Set ID.</field>
    /// <field name='partset_2' static='false' type='Number'>The  Part Set ID.</field>
    /// <field name='partset_3' static='false' type='Number'>The Part Set ID.</field>
    /// <field name='patern' static='false' type='Number'>Velocity profile of moving tool</field>
    /// <field name='patern_1' static='false' type='Number'>Velocity profile of moving tool</field>
    /// <field name='pdifmx' static='false' type='Number'>Max pressure difference for stress zeroing</field>
    /// <field name='pen_sf' static='false' type='Number'>Default local penalty scale factor</field>
    /// <field name='penchk' static='false' type='Number'>penetration allowed as ratio of part thickness</field>
    /// <field name='penopt' static='false' type='Number'>Penalty stiffness option flag</field>
    /// <field name='penout' static='false' type='Number'>Flag to output contact penetration for mortar contact</field>
    /// <field name='pf_bulk' static='false' type='Number'>Default bulk modulus of pore fluid</field>
    /// <field name='pf_rho' static='false' type='Number'>Default pore water density</field>
    /// <field name='phase' static='false' type='Number'>Phase number</field>
    /// <field name='phchpn' static='false' type='Number'>Phase change penalty parameter</field>
    /// <field name='phschng' static='false' type='Number'>Message to messag file for phase change on materials 216, 217 and 218</field>
    /// <field name='pid' static='false' type='Number'>Part ID</field>
    /// <field name='pid_1' static='false' type='Number'>Part ID of the sheet blank</field>
    /// <field name='pid_2' static='false' type='Number'>Part ID of the sheet blank</field>
    /// <field name='pid_3' static='false' type='Number'>Part id to remove adaptive constraints from</field>
    /// <field name='pid_4' static='false' type='Number'>Part id of the thin shell elements</field>
    /// <field name='pid_5' static='false' type='Number'>Part ID of tool</field>
    /// <field name='pidosu' static='false' type='Number'>Part set id for objective stress updates</field>
    /// <field name='plotel' static='false' type='Number'>Automatic generation of *ELEMENT_PLOTEL</field>
    /// <field name='pm1' static='false' type='Number'>10 noded tetrahedral solid node ID 1</field>
    /// <field name='pm10' static='false' type='Number'>10 noded tetrahedral solid node ID 10</field>
    /// <field name='pm2' static='false' type='Number'>10 noded tetrahedral solid node ID 2</field>
    /// <field name='pm3' static='false' type='Number'>10 noded tetrahedral solid node ID 3</field>
    /// <field name='pm4' static='false' type='Number'>10 noded tetrahedral solid node ID 4</field>
    /// <field name='pm5' static='false' type='Number'>10 noded tetrahedral solid node ID 5</field>
    /// <field name='pm6' static='false' type='Number'>10 noded tetrahedral solid node ID 6</field>
    /// <field name='pm7' static='false' type='Number'>10 noded tetrahedral solid node ID 7</field>
    /// <field name='pm8' static='false' type='Number'>10 noded tetrahedral solid node ID 8</field>
    /// <field name='pm9' static='false' type='Number'>10 noded tetrahedral solid node ID 9</field>
    /// <field name='pnch' static='false' type='Number'>Part that defines the punch</field>
    /// <field name='pore_air' static='false' type='Object'>*CONTROL_PORE_AIR card</field>
    /// <field name='pore_fluid' static='false' type='Object'>*CONTROL_PORE_FLUID card</field>
    /// <field name='pr' static='false' type='Number'>Poissons ratio</field>
    /// <field name='pr_1' static='false' type='Number'>Poissons ratio</field>
    /// <field name='prebd' static='false' type='Number'>Distance between lower binder and punch</field>
    /// <field name='pref' static='false' type='Number'>ref pressure on boundary</field>
    /// <field name='premove' static='false' type='Number'>Distance to pre-move tool in reverse direction</field>
    /// <field name='prit' static='false' type='Number'>Pressure equalibrium flag</field>
    /// <field name='proj' static='false' type='Number'>Projection method for warping stiffness</field>
    /// <field name='prtflg' static='false' type='Number'>Flag to print data for spotwelds</field>
    /// <field name='pset' static='false' type='Number'>Part set ID</field>
    /// <field name='psfail' static='false' type='Number'>Optional part set id</field>
    /// <field name='psid' static='false' type='Number'>excluded part set</field>
    /// <field name='psid_1' static='false' type='Number'>Part set ID</field>
    /// <field name='psnfail' static='false' type='Number'>part set id for check</field>
    /// <field name='psstupd' static='false' type='Number'>part set for thichness update, -ve to exclude</field>
    /// <field name='pstiff' static='false' type='Number'>method for penalty stiff calc</field>
    /// <field name='ptscl' static='false' type='Number'>scale factor on the contact stress exerted onto shells</field>
    /// <field name='ptype' static='false' type='Number'>Thermal problem type</field>
    /// <field name='ptype_1' static='false' type='Number'>Thermal problem type</field>
    /// <field name='pwp_auto_tmf' static='false' type='Object'>*CONTROL_PWP_AUTO_TMF card</field>
    /// <field name='q1' static='false' type='Number'>Default linear viscosity coefficient</field>
    /// <field name='q2' static='false' type='Number'>Default quadratic viscosity coefficient</field>
    /// <field name='qh' static='false' type='Number'>Default hourglass coefficient</field>
    /// <field name='ql' static='false' type='Number'>quasi-linear coefficient</field>
    /// <field name='r00' static='false' type='Number'>Material anisotropic parameter R00</field>
    /// <field name='r00_1' static='false' type='Number'>Material anisotropic parameter R00</field>
    /// <field name='r45' static='false' type='Number'>Material anisotropic parameter R45</field>
    /// <field name='r45_1' static='false' type='Number'>Material anisotropic parameter R45</field>
    /// <field name='r90' static='false' type='Number'>Material anisotropic parameter R90</field>
    /// <field name='r90_1' static='false' type='Number'>Material anisotropic parameter R90</field>
    /// <field name='radius' static='false' type='Number'>Radius of pre-bending</field>
    /// <field name='rb' static='false' type='Number'>Rebalancing option</field>
    /// <field name='rbsms' static='false' type='Number'>Flag to apply consistent treatment of rigid bodies in selective mass scaling</field>
    /// <field name='rctol' static='false' type='Number'>Residual (force) convergence tolerance</field>
    /// <field name='rdcmem' static='false' type='Number'>Factor for capping the amount of dynamic memory requested</field>
    /// <field name='refgeo' static='false' type='Number'>Flag for reference geometry in acoustic eigenvalue analysis</field>
    /// <field name='refmax' static='false' type='Number'>Max #matrix reformations per timestep</field>
    /// <field name='reltol' static='false' type='Number'>Relative convergence tolerance</field>
    /// <field name='remesh' static='false' type='Object'>*CONTROL_REMESHING card</field>
    /// <field name='restrt' static='false' type='Number'>Restart option</field>
    /// <field name='restrt_1' static='false' type='Number'>Restart option</field>
    /// <field name='reverse' static='false' type='Number'>Surface normal reversing option</field>
    /// <field name='rflag' static='false' type='Number'>Right end point finite flag</field>
    /// <field name='rhtend' static='false' type='Number'>Right end point of interval</field>
    /// <field name='rigid' static='false' type='Object'>*CONTROL_RIGID card</field>
    /// <field name='rmax' static='false' type='Number'>Maximum edge length</field>
    /// <field name='rmin' static='false' type='Number'>Minimum edge length</field>
    /// <field name='rmscl' static='false' type='Number'>flag to activate scaling of rotational inertia</field>
    /// <field name='rmtol' static='false' type='Number'>Maximum residual convergence tolerance</field>
    /// <field name='rotascl' static='false' type='Number'>Scale factor for rotary shell mass</field>
    /// <field name='rparm1' static='false' type='Number'>Eigenvalue expansion factor (for eigmth=101) or Convergence tolerance (for eigmth=102)</field>
    /// <field name='rparm1_1' static='false' type='Number'>Absolute tolerance for convergence</field>
    /// <field name='rparm2' static='false' type='Number'>BLR preconditioner tolerance</field>
    /// <field name='rparm2_1' static='false' type='Number'>Relative tolerance for convergence</field>
    /// <field name='rpbhx' static='false' type='Number'>Replace each beam with a cluster of RPBHX solids</field>
    /// <field name='rrtol' static='false' type='Number'>Rigid body rotational convergence tolerance</field>
    /// <field name='rttol' static='false' type='Number'>Rigid body translational convergence tolerance</field>
    /// <field name='rwen' static='false' type='Number'>Rigid wall energy calc flag</field>
    /// <field name='rwgaps' static='false' type='Number'>flag for gap stiffness</field>
    /// <field name='rwgdth' static='false' type='Number'>death time for gap stiffness</field>
    /// <field name='rwksf' static='false' type='Number'>penalty scale factor</field>
    /// <field name='rwpnal' static='false' type='Number'>Scale factor for rigid wall penalties</field>
    /// <field name='rylen' static='false' type='Number'>Rayleigh energy calc flag</field>
    /// <field name='sbc' static='false' type='Number'>Stefan Boltzman constant (w/m**2/K)</field>
    /// <field name='sc_flag' static='false' type='Number'>Static condensation control flag</field>
    /// <field name='sc_nsid' static='false' type='Number'>Node set ID for nodes to be preserved in the procedure</field>
    /// <field name='sc_psid' static='false' type='Number'>Part set ID for parts to be included in the procedure</field>
    /// <field name='scale' static='false' type='Number'>scale factor for artificial stabilization. Loadcurve if negative</field>
    /// <field name='scl_k' static='false' type='Number'>Scale factor for friction stiffness</field>
    /// <field name='se_damp' static='false' type='String'>Name of superelement damping matrix</field>
    /// <field name='se_filename' static='false' type='String'>File name</field>
    /// <field name='se_filename_1' static='false' type='String'>File name</field>
    /// <field name='se_inert' static='false' type='String'>Name of superelement inertia matrix</field>
    /// <field name='se_inert_1' static='false' type='String'>Name of superelement inertia matrix</field>
    /// <field name='se_mass' static='false' type='String'>Name of superelement mass matrix</field>
    /// <field name='se_mass_1' static='false' type='String'>Name of superelement mass matrix</field>
    /// <field name='se_stiff' static='false' type='String'>Name of superelement stiffness matrix</field>
    /// <field name='se_stiff_1' static='false' type='String'>Name of superelement stiffness matrix</field>
    /// <field name='segang' static='false' type='Number'>angular mesh size in 3-D axisymmetric remeshing</field>
    /// <field name='set' static='false' type='Number'>The  Set ID. Can be SOLID, SHELL or BEAM Set based on value of setyp.</field>
    /// <field name='set_option' static='false' type='Boolean'>true if _SET option is present.</field>
    /// <field name='setid' static='false' type='Number'>Set ID of *SET_SHELL or *SET_SOLID.</field>
    /// <field name='setyp' static='false' type='Number'>Type of Set. Valid values: 1-Solid Set, 2-Shell Set, 3-Beam Set.</field>
    /// <field name='sf' static='false' type='Number'>Scale factor</field>
    /// <field name='sf_1' static='false' type='Number'>Scale factor</field>
    /// <field name='sffdc' static='false' type='Number'>Scale factor of force decay constant</field>
    /// <field name='sfric' static='false' type='Number'>Default static coefficient of friction</field>
    /// <field name='sgset' static='false' type='Number'>The Segment Set ID.</field>
    /// <field name='sheark' static='false' type='Number'>ratio between sheark/normk</field>
    /// <field name='shell' static='false' type='Object'>*CONTROL_SHELL card</field>
    /// <field name='shfscl' static='false' type='Number'>Shift scale</field>
    /// <field name='shledg' static='false' type='Number'>Flag for assuming edge shape for shells</field>
    /// <field name='shlsig' static='false' type='Number'>Flag to extrapolate stresses for shells with 8 integration points to nodes</field>
    /// <field name='shlthk' static='false' type='Number'>Shell thickness consideration flag</field>
    /// <field name='shltrw' static='false' type='Number'>Shell thickness scale factor</field>
    /// <field name='sid' static='false' type='Number'>Node/Shell set id</field>
    /// <field name='sidt4tu' static='false' type='Number'>part set for type 4 thickness update where elastic strains are ignored.</field>
    /// <field name='sizeada' static='false' type='Number'>Minimum element size permitted in the adaptive mesh</field>
    /// <field name='sizeada_1' static='false' type='Number'>Minimum element size permitted in the adaptive mesh</field>
    /// <field name='skiprwg' static='false' type='Number'>Display rigidwall flag</field>
    /// <field name='slnten' static='false' type='Number'>Contact energy calc flag</field>
    /// <field name='slsfac' static='false' type='Number'>Scale factor for sliding penalties</field>
    /// <field name='smax' static='false' type='Number'>Maximum element size</field>
    /// <field name='smin' static='false' type='Number'>Element dimension limit for refining</field>
    /// <field name='solid' static='false' type='Object'>*CONTROL_SOLID card</field>
    /// <field name='solitary' static='false' type='Number'>TRUE if a plain (no _SHELL suffix) card exists</field>
    /// <field name='soln' static='false' type='Number'>Solution type flag</field>
    /// <field name='solsig' static='false' type='Number'>Flag to extrapolate stresses/history variables</field>
    /// <field name='solution' static='false' type='Object'>*CONTROL_SOLUTION card</field>
    /// <field name='solver' static='false' type='Number'>Thermal analysis solver type</field>
    /// <field name='solver_1' static='false' type='Number'>Thermal analysis solver type</field>
    /// <field name='sparse' static='false' type='Number'>Use sparse xply routines for modal &amp; stiffness damping matrices</field>
    /// <field name='spc2bnd' static='false' type='Number'>Flag to convert constraints on rigid bodies to equivalent *BOUNDARY_PRESCRIBED_MOTION_RIGID motion</field>
    /// <field name='specific' static='false' type='Boolean'>If SPECIFIC option is used</field>
    /// <field name='sph' static='false' type='Object'>*CONTROL_SPH card</field>
    /// <field name='spotdel' static='false' type='Number'>Spotweld deletion flag</field>
    /// <field name='spothin' static='false' type='Number'>Optional thickness scale factor</field>
    /// <field name='spotstp' static='false' type='Number'>Error termination flag on unfound spotweld</field>
    /// <field name='spotweld_beam' static='false' type='Object'>*CONTROL_SPOTWELD_BEAM card</field>
    /// <field name='sprfac' static='false' type='Number'>factor for reducing feedback</field>
    /// <field name='srad' static='false' type='Number'>radius of influence</field>
    /// <field name='sred' static='false' type='Number'>step reduction factor</field>
    /// <field name='ssort' static='false' type='Number'>Flag for automatic sort of background triangular shells</field>
    /// <field name='ssthk' static='false' type='Number'>Shell thickness use flag for type 4 contacts</field>
    /// <field name='staged_construction' static='false' type='Object'>*CONTROL_STAGED_CONSTRUCTION card</field>
    /// <field name='start' static='false' type='Object'>*CONTROL_START card</field>
    /// <field name='start_1' static='false' type='Number'>Start time for smoothing</field>
    /// <field name='start_2' static='false' type='Number'>start time</field>
    /// <field name='steady_state_rolling' static='false' type='Object'>*CONTROL_STEADY_STATE_ROLLING card</field>
    /// <field name='step' static='false' type='Number'>Stepping size of moving stone</field>
    /// <field name='stfbend' static='false' type='Number'>Unflanging stiffness</field>
    /// <field name='stfcnt' static='false' type='Number'>Normal stiffness</field>
    /// <field name='stge' static='false' type='Number'>end stage</field>
    /// <field name='stgs' static='false' type='Number'>start stage</field>
    /// <field name='stref' static='false' type='Number'>ref stage</field>
    /// <field name='stretch' static='false' type='Number'>Stretch ratio of element diagonals for element deletion</field>
    /// <field name='structured' static='false' type='Object'>*CONTROL_STRUCTURED card</field>
    /// <field name='stype' static='false' type='Number'>0-&gt;blkid is PART, 1-&gt;PARTSET NOTE don't use &lt;type&gt; as in stat_header</field>
    /// <field name='stype_1' static='false' type='Number'>Flag for part/part set</field>
    /// <field name='subcyl' static='false' type='Number'>Subcycling flag</field>
    /// <field name='swlocl' static='false' type='Number'>output flag for stresses in solid spotwelds</field>
    /// <field name='swradf' static='false' type='Number'>Spot weld radius scale factor</field>
    /// <field name='t10jtol' static='false' type='Number'>tolerance for jacobian in 4-point 10-noded quadratic tetrahedra</field>
    /// <field name='t_ors' static='false' type='Number'>Table ID for scaling shear response</field>
    /// <field name='t_ort' static='false' type='Number'>Table for scaling response</field>
    /// <field name='targ' static='false' type='Number'>target for change of excess pressure</field>
    /// <field name='targ_1' static='false' type='Number'>Target max pwp change/thermal timestep</field>
    /// <field name='target' static='false' type='Number'></field>
    /// <field name='target_1' static='false' type='Number'>Move tool PID to meet part TARGET</field>
    /// <field name='tbirth' static='false' type='Number'>Birth time for adaptivity</field>
    /// <field name='tdamp' static='false' type='Number'>tangential damping coefficient</field>
    /// <field name='tdcnof' static='false' type='Number'>tied constraint offset contact update option</field>
    /// <field name='tdeath' static='false' type='Number'>Death time for adaptivity</field>
    /// <field name='tdybir' static='false' type='Number'>birth time for dynamic terms. Loadcurve if negative</field>
    /// <field name='tdybur' static='false' type='Number'>burial</field>
    /// <field name='tdydth' static='false' type='Number'>death</field>
    /// <field name='temp' static='false' type='String'>K = Kelvin, C = Celsius, F = Fahrenheit, R = Rankine</field>
    /// <field name='tempini' static='false' type='Number'>Initial Temperature.</field>
    /// <field name='tend' static='false' type='Number'>End time</field>
    /// <field name='term' static='false' type='Number'>_TERM flag</field>
    /// <field name='termination' static='false' type='Object'>*CONTROL_TERMINATION card</field>
    /// <field name='tet10s8' static='false' type='Number'>tet connectivity output</field>
    /// <field name='tet13k' static='false' type='Number'>global flag for cohesive element deletion</field>
    /// <field name='tetol' static='false' type='Number'>Terminate based on total energy</field>
    /// <field name='th' static='false' type='Number'>Default contact thickness</field>
    /// <field name='th_sf' static='false' type='Number'>Default thickness scale factor</field>
    /// <field name='theory' static='false' type='Number'>Shell theory to use</field>
    /// <field name='therm' static='false' type='Number'>thermal vol expansion coeff</field>
    /// <field name='thermal_eigenvalue' static='false' type='Object'>*CONTROL_THERMAL_EIGENVALUE card</field>
    /// <field name='thermal_forming' static='false' type='Object'>*CONTROL_THERMAL_FORMING card</field>
    /// <field name='thermal_nonlinear' static='false' type='Object'>*CONTROL_THERMAL_NONLINEAR card</field>
    /// <field name='thermal_solver' static='false' type='Object'>*CONTROL_THERMAL_SOLVER card</field>
    /// <field name='thermal_timestep' static='false' type='Object'>*CONTROL_THERMAL_TIMESTEP card</field>
    /// <field name='thick' static='false' type='Number'>Thickness of the thick shell elements</field>
    /// <field name='thick_1' static='false' type='Number'>Blank thickness</field>
    /// <field name='thick_2' static='false' type='Number'>Blank thickness</field>
    /// <field name='thkchg' static='false' type='Number'>Consider shell thickness change flag</field>
    /// <field name='thlstl' static='false' type='Number'>Line search convergence tolerance</field>
    /// <field name='thmn' static='false' type='Number'>Min thickness below which elements are deleted</field>
    /// <field name='thmx' static='false' type='Number'>Max thickness beyond which elements are deleted</field>
    /// <field name='thresh' static='false' type='Number'>Threshold for rigid body node</field>
    /// <field name='thshel' static='false' type='Number'>Thermal shell option</field>
    /// <field name='tiedprj' static='false' type='Number'>Projection bypass flag for TIED_ types</field>
    /// <field name='time' static='false' type='String'>sec = second, ms = msec/millisec, micro_s = microsec</field>
    /// <field name='time_scale' static='false' type='Number'>Number of seconds in the time unit for the input deck</field>
    /// <field name='timestep' static='false' type='Object'>*CONTROL_TIMESTEP card</field>
    /// <field name='timidl' static='false' type='Number'>Idle time value</field>
    /// <field name='timsada' static='false' type='Number'>Total number of adaptive steps during the forming simulation</field>
    /// <field name='tip' static='false' type='Number'>Thermal time integration parameter</field>
    /// <field name='tjadstf' static='false' type='Number'>Joint translational stiffness</field>
    /// <field name='tjadvsc' static='false' type='Number'>Joint translational damping</field>
    /// <field name='tmax' static='false' type='Number'>Maximum thermal timestep, or LC of tmax vs time if -ve</field>
    /// <field name='tmf' static='false' type='Number'>Time magnification factor on seepage. Loadcurve if negative</field>
    /// <field name='tmin' static='false' type='Number'>Minimum thermal timestep, or LC of tmin vs time if -ve</field>
    /// <field name='tol' static='false' type='Number'>Convergence tolerance for temperature</field>
    /// <field name='tolev' static='false' type='Number'>Timing output levels</field>
    /// <field name='travel' static='false' type='Number'>Distance to move tool along VID</field>
    /// <field name='ts' static='false' type='Number'>Thermal timestep control flag</field>
    /// <field name='tscp' static='false' type='Number'>Timestep control parameter</field>
    /// <field name='tsf' static='false' type='Number'>Thermal speedup factor. Loadcurve if negative</field>
    /// <field name='tsf_1' static='false' type='Number'>Thermal Speedup Factor</field>
    /// <field name='tshell' static='false' type='Number'>Thermal shell option</field>
    /// <field name='tslimt' static='false' type='Number'>Min timestep for shell modulus change</field>
    /// <field name='tssfac' static='false' type='Number'>Scale factor for computed timestep</field>
    /// <field name='tssfdr' static='false' type='Number'>Optional timestep factor during DR</field>
    /// <field name='tstart' static='false' type='Number'>Start time</field>
    /// <field name='tstart_1' static='false' type='Number'>start time</field>
    /// <field name='tstype' static='false' type='Number'>Thick shell bulk viscosity type</field>
    /// <field name='unforc' static='false' type='Number'>Force conversion factor</field>
    /// <field name='unit' static='false' type='Number'>Units for simulation</field>
    /// <field name='unit_1' static='false' type='Number'>Units for simulation</field>
    /// <field name='units' static='false' type='Object'>*CONTROL_UNITS card</field>
    /// <field name='unleng' static='false' type='Number'>Length conversion factor</field>
    /// <field name='untime' static='false' type='Number'>Time conversion factor</field>
    /// <field name='usrfrc' static='false' type='Number'>Storage for user-controlled friction subroutine</field>
    /// <field name='usrstr' static='false' type='Number'>Storage for user-controlled control subroutine</field>
    /// <field name='v1' static='false' type='Number'>Vector component defining stoning direction</field>
    /// <field name='v2' static='false' type='Number'>Vector component defining stoning direction</field>
    /// <field name='v3' static='false' type='Number'>Vector component defining stoning direction</field>
    /// <field name='vad1' static='false' type='Number'>Excitation input type</field>
    /// <field name='vad2' static='false' type='Number'>Response output type</field>
    /// <field name='vaflag' static='false' type='Number'>Loading type</field>
    /// <field name='vaplot' static='false' type='Number'>Flag for PSD broadband plots</field>
    /// <field name='vaprld' static='false' type='Number'>Flag for including preload</field>
    /// <field name='vapsd' static='false' type='Number'>Flag for PSD output</field>
    /// <field name='varden' static='false' type='Number'>Variable thermal density flag</field>
    /// <field name='varms' static='false' type='Number'>Flag for RMS output</field>
    /// <field name='vastrs' static='false' type='Number'>Flag for including stress analysis</field>
    /// <field name='vecid1' static='false' type='Number'>The Vector ID to define x-direction.</field>
    /// <field name='vecid2' static='false' type='Number'>The Vector ID to define y-direction.</field>
    /// <field name='vector' static='false' type='Boolean'>true if _VECTOR option is set</field>
    /// <field name='vfact' static='false' type='Number'>Void factor</field>
    /// <field name='vfc' static='false' type='Number'>Default viscous friction coefficient</field>
    /// <field name='vfloss' static='false' type='Number'>necessary VF loss for remesh</field>
    /// <field name='vibro_acoustic' static='false' type='Object'>*CONTROL_VIBRO_ACOUSTIC card</field>
    /// <field name='vid' static='false' type='Number'>Vector ID defining direction of movement</field>
    /// <field name='vid_1' static='false' type='Number'>Vector ID defining direction of travel</field>
    /// <field name='vid_2' static='false' type='Number'>Vector ID for DOF1=4</field>
    /// <field name='vmax' static='false' type='Number'>Maximum allowable tool velocity</field>
    /// <field name='vmax_1' static='false' type='Number'>Maximum allowable tool velocity</field>
    /// <field name='vol' static='false' type='Number'>volume fraction</field>
    /// <field name='vtk' static='false' type='Number'>max number of subcycling cycles</field>
    /// <field name='vx' static='false' type='Number'>X component of vector defining the direction of distance in load curve</field>
    /// <field name='vx_1' static='false' type='Number'>X component of axis about which blank will be bent</field>
    /// <field name='vx_2' static='false' type='Number'>X vector component of movement of punch</field>
    /// <field name='vy' static='false' type='Number'>Y component of vector defining the direction of distance in load curve</field>
    /// <field name='vy_1' static='false' type='Number'>Y component of axis about which blank will be bent</field>
    /// <field name='vy_2' static='false' type='Number'>Y vector component of movement of punch</field>
    /// <field name='vz' static='false' type='Number'>Z component of vector defining the direction of distance in load curve</field>
    /// <field name='vz_1' static='false' type='Number'>Z component of axis about which blank will be bent</field>
    /// <field name='vz_2' static='false' type='Number'>Z vector component of movement of punch</field>
    /// <field name='weight' static='false' type='Number'>Coefficient in equation</field>
    /// <field name='weight_1' static='false' type='Number'>Coefficient in equation</field>
    /// <field name='width' static='false' type='Number'>Width of the stone</field>
    /// <field name='wmode' static='false' type='Number'>W-mode amplitude for element deletion (deg)</field>
    /// <field name='wrpang' static='false' type='Number'>Shell warpage angle (deg)</field>
    /// <field name='wtable' static='false' type='Number'>Default elevation of water table</field>
    /// <field name='x0' static='false' type='Number'>Starting position x coordinate</field>
    /// <field name='xpene' static='false' type='Number'>Surface max penetration check multiplier</field>
    /// <field name='y0' static='false' type='Number'>Starting position y coordinate</field>
    /// <field name='z0' static='false' type='Number'>Starting position z coordinate</field>
    /// <field name='zero_v' static='false' type='Number'>flag to zero vels before switch to implicit</field>
    /// <field name='zeta' static='false' type='Number'>Modal dynamic damping constant</field>
    /// <field name='zeta_1' static='false' type='Number'>Modal dynamic damping constant</field>
}

Control.prototype.GetCoefficient = function() {
    /// <signature>
    /// <summary>Returns the damping coefficient data for an index in *CONTROL_IMPLICIT_MODAL_DYNAMIC_DAMPING.</summary>
    /// <param name="index" type="Number" optional="false">The index you want the data for. Note that indices start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Control.prototype.RemoveCoefficient = function() {
    /// <signature>
    /// <summary>Removes the damping coefficient data for an index in *CONTROL_IMPLICIT_MODAL_DYNAMIC_DAMPING.</summary>
    /// <param name="index" type="Number" optional="false">The index you want to delete damping data for. Note that indices start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

Control.prototype.SetCoefficient = function() {
    /// <signature>
    /// <summary>Sets the damping coefficient data for an index in *CONTROL_IMPLICIT_MODAL_DYNAMIC_DAMPING.</summary>
    /// <param name="index" type="Number" optional="false">The index you want to set the data for. Note that indices start at 0, not 1.</param>
    /// <param name="mode/frequency" type="Number" optional="false">The mode ID (_SPECIFIC) or frequency (_FREQUENCY_RANGE).</param>
    /// <param name="zeta" type="Number" optional="false">Damping coefficient</param>
    /// <returns type="null"/>
    /// </signature>
}

var Conx = function() {
    /// <signature>
    /// <summary>Create a new Conx object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that connection will be created in</param>
    /// <param name="x" type="Number" optional="false">X coordinate</param>
    /// <param name="y" type="Number" optional="false">Y coordinate</param>
    /// <param name="z" type="Number" optional="false">Z coordinate</param>
    /// <param name="type" type="Number" optional="true">Type of connection. Can be Conx.SPOTWELD, Conx.BOLT, Conx.ADHESIVE or Conx.SPOTWELD_LINEIf omitted type will be set to Conx.SPOTWELD.</param>
    /// <param name="subtype" type="Number" optional="true">Subtype of connection. See property subtype for valid values. If omitted subtype will be set to the default subtype for this type of connection.</param>
    /// <param name="title" type="String" optional="true">Title for the connection</param>
    /// <returns type="Conx"/>
    /// </signature>
    /// <field name='adhesive_esize' static='false' type='Number'>Element size along the length of the adhesive run</field>
    /// <field name='adhesive_nelem' static='false' type='Number'>The number of elements across the width of the adhesive</field>
    /// <field name='adhesive_width' static='false' type='Number'>The width of the adhesive run</field>
    /// <field name='angtol' static='false' type='Number'>angle tolerance for bolt</field>
    /// <field name='angtol2' static='false' type='Number'>angle tolerance at end 2 for 2 point bolt</field>
    /// <field name='assembly' static='false' type='Number'>Assembly used to specify panels connection together, rather than individual layers. Integer for a part set ID, string for a Primer assembly (name).</field>
    /// <field name='assembly_type' static='false' type='Number'>The assembly type. Can be Conx.PART_SET or Conx.ASSEMBLY.</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the connection</field>
    /// <field name='diameter' static='false' type='Number'>Diameter of spotweld/rigid</field>
    /// <field name='diameter2' static='false' type='Number'>Diameter of rigid at end 2</field>
    /// <field name='edge_distance' static='false' type='Number'>Spotweld line edge distance</field>
    /// <field name='edge_lock' static='false' type='Boolean'>true if a spotweld line is locked to an edge, false if not</field>
    /// <field name='error' static='false' type='String'>Description of the error if the connection cannot be made (read only)</field>
    /// <field name='error_details' static='false' type='String'>Details of the error if the connection cannot be made (read only)</field>
    /// <field name='fit' static='false' type='Number'>contact fitting method for library bolts</field>
    /// <field name='id' static='false' type='Number'>Conx number. Also see the label property which is an alternative name for this.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the connection is in.</field>
    /// <field name='label' static='false' type='Number'>Conx number. Also see the id property which is an alternative name for this.</field>
    /// <field name='layers' static='false' type='Number'>The number of layers the connection has.</field>
    /// <field name='length' static='false' type='Number'>Length of 1 point bolt, max thickness for 2 point bolt</field>
    /// <field name='length2' static='false' type='Number'>max thickness at end 2 for 2 point bolt</field>
    /// <field name='material' static='false' type='Number'>The ID of the Material used for 'merge' bolt connections. i.e. Conx.BOLT_MRG_CYL, Conx.BOLT_MRG_CYL_BEAM,</field>
    /// <field name='model' static='false' type='Number'>The Model number that the connection is in.</field>
    /// <field name='module' static='false' type='String'>name of library module for bolt</field>
    /// <field name='part' static='false' type='Number'>The ID of the Part used for adhesive or spotweld connections. Note that in v11.0 and above you are able to specify a different part IDs for elements in the connection between different layers. If you only have one part for the elements in the connection, then this is the value of this property. If there is more than one used, then the value of this property is the first part. If you set this property to a new value, then the all the elements in the connection will have this new part ID when it is realized. To set and retrieve information on parts used between different layers, the functions GetPidData() and SetPidData() should be used.</field>
    /// <field name='patch_coords' static='false' type='Number'>The number of patch coordinate points the connection has (Adhesive patch only).</field>
    /// <field name='patch_topol' static='false' type='Number'>The number of patch topology entries the connection has (Adhesive patch only).</field>
    /// <field name='path' static='false' type='Number'>The number of path points the connection has (Adhesive only). Note that these points do NOT include the start and end points for the adhesive run. These are defined using the properties x, y, z and x2, y2, z2</field>
    /// <field name='pitch' static='false' type='Number'>Spotweld line pitch</field>
    /// <field name='resize' static='false' type='Number'>snap to points fitting method for library bolts</field>
    /// <field name='saved_settings' static='false' type='Boolean'>Whether settings are saved for a connection or not</field>
    /// <field name='shape' static='false' type='Number'>shape for bolt attachment</field>
    /// <field name='shape2' static='false' type='Number'>shape for bolt attachment at end 2 for 2 point bolt</field>
    /// <field name='status' static='false' type='Number'>The status of the connection. (read only). Can be Conx.DORMANT, Conx.MADE, Conx.INVALID, Conx.REALIZED or Conx.BAD.</field>
    /// <field name='subtype' static='false' type='Number'>The connection subtype. For SPOTWELD and SPOTWELD_LINE connections the subtype can be:  Conx.SPOTWELD_BEAM Conx.SPOTWELD_MIG Conx.SPOTWELD_SOLID1 Conx.SPOTWELD_SOLID4 Conx.SPOTWELD_SOLID8 Conx.SPOTWELD_SOLID12 Conx.SPOTWELD_SOLID16  For BOLT connections the subtype can be:  Conx.BOLT_MRG_CYL Conx.BOLT_MRG_CYL_BEAM Conx.BOLT_MRG_CYL_BALL Conx.BOLT_MRG_2PTS Conx.BOLT_MRG_2PTS_RB Conx.BOLT_MRG_2PTS_RJ Conx.BOLT_MRG_CYL Conx.BOLT_NRB_CYL_BEAM Conx.BOLT_NRB_CYL_BALL Conx.BOLT_NRB_SPH Conx.BOLT_NRB_SPH_BALL Conx.BOLT_NRB_SPH_DISC Conx.BOLT_NRB_2PTS Conx.BOLT_MODULE  For ADHESIVE connections the subtype can be: Conx.ADHESIVE_SOLID. Conx.ADHESIVE_PATCH.</field>
    /// <field name='title' static='false' type='String'>Title for connection</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the connection (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='type' static='false' type='Number'>The connection type. Can be Conx.SPOTWELD, Conx.BOLT or Conx.ADHESIVE.</field>
    /// <field name='user_data' static='false' type='String'>User data for connection</field>
    /// <field name='x' static='false' type='Number'>X coordinate</field>
    /// <field name='x2' static='false' type='Number'>X coordinate for second point (adhesive only)</field>
    /// <field name='y' static='false' type='Number'>Y coordinate</field>
    /// <field name='y2' static='false' type='Number'>Y coordinate for second point (adhesive only)</field>
    /// <field name='z' static='false' type='Number'>Z coordinate</field>
    /// <field name='z2' static='false' type='Number'>Z coordinate for second point (adhesive only)</field>
    /// <field name='ADHESIVE' static='true' type='Number'>Connection is adhesive.</field>
    /// <field name='ADHESIVE_PATCH' static='true' type='Number'>Connection adhesive type is a patch.</field>
    /// <field name='ADHESIVE_SOLID' static='true' type='Number'>Connection adhesive type is a solid line.</field>
    /// <field name='ASSEMBLY' static='true' type='Number'>If the connection refers to an assembly rather than individual layers, the assembly is defined by part tree assembly.</field>
    /// <field name='BAD' static='true' type='Number'>Connection is bad (e.g. necessary data is missing).</field>
    /// <field name='BOLT' static='true' type='Number'>Connection is a bolt.</field>
    /// <field name='BOLT_MODULE' static='true' type='Number'>Library bolt.</field>
    /// <field name='BOLT_MRG_2PTS' static='true' type='Number'>2pt Patch Beam.</field>
    /// <field name='BOLT_MRG_2PTS_RB' static='true' type='Number'>2pt Patch (Rigid Beam).</field>
    /// <field name='BOLT_MRG_2PTS_RJ' static='true' type='Number'>2pt Patch Revolute joint.</field>
    /// <field name='BOLT_MRG_CYL' static='true' type='Number'>Cylindrical Merge.</field>
    /// <field name='BOLT_MRG_CYL_BALL' static='true' type='Number'>Cylindrical Patch Ball joint.</field>
    /// <field name='BOLT_MRG_CYL_BEAM' static='true' type='Number'>Cylindrical Patch Beam.</field>
    /// <field name='BOLT_NRB_2PTS' static='true' type='Number'>2pt NRB Beam.</field>
    /// <field name='BOLT_NRB_CYL' static='true' type='Number'>Cylindrical NRB.</field>
    /// <field name='BOLT_NRB_CYL_BALL' static='true' type='Number'>Cylindrical NRB Ball joint.</field>
    /// <field name='BOLT_NRB_CYL_BEAM' static='true' type='Number'>Cylindrical NRB Beam.</field>
    /// <field name='BOLT_NRB_SPH' static='true' type='Number'>Spherical NRB.</field>
    /// <field name='BOLT_NRB_SPH_BALL' static='true' type='Number'>Spherical NRB Ball joint.</field>
    /// <field name='BOLT_NRB_SPH_DISC' static='true' type='Number'>Spherical NRB Discrete Beam.</field>
    /// <field name='DORMANT' static='true' type='Number'>Connection is dormant (not yet made).</field>
    /// <field name='INVALID' static='true' type='Number'>Connection has been made but something is wrong (e.g. part moved).</field>
    /// <field name='MADE' static='true' type='Number'>Connection has been made but status is unknown.</field>
    /// <field name='PART_SET' static='true' type='Number'>If the connection refers to an assembly rather than individual layers, the assembly is defined by part set.</field>
    /// <field name='REALIZED' static='true' type='Number'>Connection has been made and is OK (checks OK).</field>
    /// <field name='RIGID' static='true' type='Number'>Please use Conx.BOLT instead.</field>
    /// <field name='RIGID_MERGE' static='true' type='Number'>Please use Conx.BOLT_MRG_CYL instead.</field>
    /// <field name='RIGID_NRB' static='true' type='Number'>Please use Conx.BOLT_NRB_CYL instead.</field>
    /// <field name='SPOTWELD' static='true' type='Number'>Connection is a spotweld.</field>
    /// <field name='SPOTWELD_BEAM' static='true' type='Number'>Connection spotweld type is beam.</field>
    /// <field name='SPOTWELD_LINE' static='true' type='Number'>Connection is a spotweld line.</field>
    /// <field name='SPOTWELD_MIG' static='true' type='Number'>Connection spotweld type is (beam) MIG weld.</field>
    /// <field name='SPOTWELD_SOLID1' static='true' type='Number'>Connection spotweld type is one solid/spotweld layer.</field>
    /// <field name='SPOTWELD_SOLID12' static='true' type='Number'>Connection spotweld type is twelve solids/spotweld layer.</field>
    /// <field name='SPOTWELD_SOLID16' static='true' type='Number'>Connection spotweld type is sixteen solids/spotweld layer.</field>
    /// <field name='SPOTWELD_SOLID4' static='true' type='Number'>Connection spotweld type is four solids/spotweld layer.</field>
    /// <field name='SPOTWELD_SOLID8' static='true' type='Number'>Connection spotweld type is eight solids/spotweld layer.</field>
}

Conx.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the connection</summary>
    /// <returns type="null"/>
    /// </signature>
}

Conx.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all connections will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged connections will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the connections that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the connection is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Conx.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the connection.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the connection</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the connection.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Conx"/>
    /// </signature>
}

Conx.prototype.EmptyPatch = function() {
    /// <signature>
    /// <summary>Empties the patch topology/coordinates data.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for connection. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for connection. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the connection colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the connection.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Conx.First = function() {
    /// <signature>
    /// <summary>Returns the first connection in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first connection in</param>
    /// <returns type="Conx"/>
    /// </signature>
}

Conx.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free connection label in the model. Also see Conx.LastFreeLabel(), Conx.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free connection label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Conx.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the connections in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all connections will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the connections</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the connection is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the connection</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Conx.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each connection in the model. Note that ForEach has been designed to make looping over connections as fast as possible and so has some limitations. Firstly, a single temporary Conx object is created and on each function call it is updated with the current connection data. This means that you should not try to store the Conx object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new connections inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all connections are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each connection</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Conx objects for all of the connections in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get connections from</param>
    /// <returns type="Array" elementType="Conx"/>
    /// </signature>
}

Conx.prototype.GetElements = function() {
    /// <signature>
    /// <summary>Returns the beams/solids that are used in the connection.</summary>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Conx.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Conx objects for all of the flagged connections in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get connections from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the connections that you want to retrieve</param>
    /// <returns type="Array" elementType="Conx"/>
    /// </signature>
}

Conx.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Conx object for a connection ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the connection in</param>
    /// <param name="number" type="Number" optional="false">number of the connection you want the Conx object for</param>
    /// <returns type="Conx"/>
    /// </signature>
}

Conx.prototype.GetLayerData = function() {
    /// <signature>
    /// <summary>Returns the data for a layer of the connection.</summary>
    /// <param name="layer" type="Number" optional="false">The layer you want the data for. Note that layers start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Conx.prototype.GetLayerShells = function() {
    /// <signature>
    /// <summary>Returns the attached shells for a layer of the connection.</summary>
    /// <param name="layer" type="Number" optional="false">The layer you want the data for. Note that layers start at 0, not 1.</param>
    /// <returns type="Array" elementType="Shell"/>
    /// </signature>
}

Conx.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Conx property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Conx.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">connection property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Conx.prototype.GetPatchCoords = function() {
    /// <signature>
    /// <summary>Returns the data for a patch coordinate of an adhesive patch connection.</summary>
    /// <param name="point" type="Number" optional="false">The point you want the data for. Note that points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Conx.prototype.GetPatchTopol = function() {
    /// <signature>
    /// <summary>Returns the topology for a patch quad/tria of an adhesive patch connection.</summary>
    /// <param name="point" type="Number" optional="false">The patch quad/tria you want the data for. Note that points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Conx.prototype.GetPathData = function() {
    /// <signature>
    /// <summary>Returns the data for a path point of an adhesive/spotweld line connection.</summary>
    /// <param name="point" type="Number" optional="false">The point you want the data for. Note that points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Conx.prototype.GetPidData = function() {
    /// <signature>
    /// <summary>Returns an array of Part objects for the connection FE entities. A connection can contain elements with different part ID's between different layers. If one part ID is returned, that part is used for all elements in the connection. Not applicable for bolts.</summary>
    /// <returns type="Array" elementType="Part"/>
    /// </signature>
}

Conx.prototype.GetSettings = function() {
    /// <signature>
    /// <summary>Returns an object of settings stored with the connection.</summary>
    /// <returns type="Object"/>
    /// </signature>
}

Conx.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this connection (*CONNECTION_START_SPOTWELD etc). Note that a carriage return is not added. See also Conx.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Conx.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the connection. Note that a carriage return is not added. See also Conx.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Conx.Last = function() {
    /// <signature>
    /// <summary>Returns the last connection in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last connection in</param>
    /// <returns type="Conx"/>
    /// </signature>
}

Conx.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free connection label in the model. Also see Conx.FirstFreeLabel(), Conx.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free connection label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Conx.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next connection in the model.</summary>
    /// <returns type="Conx"/>
    /// </signature>
}

Conx.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) connection label in the model. Also see Conx.FirstFreeLabel(), Conx.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free connection label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Conx.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a connection.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only connections from that model can be picked. If the argument is a Flag then only connections that are flagged with limit can be selected. If omitted, or null, any connections from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Conx"/>
    /// </signature>
}

Conx.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous connection in the model.</summary>
    /// <returns type="Conx"/>
    /// </signature>
}

Conx.RealizeAll = function() {
    /// <signature>
    /// <summary>Realizes all of the connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all connections will be realized in</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.RealizeFlagged = function() {
    /// <signature>
    /// <summary>Realizes all of the flagged connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged connections will be realized in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the connections that you want to realize</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.ReloadConnectors = function() {
    /// <signature>
    /// <summary>Reload all modules from primer_library/connectors</summary>
    /// </signature>
}

Conx.prototype.RemovePatchTopol = function() {
    /// <signature>
    /// <summary>Deletes the topology at a particular location for patch type adhesive.</summary>
    /// <param name="layer" type="Number" optional="false">The topology location you want to remove. Note that layers start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.RemovePathData = function() {
    /// <signature>
    /// <summary>Deletes a pathc point for a line adhesive connection.</summary>
    /// <param name="layer" type="Number" optional="false">The point you want to remove. Note that layers start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all connections will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged connections will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the connections that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select connections using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting connections</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only connections from that model can be selected. If the argument is a Flag then only connections that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any connections can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Conx.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the connection.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the connection</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.SetLayerData = function() {
    /// <signature>
    /// <summary>Sets the data for a layer of the connection.</summary>
    /// <param name="layer" type="Number" optional="false">The layer you want to set the data for. Note that layers start at 0, not 1.</param>
    /// <param name="item1" type="Number" optional="false">The first item for the layer definition. As layer definitions can be part IDs, part names, CAD names, part set IDs, part set names or assemby names the following logic is used. If the item is an integer it is assumed to be a part ID. If the item is a string then it must be in the format 'P&lt;part ID&gt;', 'P:&lt;part name&gt;', 'C:&lt;CAD name&gt;', 'S&lt;set ID&gt;', 'S:&lt;set name&gt;'or 'A:&lt;assembly name&gt;'.</param>
    /// <param name="item2" type="Number" optional="true">The second item for the layer definition. This must be type same type as item1. e.g. if item1 is a part ID, item2 must be a part ID (it cannot be a part name etc).</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.SetPatchCoords = function() {
    /// <signature>
    /// <summary>Sets a coordinate used by the adhesive patch connection type.</summary>
    /// <param name="point" type="Number" optional="false">The point you want to set the data for. Note that points start at 0, not 1.</param>
    /// <param name="x" type="Number" optional="false">X coordinate of point</param>
    /// <param name="y" type="Number" optional="false">Y coordinate of point</param>
    /// <param name="z" type="Number" optional="false">Z coordinate of point</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.SetPatchTopol = function() {
    /// <signature>
    /// <summary>Sets the topology used by the adhesive patch connection type.</summary>
    /// <param name="point" type="Number" optional="false">The point you want to set the data for. Note that points start at 0, not 1.</param>
    /// <param name="c1" type="Number" optional="false">1st coordinate location point</param>
    /// <param name="c2" type="Number" optional="false">2nd coordinate location point</param>
    /// <param name="c3" type="Number" optional="false">3rd coordinate location point</param>
    /// <param name="c4" type="Number" optional="true">4th coordinate location point</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.SetPathData = function() {
    /// <signature>
    /// <summary>Sets the data for a path point of the connection.</summary>
    /// <param name="point" type="Number" optional="false">The point you want to set the data for. Note that points start at 0, not 1.</param>
    /// <param name="x" type="Number" optional="false">X coordinate of point</param>
    /// <param name="y" type="Number" optional="false">Y coordinate of point</param>
    /// <param name="z" type="Number" optional="false">Z coordinate of point</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.SetPidData = function() {
    /// <signature>
    /// <summary>Sets the element part IDs for the connection. A different part can be defined for elements in the connection between different layers. Not applicable for bolts.</summary>
    /// <param name="item1" type="Number" optional="false">Part label of the first item in the PID layer list.</param>
    /// <param name="item2" type="Number" optional="true">The second item for the layer definition.</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.SetRuleDiameter = function() {
    /// <signature>
    /// <summary>Set the diameter for a spotweld ring when running a rule. Note that this method can only be called when running a connection rule script. It will not have any effect if used in a 'normal' script.</summary>
    /// <param name="diameter" type="Number" optional="false">The diameter to set for the ring</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.SetRuleFEPID = function() {
    /// <signature>
    /// <summary>Set the PID for spotweld beam/solid elements or adhesive solids when running a rule. Note that this method can only be called when running a connection rule script. It will not have any effect if used in a 'normal' script.</summary>
    /// <param name="pid" type="Number" optional="false">The PID to set for the spotweld or adhesive elements</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.SetRulePID = function() {
    /// <signature>
    /// <summary>Set the PID for a spotweld ring when running a rule. Note that this method can only be called when running a connection rule script. It will not have any effect if used in a 'normal' script.</summary>
    /// <param name="pid" type="Number" optional="false">The PID to set for the ring</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.SetSettings = function() {
    /// <signature>
    /// <summary>Sets the settings stored on a connection entity. Not applicable for bolts.</summary>
    /// <param name="data" type="Object" optional="false">Object containing the connection settings data. The properties can be:</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the connection. The connection will be sketched until you either call Conx.Unsketch(), Conx.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the connection is sketched. If omitted redraw is true. If you want to sketch several connections and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged connections in the model. The connections will be sketched until you either call Conx.Unsketch(), Conx.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged connections will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the connections that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the connections are sketched. If omitted redraw is true. If you want to sketch flagged connections several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing connections should be counted. If false or omitted referenced but undefined connections will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Conx.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the connection</summary>
    /// <returns type="null"/>
    /// </signature>
}

Conx.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all connections will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged connections will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the connections that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all connections will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the connections</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the connection.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the connection is unsketched. If omitted redraw is true. If you want to unsketch several connections and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all connections.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all connections will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the connections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged connections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all connections will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the connections that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the connections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Conx"/>
    /// </signature>
}

Conx.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for connection. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Conx.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this connection.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Conx.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the connection data in keyword format. Note that this contains the keyword header and the keyword cards. See also Conx.Keyword() and Conx.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var CoordinateSystem = function() {
    /// <signature>
    /// <summary>Create a new CoordinateSystem object for *DEFINE_COORDINATE_NODES.</summary>
    /// <param name="Model" type="Model" optional="false">Model that csys will be created in</param>
    /// <param name="option" type="Number" optional="false">Must be CoordinateSystem.NODES</param>
    /// <param name="cid" type="Number" optional="false">CoordinateSystem number</param>
    /// <param name="n1" type="Number" optional="false">Node located at origin</param>
    /// <param name="n2" type="Number" optional="false">Node located along (DIR) axis</param>
    /// <param name="n3" type="Number" optional="false">Node located in plane defined by (DIR)</param>
    /// <param name="flag" type="Boolean" optional="false">Flag for local system update each time step</param>
    /// <param name="dir" type="Number" optional="false">Axis defined by N1N2</param>
    /// <param name="heading" type="String" optional="true">Title for the csys</param>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new CoordinateSystem object for *DEFINE_COORDINATE_SYSTEM.</summary>
    /// <param name="Model" type="Model" optional="false">Model that csys will be created in</param>
    /// <param name="option" type="Number" optional="false">Must be CoordinateSystem.SYSTEM</param>
    /// <param name="cid" type="Number" optional="false">CoordinateSystem number</param>
    /// <param name="ox" type="Number" optional="false">X-coordinate of origin</param>
    /// <param name="oy" type="Number" optional="false">Y-coordinate of origin</param>
    /// <param name="oz" type="Number" optional="false">Z-coordinate of origin</param>
    /// <param name="lx" type="Number" optional="false">X-coordinate of point on local X-axis</param>
    /// <param name="ly" type="Number" optional="false">Y-coordinate of point on local X-axis</param>
    /// <param name="lz" type="Number" optional="false">Z-coordinate of point on local X-axis</param>
    /// <param name="px" type="Number" optional="false">X-coordinate of point in local X-Y plane</param>
    /// <param name="py" type="Number" optional="false">Y-coordinate of point in local X-Y plane</param>
    /// <param name="pz" type="Number" optional="false">Z-coordinate of point in local X-Y plane</param>
    /// <param name="heading" type="String" optional="true">Title for the csys</param>
    /// </signature>
    /// <signature>
    /// <summary>Create a new CoordinateSystem object for *DEFINE_COORDINATE_VECTOR.</summary>
    /// <param name="Model" type="Model" optional="false">Model that csys will be created in</param>
    /// <param name="option" type="Number" optional="false">Must be CoordinateSystem.VECTOR</param>
    /// <param name="cid" type="Number" optional="false">CoordinateSystem number</param>
    /// <param name="xx" type="Number" optional="false">X-coordinate on local X-axis</param>
    /// <param name="xy" type="Number" optional="false">Y-coordinate on local X-axis</param>
    /// <param name="xz" type="Number" optional="false">Z-coordinate on local X-axis</param>
    /// <param name="vx" type="Number" optional="false">X-coordinate of local X-Y vector</param>
    /// <param name="vy" type="Number" optional="false">Y-coordinate of local X-Y vector</param>
    /// <param name="vz" type="Number" optional="false">Z-coordinate of local X-Z vector</param>
    /// <param name="nid" type="Number" optional="false">Optional node id for rotation</param>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>CoordinateSystem number. Also see the label number.</field>
    /// <field name='cidl' static='false' type='Number'>Optional local coordinate system to define the points in</field>
    /// <field name='dir' static='false' type='int'>Axis defined by N1N2</field>
    /// <field name='exists' static='false' type='Boolean'>true if csys exists, false if referred to but not defined. (read only)</field>
    /// <field name='flag' static='false' type='Boolean'>Flag for updating local system each timestep</field>
    /// <field name='heading' static='false' type='String'>CoordinateSystem heading</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the csys is in.</field>
    /// <field name='label' static='false' type='Number'>CoordinateSystem number. Also see the cid property which is an alternative name for this.</field>
    /// <field name='lx' static='false' type='Number'>X-coordinate of point on local X-axis</field>
    /// <field name='ly' static='false' type='Number'>Y-coordinate of point on local X-axis</field>
    /// <field name='lz' static='false' type='Number'>Z-coordinate of point on local X-axis</field>
    /// <field name='model' static='false' type='Number'>The Model number that the coordinate system is in.</field>
    /// <field name='n1' static='false' type='int'>Node located at local origin</field>
    /// <field name='n2' static='false' type='int'>Node located along local (dir) axis</field>
    /// <field name='n3' static='false' type='int'>Node located in local plane determined by (dir)</field>
    /// <field name='nid' static='false' type='Number'>Optional node id for rotation</field>
    /// <field name='option' static='false' type='Number'>CoordinateSystem type (Can be CoordinateSystem.NODES, CoordinateSystem.SYSTEM or CoordinateSystem.VECTOR).</field>
    /// <field name='ox' static='false' type='Number'>X-coordinate of origin</field>
    /// <field name='oy' static='false' type='Number'>Y-coordinate of origin</field>
    /// <field name='oz' static='false' type='Number'>Z-coordinate of origin</field>
    /// <field name='px' static='false' type='Number'>X-coordinate of point in local X-Y plane</field>
    /// <field name='py' static='false' type='Number'>Y-coordinate of point in local X-Y plane</field>
    /// <field name='pz' static='false' type='Number'>Z-coordinate of point in local X-Y plane</field>
    /// <field name='vx' static='false' type='Number'>X-coordinate of local X-Y vector</field>
    /// <field name='vy' static='false' type='Number'>Y-coordinate of local X-Y vector</field>
    /// <field name='vz' static='false' type='Number'>Z-coordinate of local X-Z vector</field>
    /// <field name='xx' static='false' type='Number'>X-coordinate on local X-axis</field>
    /// <field name='xy' static='false' type='Number'>Y-coordinate on local X-axis</field>
    /// <field name='xz' static='false' type='Number'>Z-coordinate on local X-axis</field>
    /// <field name='NODES' static='true' type='Number'>Csys is *DEFINE_COORDINATE_NODES.</field>
    /// <field name='SYSTEM' static='true' type='Number'>Csys is *DEFINE_COORDINATE_SYSTEM.</field>
    /// <field name='VECTOR' static='true' type='Number'>Csys is *DEFINE_COORDINATE_VECTOR.</field>
}

CoordinateSystem.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the coordinate system</summary>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the coordinate systems in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all coordinate systems will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged coordinate systems in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged coordinate systems will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the coordinate systems that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the coordinate system is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

CoordinateSystem.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the coordinate system.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the coordinate system</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the coordinate system.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a csys.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the csys will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for coordinate system. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.First = function() {
    /// <signature>
    /// <summary>Returns the first coordinate system in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first coordinate system in</param>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free coordinate system label in the model. Also see CoordinateSystem.LastFreeLabel(), CoordinateSystem.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free coordinate system label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

CoordinateSystem.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the coordinate systems in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all coordinate systems will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the coordinate systems</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the coordinate system is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the coordinate system</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

CoordinateSystem.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each coordinate system in the model. Note that ForEach has been designed to make looping over coordinate systems as fast as possible and so has some limitations. Firstly, a single temporary CoordinateSystem object is created and on each function call it is updated with the current coordinate system data. This means that you should not try to store the CoordinateSystem object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new coordinate systems inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all coordinate systems are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each coordinate system</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of CoordinateSystem objects for all of the coordinate systems in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get coordinate systems from</param>
    /// <returns type="Array" elementType="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of CoordinateSystem objects for all of the flagged coordinate systems in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get coordinate systems from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the coordinate systems that you want to retrieve</param>
    /// <returns type="Array" elementType="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the CoordinateSystem object for a coordinate system ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the coordinate system in</param>
    /// <param name="number" type="Number" optional="false">number of the coordinate system you want the CoordinateSystem object for</param>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a CoordinateSystem property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the CoordinateSystem.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">coordinate system property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

CoordinateSystem.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this csys (*DEFINE_COORDINATE). Note that a carriage return is not added. See also CoordinateSystem.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

CoordinateSystem.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the csys. Note that a carriage return is not added. See also CoordinateSystem.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

CoordinateSystem.Last = function() {
    /// <signature>
    /// <summary>Returns the last coordinate system in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last coordinate system in</param>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free coordinate system label in the model. Also see CoordinateSystem.FirstFreeLabel(), CoordinateSystem.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free coordinate system label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

CoordinateSystem.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next coordinate system in the model.</summary>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) coordinate system label in the model. Also see CoordinateSystem.FirstFreeLabel(), CoordinateSystem.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free coordinate system label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

CoordinateSystem.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a coordinate system.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only coordinate systems from that model can be picked. If the argument is a Flag then only coordinate systems that are flagged with limit can be selected. If omitted, or null, any coordinate systems from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous coordinate system in the model.</summary>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the coordinate systems in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all coordinate systems will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged coordinate systems in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged coordinate systems will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the coordinate systems that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select coordinate systems using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting coordinate systems</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only coordinate systems from that model can be selected. If the argument is a Flag then only coordinate systems that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any coordinate systems can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

CoordinateSystem.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the coordinate system.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the coordinate system</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the coordinate system. The coordinate system will be sketched until you either call CoordinateSystem.Unsketch(), CoordinateSystem.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the coordinate system is sketched. If omitted redraw is true. If you want to sketch several coordinate systems and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged coordinate systems in the model. The coordinate systems will be sketched until you either call CoordinateSystem.Unsketch(), CoordinateSystem.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged coordinate systems will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the coordinate systems that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the coordinate systems are sketched. If omitted redraw is true. If you want to sketch flagged coordinate systems several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of coordinate systems in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing coordinate systems should be counted. If false or omitted referenced but undefined coordinate systems will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

CoordinateSystem.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the coordinate system</summary>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the coordinate systems in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all coordinate systems will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged coordinate systems in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged coordinate systems will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the coordinate systems that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the coordinate systems in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all coordinate systems will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the coordinate systems</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the coordinate system.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the coordinate system is unsketched. If omitted redraw is true. If you want to unsketch several coordinate systems and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all coordinate systems.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all coordinate systems will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the coordinate systems are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged coordinate systems in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all coordinate systems will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the coordinate systems that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the coordinate systems are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="CoordinateSystem"/>
    /// </signature>
}

CoordinateSystem.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for coordinate system. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

CoordinateSystem.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this coordinate system.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

CoordinateSystem.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the csys data in keyword format. Note that this contains the keyword header and the keyword cards. See also CoordinateSystem.Keyword() and CoordinateSystem.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var CrossSection = function() {
    /// <signature>
    /// <summary>Create a new CrossSection object for *DATABASE_CROSS_SECTION_SET.</summary>
    /// <param name="Model" type="Model" optional="false">Model that database cross section will be created in</param>
    /// <param name="option" type="Number" optional="false">Database cross section type. Must be CrossSection.SET</param>
    /// <param name="nsid" type="Number" optional="false">Node set number.</param>
    /// <param name="hsid" type="Number" optional="false">Solid set number.</param>
    /// <param name="bsid" type="Number" optional="false">Beam set number.</param>
    /// <param name="ssid" type="Number" optional="false">Shell set number.</param>
    /// <param name="tsid" type="Number" optional="false">Thick shell set number.</param>
    /// <param name="dsid" type="Number" optional="false">Discrete set number.</param>
    /// <param name="id" type="Number" optional="true">Rigid part or accelerometer or coordinate system number.</param>
    /// <param name="itype" type="Number" optional="true">Flag for local system type.</param>
    /// <param name="csid" type="Number" optional="true">Database cross_section number.</param>
    /// <param name="heading" type="String" optional="true">Database cross_section title.</param>
    /// <returns type="CrossSection"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new CrossSection object for *DATABASE_CROSS_SECTION_PLANE.</summary>
    /// <param name="Model" type="Model" optional="false">Model that database cross section will be created in</param>
    /// <param name="option" type="Number" optional="false">Database cross section type. Must be CrossSection.PLANE</param>
    /// <param name="psid" type="Number" optional="false">Part set number.</param>
    /// <param name="xct" type="Number" optional="false">X coordinate of tail of normal vector.</param>
    /// <param name="yct" type="Number" optional="false">Y coordinate of tail of normal vector.</param>
    /// <param name="zct" type="Number" optional="false">Z coordinate of tail of normal vector.</param>
    /// <param name="xch" type="Number" optional="false">X coordinate of head of normal vector.</param>
    /// <param name="ych" type="Number" optional="false">Y coordinate of head of normal vector.</param>
    /// <param name="zch" type="Number" optional="false">Z coordinate of head of normal vector.</param>
    /// <param name="xhev" type="Number" optional="false">X coordinate of head of edge vector.</param>
    /// <param name="yhev" type="Number" optional="false">Y coordinate of head of edge vector.</param>
    /// <param name="zhev" type="Number" optional="false">Z coordinate of head of edge vector.</param>
    /// <param name="lenl" type="Number" optional="true">Length in l direction.</param>
    /// <param name="lenm" type="Number" optional="true">Length in m direction.</param>
    /// <param name="id" type="Number" optional="true">Rigid part or accelerometer or coordinate system number.</param>
    /// <param name="itype" type="Number" optional="true">Flag for local system type.</param>
    /// <param name="csid" type="Number" optional="true">Database cross_section number.</param>
    /// <param name="heading" type="String" optional="true">Database cross_section title.</param>
    /// <returns type="CrossSection"/>
    /// </signature>
    /// <field name='bsid' static='false' type='Number'>Beam set number.</field>
    /// <field name='csid' static='false' type='Number'>Database cross section number (identical to label).</field>
    /// <field name='dsid' static='false' type='Number'>Discrete set number.</field>
    /// <field name='exists' static='false' type='Boolean'>true if database cross section exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>Database cross section heading.</field>
    /// <field name='hsid' static='false' type='Number'>Solid set number.</field>
    /// <field name='id' static='false' type='Number'>Rigid part or accelerometer or coordinate system number.</field>
    /// <field name='idset' static='false' type='Boolean'>true if _ID option is set, false if not</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the database cross section is in.</field>
    /// <field name='itype' static='false' type='Number'>Flag for local system type.</field>
    /// <field name='label' static='false' type='Number'>Database cross section number.</field>
    /// <field name='lenl' static='false' type='Number'>Length of L edge.</field>
    /// <field name='lenm' static='false' type='Number'>Length of M edge.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the cross section is in.</field>
    /// <field name='nsid' static='false' type='Number'>Node set number.</field>
    /// <field name='option' static='false' type='Number'>The Database CrossSection option. Can be:  CrossSection.PLANE or CrossSection.SET </field>
    /// <field name='psid' static='false' type='Number'>Part set number.</field>
    /// <field name='radius' static='false' type='Number'>Radius.</field>
    /// <field name='ssid' static='false' type='Number'>Shell set number.</field>
    /// <field name='tsid' static='false' type='Number'>Thick shell set number.</field>
    /// <field name='xch' static='false' type='Number'>Head X coord of N normal vector.</field>
    /// <field name='xct' static='false' type='Number'>Tail X coord of N normal vector.</field>
    /// <field name='xhev' static='false' type='Number'>Head X coord of L edge vector.</field>
    /// <field name='ych' static='false' type='Number'>Head Y coord of N normal vector.</field>
    /// <field name='yct' static='false' type='Number'>Tail Y coord of N normal vector.</field>
    /// <field name='yhev' static='false' type='Number'>Head Y coord of L edge vector.</field>
    /// <field name='zch' static='false' type='Number'>Head Z coord of N normal vector.</field>
    /// <field name='zct' static='false' type='Number'>Tail Z coord of N normal vector.</field>
    /// <field name='zhev' static='false' type='Number'>Head Z coord of L edge vector.</field>
    /// <field name='PLANE' static='true' type='Number'>PLANE is *DATABASE_CROSS_SECTION_PLANE.</field>
    /// <field name='SET' static='true' type='Number'>SET is *DATABASE_CROSS_SECTION_SET.</field>
}

CrossSection.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the cross section</summary>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the cross sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all cross sections will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged cross sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged cross sections will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the cross sections that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the cross section is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

CrossSection.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the cross section.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the cross section</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the cross section.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="CrossSection"/>
    /// </signature>
}

CrossSection.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a cross_section.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the cross_section will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="CrossSection"/>
    /// </signature>
}

CrossSection.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.prototype.ElemCut = function() {
    /// <signature>
    /// <summary>Returns coordinates of the intersections between a shell and a database cross section. Note, ElemCut on the Shell class may be quicker</summary>
    /// <param name="Shell label" type="Number" optional="false">The label of the shell.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

CrossSection.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for cross section. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.First = function() {
    /// <signature>
    /// <summary>Returns the first cross section in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first cross section in</param>
    /// <returns type="CrossSection"/>
    /// </signature>
}

CrossSection.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free cross section label in the model. Also see CrossSection.LastFreeLabel(), CrossSection.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free cross section label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

CrossSection.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the cross sections in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all cross sections will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the cross sections</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.prototype.FlagCut = function() {
    /// <signature>
    /// <summary>Flags every element (solid,shell,tshell,beam) cut by the cross section. Note this function does not check that the element is in the cross section definition (part set)</summary>
    /// <param name="Flag" type="Flag" optional="false">Flag bit.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

CrossSection.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the cross section is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the cross section</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

CrossSection.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each cross section in the model. Note that ForEach has been designed to make looping over cross sections as fast as possible and so has some limitations. Firstly, a single temporary CrossSection object is created and on each function call it is updated with the current cross section data. This means that you should not try to store the CrossSection object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new cross sections inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all cross sections are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each cross section</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of CrossSection objects for all of the cross sections in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get cross sections from</param>
    /// <returns type="Array" elementType="CrossSection"/>
    /// </signature>
}

CrossSection.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of CrossSection objects for all of the flagged cross sections in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get cross sections from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the cross sections that you want to retrieve</param>
    /// <returns type="Array" elementType="CrossSection"/>
    /// </signature>
}

CrossSection.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the CrossSection object for a cross section ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the cross section in</param>
    /// <param name="number" type="Number" optional="false">number of the cross section you want the CrossSection object for</param>
    /// <returns type="CrossSection"/>
    /// </signature>
}

CrossSection.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a CrossSection property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the CrossSection.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">cross section property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

CrossSection.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this cross_section (*DATABASE_CROSS_SECTION). Note that a carriage return is not added. See also CrossSection.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

CrossSection.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the cross_section. Note that a carriage return is not added. See also CrossSection.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

CrossSection.Last = function() {
    /// <signature>
    /// <summary>Returns the last cross section in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last cross section in</param>
    /// <returns type="CrossSection"/>
    /// </signature>
}

CrossSection.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free cross section label in the model. Also see CrossSection.FirstFreeLabel(), CrossSection.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free cross section label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

CrossSection.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next cross section in the model.</summary>
    /// <returns type="CrossSection"/>
    /// </signature>
}

CrossSection.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) cross section label in the model. Also see CrossSection.FirstFreeLabel(), CrossSection.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free cross section label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

CrossSection.prototype.PartCut = function() {
    /// <signature>
    /// <summary>Returns true if cross section is cutting the part, false otherwise. If option flag is active, will flag every element of the part cut by the cross section. Note this function does not check that the part is in the cross section definition (part set)</summary>
    /// <param name="Part label" type="Number" optional="false">The label of the part.</param>
    /// <param name="Flag" type="Flag" optional="true">Optional Flag to flag the element which are cut by the cross section.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

CrossSection.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a cross section.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only cross sections from that model can be picked. If the argument is a Flag then only cross sections that are flagged with limit can be selected. If omitted, or null, any cross sections from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="CrossSection"/>
    /// </signature>
}

CrossSection.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous cross section in the model.</summary>
    /// <returns type="CrossSection"/>
    /// </signature>
}

CrossSection.prototype.Properties = function() {
    /// <signature>
    /// <summary>Returns an object which describe various cross section properties</summary>
    /// <returns type="Object"/>
    /// </signature>
}

CrossSection.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the cross sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all cross sections will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged cross sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged cross sections will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the cross sections that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select cross sections using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting cross sections</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only cross sections from that model can be selected. If the argument is a Flag then only cross sections that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any cross sections can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

CrossSection.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the cross section.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the cross section</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the cross section. The cross section will be sketched until you either call CrossSection.Unsketch(), CrossSection.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the cross section is sketched. If omitted redraw is true. If you want to sketch several cross sections and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged cross sections in the model. The cross sections will be sketched until you either call CrossSection.Unsketch(), CrossSection.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged cross sections will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the cross sections that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the cross sections are sketched. If omitted redraw is true. If you want to sketch flagged cross sections several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of cross sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing cross sections should be counted. If false or omitted referenced but undefined cross sections will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

CrossSection.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the cross section</summary>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the cross sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all cross sections will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged cross sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged cross sections will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the cross sections that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the cross sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all cross sections will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the cross sections</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the cross section.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the cross section is unsketched. If omitted redraw is true. If you want to unsketch several cross sections and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all cross sections.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all cross sections will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the cross sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged cross sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all cross sections will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the cross sections that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the cross sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="CrossSection"/>
    /// </signature>
}

CrossSection.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for cross section. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

CrossSection.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this cross section.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

CrossSection.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the cross_section data in keyword format. Note that this contains the keyword header and the keyword cards. See also CrossSection.Keyword() and CrossSection.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Curve = function() {
    /// <signature>
    /// <summary>Create a new Curve object.</summary>
    /// <param name="Load curve type" type="Number" optional="false">Type of load curve. Can be Curve.CURVE, Curve.TABLE, Note this does not have to be defined. In previous versions of Primer you could only construct a basic load curve type, therefore the type argument was not used. Primer is still backwards compatible with this method of load curve creation.</param>
    /// <param name="Model" type="Model" optional="false">Model that curve will be created in</param>
    /// <param name="lcid" type="Number" optional="false">Curve number</param>
    /// <param name="sidr" type="Number" optional="true">Stress initialisation by dynamic relaxation</param>
    /// <param name="sfa" type="Number" optional="true">Scale factor on abscissa value</param>
    /// <param name="sfo" type="Number" optional="true">Scale factor on ordinate value</param>
    /// <param name="offa" type="Number" optional="true">Offset on abscissa value</param>
    /// <param name="offo" type="Number" optional="true">Offset on ordinate value</param>
    /// <param name="dattyp" type="Number" optional="true">Data type</param>
    /// <param name="heading" type="String" optional="true">Title for the curve</param>
    /// <param name="lcint" type="Number" optional="true">Number of discretization points for the curve</param>
    /// <returns type="Curve"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new Curve *DEFINE_CURVE_FUNCTION object.</summary>
    /// <param name="Load curve type" type="Number" optional="false">Type of load curve. Must be Curve.CURVE_FUNCTION.</param>
    /// <param name="Model" type="Model" optional="false">Model that curve will be created in</param>
    /// <param name="lcid" type="Number" optional="false">Curve number</param>
    /// <param name="sidr" type="Number" optional="true">Stress initialisation by dynamic relaxation</param>
    /// <param name="function" type="String" optional="true">Function expression</param>
    /// <param name="heading" type="String" optional="true">Title for the curve</param>
    /// <returns type="Curve"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new Curve *DEFINE_FUNCTION object.</summary>
    /// <param name="Load curve type" type="Number" optional="false">Type of load curve. Must be Curve.FUNCTION.</param>
    /// <param name="Model" type="Model" optional="false">Model that curve will be created in</param>
    /// <param name="lcid" type="Number" optional="false">Curve number</param>
    /// <param name="function" type="String" optional="true">Function expression</param>
    /// <param name="heading" type="String" optional="true">Title for the curve</param>
    /// <returns type="Curve"/>
    /// </signature>
    /// <field name='dattyp' static='false' type='Number'>Data type</field>
    /// <field name='exists' static='false' type='Boolean'>true if curve exists, false if referred to but not defined. (read only)</field>
    /// <field name='function' static='false' type='String'>Function expression for Curve.CURVE_FUNCTION</field>
    /// <field name='heading' static='false' type='String'>Curve heading</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the curve is in.</field>
    /// <field name='label' static='false' type='Number'>Curve number. Also see the lcid property which is an alternative name for this.</field>
    /// <field name='lcid' static='false' type='Number'>Curve number. Also see the label property which is an alternative name for this.</field>
    /// <field name='lcint' static='false' type='Number'>Number of discretization points for the curve</field>
    /// <field name='model' static='false' type='Number'>The Model number that the curve is in.</field>
    /// <field name='ncurves' static='false' type='Number'>Number of points in curve or number of curves in table. The npoints property is an alternative name for this. (read only for tables)</field>
    /// <field name='npoints' static='false' type='Number'>Number of points in curve or number of curves in table. The ncurves property is an alternative name for this. (read only for tables)</field>
    /// <field name='offa' static='false' type='Number'>Offset for abscissa values</field>
    /// <field name='offo' static='false' type='Number'>Offset for ordinate values</field>
    /// <field name='sfa' static='false' type='Number'>Scale factor on abscissa value</field>
    /// <field name='sfo' static='false' type='Number'>Scale factor on ordinate value</field>
    /// <field name='sidr' static='false' type='Number'>Stress initialisation by dynamic relaxation</field>
    /// <field name='type' static='false' type='Number'>Load curve type (Can be Curve.CURVE, Curve.CURVE_FUNCTION, Curve.FUNCTION or Curve.TABLE).</field>
    /// <field name='version' static='false' type='String'>Version for discretization. Can be blank, "3858" or "5434a"</field>
    /// <field name='AFTER' static='true' type='Number'>Insertion of curve data option.</field>
    /// <field name='BEFORE' static='true' type='Number'>Insertion of curve data option.</field>
    /// <field name='CURVE' static='true' type='Number'>Load curve type *DEFINE_CURVE</field>
    /// <field name='CURVE_FUNCTION' static='true' type='Number'>Load curve type *DEFINE_CURVE_FUNCTION</field>
    /// <field name='FUNCTION' static='true' type='Number'>Load curve type *DEFINE_FUNCTION</field>
    /// <field name='TABLE' static='true' type='Number'>Load curve type *DEFINE_TABLE</field>
}

Curve.prototype.AddPoint = function() {
    /// <signature>
    /// <summary>Adds a point to a load curve.</summary>
    /// <param name="xvalue" type="Number" optional="false">The x value of the point.</param>
    /// <param name="yvalue" type="Number" optional="false">The y value of the point.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.AddTableEntry = function() {
    /// <signature>
    /// <summary>Adds an entry line to a table.</summary>
    /// <param name="value" type="Number" optional="false">The value for for this entry in the table.</param>
    /// <param name="load curve" type="Number" optional="false">The load curve corresponding to the defined value.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the curve.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the curve</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the curve.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Curve"/>
    /// </signature>
}

Curve.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a curve.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the curve will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Curve"/>
    /// </signature>
}

Curve.CreateTable = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a table.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the curve will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Curve"/>
    /// </signature>
}

Curve.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for curve. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.First = function() {
    /// <signature>
    /// <summary>Returns the first curve in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first curve in</param>
    /// <returns type="Curve"/>
    /// </signature>
}

Curve.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free curve label in the model. Also see Curve.LastFreeLabel(), Curve.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free curve label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Curve.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the curves in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all curves will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the curves</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the curve is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the curve</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Curve.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each curve in the model. Note that ForEach has been designed to make looping over curves as fast as possible and so has some limitations. Firstly, a single temporary Curve object is created and on each function call it is updated with the current curve data. This means that you should not try to store the Curve object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new curves inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all curves are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each curve</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Curve objects for all of the curves in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get curves from</param>
    /// <returns type="Array" elementType="Curve"/>
    /// </signature>
}

Curve.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Curve objects for all of the flagged curves in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get curves from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the curves that you want to retrieve</param>
    /// <returns type="Array" elementType="Curve"/>
    /// </signature>
}

Curve.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Curve object for a curve ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the curve in</param>
    /// <param name="number" type="Number" optional="false">number of the curve you want the Curve object for</param>
    /// <returns type="Curve"/>
    /// </signature>
}

Curve.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Curve property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Curve.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">curve property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Curve.prototype.GetPoint = function() {
    /// <signature>
    /// <summary>Returns x and y data for a point in a curve</summary>
    /// <param name="row" type="Number" optional="false">The row point you want the data for. Note that curve points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Curve.prototype.GetTableEntry = function() {
    /// <signature>
    /// <summary>Returns the value and curve label for a row in a table</summary>
    /// <param name="row" type="Number" optional="false">The row point you want the data for. Note that curve points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Curve.prototype.InsertPoint = function() {
    /// <signature>
    /// <summary>Inserts point values before or after a specified row of data on a load curve.</summary>
    /// <param name="ipt" type="Number" optional="false">The row you want to insert the data before or after. Note that the row data starts at 0, not 1.</param>
    /// <param name="xvalue" type="Number" optional="false">The x value of the point.</param>
    /// <param name="yvalue" type="Number" optional="false">The y value of the point.</param>
    /// <param name="position" type="Number" optional="false">Specify either before or after the selected row. Use 'Curve.BEFORE' for before, and 'Curve.AFTER' for after.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.InsertTableEntry = function() {
    /// <signature>
    /// <summary>Inserts a table row before or after a specified row of data on a table.</summary>
    /// <param name="ipt" type="Number" optional="false">The row you want to insert the data before or after. Note that the row data starts at 0, not 1.</param>
    /// <param name="value" type="Number" optional="false">The value of the row.</param>
    /// <param name="lcid" type="Number" optional="false">The load curve corresponding to the defined value.</param>
    /// <param name="position" type="Number" optional="false">Specify either before or after the selected row. Use 'Curve.BEFORE' for before, and 'Curve.AFTER' for after.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this curve (*DEFINE_CURVE_xxxx). Note that a carriage return is not added. See also Curve.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Curve.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the curve. Note that a carriage return is not added. See also Curve.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Curve.Last = function() {
    /// <signature>
    /// <summary>Returns the last curve in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last curve in</param>
    /// <returns type="Curve"/>
    /// </signature>
}

Curve.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free curve label in the model. Also see Curve.FirstFreeLabel(), Curve.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free curve label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Curve.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next curve in the model.</summary>
    /// <returns type="Curve"/>
    /// </signature>
}

Curve.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) curve label in the model. Also see Curve.FirstFreeLabel(), Curve.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free curve label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Curve.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous curve in the model.</summary>
    /// <returns type="Curve"/>
    /// </signature>
}

Curve.prototype.RemovePoint = function() {
    /// <signature>
    /// <summary>Removes a row of data from a curve</summary>
    /// <param name="row" type="Number" optional="false">The row point you want to remove. Note that curve points start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.RemoveTableEntry = function() {
    /// <signature>
    /// <summary>Removes the value and loadcurve values for a specified row of data on a load curve.</summary>
    /// <param name="ipt" type="Number" optional="false">The row you want to remove the data for. Note that the row data starts at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the curves in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all curves will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged curves in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged curves will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the curves that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select curves using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting curves</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only curves from that model can be selected. If the argument is a Flag then only curves that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any curves can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Curve.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the curve.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the curve</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.SetPoint = function() {
    /// <signature>
    /// <summary>Sets the x and y values for a specified row of data on a load curve.</summary>
    /// <param name="ipt" type="Number" optional="false">The row you want to set the data for. Note that the row data starts at 0, not 1.</param>
    /// <param name="xvalue" type="Number" optional="false">The x value of the point.</param>
    /// <param name="yvalue" type="Number" optional="false">The y value of the point.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.SetTableEntry = function() {
    /// <signature>
    /// <summary>Sets the value and loadcurve values for a specified row of data on a load curve.</summary>
    /// <param name="ipt" type="Number" optional="false">The row you want to set the data for. Note that the row data starts at 0, not 1.</param>
    /// <param name="value" type="Number" optional="false">The value for for this entry in the table.</param>
    /// <param name="load curve" type="Number" optional="false">The load curve corresponding to the defined value.</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of curves in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing curves should be counted. If false or omitted referenced but undefined curves will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Curve.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the curves in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all curves will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the curves</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Curve"/>
    /// </signature>
}

Curve.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for curve. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Curve.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this curve.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Curve.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the curve data in keyword format. Note that this contains the keyword header and the keyword cards. See also Curve.Keyword() and Curve.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Damping = function() {
    /// <field name='exists' static='false' type='Boolean'>true if damping card exists</field>
    /// <field name='global' static='false' type='Object'>*DAMPING_GLOBAL card</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the damping card is in.</field>
    /// <field name='lcid' static='false' type='Number'>Curve ID specifying system damping constant</field>
    /// <field name='srx' static='false' type='Number'>Scale factor on global x rotational damping moments</field>
    /// <field name='sry' static='false' type='Number'>Scale factor on global y rotational damping moments</field>
    /// <field name='srz' static='false' type='Number'>Scale factor on global z rotational damping moments</field>
    /// <field name='stx' static='false' type='Number'>Scale factor on global x translational damping forces</field>
    /// <field name='sty' static='false' type='Number'>Scale factor on global y translational damping forces</field>
    /// <field name='stz' static='false' type='Number'>Scale factor on global z translational damping forces</field>
    /// <field name='valdmp' static='false' type='Number'>System damping constant</field>
}

var Database = function() {
    /// <field name='abstat' static='false' type='Object'>*DATABASE_ABSTAT card</field>
    /// <field name='atdout' static='false' type='Object'>*DATABASE_ATDOUT card</field>
    /// <field name='beam' static='false' type='Number'>Beam option</field>
    /// <field name='beam_1' static='false' type='Number'>Beam option</field>
    /// <field name='beamip' static='false' type='Number'>#beam int points to output</field>
    /// <field name='bearing' static='false' type='Object'>*DATABASE_BEARING card</field>
    /// <field name='binary' static='false' type='Object'>*DATABASE_BINARY cards</field>
    /// <field name='binary_1' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_10' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_11' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_12' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_13' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_14' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_15' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_16' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_17' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_18' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_19' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_2' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_20' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_21' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_22' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_23' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_24' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_25' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_26' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_27' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_28' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_29' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_3' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_30' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_31' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_32' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_33' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_4' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_5' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_6' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_7' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_8' static='false' type='Number'>Flag for binary file</field>
    /// <field name='binary_9' static='false' type='Number'>Flag for binary file</field>
    /// <field name='blstfor' static='false' type='Object'>*DATABASE_BINARY_BLSTFOR card</field>
    /// <field name='bndout' static='false' type='Object'>*DATABASE_BNDOUT card</field>
    /// <field name='bsetid' static='false' type='Number'>Output for beam elements. +n is output for elements in beam set n, 0 no beam, -1 all elements</field>
    /// <field name='cmpflg' static='false' type='Number'>Flag to output composite material stress in local csys</field>
    /// <field name='cpmfor' static='false' type='Object'>*DATABASE_BINARY_CPMFOR card</field>
    /// <field name='cubsld' static='false' type='Number'>Output flag for quadratic solid types</field>
    /// <field name='cutoff' static='false' type='Number'>Frequency cut-off C in Hz</field>
    /// <field name='cycl' static='false' type='Number'>Output interval in cycles</field>
    /// <field name='cycl_1' static='false' type='Number'>Output interval in cycles</field>
    /// <field name='cycl_2' static='false' type='Number'>Output interval in cycles</field>
    /// <field name='d3crack' static='false' type='Object'>*DATABASE_BINARY_D3CRACK card</field>
    /// <field name='d3drlf' static='false' type='Object'>*DATABASE_BINARY_D3DRLF card</field>
    /// <field name='d3dump' static='false' type='Object'>*DATABASE_BINARY_D3DUMP card</field>
    /// <field name='d3mean' static='false' type='Object'>*DATABASE_BINARY_D3MEAN card</field>
    /// <field name='d3part' static='false' type='Object'>*DATABASE_BINARY_D3PART card</field>
    /// <field name='d3plot' static='false' type='Object'>*DATABASE_BINARY_D3PLOT card</field>
    /// <field name='d3prop' static='false' type='Object'>*DATABASE_BINARY_D3PROP card</field>
    /// <field name='d3thdt' static='false' type='Object'>*DATABASE_BINARY_D3THDT card</field>
    /// <field name='dcfail' static='false' type='Object'>*DATABASE_DCFAIL card</field>
    /// <field name='dcomp' static='false' type='Number'>Data compression flag</field>
    /// <field name='defgeo' static='false' type='Object'>*DATABASE_DEFGEO card</field>
    /// <field name='deforc' static='false' type='Object'>*DATABASE_DEFORC card</field>
    /// <field name='demfor' static='false' type='Object'>*DATABASE_BINARY_DEMFOR card</field>
    /// <field name='destat' static='false' type='Object'>*DATABASE_DESTAT card</field>
    /// <field name='dt' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_1' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_10' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_11' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_12' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_13' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_14' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_15' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_16' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_17' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_18' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_19' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_2' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_20' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_21' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_22' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_23' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_24' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_25' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_26' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_27' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_28' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_29' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_3' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_30' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_31' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_32' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_33' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_34' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_35' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_36' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_37' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_38' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_39' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_4' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_40' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_41' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_42' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_43' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_44' static='false' type='Number'>Time interval between outputs</field>
    /// <field name='dt_5' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_6' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_7' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_8' static='false' type='Number'>Time interval between output</field>
    /// <field name='dt_9' static='false' type='Number'>Time interval between output</field>
    /// <field name='dtdt' static='false' type='Number'>output of nodal temp</field>
    /// <field name='elout' static='false' type='Object'>*DATABASE_ELOUT card</field>
    /// <field name='engflg' static='false' type='Number'>Flag to in/exclude shell energy &amp; thickness</field>
    /// <field name='engflg_1' static='false' type='Number'>Flag to in/exclude shell energy &amp; thickness</field>
    /// <field name='envelope' static='false' type='Object'>*DATABASE_ENVELOPE card</field>
    /// <field name='epsflg' static='false' type='Number'>Flag to in/exclude shell strains</field>
    /// <field name='epsflg_1' static='false' type='Number'>Flag to in/exclude shell strains</field>
    /// <field name='exists' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_1' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_10' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_11' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_12' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_13' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_14' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_15' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_16' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_17' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_18' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_19' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_2' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_20' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_21' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_22' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_23' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_24' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_25' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_26' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_27' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_28' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_29' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_3' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_30' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_31' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_32' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_33' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_34' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_35' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_36' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_37' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_38' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_39' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_4' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_40' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_41' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_42' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_43' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_44' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_45' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_46' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_47' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_48' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_49' static='false' type='Boolean'>true if database binary card exists</field>
    /// <field name='exists_5' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_50' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_51' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_52' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_53' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_54' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_6' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_7' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_8' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='exists_9' static='false' type='Boolean'>true if database card exists</field>
    /// <field name='extent_binary' static='false' type='Object'>*DATABASE_EXTENT_BINARY card</field>
    /// <field name='extent_binary_comp' static='false' type='Object'>*DATABASE_EXTENT_BINARY_COMP card</field>
    /// <field name='extent_d3part' static='false' type='Object'>*DATABASE_EXTENT_D3PART card</field>
    /// <field name='extent_intfor' static='false' type='Object'>*DATABASE_EXTENT_INTFOR card</field>
    /// <field name='fname' static='false' type='String'>Filename of the database for the INTFOR data</field>
    /// <field name='format' static='false' type='Object'>*DATABASE_FORMAT card</field>
    /// <field name='fsifor' static='false' type='Object'>*DATABASE_BINARY_FSIFOR card</field>
    /// <field name='fsilnk' static='false' type='Object'>*DATABASE_BINARY_FSILNK card</field>
    /// <field name='gceout' static='false' type='Object'>*DATABASE_GCEOUT card</field>
    /// <field name='glstat' static='false' type='Object'>*DATABASE_GLSTAT card</field>
    /// <field name='h3out' static='false' type='Object'>*DATABASE_H3OUT card</field>
    /// <field name='hydro' static='false' type='Number'>adds extra history variables</field>
    /// <field name='iacc' static='false' type='String'>output of accleration data</field>
    /// <field name='ialemat' static='false' type='Number'>output ale materials</field>
    /// <field name='iavg' static='false' type='Number'>Averaging time interval</field>
    /// <field name='ibinary' static='false' type='Number'>Word size for binary output files</field>
    /// <field name='ieverf' static='false' type='Number'>Every INTFOR database to separate file flag</field>
    /// <field name='ieverp' static='false' type='Number'>Every D3PLOT file to separate database flag</field>
    /// <field name='ieverp_1' static='false' type='Number'>Every D3PLOT file to separate database flag</field>
    /// <field name='ifile' static='false' type='Number'>Output data flag</field>
    /// <field name='iform' static='false' type='Number'>Output format for D3PLOT and D3THDT files</field>
    /// <field name='iglb' static='false' type='String'>output of global data</field>
    /// <field name='imatl' static='false' type='Number'>Output *EOS, *HOURGLASS, *MAT, *part and *SECTION data</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_1' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_10' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_11' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_12' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_13' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_14' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_15' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_16' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_17' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_18' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_19' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_2' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_20' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_21' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_22' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_23' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_24' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_25' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_26' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_27' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_28' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_29' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_3' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_30' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_31' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_32' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_33' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_34' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_35' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_36' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_37' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_38' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_39' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_4' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_40' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_41' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_42' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_43' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_44' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_45' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_46' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_47' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_48' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_49' static='false' type='Number'>The Include file number that the database binary card is in.</field>
    /// <field name='include_5' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_50' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_51' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_52' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_53' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_54' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_6' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_7' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_8' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='include_9' static='false' type='Number'>The Include file number that the database card is in.</field>
    /// <field name='intfor' static='false' type='Object'>*DATABASE_BINARY_INTFOR card</field>
    /// <field name='intout' static='false' type='String'>output of intg pt data</field>
    /// <field name='ioopt' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_1' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_10' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_11' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_12' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_13' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_14' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_15' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_16' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_17' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_18' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_19' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_2' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_20' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_21' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_22' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_23' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_24' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_25' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_26' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_27' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_28' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_29' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_3' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_30' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_31' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_32' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_33' static='false' type='Number'>Flag for lcdt behaviour</field>
    /// <field name='ioopt_4' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_5' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_6' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_7' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_8' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ioopt_9' static='false' type='Number'>Flag for behaviour of load curve</field>
    /// <field name='ised' static='false' type='String'>output of strain energy density data</field>
    /// <field name='istats' static='false' type='Number'>Level of statistics</field>
    /// <field name='istra' static='false' type='String'>output of strain data</field>
    /// <field name='istrs' static='false' type='String'>output of stress data</field>
    /// <field name='ivel' static='false' type='String'>output of velocity data</field>
    /// <field name='iwall' static='false' type='Number'>Output *RIGIDWALL data</field>
    /// <field name='ixyz' static='false' type='String'>output of geometry data</field>
    /// <field name='jntforc' static='false' type='Object'>*DATABASE_JNTFORC card</field>
    /// <field name='lcdt' static='false' type='Number'>Curve ID giving time interval between dumps</field>
    /// <field name='lcdt_1' static='false' type='Number'>Curve ID giving time interval between dumps</field>
    /// <field name='lcdt_2' static='false' type='Number'>Curve ID giving time interval between dumps</field>
    /// <field name='lcdt_3' static='false' type='Number'>Curve ID giving time interval between dumps</field>
    /// <field name='lcur' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_1' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_10' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_11' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_12' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_13' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_14' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_15' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_16' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_17' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_18' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_19' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_2' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_20' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_21' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_22' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_23' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_24' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_25' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_26' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_27' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_28' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_29' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_3' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_30' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_31' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_32' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_4' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_5' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_6' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_7' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_8' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='lcur_9' static='false' type='Number'>Curve ID specifying time interval</field>
    /// <field name='mass_properties' static='false' type='Number'>Flag to include mass and inertia properties</field>
    /// <field name='matsum' static='false' type='Object'>*DATABASE_MATSUM card</field>
    /// <field name='maxint' static='false' type='Number'>#integration points for shell output</field>
    /// <field name='maxint_1' static='false' type='Number'>#integration points for shell output</field>
    /// <field name='msscl' static='false' type='Number'>output nodal mass scaling data</field>
    /// <field name='n3thdt' static='false' type='Number'>Output for material energies to D3THDT file</field>
    /// <field name='ncforc' static='false' type='Object'>*DATABASE_NCFORC card</field>
    /// <field name='neipb' static='false' type='Number'>Output of loop-stresses to d3plot</field>
    /// <field name='neiph' static='false' type='Number'>#extra values for solids</field>
    /// <field name='neiph_1' static='false' type='Number'>#extra values for solids</field>
    /// <field name='neips' static='false' type='Number'>#extra values for shells</field>
    /// <field name='neips_1' static='false' type='Number'>#extra values for shells</field>
    /// <field name='nfail' static='false' type='Number'>Display deleted contact segments flag</field>
    /// <field name='nforc' static='false' type='Number'>Output forces</field>
    /// <field name='ngapc' static='false' type='Number'>Output contact gaps</field>
    /// <field name='nglbv' static='false' type='Number'>Output global variables</field>
    /// <field name='nhuf' static='false' type='Number'>Number of user friction history variables to output from user defined friction routines</field>
    /// <field name='nintsld' static='false' type='Number'>number of solid integration pts</field>
    /// <field name='nintsld_1' static='false' type='Number'>number of solid integration pts</field>
    /// <field name='nodfor' static='false' type='Object'>*DATABASE_NODFOR card</field>
    /// <field name='nodout' static='false' type='Object'>*DATABASE_NODOUT card</field>
    /// <field name='nodout_1' static='false' type='String'>output of connectivity nodes</field>
    /// <field name='npltc' static='false' type='Number'>Number of plot files</field>
    /// <field name='npltc_1' static='false' type='Number'>Number of plot files</field>
    /// <field name='npresu' static='false' type='Number'>Output pressures</field>
    /// <field name='nr' static='false' type='Number'>Number of running restart files</field>
    /// <field name='nshear' static='false' type='Number'>Output shear stresses</field>
    /// <field name='ntied' static='false' type='Number'>Output tied segments for Mortar contact</field>
    /// <field name='nvelo' static='false' type='Number'>Output nodal velocity</field>
    /// <field name='nwear' static='false' type='Number'>Output contact wear data mode</field>
    /// <field name='nwrk' static='false' type='Number'>Output (total) sliding interface energy density for mortar contact</field>
    /// <field name='nwusr' static='false' type='Number'>Number of user wear history variables</field>
    /// <field name='option1' static='false' type='Number'>extra history variables for solids</field>
    /// <field name='option1_1' static='false' type='Number'>High frequency output interval</field>
    /// <field name='option2' static='false' type='Number'>extra history variables for shells</field>
    /// <field name='option2_1' static='false' type='Number'>Flag for binary file for high frequency output</field>
    /// <field name='option3' static='false' type='Number'>extra history variables for thick shells</field>
    /// <field name='option4' static='false' type='Number'>extra history variables for beams</field>
    /// <field name='output' static='false' type='Number'>Output format. Can be 0 or 1</field>
    /// <field name='pbstat' static='false' type='Object'>*DATABASE_PBSTAT card</field>
    /// <field name='pkp_sen' static='false' type='Number'>Flag to output peak pressure and surface energy for each contact interface</field>
    /// <field name='pllyout' static='false' type='Object'>*DATABASE_PLLYOUT card</field>
    /// <field name='prtube' static='false' type='Object'>*DATABASE_PRTUBE card</field>
    /// <field name='pset' static='false' type='Number'>Part set ID for filtering</field>
    /// <field name='psetid' static='false' type='Number'>Part Set ID</field>
    /// <field name='psetid_1' static='false' type='Number'>Part Set ID</field>
    /// <field name='quadsld' static='false' type='Number'>Output flag for cubic solid types</field>
    /// <field name='rate' static='false' type='Number'>Time interval T between filter sampling</field>
    /// <field name='rbdout' static='false' type='Object'>*DATABASE_RBDOUT card</field>
    /// <field name='rcforc' static='false' type='Object'>*DATABASE_RCFORC card</field>
    /// <field name='resplt' static='false' type='Number'>Output of residual forces</field>
    /// <field name='rltflg' static='false' type='Number'>Flag to in/exclude shell force/moment resultants</field>
    /// <field name='rltflg_1' static='false' type='Number'>Flag to in/exclude shell force/moment resultants</field>
    /// <field name='runrsf' static='false' type='Object'>*DATABASE_BINARY_RUNRSF card</field>
    /// <field name='rwforc' static='false' type='Object'>*DATABASE_RWFORC card</field>
    /// <field name='sbtout' static='false' type='Object'>*DATABASE_SBTOUT card</field>
    /// <field name='sclp' static='false' type='Number'>Scaling parameter used in the computation of the peak pressure</field>
    /// <field name='secforc' static='false' type='Object'>*DATABASE_SECFORC card</field>
    /// <field name='shge' static='false' type='Number'>Shell hourglass energy output flag</field>
    /// <field name='shge_1' static='false' type='Number'>Shell hourglass energy output flag</field>
    /// <field name='sigflg' static='false' type='Number'>Flag to in/exclude shell stress tensors</field>
    /// <field name='sigflg_1' static='false' type='Number'>Flag to in/exclude shell stress tensors</field>
    /// <field name='sleout' static='false' type='Object'>*DATABASE_SLEOUT card</field>
    /// <field name='spcforc' static='false' type='Object'>*DATABASE_SPCFORC card</field>
    /// <field name='sphout' static='false' type='Object'>*DATABASE_SPHOUT card</field>
    /// <field name='ssetid' static='false' type='Number'>Output for shell elements. +n is output for elements in shell set n, 0 no shell, -1 all elements</field>
    /// <field name='strflg' static='false' type='Number'>Strain tensor output flag</field>
    /// <field name='strflg_1' static='false' type='Number'>Strain tensor output flag</field>
    /// <field name='stssz' static='false' type='Number'>Output shell element dt flag</field>
    /// <field name='stssz_1' static='false' type='Number'>Output shell element dt flag</field>
    /// <field name='swforc' static='false' type='Object'>*DATABASE_SWFORC card</field>
    /// <field name='tback' static='false' type='Number'>Time interval for backup output files during the analysis</field>
    /// <field name='tcheck' static='false' type='Number'>Time interval for checking whether the previous maxima/minima are exceeded</field>
    /// <field name='therm' static='false' type='Number'>Output of thermal data to d3plot</field>
    /// <field name='tprint' static='false' type='Object'>*DATABASE_TPRINT card</field>
    /// <field name='trhist' static='false' type='Object'>*DATABASE_TRHIST card</field>
    /// <field name='tstart' static='false' type='Number'>Start time</field>
    /// <field name='type' static='false' type='Number'>Flag for filtering options</field>
    /// <field name='window' static='false' type='Number'>Width of the window in units of time for storing single, forward filtering</field>
    /// <field name='xtfile' static='false' type='Object'>*DATABASE_BINARY_XTFILE card</field>
}

var DeformableToRigid = function() {
    /// <signature>
    /// <summary>Create a new DeformableToRigid object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that deformable to rigid will be created in</param>
    /// <param name="Type" type="Number" optional="false">Specify the type of DeformableToRigid (Can be DeformableToRigid.SIMPLE or DeformableToRigid.AUTOMATIC or DeformableToRigid.INERTIA )</param>
    /// <param name="pid" type="Number" optional="true">Part  or Part set  ID which is switched to a rigid material. Depends on value of ptype. Used only for DeformableToRigid.SIMPLE or DeformableToRigid.INERTIA.</param>
    /// <param name="mrb" type="Number" optional="true">Part ID of the master rigid body to which the part is merged. Used only for DeformableToRigid.SIMPLE.</param>
    /// <param name="ptype" type="Number" optional="true">Type of PID. Valid values are: DeformableToRigid.PART or DeformableToRigid.PSET. Used only for DeformableToRigid.SIMPLE.</param>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
    /// <field name='code' static='false' type='Number'>Activation switch code. (Valid values: 0-5). Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='d2r' static='false' type='Number'>Number of deformable parts to be switched to rigid plus number of rigid parts for which new master/slave rigid body combinations will be defined. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='dtmax' static='false' type='Number'>Maximum permitted time step size after switch. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='entno' static='false' type='Number'>Rigid wall/contact surface number for switch codes 1, 2, 3, 4. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='exists' static='false' type='Boolean'>true if deformable to rigid exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the deformable to rigid is in.</field>
    /// <field name='ixx' static='false' type='Number'>The xx component of inertia tensor. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='ixx_1' static='false' type='Number'>The xx component of inertia tensor. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='ixy' static='false' type='Number'>The xy component of inertia tensor. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='ixz' static='false' type='Number'>The xz component of inertia tensor. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='iyz' static='false' type='Number'>The yz component of inertia tensor. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='izz' static='false' type='Number'>The zz component of inertia tensor. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the deformable to rigid is in.</field>
    /// <field name='mrb' static='false' type='Number'>Part ID of the master rigid body to which the part is merged. Used only for DeformableToRigid.SIMPLE.</field>
    /// <field name='ncsf' static='false' type='Number'>Nodal constraint body flag. (Valid values : 0, 1, 2). Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='nrbf' static='false' type='Number'>Nodal rigid body flag. (Valid values : 0, 1, 2). Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='offset' static='false' type='Number'>Optional contact thickness for switch to deformable. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='paired' static='false' type='Number'>Define a pair of related switches. (Valid values : -1, 0, 1). Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='pid' static='false' type='Number'>Part or Part set  ID which is switched to a rigid material. Depends on value of ptype. Used only for DeformableToRigid.SIMPLE or DeformableToRigid.INERTIA.</field>
    /// <field name='ptype' static='false' type='Number'>Type of PID. Valid values are: DeformableToRigid.PART or DeformableToRigid.PSET. Used only for DeformableToRigid.SIMPLE.</field>
    /// <field name='r2d' static='false' type='Number'>Number of rigid parts to be switched to deformable. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='relsw' static='false' type='Number'>Related switch set. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='rwf' static='false' type='Number'>Flag to delete or activate rigid walls. (Valid values : 0, 1, 2). Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='swset' static='false' type='Number'>Set number for this automatic switch set. (read only). Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='time1' static='false' type='Number'>Switch will not take place before this time. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='time2' static='false' type='Number'>Switch will not take place after this time. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='time3' static='false' type='Number'>After this part switch has taken place, another automatic switch will not take place for the duration of the delay period. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='tm' static='false' type='Number'>Translational mass. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='type' static='false' type='Number'>Gives the type of DeformableToRigid Object. (read only)</field>
    /// <field name='xc' static='false' type='Number'>x-coordinate of center of mass. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='yc' static='false' type='Number'>y-coordinate of center of mass. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='zc' static='false' type='Number'>z-coordinate of center of mass. Used only for DeformableToRigid.INERTIA.</field>
    /// <field name='AUTOMATIC' static='true' type='Number'>*DEFORMABLE_TO_RIGID_AUTOMATIC.</field>
    /// <field name='D2R' static='true' type='Number'>Identifies that card is being written/retreived/removed as D2R card. Used in methods GetDefToRegAutoCard, SetDefToRegAutoCard and RemoveDefToRegAutoCard. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='INERTIA' static='true' type='Number'>*DEFORMABLE_TO_RIGID_INERTIA.</field>
    /// <field name='PART' static='true' type='Number'>Identifies the PID type as Part. Used for field ptype. Used only for DeformableToRigid.SIMPLE or DeformableToRigid.INERTIA.</field>
    /// <field name='PSET' static='true' type='Number'>Identifies the PID type as Part Set. Used for field ptype. Used only for DeformableToRigid.SIMPLE or DeformableToRigid.INERTIA.</field>
    /// <field name='R2D' static='true' type='Number'>Identifies that card is being written/retreived/removed as R2D card. Used in methods GetDefToRegAutoCard, SetDefToRegAutoCard and RemoveDefToRegAutoCard. Used only for DeformableToRigid.AUTOMATIC.</field>
    /// <field name='SIMPLE' static='true' type='Number'>*DEFORMABLE_TO_RIGID.</field>
}

DeformableToRigid.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the deformable to rigid</summary>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the deformable to rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all deformable to rigids will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged deformable to rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged deformable to rigids will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the deformable to rigids that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the deformable to rigid is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

DeformableToRigid.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the deformable to rigid.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the deformable to rigid</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the deformable to rigid.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an DeformableToRigid definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the DeformableToRigid will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for deformable to rigid. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.First = function() {
    /// <signature>
    /// <summary>Returns the first deformable to rigid in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first deformable to rigid in</param>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free deformable to rigid label in the model. Also see DeformableToRigid.LastFreeLabel(), DeformableToRigid.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free deformable to rigid label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

DeformableToRigid.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the deformable to rigids in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all deformable to rigids will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the deformable to rigids</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the deformable to rigid is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the deformable to rigid</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

DeformableToRigid.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each deformable to rigid in the model. Note that ForEach has been designed to make looping over deformable to rigids as fast as possible and so has some limitations. Firstly, a single temporary DeformableToRigid object is created and on each function call it is updated with the current deformable to rigid data. This means that you should not try to store the DeformableToRigid object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new deformable to rigids inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all deformable to rigids are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each deformable to rigid</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of DeformableToRigid objects for all of the deformable to rigids in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get deformable to rigids from</param>
    /// <returns type="Array" elementType="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.prototype.GetDefToRegAutoCard = function() {
    /// <signature>
    /// <summary>Returns the D2R or R2D cards for *DEFORMABLE_TO_RIGID_AUTOMATC.</summary>
    /// <param name="ctype" type="Number" optional="false">The card type you want the data for. Can be D2R or R2D.</param>
    /// <param name="index" type="Number" optional="false">The card index you want the data for. Note that card indices start at 0, not 1.</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

DeformableToRigid.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of DeformableToRigid objects for all of the flagged deformable to rigids in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get deformable to rigids from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the deformable to rigids that you want to retrieve</param>
    /// <returns type="Array" elementType="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the DeformableToRigid object for a deformable to rigid ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the deformable to rigid in</param>
    /// <param name="number" type="Number" optional="false">number of the deformable to rigid you want the DeformableToRigid object for</param>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a DeformableToRigid property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the DeformableToRigid.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">deformable to rigid property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

DeformableToRigid.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this DeformableToRigid (*DEFORMABLE_TO_RIGID_xxxx) Note that a carriage return is not added. See also DeformableToRigid.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

DeformableToRigid.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the DeformableToRigid. Note that a carriage return is not added. See also DeformableToRigid.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

DeformableToRigid.Last = function() {
    /// <signature>
    /// <summary>Returns the last deformable to rigid in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last deformable to rigid in</param>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free deformable to rigid label in the model. Also see DeformableToRigid.FirstFreeLabel(), DeformableToRigid.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free deformable to rigid label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

DeformableToRigid.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next deformable to rigid in the model.</summary>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) deformable to rigid label in the model. Also see DeformableToRigid.FirstFreeLabel(), DeformableToRigid.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free deformable to rigid label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

DeformableToRigid.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a deformable to rigid.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only deformable to rigids from that model can be picked. If the argument is a Flag then only deformable to rigids that are flagged with limit can be selected. If omitted, or null, any deformable to rigids from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous deformable to rigid in the model.</summary>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.prototype.RemoveDefToRegAutoCard = function() {
    /// <signature>
    /// <summary>Removes the D2R or R2D cards for *DEFORMABLE_TO_RIGID_AUTOMATC.</summary>
    /// <param name="ctype" type="Number" optional="false">The card type you want removed. Can be D2R or R2D.</param>
    /// <param name="index" type="Number" optional="false">The card index you want removed. Note that card indices start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the deformable to rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all deformable to rigids will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged deformable to rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged deformable to rigids will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the deformable to rigids that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select deformable to rigids using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting deformable to rigids</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only deformable to rigids from that model can be selected. If the argument is a Flag then only deformable to rigids that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any deformable to rigids can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

DeformableToRigid.prototype.SetDefToRegAutoCard = function() {
    /// <signature>
    /// <summary>Sets the D2r or R2D card data f*DEFORMABLE_TO_RIGID_AUTOMATIC.</summary>
    /// <param name="ctype" type="Number" optional="false">The card type you want to set. Can be D2R or R2D.</param>
    /// <param name="index" type="Number" optional="false">The D2R or R2D card index you want to set. Note that cards start at 0, not 1.</param>
    /// <param name="ptype" type="Number" optional="false">Part type (PTYPE). Can be DeformableToRigid.PART or DeformableToRigid.PSET.</param>
    /// <param name="pid" type="Number" optional="false">Part or Part Set ID.</param>
    /// <param name="mrb" type="Number" optional="true">MRB Part ID (only for card type D2R)</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the deformable to rigid.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the deformable to rigid</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the deformable to rigid. The deformable to rigid will be sketched until you either call DeformableToRigid.Unsketch(), DeformableToRigid.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the deformable to rigid is sketched. If omitted redraw is true. If you want to sketch several deformable to rigids and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged deformable to rigids in the model. The deformable to rigids will be sketched until you either call DeformableToRigid.Unsketch(), DeformableToRigid.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged deformable to rigids will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the deformable to rigids that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the deformable to rigids are sketched. If omitted redraw is true. If you want to sketch flagged deformable to rigids several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of deformable to rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing deformable to rigids should be counted. If false or omitted referenced but undefined deformable to rigids will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

DeformableToRigid.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the deformable to rigid</summary>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the deformable to rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all deformable to rigids will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged deformable to rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged deformable to rigids will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the deformable to rigids that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the deformable to rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all deformable to rigids will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the deformable to rigids</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the deformable to rigid.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the deformable to rigid is unsketched. If omitted redraw is true. If you want to unsketch several deformable to rigids and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all deformable to rigids.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all deformable to rigids will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the deformable to rigids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged deformable to rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all deformable to rigids will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the deformable to rigids that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the deformable to rigids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="DeformableToRigid"/>
    /// </signature>
}

DeformableToRigid.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for deformable to rigid. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

DeformableToRigid.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this deformable to rigid.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

DeformableToRigid.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the DeformableToRigid data in keyword format. Note that this contains the keyword header and the keyword cards. See also DeformableToRigid.Keyword() and DeformableToRigid.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Discrete = function() {
    /// <signature>
    /// <summary>Create a new Discrete object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that discrete will be created in</param>
    /// <param name="eid" type="Number" optional="false">Discrete number</param>
    /// <param name="pid" type="Number" optional="false">Part number</param>
    /// <param name="n1" type="Number" optional="false">Node number 1</param>
    /// <param name="n2" type="Number" optional="false">Node number 2</param>
    /// <param name="vid" type="Number" optional="true">Orientation vector</param>
    /// <param name="s" type="Number" optional="true">Scale factor on forces</param>
    /// <param name="pf" type="Number" optional="true">Print flag. Set to write forces to the DEFORC file</param>
    /// <param name="offset" type="Number" optional="true">Initial offset</param>
    /// <returns type="Discrete"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the discrete</field>
    /// <field name='eid' static='false' type='Number'>Discrete number. Also see the label property which is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if discrete exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the discrete is in.</field>
    /// <field name='label' static='false' type='Number'>Discrete number. Also see the eid property which is an alternative name for this.</field>
    /// <field name='lcid' static='false' type='Number'>Loadcurve for offset vs time</field>
    /// <field name='lciddr' static='false' type='Number'>Loadcurve for offset vs time during dynamic relaxation</field>
    /// <field name='lco' static='false' type='Boolean'>If LCO option is set. Can be true or false</field>
    /// <field name='model' static='false' type='Number'>The Model number that the discrete is in.</field>
    /// <field name='n1' static='false' type='Number'>Node number 1</field>
    /// <field name='n2' static='false' type='Number'>Node number 2</field>
    /// <field name='offset' static='false' type='Number'>Initial offset</field>
    /// <field name='pf' static='false' type='Number'>Print flag. Set to write forces to the DEFORC file</field>
    /// <field name='pid' static='false' type='Number'>Part number</field>
    /// <field name='s' static='false' type='Number'>Scale factor on forces</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the discrete (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='vid' static='false' type='Number'>Orientation vector</field>
}

Discrete.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the discrete</summary>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the discretes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discretes will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged discretes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged discretes will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discretes that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the discrete is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Discrete.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the discrete.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the discrete</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the discrete.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Discrete"/>
    /// </signature>
}

Discrete.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a discrete.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the discrete will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Discrete"/>
    /// </signature>
}

Discrete.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for discrete. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for discrete. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the discrete colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the discrete.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Discrete.First = function() {
    /// <signature>
    /// <summary>Returns the first discrete in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first discrete in</param>
    /// <returns type="Discrete"/>
    /// </signature>
}

Discrete.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free discrete label in the model. Also see Discrete.LastFreeLabel(), Discrete.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free discrete label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Discrete.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the discretes in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discretes will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the discretes</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the discrete is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the discrete</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Discrete.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each discrete in the model. Note that ForEach has been designed to make looping over discretes as fast as possible and so has some limitations. Firstly, a single temporary Discrete object is created and on each function call it is updated with the current discrete data. This means that you should not try to store the Discrete object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new discretes inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all discretes are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each discrete</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Discrete objects for all of the discretes in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get discretes from</param>
    /// <returns type="Array" elementType="Discrete"/>
    /// </signature>
}

Discrete.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Discrete objects for all of the flagged discretes in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get discretes from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discretes that you want to retrieve</param>
    /// <returns type="Array" elementType="Discrete"/>
    /// </signature>
}

Discrete.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Discrete object for a discrete ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the discrete in</param>
    /// <param name="number" type="Number" optional="false">number of the discrete you want the Discrete object for</param>
    /// <returns type="Discrete"/>
    /// </signature>
}

Discrete.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Discrete property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Discrete.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">discrete property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Discrete.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this discrete (*ELEMENT_DISCRETE). Note that a carriage return is not added. See also Discrete.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Discrete.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the discrete. Note that a carriage return is not added. See also Discrete.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Discrete.Last = function() {
    /// <signature>
    /// <summary>Returns the last discrete in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last discrete in</param>
    /// <returns type="Discrete"/>
    /// </signature>
}

Discrete.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free discrete label in the model. Also see Discrete.FirstFreeLabel(), Discrete.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free discrete label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Discrete.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next discrete in the model.</summary>
    /// <returns type="Discrete"/>
    /// </signature>
}

Discrete.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) discrete label in the model. Also see Discrete.FirstFreeLabel(), Discrete.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free discrete label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Discrete.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a discrete.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only discretes from that model can be picked. If the argument is a Flag then only discretes that are flagged with limit can be selected. If omitted, or null, any discretes from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Discrete"/>
    /// </signature>
}

Discrete.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous discrete in the model.</summary>
    /// <returns type="Discrete"/>
    /// </signature>
}

Discrete.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the discretes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discretes will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged discretes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged discretes will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discretes that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select discretes using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting discretes</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only discretes from that model can be selected. If the argument is a Flag then only discretes that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any discretes can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Discrete.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the discrete.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the discrete</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the discrete. The discrete will be sketched until you either call Discrete.Unsketch(), Discrete.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discrete is sketched. If omitted redraw is true. If you want to sketch several discretes and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged discretes in the model. The discretes will be sketched until you either call Discrete.Unsketch(), Discrete.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged discretes will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discretes that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discretes are sketched. If omitted redraw is true. If you want to sketch flagged discretes several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.Timestep = function() {
    /// <signature>
    /// <summary>Calculates the timestep for the discrete</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Discrete.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of discretes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing discretes should be counted. If false or omitted referenced but undefined discretes will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Discrete.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the discrete</summary>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the discretes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discretes will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged discretes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged discretes will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discretes that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the discretes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all discretes will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the discretes</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the discrete.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discrete is unsketched. If omitted redraw is true. If you want to unsketch several discretes and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all discretes.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discretes will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discretes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged discretes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discretes will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discretes that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discretes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Discrete"/>
    /// </signature>
}

Discrete.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for discrete. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Discrete.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this discrete.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Discrete.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the discrete data in keyword format. Note that this contains the keyword header and the keyword cards. See also Discrete.Keyword() and Discrete.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var DiscreteSphere = function() {
    /// <signature>
    /// <summary>Create a new DiscreteSphere object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that discrete sphere will be created in</param>
    /// <param name="nid" type="Number" optional="false">Node ID and Element ID are the same for discrete spheres.</param>
    /// <param name="pid" type="Number" optional="false">Part ID to which this element belongs.</param>
    /// <param name="mass" type="Number" optional="false">Mass or volume value.</param>
    /// <param name="inertia" type="Number" optional="false">Mass moment of inertia.</param>
    /// <param name="radius" type="Number" optional="false">Particle radius.</param>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the discrete sphere</field>
    /// <field name='exists' static='false' type='Boolean'>true if discrete sphere exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the discrete sphere is in.</field>
    /// <field name='inertia' static='false' type='Number'>Mass moment of inertia.</field>
    /// <field name='mass' static='false' type='Number'>Mass or volume value (depending on whether the _VOLUME option is set).</field>
    /// <field name='model' static='false' type='Number'>The Model number that the discrete sphere is in.</field>
    /// <field name='nid' static='false' type='Number'>Node ID.</field>
    /// <field name='pid' static='false' type='Number'>Part ID to which this element belongs.</field>
    /// <field name='radius' static='false' type='Number'>Particle radius.</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the discrete sphere (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='volume' static='false' type='Boolean'>Turns _VOLUME on or OFF. Note that this does NOT refer to the data field VOLUME. For the latter see the mass property.</field>
}

DiscreteSphere.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the discrete sphere</summary>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the discrete spheres in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discrete spheres will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged discrete spheres in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged discrete spheres will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discrete spheres that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the discrete sphere is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

DiscreteSphere.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the discrete sphere.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the discrete sphere</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the discrete sphere.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a discrete sphere.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the discrete sphere will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for discrete sphere. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for discrete sphere. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the discrete sphere colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the discrete sphere.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

DiscreteSphere.First = function() {
    /// <signature>
    /// <summary>Returns the first discrete sphere in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first discrete sphere in</param>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free discrete sphere label in the model. Also see DiscreteSphere.LastFreeLabel(), DiscreteSphere.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free discrete sphere label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

DiscreteSphere.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the discrete spheres in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discrete spheres will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the discrete spheres</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the discrete sphere is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the discrete sphere</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

DiscreteSphere.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each discrete sphere in the model. Note that ForEach has been designed to make looping over discrete spheres as fast as possible and so has some limitations. Firstly, a single temporary DiscreteSphere object is created and on each function call it is updated with the current discrete sphere data. This means that you should not try to store the DiscreteSphere object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new discrete spheres inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all discrete spheres are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each discrete sphere</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of DiscreteSphere objects for all of the discrete spheres in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get discrete spheres from</param>
    /// <returns type="Array" elementType="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of DiscreteSphere objects for all of the flagged discrete spheres in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get discrete spheres from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discrete spheres that you want to retrieve</param>
    /// <returns type="Array" elementType="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the DiscreteSphere object for a discrete sphere ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the discrete sphere in</param>
    /// <param name="number" type="Number" optional="false">number of the discrete sphere you want the DiscreteSphere object for</param>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a DiscreteSphere property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the DiscreteSphere.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">discrete sphere property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

DiscreteSphere.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this discrete sphere (*ELEMENT_DISCRETE_SPHERE or *ELEMENT_DISCRETE_SPHERE_VOLUME). Note that a carriage return is not added. See also DiscreteSphere.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

DiscreteSphere.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the discrete sphere. Note that a carriage return is not added. See also DiscreteSphere.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

DiscreteSphere.Last = function() {
    /// <signature>
    /// <summary>Returns the last discrete sphere in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last discrete sphere in</param>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free discrete sphere label in the model. Also see DiscreteSphere.FirstFreeLabel(), DiscreteSphere.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free discrete sphere label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

DiscreteSphere.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next discrete sphere in the model.</summary>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) discrete sphere label in the model. Also see DiscreteSphere.FirstFreeLabel(), DiscreteSphere.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free discrete sphere label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

DiscreteSphere.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a discrete sphere.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only discrete spheres from that model can be picked. If the argument is a Flag then only discrete spheres that are flagged with limit can be selected. If omitted, or null, any discrete spheres from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous discrete sphere in the model.</summary>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select discrete spheres using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting discrete spheres</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only discrete spheres from that model can be selected. If the argument is a Flag then only discrete spheres that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any discrete spheres can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

DiscreteSphere.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the discrete sphere.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the discrete sphere</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the discrete sphere. The discrete sphere will be sketched until you either call DiscreteSphere.Unsketch(), DiscreteSphere.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discrete sphere is sketched. If omitted redraw is true. If you want to sketch several discrete spheres and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged discrete spheres in the model. The discrete spheres will be sketched until you either call DiscreteSphere.Unsketch(), DiscreteSphere.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged discrete spheres will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discrete spheres that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discrete spheres are sketched. If omitted redraw is true. If you want to sketch flagged discrete spheres several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of discrete spheres in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing discrete spheres should be counted. If false or omitted referenced but undefined discrete spheres will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

DiscreteSphere.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the discrete sphere</summary>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the discrete spheres in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discrete spheres will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged discrete spheres in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged discrete spheres will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discrete spheres that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the discrete spheres in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all discrete spheres will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the discrete spheres</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the discrete sphere.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discrete sphere is unsketched. If omitted redraw is true. If you want to unsketch several discrete spheres and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all discrete spheres.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discrete spheres will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discrete spheres are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged discrete spheres in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all discrete spheres will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the discrete spheres that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the discrete spheres are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="DiscreteSphere"/>
    /// </signature>
}

DiscreteSphere.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for discrete sphere. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

DiscreteSphere.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this discrete sphere.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

DiscreteSphere.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the discrete sphere data in keyword format. Note that this contains the keyword header and the keyword cards. See also DiscreteSphere.Keyword() and DiscreteSphere.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Dummy = function() {
    /// <field name='assemblies' static='false' type='Number'>Number of assemblies defined. (read only)</field>
    /// <field name='exists' static='false' type='Boolean'>true if dummy exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Number'>Dummy number. Also see the label property which is an alternative name for this. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the dummy is in.</field>
    /// <field name='label' static='false' type='Number'>Dummy number. Also see the id property which is an alternative name for this. (read only)</field>
    /// <field name='model' static='false' type='Number'>The Model number that the dummy is in.</field>
    /// <field name='points' static='false' type='Number'>Number of reference points defined. (read only)</field>
    /// <field name='title' static='false' type='String'>Dummy title.</field>
    /// <field name='xhpoint' static='false' type='Number'>H-Point X coordinate. (read only)</field>
    /// <field name='yhpoint' static='false' type='Number'>H-Point Y coordinate. (read only)</field>
    /// <field name='zhpoint' static='false' type='Number'>H-Point Z coordinate. (read only)</field>
}

Dummy.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the dummy</summary>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the dummys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all dummys will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged dummys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged dummys will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the dummys that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the dummy is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Dummy.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the dummy.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the dummy</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the dummy.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Dummy"/>
    /// </signature>
}

Dummy.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for dummy. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.First = function() {
    /// <signature>
    /// <summary>Returns the first dummy in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first dummy in</param>
    /// <returns type="Dummy"/>
    /// </signature>
}

Dummy.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free dummy label in the model. Also see Dummy.LastFreeLabel(), Dummy.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free dummy label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Dummy.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the dummys in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all dummys will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the dummys</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the dummy is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the dummy</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Dummy.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each dummy in the model. Note that ForEach has been designed to make looping over dummys as fast as possible and so has some limitations. Firstly, a single temporary Dummy object is created and on each function call it is updated with the current dummy data. This means that you should not try to store the Dummy object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new dummys inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all dummys are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each dummy</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Dummy objects for all of the dummys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get dummys from</param>
    /// <returns type="Array" elementType="Dummy"/>
    /// </signature>
}

Dummy.prototype.GetAssembly = function() {
    /// <signature>
    /// <summary>Returns the information for an assembly</summary>
    /// <param name="index" type="Number" optional="false">The index of the assembly you want the coordinates for. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies</param>
    /// <returns type="Object"/>
    /// </signature>
}

Dummy.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Dummy objects for all of the flagged dummys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get dummys from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the dummys that you want to retrieve</param>
    /// <returns type="Array" elementType="Dummy"/>
    /// </signature>
}

Dummy.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Dummy object for a dummy ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the dummy in</param>
    /// <param name="number" type="Number" optional="false">number of the dummy you want the Dummy object for</param>
    /// <returns type="Dummy"/>
    /// </signature>
}

Dummy.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Dummy property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Dummy.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">dummy property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Dummy.prototype.GetPoint = function() {
    /// <signature>
    /// <summary>Returns the information for a reference point</summary>
    /// <param name="index" type="Number" optional="false">The index of the reference point you want the information for. Note that reference points start at 0, not 1. 0 &lt;= index &lt; points</param>
    /// <returns type="Object"/>
    /// </signature>
}

Dummy.prototype.GetPointData = function() {
    /// <signature>
    /// <summary>Returns the coordinates of a reference point</summary>
    /// <param name="rpt" type="Number" optional="false">The reference point you want the coordinates for. Note that reference points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Dummy.prototype.GetPointTitle = function() {
    /// <signature>
    /// <summary>Returns the title of a reference point</summary>
    /// <param name="rpt" type="Number" optional="false">The reference point you want the title for. Note that reference points start at 0, not 1.</param>
    /// <returns type="String"/>
    /// </signature>
}

Dummy.Last = function() {
    /// <signature>
    /// <summary>Returns the last dummy in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last dummy in</param>
    /// <returns type="Dummy"/>
    /// </signature>
}

Dummy.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free dummy label in the model. Also see Dummy.FirstFreeLabel(), Dummy.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free dummy label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Dummy.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next dummy in the model.</summary>
    /// <returns type="Dummy"/>
    /// </signature>
}

Dummy.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) dummy label in the model. Also see Dummy.FirstFreeLabel(), Dummy.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free dummy label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Dummy.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a dummy.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only dummys from that model can be picked. If the argument is a Flag then only dummys that are flagged with limit can be selected. If omitted, or null, any dummys from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Dummy"/>
    /// </signature>
}

Dummy.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous dummy in the model.</summary>
    /// <returns type="Dummy"/>
    /// </signature>
}

Dummy.prototype.RemovePoint = function() {
    /// <signature>
    /// <summary>Removes a reference point from a dummy</summary>
    /// <param name="index" type="Number" optional="false">The index of the reference point you want to remove. Note that reference points start at 0, not 1. 0 &lt;= index &lt; points</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the dummys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all dummys will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged dummys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged dummys will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the dummys that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select dummys using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting dummys</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only dummys from that model can be selected. If the argument is a Flag then only dummys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any dummys can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Dummy.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the dummy.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the dummy</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.prototype.SetPoint = function() {
    /// <signature>
    /// <summary>Sets the data for a reference point in a dummy</summary>
    /// <param name="index" type="Number" optional="false">The index of the reference point you want to set. Note that reference points start at 0, not 1. To add a new point use index points</param>
    /// <param name="data" type="Object" optional="false">Object containing the reference point data. The properties can be:</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the dummy. The dummy will be sketched until you either call Dummy.Unsketch(), Dummy.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the dummy is sketched. If omitted redraw is true. If you want to sketch several dummys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged dummys in the model. The dummys will be sketched until you either call Dummy.Unsketch(), Dummy.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged dummys will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the dummys that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the dummys are sketched. If omitted redraw is true. If you want to sketch flagged dummys several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of dummys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing dummys should be counted. If false or omitted referenced but undefined dummys will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Dummy.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the dummy</summary>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the dummys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all dummys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged dummys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged dummys will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the dummys that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the dummys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all dummys will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the dummys</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the dummy.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the dummy is unsketched. If omitted redraw is true. If you want to unsketch several dummys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all dummys.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all dummys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the dummys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged dummys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all dummys will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the dummys that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the dummys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Dummy"/>
    /// </signature>
}

Dummy.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for dummy. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Dummy.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this dummy.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

var ElementDeath = function() {
    /// <signature>
    /// <summary>Create a new ElementDeath object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that element death will be created in</param>
    /// <param name="type" type="String" optional="false">ElementDeath type. Can be ElementDeath.SOLID, ElementDeath.SOLID_SET, ElementDeath.BEAM, ElementDeath.BEAM_SET, ElementDeath.SHELL, ElementDeath.SHELL_SET, ElementDeath.THICK_SHELL or ElementDeath.THICK_SHELL_SET</param>
    /// <param name="eid/sid" type="Number" optional="false">Element or element set ID</param>
    /// <returns type="ElementDeath"/>
    /// </signature>
    /// <field name='boxid' static='false' type='Number'>Box restricting element deletion</field>
    /// <field name='cid' static='false' type='Number'>Coordinate ID for transforming boxid.</field>
    /// <field name='eid' static='false' type='Number'>Element ID or element set ID. The sid property is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if element death exists, false if referred to but not defined. (read only)</field>
    /// <field name='idgrp' static='false' type='Number'>Group ID for simultaneous deletion.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the element death is in.</field>
    /// <field name='inout' static='false' type='Boolean'>If true, LS_DYNA deletes elements outside box, otherwise inside box.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the element death is in.</field>
    /// <field name='option' static='false' type='Number'>ElementDeath option. Can be ElementDeath.SOLID, ElementDeath.SOLID_SET, ElementDeath.BEAM, ElementDeath.BEAM_SET, ElementDeath.SHELL, ElementDeath.SHELL_SET, ElementDeath.THICK_SHELL or ElementDeath.THICK_SHELL_SET. The type property is an alternative name for this.</field>
    /// <field name='percent' static='false' type='Number'>Deletion percentage.</field>
    /// <field name='sid' static='false' type='Number'>Element ID or element set ID. The eid property is an alternative name for this.</field>
    /// <field name='time' static='false' type='Number'>Deletion time for elimination</field>
    /// <field name='title' static='false' type='String'>ElementDeath title</field>
    /// <field name='type' static='false' type='Number'>ElementDeath option. Can be ElementDeath.SOLID, ElementDeath.SOLID_SET, ElementDeath.BEAM, ElementDeath.BEAM_SET, ElementDeath.SHELL, ElementDeath.SHELL_SET, ElementDeath.THICK_SHELL or ElementDeath.THICK_SHELL_SET The option property is an alternative name for this.</field>
    /// <field name='BEAM' static='true' type='Number'>Beam option</field>
    /// <field name='BEAM_SET' static='true' type='Number'>Beam set option</field>
    /// <field name='SHELL' static='true' type='Number'>Shell option</field>
    /// <field name='SHELL_SET' static='true' type='Number'>Shell set option</field>
    /// <field name='SOLID' static='true' type='Number'>Solid option</field>
    /// <field name='SOLID_SET' static='true' type='Number'>Solid set option</field>
    /// <field name='THICK_SHELL' static='true' type='Number'>Thick shell option</field>
    /// <field name='THICK_SHELL_SET' static='true' type='Number'>Thick shell set option</field>
}

ElementDeath.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ElementDeath.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the element death.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the element death</param>
    /// <returns type="null"/>
    /// </signature>
}

ElementDeath.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the element death.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="ElementDeath"/>
    /// </signature>
}

ElementDeath.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an element death.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the element death will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="ElementDeath"/>
    /// </signature>
}

ElementDeath.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ElementDeath.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for element death. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

ElementDeath.First = function() {
    /// <signature>
    /// <summary>Returns the first element death in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first element death in</param>
    /// <returns type="ElementDeath"/>
    /// </signature>
}

ElementDeath.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the element deaths in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all element deaths will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the element deaths</param>
    /// <returns type="null"/>
    /// </signature>
}

ElementDeath.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the element death is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the element death</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

ElementDeath.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each element death in the model. Note that ForEach has been designed to make looping over element deaths as fast as possible and so has some limitations. Firstly, a single temporary ElementDeath object is created and on each function call it is updated with the current element death data. This means that you should not try to store the ElementDeath object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new element deaths inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all element deaths are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each element death</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

ElementDeath.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of ElementDeath objects for all of the element deaths in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get element deaths from</param>
    /// <returns type="Array" elementType="ElementDeath"/>
    /// </signature>
}

ElementDeath.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of ElementDeath objects for all of the flagged element deaths in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get element deaths from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the element deaths that you want to retrieve</param>
    /// <returns type="Array" elementType="ElementDeath"/>
    /// </signature>
}

ElementDeath.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the ElementDeath object for a element death ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the element death in</param>
    /// <param name="number" type="Number" optional="false">number of the element death you want the ElementDeath object for</param>
    /// <returns type="ElementDeath"/>
    /// </signature>
}

ElementDeath.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a ElementDeath property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ElementDeath.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">element death property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

ElementDeath.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this element death (*DEFINE_ELEMENT_DEATH). Note that a carriage return is not added. See also ElementDeath.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ElementDeath.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the element death. Note that a carriage return is not added. See also ElementDeath.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ElementDeath.Last = function() {
    /// <signature>
    /// <summary>Returns the last element death in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last element death in</param>
    /// <returns type="ElementDeath"/>
    /// </signature>
}

ElementDeath.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next element death in the model.</summary>
    /// <returns type="ElementDeath"/>
    /// </signature>
}

ElementDeath.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous element death in the model.</summary>
    /// <returns type="ElementDeath"/>
    /// </signature>
}

ElementDeath.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select element deaths using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting element deaths</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only element deaths from that model can be selected. If the argument is a Flag then only element deaths that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any element deaths can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ElementDeath.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the element death.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the element death</param>
    /// <returns type="null"/>
    /// </signature>
}

ElementDeath.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of element deaths in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing element deaths should be counted. If false or omitted referenced but undefined element deaths will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ElementDeath.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the element deaths in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all element deaths will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the element deaths</param>
    /// <returns type="null"/>
    /// </signature>
}

ElementDeath.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="ElementDeath"/>
    /// </signature>
}

ElementDeath.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for element death. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

ElementDeath.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this element death.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

ElementDeath.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the element death data in keyword format. Note that this contains the keyword header and the keyword cards. See also ElementDeath.Keyword() and ElementDeath.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var ExtraNodes = function() {
    /// <signature>
    /// <summary>Create a new ExtraNodes object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained extra nodes will be created in</param>
    /// <param name="option" type="Number" optional="false">Specify the type of constrained extra nodes. Can be ExtraNodes.NODE or ExtraNodes.SET)</param>
    /// <param name="pid" type="Number" optional="false">Part ID of rigid body</param>
    /// <param name="id" type="Number" optional="false">Node node ID or node set ID</param>
    /// <param name="iflag" type="Boolean" optional="false">Flag for adding node mass inertia to PART_INERTIA</param>
    /// <returns type="ExtraNodes"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if constrained extra nodes exists, false if referred to but not defined (read only)</field>
    /// <field name='id' static='false' type='Number'>Node ID or node set ID (not internal label)</field>
    /// <field name='iflag' static='false' type='Boolean'>Flag for adding node mass inertia to PART_INERTIA</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the constrained extra nodes is in.</field>
    /// <field name='label' static='false' type='Number'>The label the constrained extra nodes has in PRIMER (read only)</field>
    /// <field name='model' static='false' type='Number'>The Model number that the constrained extra node is in.</field>
    /// <field name='option' static='false' type='Number'>The Constrained Extra Nodes option. Can be ExtraNodes.NODE or ExtraNodes.SET.</field>
    /// <field name='pid' static='false' type='Number'>Part ID of rigid body.</field>
    /// <field name='NODE' static='true' type='Number'>CNST is *CONSTRAINED_EXTRA_NODES_NODE.</field>
    /// <field name='SET' static='true' type='Number'>CNST is *CONSTRAINED_EXTRA_NODES_SET.</field>
}

ExtraNodes.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the constrained extra node</summary>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the constrained extra nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained extra nodes will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged constrained extra nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged constrained extra nodes will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained extra nodes that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the constrained extra node is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

ExtraNodes.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the constrained extra node.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the constrained extra node</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the constrained extra node.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a constrained extra nodes card.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the constrained extra nodes card will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for constrained extra node. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.First = function() {
    /// <signature>
    /// <summary>Returns the first constrained extra node in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first constrained extra node in</param>
    /// <returns type="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the constrained extra nodes in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained extra nodes will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the constrained extra nodes</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the constrained extra node is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the constrained extra node</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

ExtraNodes.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each constrained extra node in the model. Note that ForEach has been designed to make looping over constrained extra nodes as fast as possible and so has some limitations. Firstly, a single temporary ExtraNodes object is created and on each function call it is updated with the current constrained extra node data. This means that you should not try to store the ExtraNodes object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new constrained extra nodes inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained extra nodes are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each constrained extra node</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of ExtraNodes objects for all of the constrained extra nodes in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get constrained extra nodes from</param>
    /// <returns type="Array" elementType="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of ExtraNodes objects for all of the flagged constrained extra nodes in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get constrained extra nodes from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained extra nodes that you want to retrieve</param>
    /// <returns type="Array" elementType="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the ExtraNodes object for a constrained extra node ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the constrained extra node in</param>
    /// <param name="number" type="Number" optional="false">number of the constrained extra node you want the ExtraNodes object for</param>
    /// <returns type="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a ExtraNodes property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ExtraNodes.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">constrained extra node property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

ExtraNodes.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this constrained extra nodes (*CONSTRAINED_EXTRA_NODES). Note that a carriage return is not added. See also ExtraNodes.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ExtraNodes.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the constrained extra nodes. Note that a carriage return is not added. See also ExtraNodes.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ExtraNodes.Last = function() {
    /// <signature>
    /// <summary>Returns the last constrained extra node in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last constrained extra node in</param>
    /// <returns type="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next constrained extra node in the model.</summary>
    /// <returns type="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a constrained extra node.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only constrained extra nodes from that model can be picked. If the argument is a Flag then only constrained extra nodes that are flagged with limit can be selected. If omitted, or null, any constrained extra nodes from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous constrained extra node in the model.</summary>
    /// <returns type="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select constrained extra nodes using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting constrained extra nodes</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only constrained extra nodes from that model can be selected. If the argument is a Flag then only constrained extra nodes that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any constrained extra nodes can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ExtraNodes.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the constrained extra node.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the constrained extra node</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the constrained extra node. The constrained extra node will be sketched until you either call ExtraNodes.Unsketch(), ExtraNodes.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained extra node is sketched. If omitted redraw is true. If you want to sketch several constrained extra nodes and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged constrained extra nodes in the model. The constrained extra nodes will be sketched until you either call ExtraNodes.Unsketch(), ExtraNodes.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged constrained extra nodes will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained extra nodes that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained extra nodes are sketched. If omitted redraw is true. If you want to sketch flagged constrained extra nodes several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of constrained extra nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing constrained extra nodes should be counted. If false or omitted referenced but undefined constrained extra nodes will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ExtraNodes.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the constrained extra node</summary>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the constrained extra nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained extra nodes will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged constrained extra nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged constrained extra nodes will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained extra nodes that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the constrained extra nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all constrained extra nodes will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the constrained extra nodes</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the constrained extra node.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained extra node is unsketched. If omitted redraw is true. If you want to unsketch several constrained extra nodes and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all constrained extra nodes.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained extra nodes will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained extra nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged constrained extra nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained extra nodes will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained extra nodes that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained extra nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="ExtraNodes"/>
    /// </signature>
}

ExtraNodes.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for constrained extra node. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

ExtraNodes.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this constrained extra node.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

ExtraNodes.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the constrained extra nodes data in keyword format. Note that this contains the keyword header and the keyword cards. See also ExtraNodes.Keyword() and ExtraNodes.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var File = function() {
    /// <signature>
    /// <summary>Create a new File object for reading and writing text files.</summary>
    /// <param name="filename" type="String" optional="false">Filename of the file you want to read/write. If reading, the file must exist. If writing, the file will be overwritten (if it exists) if mode is File.WRITE, or if mode is File.APPEND it will be appended to if it exists, or created if it does not. When reading a file the filename can also be a URL (uniform resource locator) in which case the file will be read from the remote site. See File.Get() for more details on the format of the URL.</param>
    /// <param name="mode" type="Number" optional="false">The mode to open the file with. Can be File.READ, File.WRITE or File.APPEND. For File.WRITE or File.APPEND it can also be ORed with File.BINARY if required. By default text is read and written as ASCII. To read/write text in utf-8 mode can also be ORed with File.UTF8 if required.</param>
    /// <returns type="File"/>
    /// </signature>
    /// <field name='filename' static='false' type='String'>Name of the file</field>
    /// <field name='mode' static='false' type='Number'>Mode the file was opened with (File.READ, File.WRITE etc)</field>
    /// <field name='APPEND' static='true' type='Number'>Flag to open file for appending</field>
    /// <field name='BINARY' static='true' type='Number'>Flag to open file in binary mode. This will have no effect on unix/linux but for windows if a file is opened for writing with binary mode \n will not be translated to \r\n (CRLF), it will be written as \n (LF)</field>
    /// <field name='CURRENT' static='true' type='Number'>Seek relative to current file position</field>
    /// <field name='DIRECTORY' static='true' type='Number'>Find directories</field>
    /// <field name='END' static='true' type='Number'>Seek relative to end of the file</field>
    /// <field name='FILE' static='true' type='Number'>Find files</field>
    /// <field name='READ' static='true' type='Number'>Flag to open file for reading</field>
    /// <field name='START' static='true' type='Number'>Seek relative to start of the file</field>
    /// <field name='UTF8' static='true' type='Number'>Flag to open file for reading as UTF-8 encoding.</field>
    /// <field name='WRITE' static='true' type='Number'>Flag to open file for writing</field>
}

File.prototype.Close = function() {
    /// <signature>
    /// <summary>Close a file opened by a File object.</summary>
    /// <returns type="null"/>
    /// </signature>
}

File.Copy = function() {
    /// <signature>
    /// <summary>Copies a file</summary>
    /// <param name="source" type="String" optional="false">Source filename you want to copy.</param>
    /// <param name="dest" type="String" optional="false">Destination filename you want to copy source file to.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.Delete = function() {
    /// <signature>
    /// <summary>Deletes a file</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to delete.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.DriveMapFilename = function() {
    /// <signature>
    /// <summary>Changes a filename or directory name to the correct format for a specific operating system using the directory mappings (if present)</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to drive map.</param>
    /// <param name="format" type="Number" optional="false">The format for the file/directory name. Can be Include.NATIVE, Include.UNIX or Include.WINDOWS</param>
    /// <returns type="String"/>
    /// </signature>
}

File.Exists = function() {
    /// <signature>
    /// <summary>Check if a file exists. See also File.IsDirectory() and See also File.IsFile().</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to check for existance.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.FindFiles = function() {
    /// <signature>
    /// <summary>Find any files and/or directories in a directory.</summary>
    /// <param name="directory" type="String" optional="false">Directory to look for files/directories in.</param>
    /// <param name="type" type="Number" optional="true">Type of things to find. Can be bitwise OR of File.FILE and File.DIRECTORY. If omitted only files will be returned.</param>
    /// <returns type="Array" elementType="filenames/directories"/>
    /// </signature>
}

File.prototype.FindLineContaining = function() {
    /// <signature>
    /// <summary>Reads a line from a file which contains contain, opened for reading by a File object. Although this is possible using core JavaScript functions this function should be significantly faster as most of the processing is done by Primer in C rather than in the JavaScript interpreter. To enable this function to be as fast as possible a maximum line length of 512 characters is used. If you expect a file to have lines longer than 512 characters then use ReadLongLine which allows lines of any length. If one argument is used then the line must contain that string. If more than one argument is used then lines which contain the string contain1 OR contain2 OR contain3 etc will be returned</summary>
    /// <param name="contain1" type="String" optional="false">String which matching lines must contain</param>
    /// <param name="contain2" type="String" optional="true">alternative string which matching lines must contain</param>
    /// <param name="contain3" type="String" optional="true">alternative string which matching lines must contain</param>
    /// <returns type="String"/>
    /// </signature>
}

File.prototype.FindLineStarting = function() {
    /// <signature>
    /// <summary>Reads a line from a file which starts with start, opened for reading by a File object. Although this is possible using core JavaScript functions this function should be significantly faster as most of the processing is done by Primer in C rather than in the JavaScript interpreter. To enable this function to be as fast as possible a maximum line length of 512 characters is used. If you expect a file to have lines longer than 512 characters then use ReadLongLine which allows lines of any length. If one argument is used then the line must start with that string. If more than one argument is used then lines which start with start1 OR start2 OR start3 etc will be returned</summary>
    /// <param name="start1" type="String" optional="false">String which matching lines must start with</param>
    /// <param name="start2" type="String" optional="true">alternative string which matching lines must start with</param>
    /// <param name="start3" type="String" optional="true">alternative string which matching lines must start with</param>
    /// <returns type="String"/>
    /// </signature>
}

File.prototype.Flush = function() {
    /// <signature>
    /// <summary>Flushes a file opened for writing by a File object.</summary>
    /// <returns type="null"/>
    /// </signature>
}

File.Get = function() {
    /// <signature>
    /// <summary>Get a file from a remote location. See also File.Proxy(), File.ProxyPassword() and File.ProxyUsername().</summary>
    /// <param name="url" type="String" optional="false">URL (uniform resource locator) of remote file you want to get. Currently http and ftp are supported. For http give the full address including the leading 'http://'. e.g. 'http://www.example.com/file.html'. For ftp an optional username and password can be given. e.g. 'ftp://ftp.example.com' retrieves the directory listing for the root directory. 'ftp://ftp.example.com/readme.txt' downloads the file readme.txt from the root directory. 'ftp://user:password@ftp.example.com/readme.txt' retrieves the readme.txt file from the user's home directory.</param>
    /// <param name="filename" type="String" optional="false">Filename you want to save the file to.</param>
    /// <param name="options" type="Object" optional="true">Options for get. If 'username' and 'password' are set then basic authorization using the username and password will be used.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.IsAbsolute = function() {
    /// <signature>
    /// <summary>Check if a filename is absolute or relative.</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to check.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.IsDirectory = function() {
    /// <signature>
    /// <summary>Check if a filename is a directory. See also File.Exists(), File.IsFile(), File.IsReadable() and File.IsWritable().</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to check.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.IsFile = function() {
    /// <signature>
    /// <summary>Check if a filename is a file. See also File.Exists(), File.IsDirectory(), File.IsReadable() and File.IsWritable().</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to check.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.IsReadable = function() {
    /// <signature>
    /// <summary>Check if a filename has read permissions. See also File.Exists(), File.IsDirectory() and File.IsWritable().</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to check.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.IsWritable = function() {
    /// <signature>
    /// <summary>Check if a filename has write permissions. If filename exists and it is a file then it is checked to see if it can be opened with write (File.APPEND permissions). If filename exists and it is a directory then the directory is checked for write permission (can files be created in the directory). If filename does not exist then it is assumed to be a file and is checked to see if it can be opened for writing (File.WRITE permissions). See also File.Exists(), File.IsDirectory() and File.IsReadable().</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to check.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.Mkdir = function() {
    /// <signature>
    /// <summary>Make a directory. If Primer preference 'directory_permission' is set e.g.755 then this will apply (same as if set by chmod 755) ignoring any setting of umask. If there is no preference then the users current setting of umask will control permissions (same as system mkdir)</summary>
    /// <param name="directory" type="String" optional="false">The name of the directory you want to create.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.Mktemp = function() {
    /// <signature>
    /// <summary>Make a temporary filename for writing a temporary file.</summary>
    /// <returns type="String"/>
    /// </signature>
}

File.Proxy = function() {
    /// <signature>
    /// <summary>Set a proxy for files opened by http, ftp etc. See also File.Get(), File.ProxyPassword() and File.ProxyUsername().</summary>
    /// <param name="name" type="String" optional="false">The name of the proxy.</param>
    /// <returns type="null"/>
    /// </signature>
}

File.ProxyPassword = function() {
    /// <signature>
    /// <summary>Set a proxy password for files opened by http, ftp etc. See also File.Get(), File.Proxy() and File.ProxyUsername().</summary>
    /// <param name="name" type="String" optional="false">Password for the proxy server.</param>
    /// <returns type="null"/>
    /// </signature>
}

File.ProxyUsername = function() {
    /// <signature>
    /// <summary>Set a proxy username for files opened by http, ftp etc. See also File.Get(), File.Proxy() and File.ProxyPassword().</summary>
    /// <param name="username" type="String" optional="false">The username for the proxy.</param>
    /// <returns type="null"/>
    /// </signature>
}

File.prototype.ReadAll = function() {
    /// <signature>
    /// <summary>Reads all the remaining characters from a file opened for reading by a File object. As this function can read the entire file as a string be careful when reading large files as it will consume large amounts of memory.</summary>
    /// <returns type="String"/>
    /// </signature>
}

File.prototype.ReadArrayBuffer = function() {
    /// <signature>
    /// <summary>Reads binary data from a file opened for reading by a File object. The data is returned as an ArrayBuffer object. For more details on how to use an ArrayBuffer see the following links: https://developer.mozilla.org/en/JavaScript_typed_arrays https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBufferView https://developer.mozilla.org/en/JavaScript_typed_arrays/DataView.</summary>
    /// <param name="length" type="Number" optional="true">Number of bytes to try to read from the file. If omitted all the remaining data from the file will be read.</param>
    /// <returns type="ArrayBuffer"/>
    /// </signature>
}

File.ReadCSV = function() {
    /// <signature>
    /// <summary>Reads the input CSV file and returns an array of string arrays. If the CSV file has legitimate records the function returns an Array object containing sub-arrays of strings otherwise the function returns NULL. The lengths of all the sub-arrays are the same and equal to maximum number of fields in any of the records. For records in a CSV file having fewer fields, the respective sub-arrays are padded with NULL elements to the maximum array length.</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to read CSV options from.</param>
    /// <param name="delimiter" type="String" optional="true">Delimiter string to be used. Default is a comma (",").</param>
    /// <param name="comment" type="String" optional="true">Comment string to be used. Default is a dollar sign ("$").</param>
    /// <returns type="String"/>
    /// </signature>
}

File.prototype.ReadChar = function() {
    /// <signature>
    /// <summary>Reads a single character from a file opened for reading by a File object.</summary>
    /// <returns type="String"/>
    /// </signature>
}

File.prototype.ReadLine = function() {
    /// <signature>
    /// <summary>Reads a line from a file opened for reading by a File object. To enable this function to be as fast as possible a maximum line length of 512 characters is used. If you expect a file to have lines longer than 512 characters then use ReadLongLine which allows lines of any length.</summary>
    /// <returns type="String"/>
    /// </signature>
}

File.prototype.ReadLongLine = function() {
    /// <signature>
    /// <summary>Reads a line from a file opened for reading by a File object. The line can be any length. If your file has lines shorter than 512 characters then you may want to use ReadLine instead which is faster.</summary>
    /// <returns type="String"/>
    /// </signature>
}

File.Rename = function() {
    /// <signature>
    /// <summary>Rename an existing file to have a different name.</summary>
    /// <param name="oldname" type="String" optional="false">Existing filename you want to rename</param>
    /// <param name="newname" type="String" optional="false">New filename you want to rename to</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.prototype.Seek = function() {
    /// <signature>
    /// <summary>Set the current position for reading or writing in a File object.</summary>
    /// <param name="offset" type="Number" optional="false">Offset to seek to in the file</param>
    /// <param name="origin" type="Number" optional="true">Origin for offset. Must be one of File.START, File.END or File.CURRENT. If omitted File.START will be used.</param>
    /// <returns type="null"/>
    /// </signature>
}

File.Size = function() {
    /// <signature>
    /// <summary>Return the size of a file in bytes</summary>
    /// <param name="filename" type="String" optional="false">Filename you want the size of.</param>
    /// <returns type="Number"/>
    /// </signature>
}

File.prototype.Tell = function() {
    /// <signature>
    /// <summary>Return the current file position for a File object. Note that on Windows when reading files if the file is not opened with File.BINARY this may not return the correct file position for files with unix line endings.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

File.Upload = function() {
    /// <signature>
    /// <summary>Uploads a file to a remote location. See also File.Proxy(), File.ProxyPassword() and File.ProxyUsername().</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to upload.</param>
    /// <param name="url" type="String" optional="false">URL (uniform resource locator) of the remote location you want to upload the file to. Currently only http is supported. Give the full address including the leading 'http://'. e.g. 'http://www.example.com/file.html'.</param>
    /// <param name="options" type="Object" optional="true">Options for upload. If both of these are set then basic authorization using the username and password will be used.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

File.prototype.Write = function() {
    /// <signature>
    /// <summary>Write a string to a file opened for writing by a File object. Note that a carriage return is not added.</summary>
    /// <param name="string" type="String" optional="false">The string/item that you want to write</param>
    /// <returns type="null"/>
    /// </signature>
}

File.prototype.WriteArrayBuffer = function() {
    /// <signature>
    /// <summary>Writes binary data to a file opened for writing by a File object. The data to write is an ArrayBuffer object. For more details on how to use an ArrayBuffer see the following links: https://developer.mozilla.org/en/JavaScript_typed_arrays https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBufferView https://developer.mozilla.org/en/JavaScript_typed_arrays/DataView.</summary>
    /// <param name="buffer" type="ArrayBuffer" optional="false">ArrayBuffer to write to file</param>
    /// <param name="length" type="Number" optional="true">Number of bytes to write to the file. If omitted all the data in the ArrayBuffer will be written (buffer.byteLength bytes)</param>
    /// <returns type="null"/>
    /// </signature>
}

File.prototype.Writeln = function() {
    /// <signature>
    /// <summary>Write a string to a file opened for writing by a File object adding a carriage return.</summary>
    /// <param name="string" type="String" optional="false">The string/item that you want to write</param>
    /// <returns type="null"/>
    /// </signature>
}

var GeneralizedWeld = function() {
    /// <signature>
    /// <summary>Create a new GeneralizedWeld object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that gwld will be created in</param>
    /// <param name="option" type="Number" optional="false">Constrained generalized weld type (any).</param>
    /// <param name="nsid" type="Number" optional="false">Set Node Set ID.</param>
    /// <param name="cid" type="Number" optional="true">Coordinate System ID.</param>
    /// <param name="filter" type="Number" optional="true">Number of force vectors saved for filtering.</param>
    /// <param name="window" type="Number" optional="true">Filter time window.</param>
    /// <param name="npr" type="Number" optional="true">Number of individual nodal pairs in cross fillet and combined weld.</param>
    /// <param name="nprt" type="Number" optional="true">Printout option.</param>
    /// <param name="wid" type="Number" optional="true">Constrained Generalized weld number.</param>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
    /// <field name='a' static='false' type='Number'>Width of fillet (GeneralizedWeld.FILLET, GeneralizedWeld.CROSS_FILLET)</field>
    /// <field name='alpha' static='false' type='Number'>Weld angle (GeneralizedWeld.FILLET, GeneralizedWeld.CROSS_FILLET)</field>
    /// <field name='beta' static='false' type='Number'>Failure parameter (GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET)</field>
    /// <field name='cid' static='false' type='Number'>Coordinate System ID.</field>
    /// <field name='d' static='false' type='Number'>Thickness of weld (GeneralizedWeld.BUTT)</field>
    /// <field name='epsf' static='false' type='Number'>Effective plastic strain at failure (GeneralizedWeld.SPOT, GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET)</field>
    /// <field name='exists' static='false' type='Boolean'>true if gwld exists, false if referred to but not defined. (read only)</field>
    /// <field name='filter' static='false' type='Number'>Number of force vectors saved for filtering.</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the gwld is in.</field>
    /// <field name='l' static='false' type='Number'>Length of weld (GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET)</field>
    /// <field name='label' static='false' type='Number'>Constrained Generalized weld number.</field>
    /// <field name='lt' static='false' type='Number'>Transverse length (GeneralizedWeld.BUTT)</field>
    /// <field name='m' static='false' type='Number'>Exponent for shear force (GeneralizedWeld.SPOT)</field>
    /// <field name='model' static='false' type='Number'>The Model number that the generalized weld is in.</field>
    /// <field name='n' static='false' type='Number'>Exponent for normal force (GeneralizedWeld.SPOT)</field>
    /// <field name='npr' static='false' type='Number'>Number of individual nodal pairs in cross fillet and combined weld.</field>
    /// <field name='nprt' static='false' type='Number'>Printout option.</field>
    /// <field name='nsid' static='false' type='Number'>Set Node Set ID.</field>
    /// <field name='option' static='false' type='Number'>GeneralizedWeld type. Can be GeneralizedWeld.SPOT, GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET, GeneralizedWeld.COMBINED</field>
    /// <field name='sigf' static='false' type='Number'>Stress at failure (GeneralizedWeld.FILLET)</field>
    /// <field name='sigy' static='false' type='Number'>Stress at failure (GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET)</field>
    /// <field name='sn' static='false' type='Number'>Normal force at failure (GeneralizedWeld.SPOT)</field>
    /// <field name='ss' static='false' type='Number'>Shear force at faliure (GeneralizedWeld.SPOT)</field>
    /// <field name='tfail' static='false' type='Number'>Failure time for constraint set (GeneralizedWeld.SPOT, GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET)</field>
    /// <field name='w' static='false' type='Number'>Width of flange (GeneralizedWeld.FILLET, GeneralizedWeld.CROSS_FILLET)</field>
    /// <field name='wid' static='false' type='Number'>Constrained Generalized weld number (identical to label).</field>
    /// <field name='window' static='false' type='Number'>Filter time window.</field>
    /// <field name='BUTT' static='true' type='Number'>GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_BUTT.</field>
    /// <field name='COMBINED' static='true' type='Number'>GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_COMBINED.</field>
    /// <field name='CROSS_FILLET' static='true' type='Number'>GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_CROSS_FILLET.</field>
    /// <field name='FILLET' static='true' type='Number'>GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_FILLET.</field>
    /// <field name='SPOT' static='true' type='Number'>GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_SPOT.</field>
}

GeneralizedWeld.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the generalized weld</summary>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the generalized welds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all generalized welds will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged generalized welds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged generalized welds will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the generalized welds that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the generalized weld is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

GeneralizedWeld.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the generalized weld.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the generalized weld</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the generalized weld.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a gwld.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the gwld will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for generalized weld. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.First = function() {
    /// <signature>
    /// <summary>Returns the first generalized weld in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first generalized weld in</param>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free generalized weld label in the model. Also see GeneralizedWeld.LastFreeLabel(), GeneralizedWeld.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free generalized weld label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeneralizedWeld.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the generalized welds in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all generalized welds will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the generalized welds</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the generalized weld is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the generalized weld</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

GeneralizedWeld.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each generalized weld in the model. Note that ForEach has been designed to make looping over generalized welds as fast as possible and so has some limitations. Firstly, a single temporary GeneralizedWeld object is created and on each function call it is updated with the current generalized weld data. This means that you should not try to store the GeneralizedWeld object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new generalized welds inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all generalized welds are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each generalized weld</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of GeneralizedWeld objects for all of the generalized welds in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get generalized welds from</param>
    /// <returns type="Array" elementType="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.prototype.GetCombinedData = function() {
    /// <signature>
    /// <summary>Returns the combined data for a specific nodal pair as an array.</summary>
    /// <param name="index" type="Number" optional="false">Index you want the data for. Note that indices start at 0.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

GeneralizedWeld.prototype.GetCrossFilletData = function() {
    /// <signature>
    /// <summary>Returns the cross fillet data for a specific nodal pair as an array.</summary>
    /// <param name="index" type="Number" optional="false">Index you want the data for. Note that indices start at 0.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

GeneralizedWeld.prototype.GetFailureData_#deprecated = function() {
    /// <signature>
    /// <summary>Access the properties directly or use GeneralizedWeld.GetCombinedData() for GeneralizedWeld.COMBINED instead.</summary>
    /// </signature>
}

GeneralizedWeld.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of GeneralizedWeld objects for all of the flagged generalized welds in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get generalized welds from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the generalized welds that you want to retrieve</param>
    /// <returns type="Array" elementType="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the GeneralizedWeld object for a generalized weld ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the generalized weld in</param>
    /// <param name="number" type="Number" optional="false">number of the generalized weld you want the GeneralizedWeld object for</param>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.prototype.GetNodalPair_#deprecated = function() {
    /// <signature>
    /// <summary>Use GeneralizedWeld.GetCombinedData() for GeneralizedWeld.COMBINED or GeneralizedWeld.GetCrossFilletData() for GeneralizedWeld.CROSS_FILLET instead.</summary>
    /// </signature>
}

GeneralizedWeld.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a GeneralizedWeld property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the GeneralizedWeld.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">generalized weld property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

GeneralizedWeld.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this gwld (*CONSTRAINED_GENERALIZED_WELD_xxxx). Note that a carriage return is not added. See also GeneralizedWeld.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

GeneralizedWeld.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the gwld. Note that a carriage return is not added. See also GeneralizedWeld.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

GeneralizedWeld.Last = function() {
    /// <signature>
    /// <summary>Returns the last generalized weld in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last generalized weld in</param>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free generalized weld label in the model. Also see GeneralizedWeld.FirstFreeLabel(), GeneralizedWeld.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free generalized weld label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeneralizedWeld.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next generalized weld in the model.</summary>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) generalized weld label in the model. Also see GeneralizedWeld.FirstFreeLabel(), GeneralizedWeld.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free generalized weld label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeneralizedWeld.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a generalized weld.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only generalized welds from that model can be picked. If the argument is a Flag then only generalized welds that are flagged with limit can be selected. If omitted, or null, any generalized welds from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous generalized weld in the model.</summary>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the generalized welds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all generalized welds will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged generalized welds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged generalized welds will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the generalized welds that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select generalized welds using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting generalized welds</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only generalized welds from that model can be selected. If the argument is a Flag then only generalized welds that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any generalized welds can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeneralizedWeld.prototype.SetCombinedData = function() {
    /// <signature>
    /// <summary>Sets the combined data for a specific nodal pair.</summary>
    /// <param name="index" type="Number" optional="false">Index you want to set the data for. Note that indices start at 0.</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">Array containing the data. The array length should be 12 (tfail, epsf, sigy, beta, l, w, a, alpha, nodea, nodeb, ncid, wtyp)</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.SetCrossFilletData = function() {
    /// <signature>
    /// <summary>Sets the cross fillet data for a specific nodal pair.</summary>
    /// <param name="index" type="Number" optional="false">Index you want to set the data for. Note that indices start at 0.</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">Array containing the data. The array length should be 3 (nodea, nodeb, ncid)</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.SetFailureData_#deprecated = function() {
    /// <signature>
    /// <summary>Access the properties directly or use GeneralizedWeld.SetCombinedData() for GeneralizedWeld.COMBINED instead.</summary>
    /// </signature>
}

GeneralizedWeld.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the generalized weld.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the generalized weld</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.SetNodalPair_#deprecated = function() {
    /// <signature>
    /// <summary>Use GeneralizedWeld.SetCombinedData() for GeneralizedWeld.COMBINED or GeneralizedWeld.SetCrossFilletData() for GeneralizedWeld.CROSS_FILLET instead.</summary>
    /// </signature>
}

GeneralizedWeld.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the generalized weld. The generalized weld will be sketched until you either call GeneralizedWeld.Unsketch(), GeneralizedWeld.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the generalized weld is sketched. If omitted redraw is true. If you want to sketch several generalized welds and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged generalized welds in the model. The generalized welds will be sketched until you either call GeneralizedWeld.Unsketch(), GeneralizedWeld.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged generalized welds will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the generalized welds that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the generalized welds are sketched. If omitted redraw is true. If you want to sketch flagged generalized welds several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of generalized welds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing generalized welds should be counted. If false or omitted referenced but undefined generalized welds will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeneralizedWeld.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the generalized weld</summary>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the generalized welds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all generalized welds will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged generalized welds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged generalized welds will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the generalized welds that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the generalized welds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all generalized welds will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the generalized welds</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the generalized weld.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the generalized weld is unsketched. If omitted redraw is true. If you want to unsketch several generalized welds and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all generalized welds.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all generalized welds will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the generalized welds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged generalized welds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all generalized welds will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the generalized welds that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the generalized welds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="GeneralizedWeld"/>
    /// </signature>
}

GeneralizedWeld.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for generalized weld. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

GeneralizedWeld.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this generalized weld.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

GeneralizedWeld.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the gwld data in keyword format. Note that this contains the keyword header and the keyword cards. See also GeneralizedWeld.Keyword() and GeneralizedWeld.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var GeometrySurface = function() {
    /// <field name='exists' static='false' type='Boolean'>true if gsrf exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Number'>GeometrySurface number. Also see the label property which is an alternative name for this. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the gsrf is in.</field>
    /// <field name='label' static='false' type='Number'>GeometrySurface number. Also see the id property which is an alternative name for this. (read only)</field>
    /// <field name='model' static='false' type='Number'>The Model number that the surface is in.</field>
}

GeometrySurface.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the surface</summary>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the surfaces in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all surfaces will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged surfaces in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged surfaces will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the surfaces that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the surface is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

GeometrySurface.prototype.CalculateNormal = function() {
    /// <signature>
    /// <summary>Calculate the normal vector for a parametric point on a surface.</summary>
    /// <param name="u" type="Number" optional="false">u parametric coordinate</param>
    /// <param name="y" type="Number" optional="false">v parametric coordinate</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

GeometrySurface.prototype.CalculatePoint = function() {
    /// <signature>
    /// <summary>Calculate the X, Y and Z coordinates for a parametric point on a surface.</summary>
    /// <param name="u" type="Number" optional="false">u parametric coordinate</param>
    /// <param name="v" type="Number" optional="false">v parametric coordinate</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

GeometrySurface.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the surface.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the surface</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the surface.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for surface. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.First = function() {
    /// <signature>
    /// <summary>Returns the first surface in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first surface in</param>
    /// <returns type="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free surface label in the model. Also see GeometrySurface.LastFreeLabel(), GeometrySurface.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free surface label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeometrySurface.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the surfaces in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all surfaces will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the surfaces</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the surface is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the surface</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

GeometrySurface.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each surface in the model. Note that ForEach has been designed to make looping over surfaces as fast as possible and so has some limitations. Firstly, a single temporary GeometrySurface object is created and on each function call it is updated with the current surface data. This means that you should not try to store the GeometrySurface object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new surfaces inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all surfaces are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each surface</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of GeometrySurface objects for all of the surfaces in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get surfaces from</param>
    /// <returns type="Array" elementType="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.prototype.GetEdgeIndices = function() {
    /// <signature>
    /// <summary>Return an array of all the edge indices for a surface (in pairs).</summary>
    /// <returns type="Array" elementType="indices"/>
    /// </signature>
}

GeometrySurface.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of GeometrySurface objects for all of the flagged surfaces in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get surfaces from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the surfaces that you want to retrieve</param>
    /// <returns type="Array" elementType="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the GeometrySurface object for a surface ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the surface in</param>
    /// <param name="number" type="Number" optional="false">number of the surface you want the GeometrySurface object for</param>
    /// <returns type="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a GeometrySurface property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the GeometrySurface.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">surface property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

GeometrySurface.prototype.GetTriaIndices = function() {
    /// <signature>
    /// <summary>Return an array of all the tria indices for a surface (in triplets).</summary>
    /// <returns type="Array" elementType="indices"/>
    /// </signature>
}

GeometrySurface.prototype.GetVertices = function() {
    /// <signature>
    /// <summary>Return an array of all the vertex coordinates for a surface (in triplets).</summary>
    /// <returns type="Array" elementType="indices"/>
    /// </signature>
}

GeometrySurface.Last = function() {
    /// <signature>
    /// <summary>Returns the last surface in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last surface in</param>
    /// <returns type="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free surface label in the model. Also see GeometrySurface.FirstFreeLabel(), GeometrySurface.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free surface label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeometrySurface.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next surface in the model.</summary>
    /// <returns type="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) surface label in the model. Also see GeometrySurface.FirstFreeLabel(), GeometrySurface.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free surface label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeometrySurface.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a surface.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only surfaces from that model can be picked. If the argument is a Flag then only surfaces that are flagged with limit can be selected. If omitted, or null, any surfaces from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous surface in the model.</summary>
    /// <returns type="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.prototype.ProjectPoint = function() {
    /// <signature>
    /// <summary>Project a point onto the surface.</summary>
    /// <param name="x" type="Number" optional="false">X coordinate of point to project</param>
    /// <param name="y" type="Number" optional="false">Y coordinate of point to project</param>
    /// <param name="z" type="Number" optional="false">Z coordinate of point to project</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

GeometrySurface.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the surfaces in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all surfaces will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged surfaces in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged surfaces will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the surfaces that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select surfaces using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting surfaces</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only surfaces from that model can be selected. If the argument is a Flag then only surfaces that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any surfaces can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeometrySurface.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the surface.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the surface</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the surface. The surface will be sketched until you either call GeometrySurface.Unsketch(), GeometrySurface.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the surface is sketched. If omitted redraw is true. If you want to sketch several surfaces and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged surfaces in the model. The surfaces will be sketched until you either call GeometrySurface.Unsketch(), GeometrySurface.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged surfaces will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the surfaces that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the surfaces are sketched. If omitted redraw is true. If you want to sketch flagged surfaces several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of surfaces in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing surfaces should be counted. If false or omitted referenced but undefined surfaces will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

GeometrySurface.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the surface</summary>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the surfaces in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all surfaces will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged surfaces in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged surfaces will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the surfaces that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the surfaces in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all surfaces will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the surfaces</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the surface.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the surface is unsketched. If omitted redraw is true. If you want to unsketch several surfaces and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all surfaces.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all surfaces will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the surfaces are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged surfaces in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all surfaces will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the surfaces that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the surfaces are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="GeometrySurface"/>
    /// </signature>
}

GeometrySurface.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for surface. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

GeometrySurface.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this surface.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

var Graphics = function() {
    /// <field name='CIRCLE' static='true' type='Number'>Circle shape. See Graphics.Shape() for use.</field>
    /// <field name='DASHDOT_LINE' static='true' type='Number'>Dashed and dotted lines. See Graphics.LineStyle() for use.</field>
    /// <field name='DASH_LINE' static='true' type='Number'>Dashed lines. See Graphics.LineStyle() for use.</field>
    /// <field name='DIAMOND' static='true' type='Number'>Diamond shape. See Graphics.Shape() for use.</field>
    /// <field name='DOT_LINE' static='true' type='Number'>Dotted lines. See Graphics.LineStyle() for use.</field>
    /// <field name='FILLED_CIRCLE' static='true' type='Number'>Filled circle shape. See Graphics.Shape() for use.</field>
    /// <field name='FILLED_DIAMOND' static='true' type='Number'>Filled diamond shape. See Graphics.Shape() for use.</field>
    /// <field name='FILLED_HOURGLASS' static='true' type='Number'>Filled hourglass shape. See Graphics.Shape() for use.</field>
    /// <field name='FILLED_SQUARE' static='true' type='Number'>Filled square shape. See Graphics.Shape() for use.</field>
    /// <field name='HOURGLASS' static='true' type='Number'>Hourglass shape. See Graphics.Shape() for use.</field>
    /// <field name='POINT' static='true' type='Number'>Point shape. See Graphics.Shape() for use.</field>
    /// <field name='SOLID_LINE' static='true' type='Number'>Solid lines. See Graphics.LineStyle() for use.</field>
    /// <field name='SQUARE' static='true' type='Number'>Square shape. See Graphics.Shape() for use.</field>
}

Graphics.DepthTest = function() {
    /// <signature>
    /// <summary>Allows depth testing (hidden surface removal) to be turned on or off. Temporarily turning depth testing off may be used to ensure that an item (e.g. some text) is always drawn in front and will not be obscured.</summary>
    /// <param name="enable" type="Boolean" optional="false">Whether depth testing (hidden surface removal) is performed (true) or not (false)</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.DrawingFunction = function() {
    /// <signature>
    /// <summary>Set the function to draw graphics from javaScript. This function will be called each time the graphics are redrawn after PRIMER has finished drawing everything else. This allows you to add extra items to the graphics. To remove the graphics drawing function use Graphics.DrawingFunction(null). It is the responsibility of the script developer to ensure that any objects or variables that are used in the drawing function do not refer to items in Primer that no longer exist. Not doing so may cause PRIMER to crash. For example, if you use some Node objects in the drawing function that refer to nodes in model 1 and you delete the model, when the graphics are redrawn PRIMER may crash as the nodes referred to by the Node objects no longer exist. You should either remove the drawing function by calling Graphics.DrawingFunction(null) or set the Node variables to null (and test that they exist before using them) in your drawing function before deleting the model.</summary>
    /// <param name="name" type="function" optional="false">The name of the function (or null to remove a function)</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.FillColour = function() {
    /// <signature>
    /// <summary>Sets the colour for drawing polygons. See the Colour class for more details on colours.</summary>
    /// <param name="colour" type="Colour" optional="false">The colour you want to fill polygons with</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.Finish = function() {
    /// <signature>
    /// <summary>Finish any graphics. See also Graphics.Start(). This must be used to finish drawing.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.Line = function() {
    /// <signature>
    /// <summary>Draws a line from (x1, y1, z1) to (x2, y2, z2). See also Graphics.LineTo() and Graphics.MoveTo()</summary>
    /// <param name="x1" type="Number" optional="false">X coordinate of point 1</param>
    /// <param name="y1" type="Number" optional="false">Y coordinate of point 1</param>
    /// <param name="z1" type="Number" optional="false">Z coordinate of point 1</param>
    /// <param name="x2" type="Number" optional="false">X coordinate of point 2</param>
    /// <param name="y2" type="Number" optional="false">Y coordinate of point 2</param>
    /// <param name="z2" type="Number" optional="false">Z coordinate of point 2</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.LineColour = function() {
    /// <signature>
    /// <summary>Sets the colour for drawing lines. See the Colour class for more details on colours.</summary>
    /// <param name="colour" type="Colour" optional="false">The colour you want to draw lines with</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.LineStyle = function() {
    /// <signature>
    /// <summary>Sets the style for drawing lines.</summary>
    /// <param name="style" type="Number" optional="false">The style to draw lines with. Can be: Graphics.SOLID_LINE, Graphics.DASH_LINE, Graphics.DASHDOT_LINE or Graphics.DOT_LINE</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.LineTo = function() {
    /// <signature>
    /// <summary>Draws a line from the current point to (x, y, z). After drawing the line the current point will be (x, y, z). See also Graphics.Line() and Graphics.MoveTo()</summary>
    /// <param name="x" type="Number" optional="false">X coordinate</param>
    /// <param name="y" type="Number" optional="false">Y coordinate</param>
    /// <param name="z" type="Number" optional="false">Z coordinate</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.LineWidth = function() {
    /// <signature>
    /// <summary>Sets the width for drawing lines.</summary>
    /// <param name="width" type="Number" optional="false">The width to draw lines with</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.MoveTo = function() {
    /// <signature>
    /// <summary>Sets the current point to (x, y, z). See also Graphics.Line() and Graphics.LineTo()</summary>
    /// <param name="x" type="Number" optional="false">X coordinate</param>
    /// <param name="y" type="Number" optional="false">Y coordinate</param>
    /// <param name="z" type="Number" optional="false">Z coordinate</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.PolygonFinish = function() {
    /// <signature>
    /// <summary>Ends drawing a polygon. See also Graphics.PolygonStart()</summary>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.PolygonStart = function() {
    /// <signature>
    /// <summary>Starts drawing a polygon. See also Graphics.PolygonFinish()</summary>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.Shape = function() {
    /// <signature>
    /// <summary>Draws a simple shape.</summary>
    /// <param name="shape" type="Number" optional="false">The style to draw lines with. Can be: Graphics.POINT, Graphics.SQUARE, Graphics.CIRCLE, Graphics.DIAMOND, Graphics.HOURGLASS, Graphics.FILLED_SQUARE, Graphics.FILLED_CIRCLE, Graphics.FILLED_DIAMOND or Graphics.FILLED_HOURGLASS</param>
    /// <param name="size" type="Number" optional="false">Size the shape should be drawn at.</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.Start = function() {
    /// <signature>
    /// <summary>Start any graphics. See also Graphics.Finish(). This must be used before any drawing is done.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.Text = function() {
    /// <signature>
    /// <summary>Draws text at current position. See Graphics.MoveTo() to set the current position.</summary>
    /// <param name="text" type="String" optional="false">The text to write</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.TextColour = function() {
    /// <signature>
    /// <summary>Sets the colour for drawing text. See the Colour class for more details on colours.</summary>
    /// <param name="colour" type="Colour" optional="false">The colour you want to draw text with</param>
    /// <returns type="null"/>
    /// </signature>
}

Graphics.TextSize = function() {
    /// <signature>
    /// <summary>Sets the size for drawing text.</summary>
    /// <param name="size" type="Number" optional="false">The size to draw text with</param>
    /// <returns type="null"/>
    /// </signature>
}

var Group = function() {
    /// <signature>
    /// <summary>Create a new Group object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that Group will be created in</param>
    /// <param name="label" type="Number" optional="false">Group number.</param>
    /// <param name="title" type="String" optional="true">Title for the group</param>
    /// <returns type="Group"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if group exists, false if referred to but not defined (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the group is in</field>
    /// <field name='label' static='false' type='Number'>Group number</field>
    /// <field name='lock' static='false' type='Boolean'>Whether Group contents are locked against deletion.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the group is in.</field>
    /// <field name='numtypes' static='false' type='Number'>Number of types in the group.</field>
    /// <field name='title' static='false' type='String'>Group title</field>
    /// <field name='ADD' static='true' type='Number'>Add contents to group</field>
    /// <field name='REMOVE' static='true' type='Number'>Remove contents from group</field>
}

Group.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the group</summary>
    /// <returns type="null"/>
    /// </signature>
}

Group.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all groups will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged groups will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the groups that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the group is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Group.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the group.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the group</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the group.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Group"/>
    /// </signature>
}

Group.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a group.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the group will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Group"/>
    /// </signature>
}

Group.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for group. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.First = function() {
    /// <signature>
    /// <summary>Returns the first group in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first group in</param>
    /// <returns type="Group"/>
    /// </signature>
}

Group.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free group label in the model. Also see Group.LastFreeLabel(), Group.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free group label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Group.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the groups in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all groups will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the groups</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the group is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the group</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Group.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each group in the model. Note that ForEach has been designed to make looping over groups as fast as possible and so has some limitations. Firstly, a single temporary Group object is created and on each function call it is updated with the current group data. This means that you should not try to store the Group object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new groups inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all groups are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each group</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Group objects for all of the groups in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get groups from</param>
    /// <returns type="Array" elementType="Group"/>
    /// </signature>
}

Group.prototype.GetDataAll = function() {
    /// <signature>
    /// <summary>Returns 'all' data for a given row number and type in the group.</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <param name="index" type="Number" optional="false">Index of 'all' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalAll()</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Group.prototype.GetDataList = function() {
    /// <signature>
    /// <summary>Returns 'list' data for a given row number and type in the group.</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <param name="index" type="Number" optional="false">Index of 'list' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalList()</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Group.prototype.GetDataRange = function() {
    /// <signature>
    /// <summary>Returns 'range' data for a given row number and type in the group.</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <param name="index" type="Number" optional="false">Index of 'range' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalRange()</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Group.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Group objects for all of the flagged groups in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get groups from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the groups that you want to retrieve</param>
    /// <returns type="Array" elementType="Group"/>
    /// </signature>
}

Group.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Group object for a group ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the group in</param>
    /// <param name="number" type="Number" optional="false">number of the group you want the Group object for</param>
    /// <returns type="Group"/>
    /// </signature>
}

Group.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Group property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Group.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">group property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Group.prototype.GetTotalAll = function() {
    /// <signature>
    /// <summary>Returns the total number of 'all' rows for a type in a group</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <returns type="Number"/>
    /// </signature>
}

Group.prototype.GetTotalList = function() {
    /// <signature>
    /// <summary>Returns the total number of 'list' rows for a type in a group</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <returns type="Number"/>
    /// </signature>
}

Group.prototype.GetTotalRange = function() {
    /// <signature>
    /// <summary>Returns the total number of 'range' rows for a type in a group</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <returns type="Number"/>
    /// </signature>
}

Group.prototype.GetTotals = function() {
    /// <signature>
    /// <summary>Returns the total number of 'all', 'list' and 'range' rows for a type in a group</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Group.prototype.GetType = function() {
    /// <signature>
    /// <summary>Returns the type for an entry in a group</summary>
    /// <param name="row" type="Number" optional="false">The entry in the group types that you want the type for. Note that entries start at 0, not 1</param>
    /// <returns type="String"/>
    /// </signature>
}

Group.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this group. Note that a carriage return is not added. See also Group.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Group.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the Group. Note that a carriage return is not added. See also Group.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Group.Last = function() {
    /// <signature>
    /// <summary>Returns the last group in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last group in</param>
    /// <returns type="Group"/>
    /// </signature>
}

Group.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free group label in the model. Also see Group.FirstFreeLabel(), Group.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free group label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Group.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next group in the model.</summary>
    /// <returns type="Group"/>
    /// </signature>
}

Group.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) group label in the model. Also see Group.FirstFreeLabel(), Group.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free group label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Group.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a group.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only groups from that model can be picked. If the argument is a Flag then only groups that are flagged with limit can be selected. If omitted, or null, any groups from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Group"/>
    /// </signature>
}

Group.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous group in the model.</summary>
    /// <returns type="Group"/>
    /// </signature>
}

Group.prototype.RemoveDataAll = function() {
    /// <signature>
    /// <summary>Removes 'all' data for a given row number and type in the group.</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <param name="index" type="Number" optional="false">Index of 'all' row you want to Remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalAll()</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.RemoveDataList = function() {
    /// <signature>
    /// <summary>Removes 'list' data for a given row number and type in the group.</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <param name="index" type="Number" optional="false">Index of 'list' row you want to Remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalList()</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.RemoveDataRange = function() {
    /// <signature>
    /// <summary>Removes 'range' data for a given row number and type in the group.</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <param name="index" type="Number" optional="false">Index of 'range' row you want to Remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalRange()</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all groups will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged groups will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the groups that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select groups using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting groups</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only groups from that model can be selected. If the argument is a Flag then only groups that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any groups can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Group.prototype.SetDataAll = function() {
    /// <signature>
    /// <summary>Sets 'all' data for a given row number and type in the group.</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <param name="index" type="Number" optional="false">Index of 'all' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt;= Group.GetTotalAll()</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">An array containing data [Group.ADD or Group.REMOVE, BOX (if defined)].</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.SetDataList = function() {
    /// <signature>
    /// <summary>Sets 'list' data for a given row number and type in the group.</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <param name="index" type="Number" optional="false">Index of 'list' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt;= Group.GetTotalList()</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">An array containing data [Group.ADD or Group.REMOVE, ITEM1 (if defined), ITEM2 (if defined), ITEM3 (if defined), ITEM4 (if defined), ITEM5 (if defined), BOX (if defined)].</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.SetDataRange = function() {
    /// <signature>
    /// <summary>Sets 'range' data for a given row number and type in the group.</summary>
    /// <param name="type" type="String" optional="false">The type of the item</param>
    /// <param name="index" type="Number" optional="false">Index of 'all' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt;= Group.GetTotalRange()</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">An array containing data [Group.ADD or Group.REMOVE, START, END, BOX (if defined)].</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the group.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the group</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the group. The group will be sketched until you either call Group.Unsketch(), Group.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the group is sketched. If omitted redraw is true. If you want to sketch several groups and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged groups in the model. The groups will be sketched until you either call Group.Unsketch(), Group.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged groups will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the groups that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the groups are sketched. If omitted redraw is true. If you want to sketch flagged groups several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing groups should be counted. If false or omitted referenced but undefined groups will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Group.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the group</summary>
    /// <returns type="null"/>
    /// </signature>
}

Group.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all groups will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged groups will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the groups that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all groups will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the groups</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the group.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the group is unsketched. If omitted redraw is true. If you want to unsketch several groups and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all groups.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all groups will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the groups are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all groups will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the groups that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the groups are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Group"/>
    /// </signature>
}

Group.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for group. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Group.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this group.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Group.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the Group data in keyword format. Note that this contains the keyword header and the keyword cards. See also Group.Keyword() and Group.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var History = function() {
    /// <signature>
    /// <summary>Create a new History object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that database history will be created in</param>
    /// <param name="type" type="Number" optional="false">Entity type</param>
    /// <param name="id" type="Number" optional="false">ID of the item</param>
    /// <param name="heading" type="String" optional="true">Optional heading</param>
    /// <returns type="History"/>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>Coordinate system ID for _LOCAL</field>
    /// <field name='exists' static='false' type='Boolean'>true if database history exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>Optional heading</field>
    /// <field name='hfo' static='false' type='Number'>High frequency flag for _LOCAL</field>
    /// <field name='id' static='false' type='Number'>ID of the item</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the database history is in.</field>
    /// <field name='local' static='false' type='Boolean'>Turns _LOCAL on or off</field>
    /// <field name='model' static='false' type='Number'>The Model number that the database history is in.</field>
    /// <field name='ref' static='false' type='Number'>Output reference for _LOCAL</field>
    /// <field name='type' static='false' type='Number'>The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET.</field>
    /// <field name='ALL_TYPES' static='true' type='Number'>All *DATABASE_HISTORY_ types.</field>
    /// <field name='BEAM' static='true' type='Number'>BEAM is *DATABASE_HISTORY_BEAM.</field>
    /// <field name='BEAM_SET' static='true' type='Number'>BEAM_SET is *DATABASE_HISTORY_BEAM_SET.</field>
    /// <field name='DISCRETE' static='true' type='Number'>DISCRETE is *DATABASE_HISTORY_DISCRETE.</field>
    /// <field name='DISCRETE_SET' static='true' type='Number'>DISCRETE_SET is *DATABASE_HISTORY_DISCRETE_SET.</field>
    /// <field name='NODE' static='true' type='Number'>NODE is *DATABASE_HISTORY_NODE.</field>
    /// <field name='NODE_SET' static='true' type='Number'>NODE_SET is *DATABASE_HISTORY_NODE_SET.</field>
    /// <field name='SEATBELT' static='true' type='Number'>SEATBELT is *DATABASE_HISTORY_SEATBELT.</field>
    /// <field name='SHELL' static='true' type='Number'>SHELL is *DATABASE_HISTORY_SHELL.</field>
    /// <field name='SHELL_SET' static='true' type='Number'>SHELL_SET is *DATABASE_HISTORY_SHELL_SET.</field>
    /// <field name='SOLID' static='true' type='Number'>SOLID is *DATABASE_HISTORY_SOLID.</field>
    /// <field name='SOLID_SET' static='true' type='Number'>SOLID_SET is *DATABASE_HISTORY_SOLID_SET.</field>
    /// <field name='SPH' static='true' type='Number'>SPH is *DATABASE_HISTORY_SPH.</field>
    /// <field name='SPH_SET' static='true' type='Number'>SPH_SET is *DATABASE_HISTORY_SPH_SET.</field>
    /// <field name='TSHELL' static='true' type='Number'>TSHELL is *DATABASE_HISTORY_TSHELL.</field>
    /// <field name='TSHELL_SET' static='true' type='Number'>TSHELL_SET is *DATABASE_HISTORY_TSHELL_SET.</field>
}

History.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the database histories in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all database histories will be blanked in</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

History.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged database histories in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged database histories will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the database histories that you want to blank</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

History.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the database history is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

History.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the database history.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the database history</param>
    /// <returns type="null"/>
    /// </signature>
}

History.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a database history.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the database history will be created in</param>
    /// <param name="type" type="Number" optional="false">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET.</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="History"/>
    /// </signature>
}

History.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to edit the database history.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

History.First = function() {
    /// <signature>
    /// <summary>Returns the first database history in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first database history in</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <returns type="History"/>
    /// </signature>
}

History.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the database histories in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all database histories will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the database histories</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <returns type="null"/>
    /// </signature>
}

History.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the database history is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the database history</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

History.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of History objects for all of the database histories in a models in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get database histories from</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <returns type="Array" elementType="History"/>
    /// </signature>
}

History.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the History object for a database history ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the database history in</param>
    /// <param name="database history number" type="Number" optional="false">number of the database history you want the History object for</param>
    /// <returns type="History"/>
    /// </signature>
}

History.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this database history (*DATABASE_HISTORY). Note that a carriage return is not added. See also History.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

History.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the database history. Note that a carriage return is not added. See also History.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

History.Last = function() {
    /// <signature>
    /// <summary>Returns the last database history in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last database history in</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <returns type="History"/>
    /// </signature>
}

History.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next database history in the model.</summary>
    /// <returns type="History"/>
    /// </signature>
}

History.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a database history.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only database histories from that model can be picked. If the argument is a Flag then only database histories that are flagged with limit can be selected. If omitted, or null, any database histories from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <returns type="History"/>
    /// </signature>
}

History.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous database history in the model.</summary>
    /// <returns type="History"/>
    /// </signature>
}

History.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select database histories using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting database histories</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only database histories from that model can be selected. If the argument is a Flag then only database histories that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any database histories from any model can be selected.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

History.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the database history.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the database history</param>
    /// <returns type="null"/>
    /// </signature>
}

History.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the database history. The database history will be sketched until you either call History.Unsketch(), History.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the database history is sketched. If omitted redraw is true. If you want to sketch several database histories and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

History.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged database histories in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged database histories will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the database histories that you want to sketch</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is true. If you want to do several (un)sketches and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

History.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the database histories in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all database histories will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <returns type="null"/>
    /// </signature>
}

History.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged database histories in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged database histories will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the database histories that you want to unblank</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

History.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the database histories in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all database histories will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the database histories</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <returns type="null"/>
    /// </signature>
}

History.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the database history.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the database history is unsketched. If omitted redraw is true. If you want to unsketch several database histories and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

History.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all database histories.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all database histories will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the database histories are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

History.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged database histories.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all database histories will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the database histories that you want to sketch</param>
    /// <param name="type" type="Number" optional="true">The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the database histories are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

History.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this database history.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

History.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the database history data in keyword format. Note that this contains the keyword header and the keyword cards. See also History.Keyword() and History.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Hourglass = function() {
    /// <signature>
    /// <summary>Create a new Hourglass object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that hourglass will be created in</param>
    /// <param name="hgid" type="Number" optional="false">Hourglass number</param>
    /// <param name="title" type="String" optional="true">Title for the hourglass</param>
    /// <returns type="Hourglass"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if hourglass exists, false if referred to but not defined. (read only)</field>
    /// <field name='hgid' static='false' type='Number'>Hourglass number. Also see the label property which is an alternative name for this.</field>
    /// <field name='ibq' static='false' type='Number'>Bulk viscosity type</field>
    /// <field name='ihq' static='false' type='Number'>Hourglass control type</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the hourglass is in.</field>
    /// <field name='label' static='false' type='Number'>Hourglass number. Also see the hgid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the hourglass is in.</field>
    /// <field name='q1' static='false' type='Number'>Quadratic bulk viscosity coefficient</field>
    /// <field name='q2' static='false' type='Number'>Linear bulk viscosity coefficient</field>
    /// <field name='qb' static='false' type='Number'>Coefficient for shell bending</field>
    /// <field name='qm' static='false' type='Number'>Hourglass coefficient</field>
    /// <field name='qw' static='false' type='Number'>Coefficient for shell warping</field>
    /// <field name='title' static='false' type='String'>Title for hourglass</field>
    /// <field name='vdc' static='false' type='Number'>Viscous damping coefficient</field>
}

Hourglass.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the hourglass.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the hourglass</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the hourglass.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Hourglass"/>
    /// </signature>
}

Hourglass.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a hourglass.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the hourglass will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Hourglass"/>
    /// </signature>
}

Hourglass.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for hourglass. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.First = function() {
    /// <signature>
    /// <summary>Returns the first hourglass in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first hourglass in</param>
    /// <returns type="Hourglass"/>
    /// </signature>
}

Hourglass.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free hourglass label in the model. Also see Hourglass.LastFreeLabel(), Hourglass.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free hourglass label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Hourglass.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the hourglasss in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all hourglasss will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the hourglasss</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the hourglass is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the hourglass</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Hourglass.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each hourglass in the model. Note that ForEach has been designed to make looping over hourglasss as fast as possible and so has some limitations. Firstly, a single temporary Hourglass object is created and on each function call it is updated with the current hourglass data. This means that you should not try to store the Hourglass object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new hourglasss inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all hourglasss are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each hourglass</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Hourglass objects for all of the hourglasss in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get hourglasss from</param>
    /// <returns type="Array" elementType="Hourglass"/>
    /// </signature>
}

Hourglass.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Hourglass objects for all of the flagged hourglasss in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get hourglasss from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the hourglasss that you want to retrieve</param>
    /// <returns type="Array" elementType="Hourglass"/>
    /// </signature>
}

Hourglass.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Hourglass object for a hourglass ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the hourglass in</param>
    /// <param name="number" type="Number" optional="false">number of the hourglass you want the Hourglass object for</param>
    /// <returns type="Hourglass"/>
    /// </signature>
}

Hourglass.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Hourglass property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Hourglass.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">hourglass property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Hourglass.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this hourglass (*HOURGLASS). Note that a carriage return is not added. See also Hourglass.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Hourglass.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the hourglass. Note that a carriage return is not added. See also Hourglass.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Hourglass.Last = function() {
    /// <signature>
    /// <summary>Returns the last hourglass in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last hourglass in</param>
    /// <returns type="Hourglass"/>
    /// </signature>
}

Hourglass.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free hourglass label in the model. Also see Hourglass.FirstFreeLabel(), Hourglass.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free hourglass label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Hourglass.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next hourglass in the model.</summary>
    /// <returns type="Hourglass"/>
    /// </signature>
}

Hourglass.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) hourglass label in the model. Also see Hourglass.FirstFreeLabel(), Hourglass.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free hourglass label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Hourglass.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous hourglass in the model.</summary>
    /// <returns type="Hourglass"/>
    /// </signature>
}

Hourglass.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the hourglasss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all hourglasss will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged hourglasss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged hourglasss will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the hourglasss that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select hourglasss using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting hourglasss</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only hourglasss from that model can be selected. If the argument is a Flag then only hourglasss that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any hourglasss can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Hourglass.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the hourglass.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the hourglass</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of hourglasss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing hourglasss should be counted. If false or omitted referenced but undefined hourglasss will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Hourglass.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the hourglasss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all hourglasss will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the hourglasss</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Hourglass"/>
    /// </signature>
}

Hourglass.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for hourglass. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Hourglass.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this hourglass.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Hourglass.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the hourglass data in keyword format. Note that this contains the keyword header and the keyword cards. See also Hourglass.Keyword() and Hourglass.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Image = function() {
    /// <field name='COMPRESS' static='true' type='Number'>If compression is done for 8 bit bmp images.</field>
    /// <field name='DITHER' static='true' type='Number'>If dithering is done for 8 bit images.</field>
    /// <field name='OPTIMISE' static='true' type='Number'>If palette optimisation is done for 8 bit images.</field>
    /// <field name='SCREEN' static='true' type='Number'>Image will be created at screen resolution.</field>
    /// <field name='X2' static='true' type='Number'>Image will be created at 2x screen resolution.</field>
    /// <field name='X4' static='true' type='Number'>Image will be created at 4x screen resolution.</field>
}

Image.WriteBMP = function() {
    /// <signature>
    /// <summary>Create a bmp image of the current screen image</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to write. The file will be overwritten if it already exists.</param>
    /// <param name="resolution" type="Number" optional="true">The resolution to write the image at. Can be Image.SCREEN, Image.X2 or Image.X4. If omitted screen resolution will be used</param>
    /// <param name="8bit" type="Boolean" optional="true">BMP images can be written using either 8 bit (256 colours) or 24 bit (16 million colours). If this is true then an 8 bit image will be written. If false (or omitted) a 24 bit image will be written.</param>
    /// <param name="options" type="Number" optional="true">For 8 bit images (see '8bit' argument) the palette can be optimised (Image.OPTIMISE) and/or dithered (Image.DITHER) and/or compressed (Image.COMPRESS) If 0 (or omitted) no palette optimising, dithering or compression will be done.</param>
    /// <returns type="null"/>
    /// </signature>
}

Image.WriteGIF = function() {
    /// <signature>
    /// <summary>Create a gif image of the current screen image</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to write. The file will be overwritten if it already exists.</param>
    /// <param name="resolution" type="Number" optional="true">The resolution to write the image at. Can be Image.SCREEN, Image.X2 or Image.X4. If omitted screen resolution will be used</param>
    /// <param name="palette" type="Number" optional="true">The palette can be optimised (Image.OPTIMISE) and/or dithered (Image.DITHER). If 0 (or omitted) no palette optimising or dithering will be done.</param>
    /// <returns type="null"/>
    /// </signature>
}

Image.WriteJPEG = function() {
    /// <signature>
    /// <summary>Create a jpeg image of the current screen image</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to write. The file will be overwritten if it already exists.</param>
    /// <param name="resolution" type="Number" optional="true">The resolution to write the image at. Can be Image.SCREEN, Image.X2 or Image.X4. If omitted screen resolution will be used</param>
    /// <param name="quality" type="Number" optional="true">Quality of the image in percent. Can be in the range [10,100]. If omitted, the quality is 90.</param>
    /// <returns type="null"/>
    /// </signature>
}

Image.WritePNG = function() {
    /// <signature>
    /// <summary>Create a png image of the current screen image</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to write. The file will be overwritten if it already exists.</param>
    /// <param name="resolution" type="Number" optional="true">The resolution to write the image at. Can be Image.SCREEN, Image.X2 or Image.X4. If omitted screen resolution will be used</param>
    /// <param name="8bit" type="Boolean" optional="true">PNG images can be written using either 8 bit (256 colours) or 24 bit (16 million colours). If this is true then an 8 bit image will be written. If false (or omitted) a 24 bit image will be written.</param>
    /// <param name="palette" type="Number" optional="true">For 8 bit images (see '8bit' argument) the palette can be optimised (Image.OPTIMISE) and/or dithered (Image.DITHER). If 0 (or omitted) no palette optimising or dithering will be done.</param>
    /// <returns type="null"/>
    /// </signature>
}

var Include = function() {
    /// <signature>
    /// <summary>Create a new Include object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that include will be created in</param>
    /// <param name="name" type="String" optional="false">Include filename</param>
    /// <param name="parent" type="Number" optional="true">Parent include file number. If omitted parent will be 0 (main file).</param>
    /// <returns type="Include"/>
    /// </signature>
    /// <field name='comments' static='false' type='String'>Comments stored at the top of the include file. Note that this property is not supported for master include file.</field>
    /// <field name='fctlen' static='false' type='Number'>Length transformation factor. Note that this property is not supported for master include file.</field>
    /// <field name='fctmas' static='false' type='Number'>Mass transformation factor. Note that this property is not supported for master include file.</field>
    /// <field name='fcttem' static='false' type='String'>Temperature transformation factor. Note that this property is not supported for master include file.</field>
    /// <field name='fcttim' static='false' type='Number'>Time transformation factor. Note that this property is not supported for master include file.</field>
    /// <field name='file' static='false' type='String'>The absolute filename for this include file.Note that this property is not supported for master include file. Also see the name and path properties.</field>
    /// <field name='genmax' static='false' type='Number'>Include maximum label range value for general items</field>
    /// <field name='genmin' static='false' type='Number'>Include minimum label range value for general items</field>
    /// <field name='iddoff' static='false' type='Number'>Offset to define ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file.</field>
    /// <field name='ideoff' static='false' type='Number'>Offset to element ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file.</field>
    /// <field name='idfoff' static='false' type='Number'>Offset to function and table ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file.</field>
    /// <field name='idmoff' static='false' type='Number'>Offset to material and equation of state ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file.</field>
    /// <field name='idnoff' static='false' type='Number'>Offset to node ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file.</field>
    /// <field name='idpoff' static='false' type='Number'>Offset to part, nodal rigid body and constrained node set ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file.</field>
    /// <field name='idroff' static='false' type='Number'>Offset to other ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file.</field>
    /// <field name='idsoff' static='false' type='Number'>Offset to set ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file.</field>
    /// <field name='incout' static='false' type='Number'>Create file containing transformed data. Note that this property is not supported for master include file.</field>
    /// <field name='label' static='false' type='Number'>Include number. This number is used to identify the include file. A number is required as it is possible (with include transforms) to have multiple include files with the same name so they cannot be identified by name. The master file is include file number 0. Also see the parent property.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the include is in.</field>
    /// <field name='n_locked_range' static='false' type='Number'>Number of locked label ranges. Note that this does not include label ranges locked model-wide (ALL includes).</field>
    /// <field name='name' static='false' type='String'>The filename for this include file excluding any path. Note that this property is not supported for master include file. Also see the file and path properties.</field>
    /// <field name='nelmax' static='false' type='Number'>Include maximum label range value for nodes/elements/nrbc/const. spotwelds/define HWA items</field>
    /// <field name='nelmin' static='false' type='Number'>Include minimum label range value for nodes/elements/nrbc/const. spotwelds/define HWA items</field>
    /// <field name='parent' static='false' type='Number'>Include number for the parent include file of this include. This number is used to identify the parent include file. A number is required as it is possible (with include transforms) to have multiple include files with the same name so they cannot be identified by name. The master file is include file number 0. Also see the label property. Note that this property is not supported for master include file.</field>
    /// <field name='path' static='false' type='String'>The path for this include file. Note that this property is not supported for master include file. Also see the file and name properties.</field>
    /// <field name='suppressed' static='false' type='Boolean'>If keyout of Include file has been suppressed. Note that this property is not supported for master include file.</field>
    /// <field name='tranid' static='false' type='Number'>Define transformation number. Note that this property is not supported for master include file.</field>
    /// <field name='transform' static='false' type='Boolean'>true if this include file is an *INCLUDE_TRANSFORM, false otherwise. Note that this property is not supported for master include file.</field>
    /// <field name='ABSOLUTE' static='true' type='Number'>Write include file with absolute pathname. See also Model.Write()</field>
    /// <field name='ENDOFF' static='true' type='Number'>Offset applied to Primer post end keywords (Dummy, Mechanism etc.)</field>
    /// <field name='IDDOFF' static='true' type='Number'>Offset to define ID (used in Include.SetTransformOffset() )</field>
    /// <field name='IDEOFF' static='true' type='Number'>Offset to element ID (used in Include.SetTransformOffset() )</field>
    /// <field name='IDFOFF' static='true' type='Number'>Offset to function and table ID (used in Include.SetTransformOffset() )</field>
    /// <field name='IDMOFF' static='true' type='Number'>Offset to material ID (used in Include.SetTransformOffset() )</field>
    /// <field name='IDNOFF' static='true' type='Number'>Offset to node ID (used in Include.SetTransformOffset() )</field>
    /// <field name='IDPOFF' static='true' type='Number'>Offset to part ID (used in Include.SetTransformOffset() )</field>
    /// <field name='IDROFF' static='true' type='Number'>Offset to other ID (used in Include.SetTransformOffset() )</field>
    /// <field name='IDSOFF' static='true' type='Number'>Offset to set ID (used in Include.SetTransformOffset() )</field>
    /// <field name='INDIVIDUAL_GZIP' static='true' type='Number'>Each file 'name.key' is 'gzipped' to become the individual file 'name.key.gz'</field>
    /// <field name='INDIVIDUAL_ZIP' static='true' type='Number'>Each file 'name.key' is 'zipped' to become the individual file 'name.key.zip'</field>
    /// <field name='KEEP_ORIGINAL' static='true' type='Number'>Each file 'name.key' is written using its original compression: uncompressed, '.gz. or '.zip' format</field>
    /// <field name='MASTER_ONLY' static='true' type='Number'>Only write the master file. See also Model.Write()</field>
    /// <field name='MERGE' static='true' type='Number'>Merge include files into the master file. See also Model.Write()</field>
    /// <field name='NATIVE' static='true' type='Number'>Use directory separators native to this machine when writing directory names. See also Model.Write()</field>
    /// <field name='NOT_WRITTEN' static='true' type='Number'>Prevent include files from being written. See also Model.Write()</field>
    /// <field name='RELATIVE' static='true' type='Number'>Write include file with relative pathname. See also Model.Write()</field>
    /// <field name='SAME_DIR' static='true' type='Number'>Write master and include files into the same directory. See also Model.Write()</field>
    /// <field name='SUBDIR' static='true' type='Number'>Write include files to subdirectory. See also Model.Write()</field>
    /// <field name='UNIX' static='true' type='Number'>Use unix directory separators when writing directory names. See also Model.Write()</field>
    /// <field name='WINDOWS' static='true' type='Number'>Use windows directory separators when writing directory names. See also Model.Write()</field>
}

Include.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the includes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all includes will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <param name="masterInclude" type="Boolean" optional="true">If masterInclude file should be blanked or not. If omitted masterInclude is false. The master file is include file number 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged include files in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged includes will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the includes that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the include.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the include</param>
    /// <param name="clear contents" type="Boolean" optional="true">If true then the items in the include file will also have flag cleared. If false (default) then the include file contents are not cleared.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Include.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for an include file. For more details on checking see the Check class. Note that this function is not supported for the master include file.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.First = function() {
    /// <signature>
    /// <summary>Returns the first include file in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first include in</param>
    /// <returns type="Include"/>
    /// </signature>
}

Include.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the includes in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all includes will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the includes</param>
    /// <param name="masterInclude" type="Boolean" optional="true">If masterInclude file should be flagged or not. If omitted masterInclude is false. The master file is include file number 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the include is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the include</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Include.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Include objects for all of the includes in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get includes from</param>
    /// <param name="masterInclude" type="Boolean" optional="true">If masterInclude file should be included or not. If omitted masterInclude is false. The master file is include file number 0.</param>
    /// <returns type="Array" elementType="Include"/>
    /// </signature>
}

Include.prototype.GetDetailedRange = function() {
    /// <signature>
    /// <summary>Gets detailed min and max label ranges for specified type from the include.</summary>
    /// <param name="type argument" type="String" optional="false">Entity type for which ranges are returned</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Include.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Include object for an include label.Note that items that are in the main keyword file will have a layer value of 0 which can be used as the include number argument to this function to return master include file.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the include in</param>
    /// <param name="include number" type="Number" optional="false">number of the include you want the Include object for</param>
    /// <returns type="Include"/>
    /// </signature>
}

Include.prototype.GetLockedLabelData = function() {
    /// <signature>
    /// <summary>Returns the locked label data for include files. Also see the n_locked_range property</summary>
    /// <param name="rangenum" type="Number" optional="false">The range number you want the data for; includes can have multiple ranges. Note that range numbers start at 0, not 1.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Include.prototype.IsEmpty = function() {
    /// <signature>
    /// <summary>Returns true if include is Empty (contains no INSTALLED static/sort/kid/include items).</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Include.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this include (*INCLUDE, *INCLUDE_TRANSFORM). Note that a carriage return is not added. See also Include.KeywordCards(). This function is not supported for the master include file.</summary>
    /// <returns type="String"/>
    /// </signature>
}

Include.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the include. Note that a carriage return is not added. See also Include.Keyword(). Also note that this function is not supported for the master include file.</summary>
    /// <returns type="String"/>
    /// </signature>
}

Include.Last = function() {
    /// <signature>
    /// <summary>Returns the last include file in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last include in</param>
    /// <returns type="Include"/>
    /// </signature>
}

Include.prototype.MakeCurrentLayer = function() {
    /// <signature>
    /// <summary>Sets this include file to be the current layer so that any newly created items are put in this include file. Also see the Model.layer property.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Include.prototype.Modified = function() {
    /// <signature>
    /// <summary>Returns true if include has been modified.</summary>
    /// <param name="listing" type="Boolean" optional="false">false for no listing output, true for listing output</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Include.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next include in the model. Note that this function is not supported for the master include file.</summary>
    /// <returns type="Include"/>
    /// </signature>
}

Include.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick an include.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only includes from that model can be picked. If the argument is a Flag then only includes that are flagged with limit can be selected. If omitted, or null, any includes from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Include"/>
    /// </signature>
}

Include.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous include in the model. Note that this function is not supported for the master include file.</summary>
    /// <returns type="Include"/>
    /// </signature>
}

Include.prototype.RemoveLockedLabelData = function() {
    /// <signature>
    /// <summary>Removes the locked label data for a range in include files. Also see the n_locked_range property</summary>
    /// <param name="rangenum" type="Number" optional="false">The locked label range you want to remove. Note that range numbers start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select includes using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting includes</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="Model" type="Model" optional="true">Model to select from</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Include.prototype.SetDetailedRange = function() {
    /// <signature>
    /// <summary>Sets detailed min and max label ranges for specified type on the include.</summary>
    /// <param name="type argument" type="String" optional="false">Entity type for which ranges are to be defined</param>
    /// <param name="min label" type="Number" optional="false">Defines the smallest label for entities of this type</param>
    /// <param name="max label" type="Number" optional="false">Defines the largest label for entities of this type</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the include.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the include</param>
    /// <param name="flag contents" type="Boolean" optional="true">If true then the items in the include file will also be flagged. If false (default) then the include file contents are not flagged.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Include.prototype.SetLockedLabelData = function() {
    /// <signature>
    /// <summary>Sets the locked label data for a particular range for an include file. Also see the n_locked_range property</summary>
    /// <param name="rangenum" type="Number" optional="false">The range you want to set the data for. Note that range numbers start at 0, not 1.</param>
    /// <param name="min" type="Number" optional="false">Start (min) label for a locked range.</param>
    /// <param name="max" type="Number" optional="false">End (max) label for a locked range.</param>
    /// <param name="type" type="String" optional="false">Entity type code - "NODE", "SHELL" etc. Can also be "ALL" (for a list of types see Appendix I of the PRIMER manual).</param>
    /// <param name="safe" type="Boolean" optional="true">Determines whether a locked range is safe (protected).</param>
    /// <param name="all_includes" type="Boolean" optional="true">Specified range will be set model-wide (all includes). Only useful when working with the 'master' include.</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.prototype.SetTransformOffset = function() {
    /// <signature>
    /// <summary>Sets offset values for include transform. This function is required to change the offset values rather than changing the properties directly so that the include can be checked to ensure that the new value does not cause any label clashes with existing items or any negative labels when the transform is unapplied when writing the include. Note that this function is not supported for the master include file.</summary>
    /// <param name="offset" type="Number" optional="false">The include transform offset type to change. Can be Include.IDNOFF, Include.IDEOFF, Include.IDPOFF, Include.IDMOFF, Include.IDSOFF, Include.IDFOFF, Include.IDDOFF or Include.IDROFF.</param>
    /// <param name="value" type="Number" optional="false">The value to change the offset to</param>
    /// <param name="check_only" type="Boolean" optional="true">Sometimes it may be necessary to check if changing an offset for an include will cause an error or label clash rather than actually changing it. If check only is true then Primer will just check to see if the new value for the offset will cause any label clashes or negative labels and not change the offset value or any item labels. If false or omitted then the offset and labels will be updated if there are no errors.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Include.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of include files in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get include total from</param>
    /// <returns type="Number"/>
    /// </signature>
}

Include.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the includes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all includes will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged include files in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged includes will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the includes that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the includes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all includes will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the includes</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for an include file. For more details on checking see the Check class. Note that this function is not supported for the master include file.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.prototype.Write = function() {
    /// <signature>
    /// <summary>Writes an include file. Note that this function is not supported for the master include file.</summary>
    /// <param name="filename" type="String" optional="false">Filename of the LS-Dyna keyword file you want to write</param>
    /// <param name="options" type="Object" optional="true">Options specifying how the file should be written out. If omitted the default values below will be used. The properties available are:</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.prototype.Write_#deprecated = function() {
    /// <signature>
    /// <summary>Writes an include file. Note that this function is not supported for the master include file.</summary>
    /// <param name="filename" type="String" optional="false">Filename of the LS-Dyna keyword file you want to write</param>
    /// <param name="path" type="Number" optional="true">The method used to write include paths. Can be Include.ABSOLUTE (default) or Include.RELATIVE</param>
    /// <param name="separator" type="Number" optional="true">The directory separator used when writing include files. Can be Include.NATIVE (default), Include.UNIX or Include.WINDOWS</param>
    /// <param name="version" type="String" optional="true">The LS-DYNA version used to write the file. Can be "971R5", "971R4", "971R3", "970v6763" etc. (see the version popup in Model-&gt;Write '&gt;&gt;&gt; LS-Dyna output options' for a full list). See also Options.dyna_version</param>
    /// <param name="large" type="Boolean" optional="true">If true then large format will be used to write the file. If false (default) then the normal LS-DYNA format will be used. Note that large format is only available from version R7.1 and above.</param>
    /// <returns type="null"/>
    /// </signature>
}

Include.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the include data in keyword format. Note that this contains the keyword header and the keyword cards. See also Include.Keyword() and Include.KeywordCards(). Also note that this function is not supported for the master include file.</summary>
    /// <returns type="String"/>
    /// </signature>
}

var IntegrationBeam = function() {
    /// <signature>
    /// <summary>Create a new IntegrationBeam object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that intb will be created in.</param>
    /// <param name="irid" type="Number" optional="false">Integration_Beam ID.</param>
    /// <param name="nip" type="Number" optional="true">Number of integration points. If omitted nip will be 0.</param>
    /// <param name="ra" type="Number" optional="true">Relative area of cross section. If omitted ra will be 0.</param>
    /// <param name="icst" type="Number" optional="true">Standard cross section type. If omitted icst will be 0.</param>
    /// <param name="k" type="Number" optional="true">Integration refinement parameter for standard cross section types. If omitted k will be 0.</param>
    /// <returns type="IntegrationBeam"/>
    /// </signature>
    /// <field name='d1' static='false' type='Number'>Cross-section dimension.</field>
    /// <field name='d2' static='false' type='Number'>Cross-section dimension.</field>
    /// <field name='d3' static='false' type='Number'>Cross-section dimension.</field>
    /// <field name='d4' static='false' type='Number'>Cross-section dimension.</field>
    /// <field name='exists' static='false' type='Boolean'>true if intb exists, false if referred to but not defined. (read only)</field>
    /// <field name='icst' static='false' type='Number'>Standard cross section type.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the intb is in.</field>
    /// <field name='irid' static='false' type='Number'>Integration rule id.</field>
    /// <field name='k' static='false' type='Number'>Integration refinement parameter for standard cross section types.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the integration beam is in.</field>
    /// <field name='nip' static='false' type='Number'>Number of integration points.</field>
    /// <field name='pid' static='false' type='Part'>Optional part ID if different from the PID specified on the element card.</field>
    /// <field name='ra' static='false' type='Number'>Relative area of cross section.</field>
    /// <field name='s' static='false' type='Number'>Normalized s coordinate of integration point.</field>
    /// <field name='sref' static='false' type='Number'>Location of reference surface normal to s, for the Hughes-Liu beam only.</field>
    /// <field name='t' static='false' type='Number'>Normalized t coordinate of integration point.</field>
    /// <field name='tref' static='false' type='Number'>Location of reference surface normal to t, for the Hughes-Liu beam only.</field>
    /// <field name='wf' static='false' type='Number'>Weighting factor (area associated with integration point divided by actual cross sectional area).</field>
}

IntegrationBeam.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the integration beam.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the integration beam</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the integration beam.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a intb.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the intb will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for integration beam. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.First = function() {
    /// <signature>
    /// <summary>Returns the first integration beam in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first integration beam in</param>
    /// <returns type="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free integration beam label in the model. Also see IntegrationBeam.LastFreeLabel(), IntegrationBeam.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free integration beam label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationBeam.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the integration beams in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all integration beams will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the integration beams</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the integration beam is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the integration beam</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

IntegrationBeam.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each integration beam in the model. Note that ForEach has been designed to make looping over integration beams as fast as possible and so has some limitations. Firstly, a single temporary IntegrationBeam object is created and on each function call it is updated with the current integration beam data. This means that you should not try to store the IntegrationBeam object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new integration beams inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all integration beams are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each integration beam</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of IntegrationBeam objects for all of the integration beams in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get integration beams from</param>
    /// <returns type="Array" elementType="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of IntegrationBeam objects for all of the flagged integration beams in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get integration beams from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the integration beams that you want to retrieve</param>
    /// <returns type="Array" elementType="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the IntegrationBeam object for a integration beam ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the integration beam in</param>
    /// <param name="number" type="Number" optional="false">number of the integration beam you want the IntegrationBeam object for</param>
    /// <returns type="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.prototype.GetIntegrationPoint = function() {
    /// <signature>
    /// <summary>Returns the data for an integration point in *INTEGRATION_BEAM.Note data is only available when NIP&gt;0.</summary>
    /// <param name="index" type="Number" optional="false">Index you want the integration point data for. Note that indices start at 0.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

IntegrationBeam.prototype.GetNipCard_#deprecated = function() {
    /// <signature>
    /// <summary>Please use IntegrationBeam.GetIntegrationPoint() instead.</summary>
    /// </signature>
}

IntegrationBeam.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a IntegrationBeam property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the IntegrationBeam.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">integration beam property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

IntegrationBeam.prototype.GetSectionData_#deprecated = function() {
    /// <signature>
    /// <summary>Use properties d1, d2, sref etc to get the section data.</summary>
    /// </signature>
}

IntegrationBeam.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this intb (*INTEGRATION_BEAM). Note that a carriage return is not added. See also IntegrationBeam.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

IntegrationBeam.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the intb. Note that a carriage return is not added. See also IntegrationBeam.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

IntegrationBeam.Last = function() {
    /// <signature>
    /// <summary>Returns the last integration beam in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last integration beam in</param>
    /// <returns type="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free integration beam label in the model. Also see IntegrationBeam.FirstFreeLabel(), IntegrationBeam.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free integration beam label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationBeam.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next integration beam in the model.</summary>
    /// <returns type="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) integration beam label in the model. Also see IntegrationBeam.FirstFreeLabel(), IntegrationBeam.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free integration beam label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationBeam.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous integration beam in the model.</summary>
    /// <returns type="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the integration beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all integration beams will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged integration beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged integration beams will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the integration beams that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select integration beams using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting integration beams</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only integration beams from that model can be selected. If the argument is a Flag then only integration beams that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any integration beams can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationBeam.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the integration beam.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the integration beam</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.prototype.SetIntegrationPoint = function() {
    /// <signature>
    /// <summary>Sets the integration point data for an *INTEGRATION_BEAM.</summary>
    /// <param name="index" type="Number" optional="false">Index you want to set the integration point data for. Note that indices start at 0.</param>
    /// <param name="s" type="Number" optional="false">s coordinate of integration point in range -1 to 1.</param>
    /// <param name="t" type="Number" optional="false">s coordinate of integration point in range -1 to 1.</param>
    /// <param name="wf" type="Number" optional="false">Weighting factor, area associated with the integration point divided by actual beam cross sectional area.</param>
    /// <param name="pid" type="Number" optional="true">Optional part ID if different from the PID specified on the element card.</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.prototype.SetNipCard_#deprecated = function() {
    /// <signature>
    /// <summary>Please use IntegrationBeam.SetIntegrationPoint() instead.</summary>
    /// </signature>
}

IntegrationBeam.prototype.SetSectionData_#deprecated = function() {
    /// <signature>
    /// <summary>Use properties d1, d2, sref etc to set the section data.</summary>
    /// </signature>
}

IntegrationBeam.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of integration beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing integration beams should be counted. If false or omitted referenced but undefined integration beams will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationBeam.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the integration beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all integration beams will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the integration beams</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="IntegrationBeam"/>
    /// </signature>
}

IntegrationBeam.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for integration beam. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationBeam.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this integration beam.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

IntegrationBeam.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the intb data in keyword format. Note that this contains the keyword header and the keyword cards. See also IntegrationBeam.Keyword() and IntegrationBeam.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var IntegrationShell = function() {
    /// <signature>
    /// <summary>Create a new IntegrationShell object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that ints will be created in.</param>
    /// <param name="irid" type="Number" optional="false">Integration_Beam ID.</param>
    /// <param name="nip" type="Number" optional="false">Number of integration points.</param>
    /// <param name="esop" type="Number" optional="true">Equal spacing of integration points option. If omitted esop will be 0.</param>
    /// <param name="failopt" type="Number" optional="true">Treatment of failure when mixing different constitutive types. If omitted failopt will be 0.</param>
    /// <returns type="IntegrationShell"/>
    /// </signature>
    /// <field name='esop' static='false' type='Number'>Equal spacing of integration points option.</field>
    /// <field name='exists' static='false' type='Boolean'>true if ints exists, false if referred to but not defined. (read only)</field>
    /// <field name='failopt' static='false' type='Number'>Treatment of failure when mixing different constitutive types.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the ints is in.</field>
    /// <field name='irid' static='false' type='Number'>Integration rule id.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the integration shell is in.</field>
    /// <field name='nip' static='false' type='Number'>Number of integration points.</field>
    /// <field name='pid' static='false' type='Part'>Optional part ID if different from the PID specified on the element card.</field>
    /// <field name='s' static='false' type='Number'>Coordinate of integration point in range -1 to 1.</field>
    /// <field name='wf' static='false' type='Number'>Weighting factor (thickness associated with integration point divided by actual shell thickness).</field>
}

IntegrationShell.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the integration shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the integration shell</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the integration shell.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a ints.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the ints will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for integration shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.First = function() {
    /// <signature>
    /// <summary>Returns the first integration shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first integration shell in</param>
    /// <returns type="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free integration shell label in the model. Also see IntegrationShell.LastFreeLabel(), IntegrationShell.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free integration shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationShell.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the integration shells in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all integration shells will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the integration shells</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the integration shell is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the integration shell</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

IntegrationShell.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each integration shell in the model. Note that ForEach has been designed to make looping over integration shells as fast as possible and so has some limitations. Firstly, a single temporary IntegrationShell object is created and on each function call it is updated with the current integration shell data. This means that you should not try to store the IntegrationShell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new integration shells inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all integration shells are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each integration shell</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of IntegrationShell objects for all of the integration shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get integration shells from</param>
    /// <returns type="Array" elementType="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of IntegrationShell objects for all of the flagged integration shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get integration shells from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the integration shells that you want to retrieve</param>
    /// <returns type="Array" elementType="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the IntegrationShell object for a integration shell ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the integration shell in</param>
    /// <param name="number" type="Number" optional="false">number of the integration shell you want the IntegrationShell object for</param>
    /// <returns type="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.prototype.GetIntegrationPoint = function() {
    /// <signature>
    /// <summary>Returns the data for an integration point in *INTEGRATION_SHELL.Note data is only available when NIP&gt;0 and ESOP=0.</summary>
    /// <param name="index" type="Number" optional="false">Index you want the integration point data for. Note that indices start at 0.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

IntegrationShell.prototype.GetNipCard_#deprecated = function() {
    /// <signature>
    /// <summary>Please use IntegrationShell.GetIntegrationPoint() instead.</summary>
    /// </signature>
}

IntegrationShell.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a IntegrationShell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the IntegrationShell.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">integration shell property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

IntegrationShell.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this ints (*INTEGRATION_SHELL). Note that a carriage return is not added. See also IntegrationShell.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

IntegrationShell.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the ints. Note that a carriage return is not added. See also IntegrationShell.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

IntegrationShell.Last = function() {
    /// <signature>
    /// <summary>Returns the last integration shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last integration shell in</param>
    /// <returns type="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free integration shell label in the model. Also see IntegrationShell.FirstFreeLabel(), IntegrationShell.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free integration shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationShell.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next integration shell in the model.</summary>
    /// <returns type="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) integration shell label in the model. Also see IntegrationShell.FirstFreeLabel(), IntegrationShell.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free integration shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationShell.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous integration shell in the model.</summary>
    /// <returns type="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the integration shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all integration shells will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged integration shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged integration shells will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the integration shells that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select integration shells using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting integration shells</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only integration shells from that model can be selected. If the argument is a Flag then only integration shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any integration shells can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationShell.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the integration shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the integration shell</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.prototype.SetIntegrationPoint = function() {
    /// <signature>
    /// <summary>Sets the integration point data for an *INTEGRATION_SHELL.</summary>
    /// <param name="index" type="Number" optional="false">Index you want to set the integration point data for. Note that indices start at 0.</param>
    /// <param name="s" type="Number" optional="false">Coordinate of integration point in range -1 to 1.</param>
    /// <param name="wf" type="Number" optional="false">Weighting factor, thickness associated with the integration point divided by actual shell thickness.</param>
    /// <param name="pid" type="Number" optional="true">Optional part ID if different from the PID specified on the element card.</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.prototype.SetNipCard_#deprecated = function() {
    /// <signature>
    /// <summary>Please use IntegrationShell.SetIntegrationPoint() instead.</summary>
    /// </signature>
}

IntegrationShell.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of integration shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing integration shells should be counted. If false or omitted referenced but undefined integration shells will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

IntegrationShell.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the integration shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all integration shells will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the integration shells</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="IntegrationShell"/>
    /// </signature>
}

IntegrationShell.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for integration shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

IntegrationShell.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this integration shell.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

IntegrationShell.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the ints data in keyword format. Note that this contains the keyword header and the keyword cards. See also IntegrationShell.Keyword() and IntegrationShell.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var InterfaceComponent = function() {
    /// <signature>
    /// <summary>Create a new InterfaceComponent object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that InterfaceComponent will be created in</param>
    /// <param name="type" type="Number" optional="false">InterfaceComponent type. Can be InterfaceComponent.NODE, InterfaceComponent.SEGMENT,</param>
    /// <param name="snid/ssid" type="Number" optional="false">Set node or set segment ID</param>
    /// <param name="cid" type="Number" optional="false">Coordinate system ID</param>
    /// <param name="nid" type="Number" optional="false">Node ID</param>
    /// <param name="label" type="Number" optional="true">InterfaceComponent number</param>
    /// <param name="title" type="String" optional="true">Title for this interface</param>
    /// <returns type="InterfaceComponent"/>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>Coordinate system ID.</field>
    /// <field name='exists' static='false' type='Boolean'>true if interface component exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the interface component is in.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the interface component is in.</field>
    /// <field name='nid' static='false' type='Number'>Node ID.</field>
    /// <field name='nsid' static='false' type='Number'>Element ID or element set ID. The ssid property is an alternative name for this.</field>
    /// <field name='option' static='false' type='Number'>InterfaceComponent option. Can be InterfaceComponent.NODE, InterfaceComponent.SEGMENT,</field>
    /// <field name='ssid' static='false' type='Number'>Element ID or element set ID. The nsid property is an alternative name for this.</field>
    /// <field name='title' static='false' type='String'>InterfaceComponent title</field>
    /// <field name='NODE' static='true' type='Number'>Node option</field>
    /// <field name='SEGMENT' static='true' type='Number'>Segment option</field>
}

InterfaceComponent.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the interface component.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the interface component</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the interface component.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an InterfaceComponent.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the InterfaceComponent will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for interface component. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.First = function() {
    /// <signature>
    /// <summary>Returns the first interface component in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first interface component in</param>
    /// <returns type="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free interface component label in the model. Also see InterfaceComponent.LastFreeLabel(), InterfaceComponent.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free interface component label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterfaceComponent.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the interface components in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all interface components will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the interface components</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the interface component is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the interface component</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

InterfaceComponent.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each interface component in the model. Note that ForEach has been designed to make looping over interface components as fast as possible and so has some limitations. Firstly, a single temporary InterfaceComponent object is created and on each function call it is updated with the current interface component data. This means that you should not try to store the InterfaceComponent object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new interface components inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all interface components are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each interface component</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of InterfaceComponent objects for all of the interface components in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get interface components from</param>
    /// <returns type="Array" elementType="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of InterfaceComponent objects for all of the flagged interface components in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get interface components from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the interface components that you want to retrieve</param>
    /// <returns type="Array" elementType="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the InterfaceComponent object for a interface component ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the interface component in</param>
    /// <param name="number" type="Number" optional="false">number of the interface component you want the InterfaceComponent object for</param>
    /// <returns type="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a InterfaceComponent property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the InterfaceComponent.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">interface component property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

InterfaceComponent.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this InterfaceComponent (*INTERFACE_COMPONENT). Note that a carriage return is not added. See also InterfaceComponent.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

InterfaceComponent.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the InterfaceComponent. Note that a carriage return is not added. See also InterfaceComponent.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

InterfaceComponent.Last = function() {
    /// <signature>
    /// <summary>Returns the last interface component in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last interface component in</param>
    /// <returns type="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free interface component label in the model. Also see InterfaceComponent.FirstFreeLabel(), InterfaceComponent.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free interface component label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterfaceComponent.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next interface component in the model.</summary>
    /// <returns type="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) interface component label in the model. Also see InterfaceComponent.FirstFreeLabel(), InterfaceComponent.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free interface component label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterfaceComponent.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous interface component in the model.</summary>
    /// <returns type="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the interface components in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all interface components will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged interface components in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged interface components will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the interface components that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select interface components using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting interface components</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only interface components from that model can be selected. If the argument is a Flag then only interface components that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any interface components can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterfaceComponent.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the interface component.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the interface component</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of interface components in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing interface components should be counted. If false or omitted referenced but undefined interface components will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterfaceComponent.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the interface components in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all interface components will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the interface components</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="InterfaceComponent"/>
    /// </signature>
}

InterfaceComponent.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for interface component. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceComponent.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this interface component.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

InterfaceComponent.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the InterfaceComponent data in keyword format. Note that this contains the keyword header and the keyword cards. See also InterfaceComponent.Keyword() and InterfaceComponent.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var InterfaceLinkingEdge = function() {
    /// <signature>
    /// <summary>Create a new InterfaceLinkingEdge object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that Interface Linking Edge will be created in</param>
    /// <param name="nsid" type="Number" optional="false">Node set ID</param>
    /// <param name="ifid" type="Number" optional="false">Interface ID</param>
    /// <returns type="InterfaceLinkingEdge"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if Interface Linking Edge exists, false if referred to but not defined. (read only)</field>
    /// <field name='ifid' static='false' type='Number'>Interface ID.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the Interface Linking Edge is in.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the Interface Linking Edge is in.</field>
    /// <field name='nsid' static='false' type='Number'>Node set  ID</field>
}

InterfaceLinkingEdge.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the Interface Linking Edge.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the Interface Linking Edge</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the Interface Linking Edge.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="InterfaceLinkingEdge"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for Interface Linking Edge. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceLinkingEdge.First = function() {
    /// <signature>
    /// <summary>Returns the first Interface Linking Edge in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first Interface Linking Edge in</param>
    /// <returns type="InterfaceLinkingEdge"/>
    /// </signature>
}

InterfaceLinkingEdge.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the Interface Linking Edges in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all Interface Linking Edges will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the Interface Linking Edges</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the Interface Linking Edge is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the Interface Linking Edge</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

InterfaceLinkingEdge.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each Interface Linking Edge in the model. Note that ForEach has been designed to make looping over Interface Linking Edges as fast as possible and so has some limitations. Firstly, a single temporary InterfaceLinkingEdge object is created and on each function call it is updated with the current Interface Linking Edge data. This means that you should not try to store the InterfaceLinkingEdge object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new Interface Linking Edges inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all Interface Linking Edges are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each Interface Linking Edge</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceLinkingEdge.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of InterfaceLinkingEdge objects for all of the Interface Linking Edges in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get Interface Linking Edges from</param>
    /// <returns type="Array" elementType="InterfaceLinkingEdge"/>
    /// </signature>
}

InterfaceLinkingEdge.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of InterfaceLinkingEdge objects for all of the flagged Interface Linking Edges in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get Interface Linking Edges from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the Interface Linking Edges that you want to retrieve</param>
    /// <returns type="Array" elementType="InterfaceLinkingEdge"/>
    /// </signature>
}

InterfaceLinkingEdge.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the InterfaceLinkingEdge object for a Interface Linking Edge ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the Interface Linking Edge in</param>
    /// <param name="number" type="Number" optional="false">number of the Interface Linking Edge you want the InterfaceLinkingEdge object for</param>
    /// <returns type="InterfaceLinkingEdge"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a InterfaceLinkingEdge property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the InterfaceLinkingEdge.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">Interface Linking Edge property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this Interface Linking Edge (*INTERFACE_LINKING_EDGE). Note that a carriage return is not added. See also InterfaceLinkingEdge.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the Interface Linking Edge. Note that a carriage return is not added. See also InterfaceLinkingEdge.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

InterfaceLinkingEdge.Last = function() {
    /// <signature>
    /// <summary>Returns the last Interface Linking Edge in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last Interface Linking Edge in</param>
    /// <returns type="InterfaceLinkingEdge"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next Interface Linking Edge in the model.</summary>
    /// <returns type="InterfaceLinkingEdge"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous Interface Linking Edge in the model.</summary>
    /// <returns type="InterfaceLinkingEdge"/>
    /// </signature>
}

InterfaceLinkingEdge.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select Interface Linking Edges using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting Interface Linking Edges</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only Interface Linking Edges from that model can be selected. If the argument is a Flag then only Interface Linking Edges that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any Interface Linking Edges can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the Interface Linking Edge.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the Interface Linking Edge</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceLinkingEdge.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of Interface Linking Edges in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing Interface Linking Edges should be counted. If false or omitted referenced but undefined Interface Linking Edges will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterfaceLinkingEdge.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the Interface Linking Edges in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all Interface Linking Edges will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the Interface Linking Edges</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="InterfaceLinkingEdge"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for Interface Linking Edge. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this Interface Linking Edge.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

InterfaceLinkingEdge.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the Interface Linking Edge data in keyword format. Note that this contains the keyword header and the keyword cards. See also InterfaceLinkingEdge.Keyword() and InterfaceLinkingEdge.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var InterfaceSpringback = function() {
    /// <signature>
    /// <summary>Create a new InterfaceSpringback object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that interface springback will be created in</param>
    /// <param name="Type" type="Number" optional="false">Specify the type of InterfaceSpringback (Can be InterfaceSpringback.NIKE3D or InterfaceSpringback.LSDYNA or InterfaceSpringback.NASTRAN or InterfaceSpringback.SEAMLESS )</param>
    /// <param name="psid" type="Number" optional="true">Part set  ID for springback.</param>
    /// <param name="nshv" type="Number" optional="true">Num additional Shell/Solid history variables number.</param>
    /// <param name="ftype" type="Number" optional="true">Filetype (0-3, 10-12).</param>
    /// <param name="ftensr" type="Number" optional="true">Flag for dumping tensor data from the element history variables into the dynain file (0/1).</param>
    /// <param name="nthhsv" type="Number" optional="true">Number of thermal history variables.</param>
    /// <param name="intstrn" type="Number" optional="true">Output of strains at all integration points of shell element is requested.</param>
    /// <param name="optcard" type="Boolean" optional="true">Whether to have an optional card. Can be true or false.</param>
    /// <param name="sldo" type="Number" optional="true">Output of solid element data as 0 - *ELEMENT_SOLID, 1- *ELEM_SOLID_ORTHO. Used only for optional card.</param>
    /// <param name="ncyc" type="Number" optional="true">Number of process cycles. Used only for optional card.</param>
    /// <param name="fsplit" type="Number" optional="true">Flag for splitting of the dynain file (0 - One file, 1 - Two files.). Used only for optional card.</param>
    /// <param name="ndflag" type="Number" optional="true">Flag to dump nodes into dynain file.</param>
    /// <param name="cflag" type="Number" optional="true">Output contact state.</param>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new InterfaceSpringback object with InterfaceSpringback.EXCLUDE option.</summary>
    /// <param name="Model" type="Model" optional="false">Model that interface springback will be created in</param>
    /// <param name="Type" type="Number" optional="false">Specify the type of InterfaceSpringback (Should be InterfaceSpringback.EXCLUDE )</param>
    /// <param name="keylist" type="String" optional="true">List of keywords to be excluded.</param>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
    /// <field name='cflag' static='false' type='Number'>Output contact state.</field>
    /// <field name='exists' static='false' type='Boolean'>true if interface springback exists, false if referred to but not defined. (read only)</field>
    /// <field name='fsplit' static='false' type='Number'>Flag for splitting of the dynain file (0 - One file, 1 - Two files.). Used for OPTCARD field.</field>
    /// <field name='ftensr' static='false' type='Number'>Flag for dumping tensor data from the element history variables into the dynain file (0/1).</field>
    /// <field name='ftype' static='false' type='Number'>Filetype (0-3, 10-12).</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the interface springback is in.</field>
    /// <field name='intstrn' static='false' type='Number'>Output of strains at all integration points of shell element is requested.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the interface springback is in.</field>
    /// <field name='ncyc' static='false' type='Number'>Number of process cycles. Used for OPTCARD field.</field>
    /// <field name='ndflag' static='false' type='Number'>Flag to dump nodes into dynain file.</field>
    /// <field name='nexclude' static='false' type='Number'>gives the number of excluded keywords. Needed only for InterfaceSpringback.EXCLUDE.</field>
    /// <field name='nnodes' static='false' type='Number'>gives the number of nodal points constrained for this keyword. (read_only)</field>
    /// <field name='nothickness' static='false' type='Boolean'>true if _NOTHICKNESS (option2) is set. _NOTHICKNESS can be used only for InterfaceSpringback.LSDYNA or InterfaceSpringback.NASTRAN.</field>
    /// <field name='nshv' static='false' type='Number'>Num additional Shell/Solid history variables number.</field>
    /// <field name='nthhsv' static='false' type='Number'>Number of thermal history variables.</field>
    /// <field name='optcard' static='false' type='Boolean'>Whether to have a OPTCARD. Can be true or false.</field>
    /// <field name='psid' static='false' type='Number'>Part set  ID for springback.</field>
    /// <field name='sldo' static='false' type='Number'>Output of solid element data as 0 - *ELEMENT_SOLID, 1- *ELEM_SOLID_ORTHO. Used for OPTCARD field.</field>
    /// <field name='type' static='false' type='Number'>gives the type of InterfaceSpringback object. (read only)</field>
    /// <field name='EXCLUDE' static='true' type='Number'>INTERFACE is *INTERFACE_SPRINGBACK_EXCLUDE.</field>
    /// <field name='LSDYNA' static='true' type='Number'>INTERFACE is *INTERFACE_SPRINGBACK_LSDYNA.</field>
    /// <field name='NASTRAN' static='true' type='Number'>INTERFACE is *INTERFACE_SPRINGBACK_NASTRAN.</field>
    /// <field name='NIKE3D' static='true' type='Number'>INTERFACE is *INTERFACE_SPRINGBACK_NIKE3D.</field>
    /// <field name='SEAMLESS' static='true' type='Number'>INTERFACE is *INTERFACE_SPRINGBACK_SEAMLESS.</field>
}

InterfaceSpringback.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the interface springback.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the interface springback</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the interface springback.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an InterfaceSpringback definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the InterfaceSpringback will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for interface springback. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.First = function() {
    /// <signature>
    /// <summary>Returns the first interface springback in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first interface springback in</param>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the interface springbacks in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all interface springbacks will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the interface springbacks</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the interface springback is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the interface springback</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

InterfaceSpringback.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each interface springback in the model. Note that ForEach has been designed to make looping over interface springbacks as fast as possible and so has some limitations. Firstly, a single temporary InterfaceSpringback object is created and on each function call it is updated with the current interface springback data. This means that you should not try to store the InterfaceSpringback object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new interface springbacks inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all interface springbacks are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each interface springback</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of InterfaceSpringback objects for all of the interface springbacks in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get interface springbacks from</param>
    /// <returns type="Array" elementType="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.prototype.GetExcludeKeyword = function() {
    /// <signature>
    /// <summary>Returns the keyword string excluded at given index in Keyword list. Needed only for InterfaceSpringback.EXCLUDE.</summary>
    /// <param name="idx" type="Number" optional="false">The index in Keyword list you want the Keyword string for. Note that indices start at 0, not 1.</param>
    /// <returns type="String"/>
    /// </signature>
}

InterfaceSpringback.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of InterfaceSpringback objects for all of the flagged interface springbacks in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get interface springbacks from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the interface springbacks that you want to retrieve</param>
    /// <returns type="Array" elementType="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the InterfaceSpringback object for a interface springback ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the interface springback in</param>
    /// <param name="number" type="Number" optional="false">number of the interface springback you want the InterfaceSpringback object for</param>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.prototype.GetNodalPoint = function() {
    /// <signature>
    /// <summary>Returns the data for nodal point constrained for *INTERFACE_SPRINGBACK.</summary>
    /// <param name="npt" type="Number" optional="false">The nodal point you want the data for. Note that nodal points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

InterfaceSpringback.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a InterfaceSpringback property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the InterfaceSpringback.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">interface springback property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

InterfaceSpringback.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this Interface Springback (*INTERFACE_SPRINGBACK_xxxx_xxxx) Note that a carriage return is not added. See also InterfaceSpringback.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

InterfaceSpringback.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the InterfaceSpringback. Note that a carriage return is not added. See also InterfaceSpringback.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

InterfaceSpringback.Last = function() {
    /// <signature>
    /// <summary>Returns the last interface springback in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last interface springback in</param>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next interface springback in the model.</summary>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous interface springback in the model.</summary>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.prototype.RemoveExcludeKeyword = function() {
    /// <signature>
    /// <summary>Removes the keyword string excluded at given index in Keyword list. Needed only for InterfaceSpringback.EXCLUDE</summary>
    /// <param name="idx" type="Number" optional="false">The index in Keyword list you removed. Note that indices start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.prototype.RemoveNodalPoint = function() {
    /// <signature>
    /// <summary>Removes the nodal point for constrained node for *INTERFACE_SPRINGBACK.</summary>
    /// <param name="npt" type="Number" optional="false">The nodal point you want to remove. Note that nodal points start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select interface springbacks using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting interface springbacks</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only interface springbacks from that model can be selected. If the argument is a Flag then only interface springbacks that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any interface springbacks can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterfaceSpringback.prototype.SetExcludeKeyword = function() {
    /// <signature>
    /// <summary>Sets a keyword string to be excluded. Adds a new keyword if index value is not given, else replaces the keyword string at given index. Note that indices start at 0, not 1. Needed only for InterfaceSpringback.EXCLUDE</summary>
    /// <param name="keystr" type="String" optional="false">The keyword string you want to be excluded.</param>
    /// <param name="index" type="Number" optional="true">The index at which keyword string should be set.</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the interface springback.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the interface springback</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.prototype.SetNodalPoint = function() {
    /// <signature>
    /// <summary>Sets the nodal point data for a node in *INTERFACE_SPRINGBACK.</summary>
    /// <param name="npt" type="Number" optional="false">The nodal point you want to set the data for. Note that nodal points start at 0, not 1.</param>
    /// <param name="nid" type="Number" optional="false">Node ID for the nodal point.</param>
    /// <param name="tc" type="Number" optional="false">Translational constraint constant of the nodal point. (0-7)</param>
    /// <param name="rc" type="Number" optional="false">Rotational constraint constant of the nodal point. (0-7)</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of interface springbacks in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing interface springbacks should be counted. If false or omitted referenced but undefined interface springbacks will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterfaceSpringback.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the interface springbacks in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all interface springbacks will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the interface springbacks</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="InterfaceSpringback"/>
    /// </signature>
}

InterfaceSpringback.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for interface springback. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

InterfaceSpringback.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this interface springback.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

InterfaceSpringback.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the InterfaceSpringback data in keyword format. Note that this contains the keyword header and the keyword cards. See also InterfaceSpringback.Keyword() and InterfaceSpringback.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Interpolation = function() {
    /// <signature>
    /// <summary>Create a new Interpolation object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that Interpolation will be created in</param>
    /// <param name="icid" type="Number" optional="false">Interpolation label</param>
    /// <param name="dnid" type="Number" optional="false">Dependent Node id.</param>
    /// <param name="inid" type="Number" optional="false">Independent Node or Node Set id.</param>
    /// <param name="ddof" type="Number" optional="true">Dependent Degrees-of-Freedom. The default value is 123456.</param>
    /// <param name="local" type="Boolean" optional="true">true if _LOCAL is set.</param>
    /// <param name="cidd" type="Number" optional="true">Coordinate System ID if LOCAL option is active. The default value is 0.</param>
    /// <param name="ityp" type="Number" optional="true">The Independent Node type. Can be Interpolation.NODE or Interpolation.NODE_SET. The default value is Interpolation.NODE.</param>
    /// <param name="idof" type="Number" optional="true">Independent Degrees-of-Freedom. The default value is 123456.</param>
    /// <param name="twghtx" type="Number" optional="true">Weighting factor for INID. Scales the x-translational component. The default value is 1.0.</param>
    /// <param name="twghty" type="Number" optional="true">Weighting factor for INID. Scales the y-translational component. The default value is twghtx.</param>
    /// <param name="twghtz" type="Number" optional="true">Weighting factor for INID. Scales the z-translational component. The default value is twghtx.</param>
    /// <param name="rwghtx" type="Number" optional="true">Weighting factor for INID. Scales the x-rotational component. The default value is twghtx.</param>
    /// <param name="rwghty" type="Number" optional="true">Weighting factor for INID. Scales the y-rotational component. The default value is twghtx.</param>
    /// <param name="rwghtz" type="Number" optional="true">Weighting factor for INID. Scales the z-rotational component. The default value is twghtx.</param>
    /// <param name="cidi" type="Number" optional="true">Coordinate System ID if LOCAL option is active. The default value is 0</param>
    /// <returns type="Interpolation"/>
    /// </signature>
    /// <field name='cidd' static='false' type='Number'>Coordinate System ID if LOCAL option is active.</field>
    /// <field name='ddof' static='false' type='Number'>Dependent Degrees-of-Freedom.</field>
    /// <field name='dnid' static='false' type='Number'>Dependent Node id.</field>
    /// <field name='exists' static='false' type='Boolean'>true if Interpolation exists, false if referred to but not defined. (read only)</field>
    /// <field name='icid' static='false' type='Number'>Interpolation label</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the Interpolation is in.</field>
    /// <field name='indsw' static='false' type='Number'>Switch for controlling the explicit solution when an independent (or dependent) node is deleted.</field>
    /// <field name='ityp' static='false' type='Number'>The Independent Node type. Can be Interpolation.NODE or Interpolation.NODE_SET.</field>
    /// <field name='local' static='false' type='Boolean'>true if _LOCAL is set.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the constrained interpolation is in.</field>
    /// <field name='total' static='false' type='Number'>Total number of INID fields in the keyword.</field>
    /// <field name='NODE' static='true' type='Number'>INID is a node.</field>
    /// <field name='NODE_SET' static='true' type='Number'>INID is a node set.</field>
}

Interpolation.prototype.AddRowData = function() {
    /// <signature>
    /// <summary>Used to add additional independent node card and local coordinate card (if ITYP is Interpolation.NODE_SET) to the keyword. Adds this data to the end of the selected *CONSTRAINED_INTERPOLATION</summary>
    /// <param name="inid" type="Number" optional="false">Independent Node or Node Set id.</param>
    /// <param name="idof" type="Number" optional="true">Independent Degrees-of-Freedom. The default value is 123456.</param>
    /// <param name="twghtx" type="Number" optional="true">Weighting factor for INID. Scales the x-translational component. The default value is 1.0.</param>
    /// <param name="twghty" type="Number" optional="true">Weighting factor for INID. Scales the y-translational component. The default value is twghtx.</param>
    /// <param name="twghtz" type="Number" optional="true">Weighting factor for INID. Scales the z-translational component. The default value is twghtx.</param>
    /// <param name="rwghtx" type="Number" optional="true">Weighting factor for INID. Scales the x-rotational component. The default value is twghtx.</param>
    /// <param name="rwghty" type="Number" optional="true">Weighting factor for INID. Scales the y-rotational component. The default value is twghtx.</param>
    /// <param name="rwghtz" type="Number" optional="true">Weighting factor for INID. Scales the z-rotational component. The default value is twghtx.</param>
    /// <param name="cidi" type="Number" optional="true">Coordinate System ID if LOCAL option is active. The default value is 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the constrained interpolation</summary>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the constrained interpolations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained interpolations will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged constrained interpolations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged constrained interpolations will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained interpolations that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the constrained interpolation is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Interpolation.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the constrained interpolation.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the constrained interpolation</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the constrained interpolation.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Interpolation"/>
    /// </signature>
}

Interpolation.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a Interpolation.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the constrainedInterpolation will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Interpolation"/>
    /// </signature>
}

Interpolation.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for constrained interpolation. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.First = function() {
    /// <signature>
    /// <summary>Returns the first constrained interpolation in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first constrained interpolation in</param>
    /// <returns type="Interpolation"/>
    /// </signature>
}

Interpolation.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free constrained interpolation label in the model. Also see Interpolation.LastFreeLabel(), Interpolation.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free constrained interpolation label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Interpolation.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the constrained interpolations in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained interpolations will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the constrained interpolations</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the constrained interpolation is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the constrained interpolation</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Interpolation.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each constrained interpolation in the model. Note that ForEach has been designed to make looping over constrained interpolations as fast as possible and so has some limitations. Firstly, a single temporary Interpolation object is created and on each function call it is updated with the current constrained interpolation data. This means that you should not try to store the Interpolation object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new constrained interpolations inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained interpolations are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each constrained interpolation</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Interpolation objects for all of the constrained interpolations in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get constrained interpolations from</param>
    /// <returns type="Array" elementType="Interpolation"/>
    /// </signature>
}

Interpolation.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Interpolation objects for all of the flagged constrained interpolations in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get constrained interpolations from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained interpolations that you want to retrieve</param>
    /// <returns type="Array" elementType="Interpolation"/>
    /// </signature>
}

Interpolation.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Interpolation object for a constrained interpolation ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the constrained interpolation in</param>
    /// <param name="number" type="Number" optional="false">number of the constrained interpolation you want the Interpolation object for</param>
    /// <returns type="Interpolation"/>
    /// </signature>
}

Interpolation.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Interpolation property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Interpolation.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">constrained interpolation property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Interpolation.prototype.GetRowData = function() {
    /// <signature>
    /// <summary>Returns independent node cards and local coordinate cards (if ITYP is Interpolation.NODE_SET) for the selected row of the *CONSTRAINED_INTERPOLATION.</summary>
    /// <param name="row_index" type="Number" optional="false">The row index of the data to return. Note that indices start at 0, not 1. 0 &lt;= row_index &lt; Interpolation.total</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Interpolation.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this Interpolation (*constrained_interpolation). Note that a carriage return is not added. See also Interpolation.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Interpolation.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the Interpolation. Note that a carriage return is not added. See also Interpolation.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Interpolation.Last = function() {
    /// <signature>
    /// <summary>Returns the last constrained interpolation in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last constrained interpolation in</param>
    /// <returns type="Interpolation"/>
    /// </signature>
}

Interpolation.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free constrained interpolation label in the model. Also see Interpolation.FirstFreeLabel(), Interpolation.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free constrained interpolation label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Interpolation.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next constrained interpolation in the model.</summary>
    /// <returns type="Interpolation"/>
    /// </signature>
}

Interpolation.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) constrained interpolation label in the model. Also see Interpolation.FirstFreeLabel(), Interpolation.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free constrained interpolation label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Interpolation.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a constrained interpolation.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only constrained interpolations from that model can be picked. If the argument is a Flag then only constrained interpolations that are flagged with limit can be selected. If omitted, or null, any constrained interpolations from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Interpolation"/>
    /// </signature>
}

Interpolation.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous constrained interpolation in the model.</summary>
    /// <returns type="Interpolation"/>
    /// </signature>
}

Interpolation.prototype.RemoveRowData = function() {
    /// <signature>
    /// <summary>Removes an independent node card and a local coordinate card (if ITYP is Interpolation.NODE_SET) for the selected row on the *CONSTRAINED_INTERPOLATION.</summary>
    /// <param name="row_index" type="Number" optional="false">The row index of the data to return. Note that indices start at 0, not 1. 0 &lt;= row_index &lt; Interpolation.total</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the constrained interpolations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained interpolations will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged constrained interpolations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged constrained interpolations will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained interpolations that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select constrained interpolations using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting constrained interpolations</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only constrained interpolations from that model can be selected. If the argument is a Flag then only constrained interpolations that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any constrained interpolations can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Interpolation.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the constrained interpolation.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the constrained interpolation</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.SetRowData = function() {
    /// <signature>
    /// <summary>Used to reset values in already existing independent node cards and local coordinate cards (if ITYP is Interpolation.NODE_SET) in the selected row of *CONSTRAINED_INTERPOLATION</summary>
    /// <param name="row_index" type="Number" optional="false">The row index of the data to return. Note that indices start at 0, not 1. 0 &lt;= row_index &lt; Interpolation.total</param>
    /// <param name="inid" type="Number" optional="false">Independent Node or Node Set id.</param>
    /// <param name="idof" type="Number" optional="true">Independent Degrees-of-Freedom. The default value is 123456.</param>
    /// <param name="twghtx" type="Number" optional="true">Weighting factor for INID. Scales the x-translational component. The default value is 1.0.</param>
    /// <param name="twghty" type="Number" optional="true">Weighting factor for INID. Scales the y-translational component. The default value is twghtx.</param>
    /// <param name="twghtz" type="Number" optional="true">Weighting factor for INID. Scales the z-translational component. The default value is twghtx.</param>
    /// <param name="rwghtx" type="Number" optional="true">Weighting factor for INID. Scales the x-rotational component. The default value is twghtx.</param>
    /// <param name="rwghty" type="Number" optional="true">Weighting factor for INID. Scales the y-rotational component. The default value is twghtx.</param>
    /// <param name="rwghtz" type="Number" optional="true">Weighting factor for INID. Scales the z-rotational component. The default value is twghtx.</param>
    /// <param name="cidi" type="Number" optional="true">Coordinate System ID if LOCAL option is active. The default value is 0</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the constrained interpolation. The constrained interpolation will be sketched until you either call Interpolation.Unsketch(), Interpolation.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained interpolation is sketched. If omitted redraw is true. If you want to sketch several constrained interpolations and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged constrained interpolations in the model. The constrained interpolations will be sketched until you either call Interpolation.Unsketch(), Interpolation.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged constrained interpolations will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained interpolations that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained interpolations are sketched. If omitted redraw is true. If you want to sketch flagged constrained interpolations several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of constrained interpolations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing constrained interpolations should be counted. If false or omitted referenced but undefined constrained interpolations will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Interpolation.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the constrained interpolation</summary>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the constrained interpolations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained interpolations will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged constrained interpolations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged constrained interpolations will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained interpolations that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the constrained interpolations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all constrained interpolations will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the constrained interpolations</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the constrained interpolation.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained interpolation is unsketched. If omitted redraw is true. If you want to unsketch several constrained interpolations and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all constrained interpolations.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained interpolations will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained interpolations are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged constrained interpolations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all constrained interpolations will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the constrained interpolations that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the constrained interpolations are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Interpolation"/>
    /// </signature>
}

Interpolation.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for constrained interpolation. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Interpolation.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this constrained interpolation.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Interpolation.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the Interpolation data in keyword format. Note that this contains the keyword header and the keyword cards. See also Interpolation.Keyword() and Interpolation.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var InterpolationSpotweld = function() {
    /// <signature>
    /// <summary>Create a new InterpolationSpotweld object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained interpolation spotweld will be created in</param>
    /// <param name="pid1" type="Number" optional="false">Part ID of first sheet.</param>
    /// <param name="pid2" type="Number" optional="false">Part ID of second sheet.</param>
    /// <param name="nsid" type="Number" optional="false">Node Set ID of spotweld location nodes.</param>
    /// <returns type="InterpolationSpotweld"/>
    /// </signature>
    /// <field name='alpha1' static='false' type='Number'>Scaling factor alpha 1. Function ID if MODEL &gt; 10.</field>
    /// <field name='alpha2' static='false' type='Number'>Plastic initiation displacement scaling factor alpha2.</field>
    /// <field name='alpha3' static='false' type='Number'>Plastic initiation displacement scaling factor alpha3.</field>
    /// <field name='beta' static='false' type='Number'>Exponent for plastic potential beta 1. Function ID if MODEL &gt; 10.</field>
    /// <field name='beta2' static='false' type='Number'>Exponent for plastic initiation displacement beta2.</field>
    /// <field name='beta3' static='false' type='Number'>Exponent for plastic initiation displacement beta3.</field>
    /// <field name='dens' static='false' type='Number'>Spotweld density (necessary for time step calculation).</field>
    /// <field name='exists' static='false' type='Boolean'>true if constrained interpolation spotweld exists, false if referred to but not defined. (read only)</field>
    /// <field name='gamma' static='false' type='Number'>Scaling factor.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the constrained interpolation spotweld is in.</field>
    /// <field name='intp' static='false' type='Number'>Flag for interpolation. Values can be InterpolationSpotweld.LINEAR, InterpolationSpotweld.UNIFORM or InterpolationSpotweld.INVERSE.</field>
    /// <field name='lcdexp' static='false' type='Number'>Load curve ID for damage exponent vs. mode mixity</field>
    /// <field name='lcf' static='false' type='Number'>Load curve ID describing force versus plastic displacement.</field>
    /// <field name='lcupf' static='false' type='Number'>Load curve ID describing plastic initiation displacement versus mode mixity. Required only for MODEL values = InterpolationSpotweld.SPR3, InterpolationSpotweld.SPR3_MAT_PARAM or InterpolationSpotweld.SPR3_MAT_PARAM_MOD.</field>
    /// <field name='lcupr' static='false' type='Number'>Load curve ID describing plastic rupture displacement versus mode mixity. Required only for MODEL values = InterpolationSpotweld.SPR3, InterpolationSpotweld.SPR3_MAT_PARAM or InterpolationSpotweld.SPR3_MAT_PARAM_MOD.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the interpolation spotweld is in.</field>
    /// <field name='mrn' static='false' type='Number'>Proportionality factor for dependency RN.</field>
    /// <field name='mrs' static='false' type='Number'>Proportionality factor for dependency RS.</field>
    /// <field name='nsid' static='false' type='Number'>Node Set ID of spotweld location nodes.</field>
    /// <field name='pid1' static='false' type='Number'>Part ID of first sheet.</field>
    /// <field name='pid2' static='false' type='Number'>Part ID</field>
    /// <field name='pidvb' static='false' type='Number'>Part ID for visualization beams representing SPR3 in post-processing.</field>
    /// <field name='r' static='false' type='Number'>Spotweld Radius.</field>
    /// <field name='rn' static='false' type='Number'>Tensile strength factor. Function ID if MODEL &gt; 10.</field>
    /// <field name='rs' static='false' type='Number'>Shear strength factor. Function ID if MODEL &gt; 10.</field>
    /// <field name='sropt' static='false' type='Number'>Shear rotation option.</field>
    /// <field name='stf' static='false' type='Number'>Elastic stiffness OR material ID if less than 0. Function ID if MODEL &gt; 10.</field>
    /// <field name='stiff2' static='false' type='Number'>Elastic shear stiffness.</field>
    /// <field name='stiff3' static='false' type='Number'>Elastic bending stiffness.</field>
    /// <field name='stiff4' static='false' type='Number'>Elastic torsional stiffness.</field>
    /// <field name='thick' static='false' type='Number'>Total thickness of both sheets.</field>
    /// <field name='upfn' static='false' type='Number'>Plastic initiation displacement in normal direction.</field>
    /// <field name='upfs' static='false' type='Number'>Plastic initiation displacement in shear direction.</field>
    /// <field name='uprn' static='false' type='Number'>Plastic rupture displacement in normal direction.</field>
    /// <field name='uprs' static='false' type='Number'>Plastic rupture displacement in shear direction.</field>
    /// <field name='INVERSE' static='true' type='Number'>Property INTP value EQ.2.0: Inverse distance weighting.</field>
    /// <field name='LINEAR' static='true' type='Number'>Property INTP value EQ.0.0: Linear (default).</field>
    /// <field name='SPR3' static='true' type='Number'>Property MODEL value EQ.1.0: SPR3 (default).</field>
    /// <field name='SPR3_MAT_PARAM' static='true' type='Number'>Property MODEL value EQ.11.0: Same as 1 with selected material parameters as functions.</field>
    /// <field name='SPR3_MAT_PARAM_MOD' static='true' type='Number'>Property MODEL value EQ.21.0: Same as 11 with slight modification.</field>
    /// <field name='SPR4' static='true' type='Number'>Property MODEL value EQ.2.0: SPR4.</field>
    /// <field name='SPR4_MAT_PARAM' static='true' type='Number'>Property MODEL value EQ.12.0: Same as 2 with selected material parameters as functions.</field>
    /// <field name='SPR4_MAT_PARAM_MOD' static='true' type='Number'>Property MODEL value EQ.22.0: Same as 12 with slight modification.</field>
    /// <field name='UNIFORM' static='true' type='Number'>Property INTP value EQ.1.0: Uniform.</field>
}

InterpolationSpotweld.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the interpolation spotweld</summary>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the interpolation spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all interpolation spotwelds will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged interpolation spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged interpolation spotwelds will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the interpolation spotwelds that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the interpolation spotweld is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

InterpolationSpotweld.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the interpolation spotweld.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the interpolation spotweld</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the interpolation spotweld.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for interpolation spotweld. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.First = function() {
    /// <signature>
    /// <summary>Returns the first interpolation spotweld in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first interpolation spotweld in</param>
    /// <returns type="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the interpolation spotwelds in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all interpolation spotwelds will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the interpolation spotwelds</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the interpolation spotweld is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the interpolation spotweld</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

InterpolationSpotweld.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each interpolation spotweld in the model. Note that ForEach has been designed to make looping over interpolation spotwelds as fast as possible and so has some limitations. Firstly, a single temporary InterpolationSpotweld object is created and on each function call it is updated with the current interpolation spotweld data. This means that you should not try to store the InterpolationSpotweld object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new interpolation spotwelds inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all interpolation spotwelds are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each interpolation spotweld</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of InterpolationSpotweld objects for all of the interpolation spotwelds in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get interpolation spotwelds from</param>
    /// <returns type="Array" elementType="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of InterpolationSpotweld objects for all of the flagged interpolation spotwelds in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get interpolation spotwelds from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the interpolation spotwelds that you want to retrieve</param>
    /// <returns type="Array" elementType="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the InterpolationSpotweld object for a interpolation spotweld ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the interpolation spotweld in</param>
    /// <param name="number" type="Number" optional="false">number of the interpolation spotweld you want the InterpolationSpotweld object for</param>
    /// <returns type="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a InterpolationSpotweld property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the InterpolationSpotweld.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">interpolation spotweld property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this interpolation spotweld (*CONSTRAINED_INTERPOLATION_SPOTWELD). Note that a carriage return is not added. See also InterpolationSpotweld.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

InterpolationSpotweld.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the interpolation spotweld. Note that a carriage return is not added. See also InterpolationSpotweld.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

InterpolationSpotweld.Last = function() {
    /// <signature>
    /// <summary>Returns the last interpolation spotweld in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last interpolation spotweld in</param>
    /// <returns type="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next interpolation spotweld in the model.</summary>
    /// <returns type="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a interpolation spotweld.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only interpolation spotwelds from that model can be picked. If the argument is a Flag then only interpolation spotwelds that are flagged with limit can be selected. If omitted, or null, any interpolation spotwelds from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous interpolation spotweld in the model.</summary>
    /// <returns type="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select interpolation spotwelds using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting interpolation spotwelds</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only interpolation spotwelds from that model can be selected. If the argument is a Flag then only interpolation spotwelds that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any interpolation spotwelds can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterpolationSpotweld.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the interpolation spotweld.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the interpolation spotweld</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the interpolation spotweld. The interpolation spotweld will be sketched until you either call InterpolationSpotweld.Unsketch(), InterpolationSpotweld.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the interpolation spotweld is sketched. If omitted redraw is true. If you want to sketch several interpolation spotwelds and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged interpolation spotwelds in the model. The interpolation spotwelds will be sketched until you either call InterpolationSpotweld.Unsketch(), InterpolationSpotweld.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged interpolation spotwelds will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the interpolation spotwelds that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the interpolation spotwelds are sketched. If omitted redraw is true. If you want to sketch flagged interpolation spotwelds several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of interpolation spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing interpolation spotwelds should be counted. If false or omitted referenced but undefined interpolation spotwelds will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the interpolation spotweld</summary>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the interpolation spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all interpolation spotwelds will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged interpolation spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged interpolation spotwelds will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the interpolation spotwelds that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the interpolation spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all interpolation spotwelds will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the interpolation spotwelds</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the interpolation spotweld.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the interpolation spotweld is unsketched. If omitted redraw is true. If you want to unsketch several interpolation spotwelds and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all interpolation spotwelds.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all interpolation spotwelds will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the interpolation spotwelds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged interpolation spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all interpolation spotwelds will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the interpolation spotwelds that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the interpolation spotwelds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="InterpolationSpotweld"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for interpolation spotweld. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

InterpolationSpotweld.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this interpolation spotweld.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

InterpolationSpotweld.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the interpolation spotweld data in keyword format. Note that this contains the keyword header and the keyword cards. See also InterpolationSpotweld.Keyword() and InterpolationSpotweld.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Joint = function() {
    /// <signature>
    /// <summary>Create a new Joint object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained joint will be created in</param>
    /// <param name="option" type="Number" optional="false">Constrained joint type (any).</param>
    /// <param name="n1" type="Number" optional="false">Node 1.</param>
    /// <param name="n2" type="Number" optional="false">Node 2.</param>
    /// <param name="jid" type="Number" optional="true">Constrained joint number.</param>
    /// <param name="heading" type="String" optional="true">Constrained joint title.</param>
    /// <returns type="Joint"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new Joint object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained joint will be created in</param>
    /// <param name="option" type="Number" optional="false">Constrained joint type. Can be Joint.REVOLUTE, Joint.CYLINDRICAL, Joint.PLANAR, Joint.UNIVERSAL or Joint.TRANSLATIONAL_MOTOR.</param>
    /// <param name="n1" type="Number" optional="false">Node 1.</param>
    /// <param name="n2" type="Number" optional="false">Node 2.</param>
    /// <param name="n3" type="Number" optional="false">Node 3.</param>
    /// <param name="n4" type="Number" optional="false">Node 4.</param>
    /// <param name="jid" type="Number" optional="true">Constrained joint number.</param>
    /// <param name="heading" type="String" optional="true">Constrained joint title.</param>
    /// <returns type="Joint"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new Joint object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained joint will be created in</param>
    /// <param name="option" type="Number" optional="false">Constrained joint type. Can be Joint.TRANSLATIONAL, Joint.LOCKING, Joint.ROTATIONAL_MOTOR, Joint.GEARS, Joint.RACK_AND_PINION, Joint.CONSTANT_VELOCITY, Joint.PULLEY or Joint.SCREW.</param>
    /// <param name="n1" type="Number" optional="false">Node 1.</param>
    /// <param name="n2" type="Number" optional="false">Node 2.</param>
    /// <param name="n3" type="Number" optional="false">Node 3.</param>
    /// <param name="n4" type="Number" optional="false">Node 4.</param>
    /// <param name="n5" type="Number" optional="false">Node 5.</param>
    /// <param name="n6" type="Number" optional="false">Node 6.</param>
    /// <param name="jid" type="Number" optional="true">Constrained joint number.</param>
    /// <param name="heading" type="String" optional="true">Constrained joint title.</param>
    /// <returns type="Joint"/>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>Coordinate system number.</field>
    /// <field name='coupl' static='false' type='Number'>Coupling between force and moment failure.</field>
    /// <field name='damp' static='false' type='Number'>Damping scale factor.</field>
    /// <field name='exists' static='false' type='Boolean'>true if constrained joint exists, false if referred to but not defined. (read only)</field>
    /// <field name='failure' static='false' type='Boolean'>true if _FAILURE option is set, false if not.</field>
    /// <field name='h_angle' static='false' type='Number'>Helix angle for gears.</field>
    /// <field name='heading' static='false' type='String'>Constrained joint heading.</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the constrained joint is in.</field>
    /// <field name='jid' static='false' type='Number'>Constrained joint number (identical to label).</field>
    /// <field name='label' static='false' type='Number'>Constrained joint number.</field>
    /// <field name='lcid' static='false' type='Number'>Loadcuve number.</field>
    /// <field name='local' static='false' type='Boolean'>true if _LOCAL option is set, false if not.</field>
    /// <field name='lst' static='false' type='Number'>Local system type is accelerometer if lst is 1, rigid body if 0.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the joint is in.</field>
    /// <field name='mxx' static='false' type='Number'>Torsional moment resultant at failure.</field>
    /// <field name='myy' static='false' type='Number'>Moment resultant at failure.</field>
    /// <field name='mzz' static='false' type='Number'>Moment resultant at failure.</field>
    /// <field name='n1' static='false' type='Number'>Node number 1.</field>
    /// <field name='n2' static='false' type='Number'>Node number 2.</field>
    /// <field name='n3' static='false' type='Number'>Node number 3.</field>
    /// <field name='n4' static='false' type='Number'>Node number 4.</field>
    /// <field name='n5' static='false' type='Number'>Node number 5.</field>
    /// <field name='n6' static='false' type='Number'>Node number 6.</field>
    /// <field name='nxx' static='false' type='Number'>Axial force resultant at failure.</field>
    /// <field name='nyy' static='false' type='Number'>Force resultant at failure.</field>
    /// <field name='nzz' static='false' type='Number'>Force resultant at failure.</field>
    /// <field name='option' static='false' type='Number'>The Constrained Joint option. Can be: Joint.SPHERICAL, Joint.REVOLUTE, Joint.CYLINDRICAL, Joint.PLANAR, Joint.UNIVERSAL, Joint.TRANSLATIONAL, Joint.LOCKING, Joint.TRANSLATIONAL_MOTOR, Joint.ROTATIONAL_MOTOR, Joint.GEARS, Joint.RACK_AND_PINION, Joint.CONSTANT_VELOCITY, Joint.PULLEY or Joint.SCREW</field>
    /// <field name='parm' static='false' type='Number'>Parameter for function.</field>
    /// <field name='r1' static='false' type='Number'>Gear and pulley radius.</field>
    /// <field name='raid' static='false' type='Number'>Rigid body or accelerometer number.</field>
    /// <field name='rps' static='false' type='Number'>Relative penalty stiffness.</field>
    /// <field name='tfail' static='false' type='Number'>Time for joint failure.</field>
    /// <field name='type' static='false' type='Number'>Flag for motor type.</field>
    /// <field name='CONSTANT_VELOCITY' static='true' type='Number'>CONSTANT_VELOCITY is *CONSTRAINED_JOINT_CONSTANT_VELOCITY.</field>
    /// <field name='CYLINDRICAL' static='true' type='Number'>CYLINDRICAL is *CONSTRAINED_JOINT_CYLINDRICAL.</field>
    /// <field name='GEARS' static='true' type='Number'>GEARS is *CONSTRAINED_JOINT_GEARS.</field>
    /// <field name='LOCKING' static='true' type='Number'>LOCKING is *CONSTRAINED_JOINT_LOCKING.</field>
    /// <field name='PLANAR' static='true' type='Number'>PLANAR is *CONSTRAINED_JOINT_PLANAR.</field>
    /// <field name='PULLEY' static='true' type='Number'>PULLEY is *CONSTRAINED_JOINT_PULLEY.</field>
    /// <field name='RACK_AND_PINION' static='true' type='Number'>RACK_AND_PINION is *CONSTRAINED_JOINT_RACK_AND_PINION.</field>
    /// <field name='REVOLUTE' static='true' type='Number'>REVOLUTE is *CONSTRAINED_JOINT_REVOLUTE.</field>
    /// <field name='ROTATIONAL_MOTOR' static='true' type='Number'>ROTATIONAL_MOTOR is *CONSTRAINED_JOINT_ROTATIONAL_MOTOR.</field>
    /// <field name='SCREW' static='true' type='Number'>SCREW is *CONSTRAINED_JOINT_SCREW.</field>
    /// <field name='SPHERICAL' static='true' type='Number'>SPHERICAL is *CONSTRAINED_JOINT_SPHERICAL.</field>
    /// <field name='TRANSLATIONAL' static='true' type='Number'>TRANSLATIONAL is *CONSTRAINED_JOINT_TRANSLATIONAL.</field>
    /// <field name='TRANSLATIONAL_MOTOR' static='true' type='Number'>TRANSLATIONAL_MOTOR is *CONSTRAINED_JOINT_TRANSLATIONAL_MOTOR.</field>
    /// <field name='UNIVERSAL' static='true' type='Number'>UNIVERSAL is *CONSTRAINED_JOINT_UNIVERSAL.</field>
}

Joint.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the joint</summary>
    /// <returns type="null"/>
    /// </signature>
}

Joint.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the joints in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joints will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged joints in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged joints will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joints that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the joint is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Joint.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the joint.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the joint</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the joint.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Joint"/>
    /// </signature>
}

Joint.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a joint.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the joint will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Joint"/>
    /// </signature>
}

Joint.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for joint. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.First = function() {
    /// <signature>
    /// <summary>Returns the first joint in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first joint in</param>
    /// <returns type="Joint"/>
    /// </signature>
}

Joint.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free joint label in the model. Also see Joint.LastFreeLabel(), Joint.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free joint label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Joint.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the joints in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joints will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the joints</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the joint is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the joint</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Joint.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each joint in the model. Note that ForEach has been designed to make looping over joints as fast as possible and so has some limitations. Firstly, a single temporary Joint object is created and on each function call it is updated with the current joint data. This means that you should not try to store the Joint object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new joints inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all joints are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each joint</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Joint objects for all of the joints in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get joints from</param>
    /// <returns type="Array" elementType="Joint"/>
    /// </signature>
}

Joint.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Joint objects for all of the flagged joints in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get joints from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joints that you want to retrieve</param>
    /// <returns type="Array" elementType="Joint"/>
    /// </signature>
}

Joint.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Joint object for a joint ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the joint in</param>
    /// <param name="number" type="Number" optional="false">number of the joint you want the Joint object for</param>
    /// <returns type="Joint"/>
    /// </signature>
}

Joint.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Joint property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Joint.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">joint property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Joint.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this joint (*CONSTRAINED_JOINT). Note that a carriage return is not added. See also Joint.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Joint.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the joint. Note that a carriage return is not added. See also Joint.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Joint.Last = function() {
    /// <signature>
    /// <summary>Returns the last joint in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last joint in</param>
    /// <returns type="Joint"/>
    /// </signature>
}

Joint.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free joint label in the model. Also see Joint.FirstFreeLabel(), Joint.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free joint label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Joint.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next joint in the model.</summary>
    /// <returns type="Joint"/>
    /// </signature>
}

Joint.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) joint label in the model. Also see Joint.FirstFreeLabel(), Joint.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free joint label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Joint.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a joint.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only joints from that model can be picked. If the argument is a Flag then only joints that are flagged with limit can be selected. If omitted, or null, any joints from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Joint"/>
    /// </signature>
}

Joint.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous joint in the model.</summary>
    /// <returns type="Joint"/>
    /// </signature>
}

Joint.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the joints in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joints will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged joints in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged joints will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joints that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select joints using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting joints</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only joints from that model can be selected. If the argument is a Flag then only joints that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any joints can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Joint.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the joint.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the joint</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the joint. The joint will be sketched until you either call Joint.Unsketch(), Joint.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joint is sketched. If omitted redraw is true. If you want to sketch several joints and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged joints in the model. The joints will be sketched until you either call Joint.Unsketch(), Joint.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged joints will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joints that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joints are sketched. If omitted redraw is true. If you want to sketch flagged joints several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of joints in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing joints should be counted. If false or omitted referenced but undefined joints will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Joint.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the joint</summary>
    /// <returns type="null"/>
    /// </signature>
}

Joint.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the joints in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joints will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged joints in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged joints will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joints that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the joints in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all joints will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the joints</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the joint.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joint is unsketched. If omitted redraw is true. If you want to unsketch several joints and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all joints.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joints will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joints are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged joints in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joints will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joints that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joints are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Joint"/>
    /// </signature>
}

Joint.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for joint. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Joint.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this joint.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Joint.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the joint data in keyword format. Note that this contains the keyword header and the keyword cards. See also Joint.Keyword() and Joint.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var JointStiffness = function() {
    /// <signature>
    /// <summary>Create a new JointStiffness object for *CONSTRAINED_JOINT_STIFFNESS_GENERALIZED.</summary>
    /// <param name="Model" type="Model" optional="false">Model that jstf will be created in</param>
    /// <param name="option" type="Number" optional="false">Must be JointStiffness.GENERALIZED.</param>
    /// <param name="label" type="Number" optional="false">JointStiffness ID of the JSTF. Also see the label argument which is an alternative name for this.</param>
    /// <param name="pida" type="Number" optional="false">Part ID #A.</param>
    /// <param name="pidb" type="Number" optional="false">Part ID #B.</param>
    /// <param name="cida" type="Number" optional="false">Coordinate System ID #A.</param>
    /// <param name="cidb" type="Number" optional="false">Coordinate System ID #B.</param>
    /// <param name="jid" type="Number" optional="false">Joint for restraint/table uses.</param>
    /// <param name="lcidph" type="Number" optional="false">LC: Phi moment vs rotation.</param>
    /// <param name="lcidt" type="Number" optional="false">LC: Theta moment vs rotation.</param>
    /// <param name="lcidps" type="Number" optional="false">LC: Psi moment vs rotation.</param>
    /// <param name="dlcidph" type="Number" optional="false">LC: Phi damping moment vs rotation vel.</param>
    /// <param name="dlcidt" type="Number" optional="false">LC: Theta damping moment vs rotation vel.</param>
    /// <param name="dlcidps" type="Number" optional="false">LC: Psi damping moment vs rotation vel.</param>
    /// <param name="esph" type="Number" optional="false">Stiffness/angle in Phi direction.</param>
    /// <param name="fmph" type="Number" optional="false">LC: Psi frictional moment vs rotation.</param>
    /// <param name="est" type="Number" optional="false">Stiffness/angle in Theta direction.</param>
    /// <param name="fmt" type="Number" optional="false">LC: Theta frictional moment vs rotation.</param>
    /// <param name="esps" type="Number" optional="false">Stiffness/angle in Psi direction.</param>
    /// <param name="fmps" type="Number" optional="false">LC: Psi frictional moment vs rotation.</param>
    /// <param name="nsaph" type="Number" optional="false">Stop angle for -ve Phi rotation.</param>
    /// <param name="psaph" type="Number" optional="false">Stop angle for +ve Phi rotation.</param>
    /// <param name="nsat" type="Number" optional="false">Stop angle for -ve Theta rotation.</param>
    /// <param name="psat" type="Number" optional="false">Stop angle for +ve Theta rotation.</param>
    /// <param name="nsaps" type="Number" optional="false">Stop angle for -ve Psi rotation.</param>
    /// <param name="psaps" type="Number" optional="false">Stop angle for +ve Psi rotation.</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new JointStiffness object for *CONSTRAINED_JOINT_STIFFNESS_FLEXION-TORSION.</summary>
    /// <param name="Model" type="Model" optional="false">Model that jstf will be created in</param>
    /// <param name="option" type="Number" optional="false">Must be JointStiffness.FLEXION-TORSION.</param>
    /// <param name="label" type="Number" optional="false">JointStiffness ID of the JSTF. Also see the label argument which is an alternative name for this.</param>
    /// <param name="pida" type="Number" optional="false">Part ID #A.</param>
    /// <param name="pidb" type="Number" optional="false">Part ID #B.</param>
    /// <param name="cida" type="Number" optional="false">Coordinate System ID #A.</param>
    /// <param name="cidb" type="Number" optional="false">Coordinate System ID #B.</param>
    /// <param name="jid" type="Number" optional="false">Joint for restraint/table uses.</param>
    /// <param name="lcidal" type="Number" optional="false">LC: Alpha moment vs Rotation.</param>
    /// <param name="lcidg" type="Number" optional="false">LC: Gamma angle vs factor on Alpha blending.</param>
    /// <param name="lcidbt" type="Number" optional="false">LC: Beta moment vs Rotation.</param>
    /// <param name="dlcidal" type="Number" optional="false">LC: Alpha damping moment vs Rotl vel.</param>
    /// <param name="dlcidg" type="Number" optional="false">LC: Gamma damping factor vs factor on Alpha damping moment.</param>
    /// <param name="dlcidbt" type="Number" optional="false">LC: Beta damping moment vs Rotl vel.</param>
    /// <param name="esal" type="Number" optional="false">Stiffness/angle in Alpha direction.</param>
    /// <param name="fmal" type="Number" optional="false">LC: Alpha Frictional moment vs rotation.</param>
    /// <param name="esbt" type="Number" optional="false">Stiffness/angle in Beta direction.</param>
    /// <param name="fmbt" type="Number" optional="false">LC: Beta Frictional moment vs rotation.</param>
    /// <param name="saal" type="Number" optional="false">Stop angle for Alpha rotation.</param>
    /// <param name="nsabt" type="Number" optional="false">Stop angle for -ve Beta rotation.</param>
    /// <param name="psabt" type="Number" optional="false">Stop angle for +ve Beta rotation.</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new JointStiffness object for *CONSTRAINED_JOINT_STIFFNESS_TRANSLATIONAL.</summary>
    /// <param name="Model" type="Model" optional="false">Model that jstf will be created in</param>
    /// <param name="option" type="Number" optional="false">Must be JointStiffness.TRANSLATIONAL.</param>
    /// <param name="label" type="Number" optional="false">JointStiffness ID of the JSTF. Also see the label argument which is an alternative name for this.</param>
    /// <param name="pida" type="Number" optional="false">Part ID #A.</param>
    /// <param name="pidb" type="Number" optional="false">Part ID #B.</param>
    /// <param name="cida" type="Number" optional="false">Coordinate System ID #A.</param>
    /// <param name="cidb" type="Number" optional="false">Coordinate System ID #B.</param>
    /// <param name="jid" type="Number" optional="false">Joint for restraint/table uses.</param>
    /// <param name="lcidx" type="Number" optional="false">LC: X force vs X rel displ.</param>
    /// <param name="lcidy" type="Number" optional="false">LC: Y force vs Y rel displ.</param>
    /// <param name="lcidz" type="Number" optional="false">LC: Z force vs Z rel displ.</param>
    /// <param name="dlcidx" type="Number" optional="false">LC: X damping vs X rel velocity.</param>
    /// <param name="dlcidy" type="Number" optional="false">LC: Y damping vs Y rel velocity.</param>
    /// <param name="dlcidz" type="Number" optional="false">LC: Z damping vs Z rel velocity.</param>
    /// <param name="esx" type="Number" optional="false">Elastic stiffness for X stop and friction.</param>
    /// <param name="ffx" type="Number" optional="false">LC: Lim X force, or yield force vs X translation.</param>
    /// <param name="esy" type="Number" optional="false">Elastic stiffness for Y stop and friction.</param>
    /// <param name="ffy" type="Number" optional="false">LC: Lim Y force, or yield force vs Y translation.</param>
    /// <param name="esz" type="Number" optional="false">Elastic stiffness for Z stop and friction.</param>
    /// <param name="ffz" type="Number" optional="false">LC: Lim Z force, or yield force vs Z translation.</param>
    /// <param name="nsdx" type="Number" optional="false">Limiting -ve X translation.</param>
    /// <param name="psdx" type="Number" optional="false">Limiting +ve X translation.</param>
    /// <param name="nsdy" type="Number" optional="false">Limiting -ve Y translation.</param>
    /// <param name="psdy" type="Number" optional="false">Limiting +ve Y translation.</param>
    /// <param name="nsdz" type="Number" optional="false">Limiting -ve Z translation.</param>
    /// <param name="psdz" type="Number" optional="false">Limiting +ve Z translation.</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new JointStiffness object for *CONSTRAINED_JOINT_STIFFNESS_CYLINDRICAL.</summary>
    /// <param name="Model" type="Model" optional="false">Model that jstf will be created in</param>
    /// <param name="option" type="Number" optional="false">Must be JointStiffness.CYLINDRICAL.</param>
    /// <param name="label" type="Number" optional="false">JointStiffness ID of the JSTF. Also see the label argument which is an alternative name for this.</param>
    /// <param name="pida" type="Number" optional="false">Part ID #A.</param>
    /// <param name="pidb" type="Number" optional="false">Part ID #B.</param>
    /// <param name="cida" type="Number" optional="false">Coordinate System ID #A.</param>
    /// <param name="cidb" type="Number" optional="false">Coordinate System ID #B.</param>
    /// <param name="jid" type="Number" optional="false">Joint for restraint/table uses.</param>
    /// <param name="lcidr" type="Number" optional="false">LC: R force vs R rel displ.</param>
    /// <param name="lcidz" type="Number" optional="false">LC: Z force vs Z rel displ.</param>
    /// <param name="dlcidr" type="Number" optional="false">LC: R damping vs R rel velocity.</param>
    /// <param name="dlcidp" type="Number" optional="false">LC: P damping vs P rel velocity.</param>
    /// <param name="dlcidz" type="Number" optional="false">LC: Z damping vs Z rel velocity.</param>
    /// <param name="lcidt" type="Number" optional="false">LC: Theta moment vs rotation.</param>
    /// <param name="dlcidt" type="Number" optional="false">LC: Theta damping moment vs rotation vel.</param>
    /// <param name="esr" type="Number" optional="false">Elastic stiffness for R stop and friction.</param>
    /// <param name="ffr" type="Number" optional="false">LC: Lim R force, or yield force vs R translation.</param>
    /// <param name="esz" type="Number" optional="false">Elastic stiffness for Z stop and friction.</param>
    /// <param name="ffz" type="Number" optional="false">LC: Lim Z force, or yield force vs Z translation.</param>
    /// <param name="rad1" type="Number" optional="false">Radius of pin.</param>
    /// <param name="rad2" type="Number" optional="false">Radius of hole.</param>
    /// <param name="psdr" type="Number" optional="false">Limiting R translation.</param>
    /// <param name="nsdz" type="Number" optional="false">Limiting -ve Z translation.</param>
    /// <param name="psdz" type="Number" optional="false">Limiting +ve Z translation.</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
    /// <field name='cida' static='false' type='Number'>Coordinate System ID #A.</field>
    /// <field name='cidb' static='false' type='Number'>Coordinate System ID #B.</field>
    /// <field name='dlcidal' static='false' type='Number'>LC: Alpha damping moment vs Rotl vel.</field>
    /// <field name='dlcidbt' static='false' type='Number'>LC: Beta damping moment vs Rotl vel.</field>
    /// <field name='dlcidg' static='false' type='Number'>LC: Gamma damping factor vs factor on Alpha damping moment.</field>
    /// <field name='dlcidp' static='false' type='Number'>LC: P damping vs P rel velocity.</field>
    /// <field name='dlcidph' static='false' type='Number'>LC: Phi damping moment vs rotation vel.</field>
    /// <field name='dlcidps' static='false' type='Number'>LC: Psi damping moment vs rotation vel.</field>
    /// <field name='dlcidr' static='false' type='Number'>LC: R damping vs R rel velocity.</field>
    /// <field name='dlcidt' static='false' type='Number'>LC: Theta damping moment vs rotation vel.</field>
    /// <field name='dlcidx' static='false' type='Number'>LC: X damping vs X rel velocity.</field>
    /// <field name='dlcidy' static='false' type='Number'>LC: Y damping vs Y rel velocity.</field>
    /// <field name='dlcidz' static='false' type='Number'>LC: Z damping vs Z rel velocity.</field>
    /// <field name='esal' static='false' type='Number'>Stiffness/angle in Alpha direction.</field>
    /// <field name='esbt' static='false' type='Number'>Stiffness/angle in Beta direction.</field>
    /// <field name='esph' static='false' type='Number'>Stiffness/angle in Phi direction.</field>
    /// <field name='esps' static='false' type='Number'>Stiffness/angle in Psi direction.</field>
    /// <field name='esr' static='false' type='Number'>Elastic stiffness for R stop and friction.</field>
    /// <field name='est' static='false' type='Number'>Stiffness/angle in Theta direction.</field>
    /// <field name='esx' static='false' type='Number'>Elastic stiffness for X stop and friction.</field>
    /// <field name='esy' static='false' type='Number'>Elastic stiffness for Y stop and friction.</field>
    /// <field name='esz' static='false' type='Number'>Elastic stiffness for Z stop and friction.</field>
    /// <field name='exists' static='false' type='Boolean'>true if jstf exists, false if referred to but not defined. (read only)</field>
    /// <field name='ffr' static='false' type='Number'>LC: Lim R force, or yield force vs R translation.</field>
    /// <field name='ffx' static='false' type='Number'>LC: Lim X force, or yield force vs X translation.</field>
    /// <field name='ffy' static='false' type='Number'>LC: Lim Y force, or yield force vs Y translation.</field>
    /// <field name='ffz' static='false' type='Number'>LC: Lim Z force, or yield force vs Z translation.</field>
    /// <field name='fmal' static='false' type='Number'>LC: Alpha Frictional moment vs rotation.</field>
    /// <field name='fmbt' static='false' type='Number'>LC: Beta Frictional moment vs rotation.</field>
    /// <field name='fmph' static='false' type='Number'>LC: Psi frictional moment vs rotation.</field>
    /// <field name='fmps' static='false' type='Number'>LC: Psi frictional moment vs rotation.</field>
    /// <field name='fmt' static='false' type='Number'>LC: Theta frictional moment vs rotation.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the jstf is in.</field>
    /// <field name='jid' static='false' type='Number'>Joint for restraint/table uses.</field>
    /// <field name='label' static='false' type='Number'>JointStiffness ID of the JSTF. Also see the label property which is an alternative name for this.</field>
    /// <field name='lcidal' static='false' type='Number'>LC: Alpha moment vs Rotation.</field>
    /// <field name='lcidbt' static='false' type='Number'>LC: Beta moment vs Rotation.</field>
    /// <field name='lcidg' static='false' type='Number'>LC: Gamma angle vs factor on Alpha blending.</field>
    /// <field name='lcidph' static='false' type='Number'>LC: Phi moment vs rotation.</field>
    /// <field name='lcidps' static='false' type='Number'>LC: Psi moment vs rotation.</field>
    /// <field name='lcidr' static='false' type='Number'>LC: R force vs R rel displ.</field>
    /// <field name='lcidt' static='false' type='Number'>LC: Theta moment vs rotation.</field>
    /// <field name='lcidx' static='false' type='Number'>LC: X force vs X rel displ.</field>
    /// <field name='lcidy' static='false' type='Number'>LC: Y force vs Y rel displ.</field>
    /// <field name='lcidz' static='false' type='Number'>LC: Z force vs Z rel displ.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the joint stiffness is in.</field>
    /// <field name='nsabt' static='false' type='Number'>Stop angle for -ve Beta rotation.</field>
    /// <field name='nsaph' static='false' type='Number'>Stop angle for -ve Phi rotation.</field>
    /// <field name='nsaps' static='false' type='Number'>Stop angle for -ve Psi rotation.</field>
    /// <field name='nsat' static='false' type='Number'>Stop angle for -ve Theta rotation.</field>
    /// <field name='nsdx' static='false' type='Number'>Limiting -ve X translation.</field>
    /// <field name='nsdy' static='false' type='Number'>Limiting -ve Y translation.</field>
    /// <field name='nsdz' static='false' type='Number'>Limiting -ve Z translation.</field>
    /// <field name='option' static='false' type='Number'>JointStiffness type. Can be JointStiffness.GENERALIZED, JointStiffness.FLEXION_TORSION, JointStiffness.TRANSLATIONAL or JointStiffness.CYLINDRICAL.</field>
    /// <field name='pida' static='false' type='Number'>Part ID #A.</field>
    /// <field name='pidb' static='false' type='Number'>Part ID #B.</field>
    /// <field name='psabt' static='false' type='Number'>Stop angle for +ve Beta rotation.</field>
    /// <field name='psaph' static='false' type='Number'>Stop angle for +ve Phi rotation.</field>
    /// <field name='psaps' static='false' type='Number'>Stop angle for +ve Psi rotation.</field>
    /// <field name='psat' static='false' type='Number'>Stop angle for +ve Theta rotation.</field>
    /// <field name='psdr' static='false' type='Number'>Limiting R translation.</field>
    /// <field name='psdx' static='false' type='Number'>Limiting +ve X translation.</field>
    /// <field name='psdy' static='false' type='Number'>Limiting +ve Y translation.</field>
    /// <field name='psdz' static='false' type='Number'>Limiting +ve Z translation.</field>
    /// <field name='rad1' static='false' type='Number'>Radius of pin.</field>
    /// <field name='rad2' static='false' type='Number'>Radius of hole.</field>
    /// <field name='saal' static='false' type='Number'>Stop angle for Alpha rotation.</field>
    /// <field name='CYLINDRICAL' static='true' type='Number'>JointStiffness is *CONSTRAINED_JOINT_STIFFNESS_CYLINDRICAL.</field>
    /// <field name='FLEXION_TORSION' static='true' type='Number'>JointStiffness is *CONSTRAINED_JOINT_STIFFNESS_FLEXION-TORSION.</field>
    /// <field name='GENERALIZED' static='true' type='Number'>JointStiffness is *CONSTRAINED_JOINT_STIFFNESS_GENERALIZED.</field>
    /// <field name='TRANSLATIONAL' static='true' type='Number'>JointStiffness is *CONSTRAINED_JOINT_STIFFNESS_TRANSLATIONAL.</field>
}

JointStiffness.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the joint stiffness</summary>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the joint stiffnesss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joint stiffnesss will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged joint stiffnesss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged joint stiffnesss will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joint stiffnesss that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the joint stiffness is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

JointStiffness.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the joint stiffness.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the joint stiffness</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the joint stiffness.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
}

JointStiffness.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a jstf.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the jstf will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
}

JointStiffness.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for joint stiffness. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.First = function() {
    /// <signature>
    /// <summary>Returns the first joint stiffness in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first joint stiffness in</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
}

JointStiffness.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free joint stiffness label in the model. Also see JointStiffness.LastFreeLabel(), JointStiffness.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free joint stiffness label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

JointStiffness.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the joint stiffnesss in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joint stiffnesss will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the joint stiffnesss</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the joint stiffness is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the joint stiffness</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

JointStiffness.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each joint stiffness in the model. Note that ForEach has been designed to make looping over joint stiffnesss as fast as possible and so has some limitations. Firstly, a single temporary JointStiffness object is created and on each function call it is updated with the current joint stiffness data. This means that you should not try to store the JointStiffness object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new joint stiffnesss inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all joint stiffnesss are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each joint stiffness</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of JointStiffness objects for all of the joint stiffnesss in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get joint stiffnesss from</param>
    /// <returns type="Array" elementType="JointStiffness"/>
    /// </signature>
}

JointStiffness.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of JointStiffness objects for all of the flagged joint stiffnesss in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get joint stiffnesss from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joint stiffnesss that you want to retrieve</param>
    /// <returns type="Array" elementType="JointStiffness"/>
    /// </signature>
}

JointStiffness.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the JointStiffness object for a joint stiffness ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the joint stiffness in</param>
    /// <param name="number" type="Number" optional="false">number of the joint stiffness you want the JointStiffness object for</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
}

JointStiffness.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a JointStiffness property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the JointStiffness.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">joint stiffness property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

JointStiffness.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this jstf (*CONSTRAINED_JOINT_STIFFNESS). Note that a carriage return is not added. See also JointStiffness.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

JointStiffness.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the jstf. Note that a carriage return is not added. See also JointStiffness.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

JointStiffness.Last = function() {
    /// <signature>
    /// <summary>Returns the last joint stiffness in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last joint stiffness in</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
}

JointStiffness.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free joint stiffness label in the model. Also see JointStiffness.FirstFreeLabel(), JointStiffness.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free joint stiffness label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

JointStiffness.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next joint stiffness in the model.</summary>
    /// <returns type="JointStiffness"/>
    /// </signature>
}

JointStiffness.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) joint stiffness label in the model. Also see JointStiffness.FirstFreeLabel(), JointStiffness.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free joint stiffness label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

JointStiffness.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a joint stiffness.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only joint stiffnesss from that model can be picked. If the argument is a Flag then only joint stiffnesss that are flagged with limit can be selected. If omitted, or null, any joint stiffnesss from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="JointStiffness"/>
    /// </signature>
}

JointStiffness.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous joint stiffness in the model.</summary>
    /// <returns type="JointStiffness"/>
    /// </signature>
}

JointStiffness.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the joint stiffnesss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joint stiffnesss will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged joint stiffnesss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged joint stiffnesss will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joint stiffnesss that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select joint stiffnesss using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting joint stiffnesss</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only joint stiffnesss from that model can be selected. If the argument is a Flag then only joint stiffnesss that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any joint stiffnesss can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

JointStiffness.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the joint stiffness.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the joint stiffness</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the joint stiffness. The joint stiffness will be sketched until you either call JointStiffness.Unsketch(), JointStiffness.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joint stiffness is sketched. If omitted redraw is true. If you want to sketch several joint stiffnesss and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged joint stiffnesss in the model. The joint stiffnesss will be sketched until you either call JointStiffness.Unsketch(), JointStiffness.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged joint stiffnesss will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joint stiffnesss that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joint stiffnesss are sketched. If omitted redraw is true. If you want to sketch flagged joint stiffnesss several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of joint stiffnesss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing joint stiffnesss should be counted. If false or omitted referenced but undefined joint stiffnesss will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

JointStiffness.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the joint stiffness</summary>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the joint stiffnesss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joint stiffnesss will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged joint stiffnesss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged joint stiffnesss will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joint stiffnesss that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the joint stiffnesss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all joint stiffnesss will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the joint stiffnesss</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the joint stiffness.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joint stiffness is unsketched. If omitted redraw is true. If you want to unsketch several joint stiffnesss and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all joint stiffnesss.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joint stiffnesss will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joint stiffnesss are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged joint stiffnesss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all joint stiffnesss will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the joint stiffnesss that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the joint stiffnesss are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="JointStiffness"/>
    /// </signature>
}

JointStiffness.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for joint stiffness. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

JointStiffness.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this joint stiffness.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

JointStiffness.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the jstf data in keyword format. Note that this contains the keyword header and the keyword cards. See also JointStiffness.Keyword() and JointStiffness.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var LoadBeam = function() {
    /// <signature>
    /// <summary>Create a new LoadBeam object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that load beam will be created in</param>
    /// <param name="type" type="Number" optional="false">Specify the type of load beam (Can be LoadBeam.ELEMENT or LoadBeam.SET)</param>
    /// <param name="eid/esid" type="Number" optional="false">Beam ID or beam set ID</param>
    /// <param name="dal" type="Number" optional="false">Direction of applied load. 1 for r-axis, 2 for s-axis or 3 for t-axis of beam.</param>
    /// <param name="lcid" type="Number" optional="false">Curve ID</param>
    /// <param name="sf" type="Number" optional="true">Load curve scale factor</param>
    /// <returns type="LoadBeam"/>
    /// </signature>
    /// <field name='dal' static='false' type='Number'>Direction of applied load. 1 for r-axis, 2 for s-axis or 3 for t-axis of beam.</field>
    /// <field name='eid' static='false' type='Number'>NodeBeam ID or beam set ID. The esid property is an alternative name for this.</field>
    /// <field name='esid' static='false' type='Number'>NodeBeam ID or beam set ID. The eid property is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if load beam exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the load beam is in.</field>
    /// <field name='lcid' static='false' type='Number'>Curve ID or function ID</field>
    /// <field name='model' static='false' type='Number'>The Model number that the load beam is in.</field>
    /// <field name='sf' static='false' type='Number'>Load curve scale factor</field>
    /// <field name='type' static='false' type='Number'>The Load Beam type. Can be LoadBeam.ELEMENT or LoadBeam.SET.</field>
    /// <field name='ELEMENT' static='true' type='Number'>Load is *LOAD_BEAM_ELEMENT.</field>
    /// <field name='SET' static='true' type='Number'>LOAD is *LOAD_BEAM_SET.</field>
}

LoadBeam.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the load beam</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the load beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load beams will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged load beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load beams will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load beams that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the load beam is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadBeam.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the load beam.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the load beam</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the load beam.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="LoadBeam"/>
    /// </signature>
}

LoadBeam.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a load beam definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the load beam will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="LoadBeam"/>
    /// </signature>
}

LoadBeam.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for load beam. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.First = function() {
    /// <signature>
    /// <summary>Returns the first load beam in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first load beam in</param>
    /// <returns type="LoadBeam"/>
    /// </signature>
}

LoadBeam.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the load beams in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load beams will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load beams</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the load beam is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the load beam</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadBeam.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each load beam in the model. Note that ForEach has been designed to make looping over load beams as fast as possible and so has some limitations. Firstly, a single temporary LoadBeam object is created and on each function call it is updated with the current load beam data. This means that you should not try to store the LoadBeam object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load beams inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all load beams are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each load beam</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of LoadBeam objects for all of the load beams in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load beams from</param>
    /// <returns type="Array" elementType="LoadBeam"/>
    /// </signature>
}

LoadBeam.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of LoadBeam objects for all of the flagged load beams in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load beams from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load beams that you want to retrieve</param>
    /// <returns type="Array" elementType="LoadBeam"/>
    /// </signature>
}

LoadBeam.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the LoadBeam object for a load beam ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the load beam in</param>
    /// <param name="number" type="Number" optional="false">number of the load beam you want the LoadBeam object for</param>
    /// <returns type="LoadBeam"/>
    /// </signature>
}

LoadBeam.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a LoadBeam property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadBeam.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">load beam property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

LoadBeam.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this load beam (*LOAD_BEAM_xxxx). Note that a carriage return is not added. See also LoadBeam.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadBeam.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the load beam. Note that a carriage return is not added. See also LoadBeam.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadBeam.Last = function() {
    /// <signature>
    /// <summary>Returns the last load beam in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last load beam in</param>
    /// <returns type="LoadBeam"/>
    /// </signature>
}

LoadBeam.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next load beam in the model.</summary>
    /// <returns type="LoadBeam"/>
    /// </signature>
}

LoadBeam.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a load beam.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load beams from that model can be picked. If the argument is a Flag then only load beams that are flagged with limit can be selected. If omitted, or null, any load beams from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="LoadBeam"/>
    /// </signature>
}

LoadBeam.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous load beam in the model.</summary>
    /// <returns type="LoadBeam"/>
    /// </signature>
}

LoadBeam.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select load beams using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting load beams</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load beams from that model can be selected. If the argument is a Flag then only load beams that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load beams can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadBeam.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the load beam.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load beam</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the load beam. The load beam will be sketched until you either call LoadBeam.Unsketch(), LoadBeam.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load beam is sketched. If omitted redraw is true. If you want to sketch several load beams and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged load beams in the model. The load beams will be sketched until you either call LoadBeam.Unsketch(), LoadBeam.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load beams will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load beams that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load beams are sketched. If omitted redraw is true. If you want to sketch flagged load beams several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of load beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing load beams should be counted. If false or omitted referenced but undefined load beams will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadBeam.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the load beam</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the load beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load beams will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged load beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged load beams will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load beams that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the load beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all load beams will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the load beams</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the load beam.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load beam is unsketched. If omitted redraw is true. If you want to unsketch several load beams and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all load beams.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load beams will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged load beams in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load beams will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load beams that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="LoadBeam"/>
    /// </signature>
}

LoadBeam.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for load beam. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBeam.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this load beam.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

LoadBeam.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the load beam data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadBeam.Keyword() and LoadBeam.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var LoadBody = function() {
    /// <field name='cid' static='false' type='Number'>Coordinate system ID (not _PARTS)</field>
    /// <field name='exists' static='false' type='Boolean'>true if LoadBody card exists</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the LoadBody card is in.</field>
    /// <field name='lcid' static='false' type='Number'>Load curve ID (not _PARTS)</field>
    /// <field name='lciddr' static='false' type='Number'>Load curve ID for dynamic relaxation (not _PARTS)</field>
    /// <field name='parts' static='false' type='Object'>*LOAD_BODY_PARTS card</field>
    /// <field name='psid' static='false' type='Number'>Part set id (_PARTS only)</field>
    /// <field name='rx' static='false' type='Object'>*LOAD_BODY_RX card</field>
    /// <field name='ry' static='false' type='Object'>*LOAD_BODY_RY card</field>
    /// <field name='rz' static='false' type='Object'>*LOAD_BODY_RZ card</field>
    /// <field name='sf' static='false' type='Number'>Load curve scale factor (not _PARTS)</field>
    /// <field name='v1' static='false' type='Number'>X-component of Vector</field>
    /// <field name='v2' static='false' type='Number'>Y-component of Vector</field>
    /// <field name='v3' static='false' type='Number'>Z-component of Vector</field>
    /// <field name='vector' static='false' type='Object'>*LOAD_BODY_VECTOR card</field>
    /// <field name='x' static='false' type='Object'>*LOAD_BODY_X card</field>
    /// <field name='xc' static='false' type='Number'>X centre of rotation (_RX, _RY and _RZ)</field>
    /// <field name='y' static='false' type='Object'>*LOAD_BODY_Y card</field>
    /// <field name='yc' static='false' type='Number'>Y centre of rotation (_RX, _RY and _RZ)</field>
    /// <field name='z' static='false' type='Object'>*LOAD_BODY_Z card</field>
    /// <field name='zc' static='false' type='Number'>Z centre of rotation (_RX, _RY and _RZ)</field>
}

var LoadBodyGeneralized = function() {
    /// <signature>
    /// <summary>Create a new LoadBodyGeneralized object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that load body generalized will be created in</param>
    /// <param name="type" type="Number" optional="false">Specify the type of load body generalized (Can be LoadBodyGeneralized.NODE or LoadBodyGeneralized.SET_NODE or LoadBodyGeneralized.SET_PART)</param>
    /// <param name="n1" type="Number" optional="false">Beginning Node ID for body force load or the node or Part set ID</param>
    /// <param name="n2" type="Number" optional="false">Ending Node ID for body force load. Set to zero if a set ID is defined</param>
    /// <param name="lcid" type="Number" optional="false">Curve ID</param>
    /// <param name="drlcid" type="Number" optional="true">Curve ID for dynamic relaxation phase</param>
    /// <param name="xc" type="Number" optional="true">X-center of rotation</param>
    /// <param name="yc" type="Number" optional="true">Y-center of rotation</param>
    /// <param name="zc" type="Number" optional="true">Z-center of rotation</param>
    /// <param name="ax" type="Number" optional="true">Scale factor for acceleration in x-direction</param>
    /// <param name="ay" type="Number" optional="true">Scale factor for acceleration in y-direction</param>
    /// <param name="az" type="Number" optional="true">Scale factor for acceleration in z-direction</param>
    /// <param name="omx" type="Number" optional="true">Scale factor for x-angular velocity or acceleration</param>
    /// <param name="omy" type="Number" optional="true">Scale factor for y-angular velocity or acceleration</param>
    /// <param name="omz" type="Number" optional="true">Scale factor for z-angular velocity or acceleration</param>
    /// <param name="cid" type="Number" optional="true">Coordinate system ID to define acceleration</param>
    /// <param name="angtyp" type="String" optional="true">Type of body loads</param>
    /// <returns type="LoadBodyGeneralized"/>
    /// </signature>
    /// <field name='angtyp' static='false' type='String'>Type of body loads</field>
    /// <field name='ax' static='false' type='Number'>Scale factor for acceleration in x-direction</field>
    /// <field name='ay' static='false' type='Number'>Scale factor for acceleration in y-direction</field>
    /// <field name='az' static='false' type='Number'>Scale factor for acceleration in z-direction</field>
    /// <field name='cid' static='false' type='Number'>Coordinate system ID to define acceleration</field>
    /// <field name='drlcid' static='false' type='Number'>Curve ID for dynamic relaxation phase</field>
    /// <field name='exists' static='false' type='Boolean'>true if load body generalized exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the load body generalized is in.</field>
    /// <field name='lcid' static='false' type='Number'>Curve ID</field>
    /// <field name='model' static='false' type='Number'>The Model number that the load body generalized is in.</field>
    /// <field name='n1' static='false' type='Number'>Beginning Node ID for body force load or the node or Part set ID</field>
    /// <field name='n2' static='false' type='Number'>Ending Node ID for body force load. Set to zero if a set ID is defined</field>
    /// <field name='omx' static='false' type='Number'>Scale factor for x-angular velocity or acceleration</field>
    /// <field name='omy' static='false' type='Number'>Scale factor for y-angular velocity or acceleration</field>
    /// <field name='omz' static='false' type='Number'>Scale factor for z-angular velocity or acceleration</field>
    /// <field name='type' static='false' type='Number'>The Load Node type, can be LoadBodyGeneralized.NODE or LoadBodyGeneralized.SET_NODE or LoadBodyGeneralized.SET_PART.</field>
    /// <field name='xc' static='false' type='Number'>X-center of rotation</field>
    /// <field name='yc' static='false' type='Number'>Y-center of rotation</field>
    /// <field name='zc' static='false' type='Number'>Z-center of rotation</field>
    /// <field name='NODE' static='true' type='Number'>Load is *LOAD_BODY_GENERALIZED.</field>
    /// <field name='SET_NODE' static='true' type='Number'>Load is *LOAD_BODY_GENERALIZED_SET_NODE.</field>
    /// <field name='SET_PART' static='true' type='Number'>LOAD is *LOAD_BODY_GENERALIZED_SET_PART.</field>
}

LoadBodyGeneralized.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the load body generalized</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the load body generalizeds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load body generalizeds will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged load body generalizeds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load body generalizeds will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load body generalizeds that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the load body generalized is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the load body generalized.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the load body generalized</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the load body generalized.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for load body generalized. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.First = function() {
    /// <signature>
    /// <summary>Returns the first load body generalized in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first load body generalized in</param>
    /// <returns type="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the load body generalizeds in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load body generalizeds will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load body generalizeds</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the load body generalized is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the load body generalized</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadBodyGeneralized.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each load body generalized in the model. Note that ForEach has been designed to make looping over load body generalizeds as fast as possible and so has some limitations. Firstly, a single temporary LoadBodyGeneralized object is created and on each function call it is updated with the current load body generalized data. This means that you should not try to store the LoadBodyGeneralized object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load body generalizeds inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all load body generalizeds are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each load body generalized</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of LoadBodyGeneralized objects for all of the load body generalizeds in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load body generalizeds from</param>
    /// <returns type="Array" elementType="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of LoadBodyGeneralized objects for all of the flagged load body generalizeds in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load body generalizeds from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load body generalizeds that you want to retrieve</param>
    /// <returns type="Array" elementType="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the LoadBodyGeneralized object for a load body generalized ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the load body generalized in</param>
    /// <param name="number" type="Number" optional="false">number of the load body generalized you want the LoadBodyGeneralized object for</param>
    /// <returns type="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a LoadBodyGeneralized property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadBodyGeneralized.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">load body generalized property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this load body generalized (*LOAD_NODE_xxxx). Note that a carriage return is not added. See also LoadBodyGeneralized.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the load body generalized. Note that a carriage return is not added. See also LoadBodyGeneralized.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadBodyGeneralized.Last = function() {
    /// <signature>
    /// <summary>Returns the last load body generalized in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last load body generalized in</param>
    /// <returns type="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next load body generalized in the model.</summary>
    /// <returns type="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a load body generalized.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load body generalizeds from that model can be picked. If the argument is a Flag then only load body generalizeds that are flagged with limit can be selected. If omitted, or null, any load body generalizeds from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous load body generalized in the model.</summary>
    /// <returns type="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select load body generalizeds using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting load body generalizeds</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load body generalizeds from that model can be selected. If the argument is a Flag then only load body generalizeds that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load body generalizeds can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the load body generalized.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load body generalized</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the load body generalized. The load body generalized will be sketched until you either call LoadBodyGeneralized.Unsketch(), LoadBodyGeneralized.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load body generalized is sketched. If omitted redraw is true. If you want to sketch several load body generalizeds and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged load body generalizeds in the model. The load body generalizeds will be sketched until you either call LoadBodyGeneralized.Unsketch(), LoadBodyGeneralized.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load body generalizeds will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load body generalizeds that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load body generalizeds are sketched. If omitted redraw is true. If you want to sketch flagged load body generalizeds several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of load body generalizeds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing load body generalizeds should be counted. If false or omitted referenced but undefined load body generalizeds will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the load body generalized</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the load body generalizeds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load body generalizeds will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged load body generalizeds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged load body generalizeds will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load body generalizeds that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the load body generalizeds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all load body generalizeds will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the load body generalizeds</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the load body generalized.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load body generalized is unsketched. If omitted redraw is true. If you want to unsketch several load body generalizeds and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all load body generalizeds.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load body generalizeds will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load body generalizeds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged load body generalizeds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load body generalizeds will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load body generalizeds that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load body generalizeds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="LoadBodyGeneralized"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for load body generalized. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this load body generalized.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

LoadBodyGeneralized.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the load body generalized data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadBodyGeneralized.Keyword() and LoadBodyGeneralized.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var LoadGravity = function() {
    /// <signature>
    /// <summary>Create a new LoadGravity object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that LoadGravity will be created in</param>
    /// <param name="type" type="Number" optional="false">Specify the type of LoadGravity (Can be LoadGravity.PART or LoadGravity.SET_PART</param>
    /// <param name="pid" type="Number" optional="false">Part ID or Part set ID</param>
    /// <param name="dof" type="Number" optional="false">Direction: enter 1, 2 or 3 for x, y or z</param>
    /// <param name="lc" type="Number" optional="false">Curve ID. Load curve defining factor vs. time (or zero if STGA, STGR are defined)</param>
    /// <param name="accel" type="Number" optional="false">Acceleration (will be multiplied by factor from curve)</param>
    /// <param name="lcdr" type="Number" optional="false">Curve ID. Load curve defining factor vs. time during dynamic relaxation</param>
    /// <param name="stga" type="Number" optional="true">Construction Stage ID at which part is added (optional)</param>
    /// <param name="stgr" type="Number" optional="true">Construction Stage ID at which part is removed (optional)</param>
    /// <returns type="LoadGravity"/>
    /// </signature>
    /// <field name='accel' static='false' type='Number'>Acceleration (will be multiplied by factor from curve)</field>
    /// <field name='dof' static='false' type='Number'>Direction: enter 1, 2 or 3 for x, y, or z</field>
    /// <field name='exists' static='false' type='Boolean'>true if LoadGravity exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the LoadGravity is in.</field>
    /// <field name='lc' static='false' type='Number'>Curve ID. Load curve defining factor vs. time (or zero if STGA, STGR are defined)</field>
    /// <field name='lcdr' static='false' type='Number'>Curve ID. Load curve defining factor vs. time during dynamic relaxation</field>
    /// <field name='model' static='false' type='Number'>The Model number that the load gravity is in.</field>
    /// <field name='pid' static='false' type='Number'>Part ID or Part set ID</field>
    /// <field name='stga' static='false' type='Number'>Construction Stages ID at which part is added (optional)</field>
    /// <field name='stgr' static='false' type='Number'>Construction Stages ID at which part is removed (optional)</field>
    /// <field name='type' static='false' type='Number'>The Load Gravity type. Can be LoadGravity.PART or LoadGravity.SET_PART.</field>
    /// <field name='PART' static='true' type='Number'>LOAD is *LOAD_GRAVITY_PART.</field>
    /// <field name='SET_PART' static='true' type='Number'>LOAD is *LOAD_GRAVITY_PART_SET.</field>
}

LoadGravity.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the load gravity</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the load gravitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load gravitys will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged load gravitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load gravitys will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load gravitys that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the load gravity is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadGravity.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the load gravity.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the load gravity</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the load gravity.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="LoadGravity"/>
    /// </signature>
}

LoadGravity.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for load gravity. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.First = function() {
    /// <signature>
    /// <summary>Returns the first load gravity in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first load gravity in</param>
    /// <returns type="LoadGravity"/>
    /// </signature>
}

LoadGravity.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the load gravitys in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load gravitys will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load gravitys</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the load gravity is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the load gravity</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadGravity.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each load gravity in the model. Note that ForEach has been designed to make looping over load gravitys as fast as possible and so has some limitations. Firstly, a single temporary LoadGravity object is created and on each function call it is updated with the current load gravity data. This means that you should not try to store the LoadGravity object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load gravitys inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all load gravitys are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each load gravity</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of LoadGravity objects for all of the load gravitys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load gravitys from</param>
    /// <returns type="Array" elementType="LoadGravity"/>
    /// </signature>
}

LoadGravity.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of LoadGravity objects for all of the flagged load gravitys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load gravitys from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load gravitys that you want to retrieve</param>
    /// <returns type="Array" elementType="LoadGravity"/>
    /// </signature>
}

LoadGravity.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the LoadGravity object for a load gravity ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the load gravity in</param>
    /// <param name="number" type="Number" optional="false">number of the load gravity you want the LoadGravity object for</param>
    /// <returns type="LoadGravity"/>
    /// </signature>
}

LoadGravity.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a LoadGravity property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadGravity.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">load gravity property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

LoadGravity.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this LoadGravity (*LOAD_GRAVITY_PART). Note that a carriage return is not added. See also LoadGravity.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadGravity.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the LoadGravity. Note that a carriage return is not added. See also LoadGravity.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadGravity.Last = function() {
    /// <signature>
    /// <summary>Returns the last load gravity in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last load gravity in</param>
    /// <returns type="LoadGravity"/>
    /// </signature>
}

LoadGravity.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next load gravity in the model.</summary>
    /// <returns type="LoadGravity"/>
    /// </signature>
}

LoadGravity.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a load gravity.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load gravitys from that model can be picked. If the argument is a Flag then only load gravitys that are flagged with limit can be selected. If omitted, or null, any load gravitys from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="LoadGravity"/>
    /// </signature>
}

LoadGravity.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous load gravity in the model.</summary>
    /// <returns type="LoadGravity"/>
    /// </signature>
}

LoadGravity.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select load gravitys using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting load gravitys</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load gravitys from that model can be selected. If the argument is a Flag then only load gravitys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load gravitys can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadGravity.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the load gravity.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load gravity</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the load gravity. The load gravity will be sketched until you either call LoadGravity.Unsketch(), LoadGravity.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load gravity is sketched. If omitted redraw is true. If you want to sketch several load gravitys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged load gravitys in the model. The load gravitys will be sketched until you either call LoadGravity.Unsketch(), LoadGravity.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load gravitys will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load gravitys that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load gravitys are sketched. If omitted redraw is true. If you want to sketch flagged load gravitys several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of load gravitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing load gravitys should be counted. If false or omitted referenced but undefined load gravitys will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadGravity.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the load gravity</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the load gravitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load gravitys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged load gravitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged load gravitys will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load gravitys that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the load gravitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all load gravitys will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the load gravitys</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the load gravity.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load gravity is unsketched. If omitted redraw is true. If you want to unsketch several load gravitys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all load gravitys.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load gravitys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load gravitys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged load gravitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load gravitys will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load gravitys that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load gravitys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="LoadGravity"/>
    /// </signature>
}

LoadGravity.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for load gravity. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadGravity.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this load gravity.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

LoadGravity.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the LoadGravity data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadGravity.Keyword() and LoadGravity.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var LoadNode = function() {
    /// <signature>
    /// <summary>Create a new LoadNode object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that load node will be created in</param>
    /// <param name="type" type="Number" optional="false">Specify the type of load node (Can be LoadNode.POINT or LoadNode.SET)</param>
    /// <param name="nid" type="Number" optional="false">Node ID or node set ID</param>
    /// <param name="dof" type="Number" optional="false">Applicable degrees-of-freedom</param>
    /// <param name="lcid" type="Number" optional="false">Curve ID</param>
    /// <param name="sf" type="Number" optional="true">Curve scale factor</param>
    /// <param name="cid" type="Number" optional="true">Coordinate system ID</param>
    /// <param name="m1" type="Number" optional="true">Node 1 ID</param>
    /// <param name="m2" type="Number" optional="true">Node 2 ID</param>
    /// <param name="m3" type="Number" optional="true">Node 3 ID</param>
    /// <returns type="LoadNode"/>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>Coordinate system ID</field>
    /// <field name='dof' static='false' type='Number'>Applicable degrees-of-freedom</field>
    /// <field name='exists' static='false' type='Boolean'>true if load node exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the load node is in.</field>
    /// <field name='lcid' static='false' type='Number'>Curve ID</field>
    /// <field name='m1' static='false' type='Number'>Node 1 ID</field>
    /// <field name='m2' static='false' type='Number'>Node 2 ID</field>
    /// <field name='m3' static='false' type='Number'>Node 3 ID</field>
    /// <field name='model' static='false' type='Number'>The Model number that the load node is in.</field>
    /// <field name='nid' static='false' type='Number'>Node ID or node set ID</field>
    /// <field name='sf' static='false' type='Number'>Curve scale factor</field>
    /// <field name='type' static='false' type='Number'>The Load Node type. Can be LoadNode.POINT or LoadNode.SET.</field>
    /// <field name='POINT' static='true' type='Number'>Load is *LOAD_NODE_POINT.</field>
    /// <field name='SET' static='true' type='Number'>LOAD is *LOAD_NODE_SET.</field>
}

LoadNode.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the load node</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the load nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load nodes will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged load nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load nodes will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load nodes that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the load node is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadNode.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the load node.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the load node</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the load node.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="LoadNode"/>
    /// </signature>
}

LoadNode.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for load node. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.First = function() {
    /// <signature>
    /// <summary>Returns the first load node in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first load node in</param>
    /// <returns type="LoadNode"/>
    /// </signature>
}

LoadNode.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the load nodes in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load nodes will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load nodes</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the load node is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the load node</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadNode.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each load node in the model. Note that ForEach has been designed to make looping over load nodes as fast as possible and so has some limitations. Firstly, a single temporary LoadNode object is created and on each function call it is updated with the current load node data. This means that you should not try to store the LoadNode object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load nodes inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all load nodes are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each load node</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of LoadNode objects for all of the load nodes in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load nodes from</param>
    /// <returns type="Array" elementType="LoadNode"/>
    /// </signature>
}

LoadNode.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of LoadNode objects for all of the flagged load nodes in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load nodes from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load nodes that you want to retrieve</param>
    /// <returns type="Array" elementType="LoadNode"/>
    /// </signature>
}

LoadNode.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the LoadNode object for a load node ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the load node in</param>
    /// <param name="number" type="Number" optional="false">number of the load node you want the LoadNode object for</param>
    /// <returns type="LoadNode"/>
    /// </signature>
}

LoadNode.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a LoadNode property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadNode.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">load node property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

LoadNode.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this load node (*LOAD_NODE_xxxx). Note that a carriage return is not added. See also LoadNode.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadNode.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the load node. Note that a carriage return is not added. See also LoadNode.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadNode.Last = function() {
    /// <signature>
    /// <summary>Returns the last load node in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last load node in</param>
    /// <returns type="LoadNode"/>
    /// </signature>
}

LoadNode.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next load node in the model.</summary>
    /// <returns type="LoadNode"/>
    /// </signature>
}

LoadNode.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a load node.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load nodes from that model can be picked. If the argument is a Flag then only load nodes that are flagged with limit can be selected. If omitted, or null, any load nodes from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="LoadNode"/>
    /// </signature>
}

LoadNode.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous load node in the model.</summary>
    /// <returns type="LoadNode"/>
    /// </signature>
}

LoadNode.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select load nodes using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting load nodes</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load nodes from that model can be selected. If the argument is a Flag then only load nodes that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load nodes can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadNode.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the load node.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load node</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the load node. The load node will be sketched until you either call LoadNode.Unsketch(), LoadNode.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load node is sketched. If omitted redraw is true. If you want to sketch several load nodes and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged load nodes in the model. The load nodes will be sketched until you either call LoadNode.Unsketch(), LoadNode.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load nodes will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load nodes that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load nodes are sketched. If omitted redraw is true. If you want to sketch flagged load nodes several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of load nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing load nodes should be counted. If false or omitted referenced but undefined load nodes will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadNode.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the load node</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the load nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load nodes will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged load nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged load nodes will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load nodes that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the load nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all load nodes will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the load nodes</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the load node.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load node is unsketched. If omitted redraw is true. If you want to unsketch several load nodes and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all load nodes.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load nodes will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged load nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load nodes will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load nodes that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="LoadNode"/>
    /// </signature>
}

LoadNode.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for load node. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadNode.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this load node.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

LoadNode.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the load node data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadNode.Keyword() and LoadNode.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var LoadRemovePart = function() {
    /// <signature>
    /// <summary>Create a new LoadRemovePart object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that LoadRemovePart will be created in</param>
    /// <param name="type" type="Number" optional="false">Specify the type of LoadRemovePart (Can be LoadRemovePart.PART or LoadRemovePart.SET_PART</param>
    /// <param name="pid" type="Number" optional="false">Part ID or Part Set ID</param>
    /// <param name="time0" type="Number" optional="true">Time at which stress reduction starts.</param>
    /// <param name="time1" type="Number" optional="true">Time at which stresses become zero and elements are deleted.</param>
    /// <param name="stgr" type="Number" optional="true">Construction Stage ID at which part is removed.</param>
    /// <returns type="LoadRemovePart"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if LoadRemovePart exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the LoadRemovePart is in.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the load remove_part is in.</field>
    /// <field name='pid' static='false' type='Number'>Part ID or Part Set ID</field>
    /// <field name='stgr' static='false' type='Number'>Construction Stages ID at which part is removed.</field>
    /// <field name='time0' static='false' type='Number'>Time at which stress reduction starts.</field>
    /// <field name='time1' static='false' type='Number'>Time at which stresses become zero and elements are deleted.</field>
    /// <field name='type' static='false' type='Number'>The Load RemovePart type. Can be LoadRemovePart.PART or LoadRemovePart.SET_PART.</field>
    /// <field name='PART' static='true' type='Number'>LOAD is *LOAD_REMOVE_PART.</field>
    /// <field name='SET_PART' static='true' type='Number'>LOAD is *LOAD_REMOVE_PART_SET.</field>
}

LoadRemovePart.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the load remove_part</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the load remove_parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load remove_parts will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged load remove_parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load remove_parts will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load remove_parts that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the load remove_part is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadRemovePart.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the load remove_part.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the load remove_part</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the load remove_part.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for load remove_part. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.First = function() {
    /// <signature>
    /// <summary>Returns the first load remove_part in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first load remove_part in</param>
    /// <returns type="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the load remove_parts in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load remove_parts will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load remove_parts</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the load remove_part is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the load remove_part</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadRemovePart.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each load remove_part in the model. Note that ForEach has been designed to make looping over load remove_parts as fast as possible and so has some limitations. Firstly, a single temporary LoadRemovePart object is created and on each function call it is updated with the current load remove_part data. This means that you should not try to store the LoadRemovePart object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load remove_parts inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all load remove_parts are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each load remove_part</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of LoadRemovePart objects for all of the load remove_parts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load remove_parts from</param>
    /// <returns type="Array" elementType="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of LoadRemovePart objects for all of the flagged load remove_parts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load remove_parts from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load remove_parts that you want to retrieve</param>
    /// <returns type="Array" elementType="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the LoadRemovePart object for a load remove_part ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the load remove_part in</param>
    /// <param name="number" type="Number" optional="false">number of the load remove_part you want the LoadRemovePart object for</param>
    /// <returns type="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a LoadRemovePart property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadRemovePart.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">load remove_part property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

LoadRemovePart.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this LoadRemovePart (*LOAD_REMOVE_PART). Note that a carriage return is not added. See also LoadRemovePart.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadRemovePart.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the LoadRemovePart. Note that a carriage return is not added. See also LoadRemovePart.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadRemovePart.Last = function() {
    /// <signature>
    /// <summary>Returns the last load remove_part in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last load remove_part in</param>
    /// <returns type="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next load remove_part in the model.</summary>
    /// <returns type="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a load remove_part.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load remove_parts from that model can be picked. If the argument is a Flag then only load remove_parts that are flagged with limit can be selected. If omitted, or null, any load remove_parts from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous load remove_part in the model.</summary>
    /// <returns type="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select load remove_parts using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting load remove_parts</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load remove_parts from that model can be selected. If the argument is a Flag then only load remove_parts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load remove_parts can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadRemovePart.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the load remove_part.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load remove_part</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the load remove_part. The load remove_part will be sketched until you either call LoadRemovePart.Unsketch(), LoadRemovePart.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load remove_part is sketched. If omitted redraw is true. If you want to sketch several load remove_parts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged load remove_parts in the model. The load remove_parts will be sketched until you either call LoadRemovePart.Unsketch(), LoadRemovePart.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load remove_parts will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load remove_parts that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load remove_parts are sketched. If omitted redraw is true. If you want to sketch flagged load remove_parts several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of load remove_parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing load remove_parts should be counted. If false or omitted referenced but undefined load remove_parts will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadRemovePart.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the load remove_part</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the load remove_parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load remove_parts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged load remove_parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged load remove_parts will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load remove_parts that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the load remove_parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all load remove_parts will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the load remove_parts</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the load remove_part.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load remove_part is unsketched. If omitted redraw is true. If you want to unsketch several load remove_parts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all load remove_parts.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load remove_parts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load remove_parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged load remove_parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load remove_parts will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load remove_parts that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load remove_parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="LoadRemovePart"/>
    /// </signature>
}

LoadRemovePart.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for load remove_part. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRemovePart.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this load remove_part.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

LoadRemovePart.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the LoadRemovePart data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadRemovePart.Keyword() and LoadRemovePart.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var LoadRigidBody = function() {
    /// <signature>
    /// <summary>Create a new LoadRigidBody object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that load rigidbody will be created in</param>
    /// <param name="pid" type="Number" optional="false">Part ID</param>
    /// <param name="dof" type="Number" optional="false">Applicable degrees-of-freedom</param>
    /// <param name="lcid" type="Number" optional="false">Curve ID</param>
    /// <param name="sf" type="Number" optional="true">Curve scale factor</param>
    /// <param name="cid" type="Number" optional="true">Coordinate system ID</param>
    /// <param name="m1" type="Number" optional="true">Node 1 ID</param>
    /// <param name="m2" type="Number" optional="true">Node 2 ID</param>
    /// <param name="m3" type="Number" optional="true">Node 3 ID</param>
    /// <returns type="LoadRigidBody"/>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>Coordinate system ID</field>
    /// <field name='dof' static='false' type='Number'>Applicable degrees-of-freedom</field>
    /// <field name='exists' static='false' type='Boolean'>true if load rigidbody exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the load rigidbody is in.</field>
    /// <field name='lcid' static='false' type='Number'>Curve ID</field>
    /// <field name='m1' static='false' type='Number'>Node 1 ID</field>
    /// <field name='m2' static='false' type='Number'>Node 2 ID</field>
    /// <field name='m3' static='false' type='Number'>Node 3 ID</field>
    /// <field name='model' static='false' type='Number'>The Model number that the load rigidbody is in.</field>
    /// <field name='pid' static='false' type='Number'>Part ID</field>
    /// <field name='sf' static='false' type='Number'>Curve scale factor</field>
}

LoadRigidBody.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the load rigidbody</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the load rigidbodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load rigidbodys will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged load rigidbodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load rigidbodys will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load rigidbodys that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the load rigidbody is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadRigidBody.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the load rigidbody.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the load rigidbody</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the load rigidbody.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for load rigidbody. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.First = function() {
    /// <signature>
    /// <summary>Returns the first load rigidbody in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first load rigidbody in</param>
    /// <returns type="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the load rigidbodys in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load rigidbodys will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load rigidbodys</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the load rigidbody is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the load rigidbody</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadRigidBody.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each load rigidbody in the model. Note that ForEach has been designed to make looping over load rigidbodys as fast as possible and so has some limitations. Firstly, a single temporary LoadRigidBody object is created and on each function call it is updated with the current load rigidbody data. This means that you should not try to store the LoadRigidBody object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load rigidbodys inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all load rigidbodys are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each load rigidbody</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of LoadRigidBody objects for all of the load rigidbodys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load rigidbodys from</param>
    /// <returns type="Array" elementType="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of LoadRigidBody objects for all of the flagged load rigidbodys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load rigidbodys from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load rigidbodys that you want to retrieve</param>
    /// <returns type="Array" elementType="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the LoadRigidBody object for a load rigidbody ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the load rigidbody in</param>
    /// <param name="number" type="Number" optional="false">number of the load rigidbody you want the LoadRigidBody object for</param>
    /// <returns type="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a LoadRigidBody property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadRigidBody.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">load rigidbody property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

LoadRigidBody.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this load rigidbody (*LOAD_RIGIDBODY). Note that a carriage return is not added. See also LoadRigidBody.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadRigidBody.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the load rigidbody. Note that a carriage return is not added. See also LoadRigidBody.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadRigidBody.Last = function() {
    /// <signature>
    /// <summary>Returns the last load rigidbody in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last load rigidbody in</param>
    /// <returns type="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next load rigidbody in the model.</summary>
    /// <returns type="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a load rigidbody.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load rigidbodys from that model can be picked. If the argument is a Flag then only load rigidbodys that are flagged with limit can be selected. If omitted, or null, any load rigidbodys from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous load rigidbody in the model.</summary>
    /// <returns type="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select load rigidbodys using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting load rigidbodys</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load rigidbodys from that model can be selected. If the argument is a Flag then only load rigidbodys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load rigidbodys can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadRigidBody.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the load rigidbody.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load rigidbody</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the load rigidbody. The load rigidbody will be sketched until you either call LoadRigidBody.Unsketch(), LoadRigidBody.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load rigidbody is sketched. If omitted redraw is true. If you want to sketch several load rigidbodys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged load rigidbodys in the model. The load rigidbodys will be sketched until you either call LoadRigidBody.Unsketch(), LoadRigidBody.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load rigidbodys will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load rigidbodys that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load rigidbodys are sketched. If omitted redraw is true. If you want to sketch flagged load rigidbodys several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of load rigidbodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing load rigidbodys should be counted. If false or omitted referenced but undefined load rigidbodys will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadRigidBody.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the load rigidbody</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the load rigidbodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load rigidbodys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged load rigidbodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged load rigidbodys will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load rigidbodys that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the load rigidbodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all load rigidbodys will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the load rigidbodys</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the load rigidbody.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load rigidbody is unsketched. If omitted redraw is true. If you want to unsketch several load rigidbodys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all load rigidbodys.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load rigidbodys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load rigidbodys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged load rigidbodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load rigidbodys will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load rigidbodys that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load rigidbodys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="LoadRigidBody"/>
    /// </signature>
}

LoadRigidBody.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for load rigidbody. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadRigidBody.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this load rigidbody.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

LoadRigidBody.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the load rigidbody data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadRigidBody.Keyword() and LoadRigidBody.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var LoadShell = function() {
    /// <signature>
    /// <summary>Create a new LoadShell object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that LoadShell will be created in</param>
    /// <param name="type" type="Number" optional="false">Specify the type of LoadShell (Can be LoadShell.ELEMENT or LoadShell.SET)</param>
    /// <param name="eid" type="Number" optional="false">Shell ID or shell set ID</param>
    /// <param name="lcid" type="Number" optional="false">Curve ID</param>
    /// <param name="sf" type="Number" optional="true">Curve scale factor</param>
    /// <param name="at" type="Number" optional="true">Arrival time for pressure</param>
    /// <param name="lsid" type="Number" optional="true">LoadShell number</param>
    /// <param name="heading" type="String" optional="true">Title for the LoadShell</param>
    /// <returns type="LoadShell"/>
    /// </signature>
    /// <field name='at' static='false' type='Number'>Arrival time for pressure</field>
    /// <field name='eid' static='false' type='Number'>Shell ID or shell set ID</field>
    /// <field name='exists' static='false' type='Boolean'>true if LoadShell exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>LoadShell heading</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the LoadShell is in.</field>
    /// <field name='label' static='false' type='Number'>LoadShell number.</field>
    /// <field name='lcid' static='false' type='Number'>Curve ID</field>
    /// <field name='lsid' static='false' type='Number'>LoadShell number (identical to label).</field>
    /// <field name='model' static='false' type='Number'>The Model number that the load shell is in.</field>
    /// <field name='sf' static='false' type='Number'>Curve scale factor</field>
    /// <field name='type' static='false' type='Number'>The Load Node type. Can be LoadShell.ELEMENT or LoadShell.SET.</field>
    /// <field name='ELEMENT' static='true' type='Number'>Load is *LOAD_SHELL_ELEMENT.</field>
    /// <field name='SET' static='true' type='Number'>LOAD is *LOAD_SHELL_SET.</field>
}

LoadShell.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the load shell</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the load shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load shells will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged load shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load shells will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load shells that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the load shell is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadShell.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the load shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the load shell</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the load shell.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="LoadShell"/>
    /// </signature>
}

LoadShell.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for load shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.First = function() {
    /// <signature>
    /// <summary>Returns the first load shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first load shell in</param>
    /// <returns type="LoadShell"/>
    /// </signature>
}

LoadShell.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free load shell label in the model. Also see LoadShell.LastFreeLabel(), LoadShell.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free load shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadShell.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the load shells in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load shells will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load shells</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the load shell is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the load shell</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

LoadShell.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each load shell in the model. Note that ForEach has been designed to make looping over load shells as fast as possible and so has some limitations. Firstly, a single temporary LoadShell object is created and on each function call it is updated with the current load shell data. This means that you should not try to store the LoadShell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load shells inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all load shells are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each load shell</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of LoadShell objects for all of the load shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load shells from</param>
    /// <returns type="Array" elementType="LoadShell"/>
    /// </signature>
}

LoadShell.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of LoadShell objects for all of the flagged load shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get load shells from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load shells that you want to retrieve</param>
    /// <returns type="Array" elementType="LoadShell"/>
    /// </signature>
}

LoadShell.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the LoadShell object for a load shell ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the load shell in</param>
    /// <param name="number" type="Number" optional="false">number of the load shell you want the LoadShell object for</param>
    /// <returns type="LoadShell"/>
    /// </signature>
}

LoadShell.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a LoadShell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadShell.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">load shell property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

LoadShell.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this LoadShell (*LOAD_SHELL_xxxx). Note that a carriage return is not added. See also LoadShell.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadShell.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the LoadShell. Note that a carriage return is not added. See also LoadShell.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

LoadShell.Last = function() {
    /// <signature>
    /// <summary>Returns the last load shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last load shell in</param>
    /// <returns type="LoadShell"/>
    /// </signature>
}

LoadShell.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free load shell label in the model. Also see LoadShell.FirstFreeLabel(), LoadShell.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free load shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadShell.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next load shell in the model.</summary>
    /// <returns type="LoadShell"/>
    /// </signature>
}

LoadShell.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) load shell label in the model. Also see LoadShell.FirstFreeLabel(), LoadShell.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free load shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadShell.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a load shell.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load shells from that model can be picked. If the argument is a Flag then only load shells that are flagged with limit can be selected. If omitted, or null, any load shells from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="LoadShell"/>
    /// </signature>
}

LoadShell.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous load shell in the model.</summary>
    /// <returns type="LoadShell"/>
    /// </signature>
}

LoadShell.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the load shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load shells will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged load shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load shells will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load shells that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select load shells using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting load shells</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only load shells from that model can be selected. If the argument is a Flag then only load shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load shells can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadShell.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the load shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the load shell</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the load shell. The load shell will be sketched until you either call LoadShell.Unsketch(), LoadShell.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load shell is sketched. If omitted redraw is true. If you want to sketch several load shells and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged load shells in the model. The load shells will be sketched until you either call LoadShell.Unsketch(), LoadShell.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged load shells will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load shells that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load shells are sketched. If omitted redraw is true. If you want to sketch flagged load shells several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of load shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing load shells should be counted. If false or omitted referenced but undefined load shells will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

LoadShell.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the load shell</summary>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the load shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load shells will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged load shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged load shells will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load shells that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the load shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all load shells will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the load shells</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the load shell.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load shell is unsketched. If omitted redraw is true. If you want to unsketch several load shells and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all load shells.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load shells will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged load shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all load shells will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the load shells that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the load shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="LoadShell"/>
    /// </signature>
}

LoadShell.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for load shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

LoadShell.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this load shell.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

LoadShell.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the LoadShell data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadShell.Keyword() and LoadShell.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Mass = function() {
    /// <signature>
    /// <summary>Create a new Mass object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that mass will be created in</param>
    /// <param name="eid" type="Number" optional="false">Mass number</param>
    /// <param name="id" type="Number" optional="false">Node id or node set id</param>
    /// <param name="mass" type="Number" optional="false">Mass value</param>
    /// <param name="node set" type="Number" optional="true">Only used if a node set is used</param>
    /// <returns type="Mass"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the mass</field>
    /// <field name='eid' static='false' type='Number'>Mass number. Also see the label property which is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if mass exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Number'>Node id or node set id</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the mass is in.</field>
    /// <field name='label' static='false' type='Number'>Mass number. Also see the eid property which is an alternative name for this.</field>
    /// <field name='mass' static='false' type='Number'>Mass value</field>
    /// <field name='model' static='false' type='Number'>The Model number that the mass is in.</field>
    /// <field name='node_set' static='false' type='Number'>The type of the mass. Can be false (*MASS) or Mass.NODE_SET (*MASS_NODE_SET)</field>
    /// <field name='pid' static='false' type='Number'>Part ID</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the mass (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='NODE_SET' static='true' type='Number'>Mass is *MASS_NODE_SET.</field>
}

Mass.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the mass</summary>
    /// <returns type="null"/>
    /// </signature>
}

Mass.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the masss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all masss will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged masss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged masss will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the masss that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the mass is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Mass.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the mass.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the mass</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the mass.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Mass"/>
    /// </signature>
}

Mass.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a mass.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the mass will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Mass"/>
    /// </signature>
}

Mass.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for mass. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for mass. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the mass colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the mass.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Mass.First = function() {
    /// <signature>
    /// <summary>Returns the first mass in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first mass in</param>
    /// <returns type="Mass"/>
    /// </signature>
}

Mass.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free mass label in the model. Also see Mass.LastFreeLabel(), Mass.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free mass label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mass.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the masss in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all masss will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the masss</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the mass is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the mass</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Mass.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each mass in the model. Note that ForEach has been designed to make looping over masss as fast as possible and so has some limitations. Firstly, a single temporary Mass object is created and on each function call it is updated with the current mass data. This means that you should not try to store the Mass object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new masss inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all masss are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each mass</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Mass objects for all of the masss in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get masss from</param>
    /// <returns type="Array" elementType="Mass"/>
    /// </signature>
}

Mass.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Mass objects for all of the flagged masss in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get masss from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the masss that you want to retrieve</param>
    /// <returns type="Array" elementType="Mass"/>
    /// </signature>
}

Mass.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Mass object for a mass ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the mass in</param>
    /// <param name="number" type="Number" optional="false">number of the mass you want the Mass object for</param>
    /// <returns type="Mass"/>
    /// </signature>
}

Mass.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Mass property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Mass.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">mass property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Mass.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this mass (*ELEMENT_MASS or *ELEMENT_MASS_NODE_SET). Note that a carriage return is not added. See also Mass.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Mass.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the mass. Note that a carriage return is not added. See also Mass.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Mass.Last = function() {
    /// <signature>
    /// <summary>Returns the last mass in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last mass in</param>
    /// <returns type="Mass"/>
    /// </signature>
}

Mass.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free mass label in the model. Also see Mass.FirstFreeLabel(), Mass.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free mass label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mass.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next mass in the model.</summary>
    /// <returns type="Mass"/>
    /// </signature>
}

Mass.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) mass label in the model. Also see Mass.FirstFreeLabel(), Mass.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free mass label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mass.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a mass.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only masss from that model can be picked. If the argument is a Flag then only masss that are flagged with limit can be selected. If omitted, or null, any masss from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Mass"/>
    /// </signature>
}

Mass.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous mass in the model.</summary>
    /// <returns type="Mass"/>
    /// </signature>
}

Mass.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the masss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all masss will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged masss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged masss will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the masss that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select masss using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting masss</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only masss from that model can be selected. If the argument is a Flag then only masss that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any masss can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mass.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the mass.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the mass</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the mass. The mass will be sketched until you either call Mass.Unsketch(), Mass.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the mass is sketched. If omitted redraw is true. If you want to sketch several masss and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged masss in the model. The masss will be sketched until you either call Mass.Unsketch(), Mass.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged masss will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the masss that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the masss are sketched. If omitted redraw is true. If you want to sketch flagged masss several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of masss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing masss should be counted. If false or omitted referenced but undefined masss will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mass.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the mass</summary>
    /// <returns type="null"/>
    /// </signature>
}

Mass.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the masss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all masss will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged masss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged masss will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the masss that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the masss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all masss will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the masss</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the mass.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the mass is unsketched. If omitted redraw is true. If you want to unsketch several masss and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all masss.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all masss will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the masss are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged masss in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all masss will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the masss that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the masss are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Mass"/>
    /// </signature>
}

Mass.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for mass. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Mass.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this mass.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Mass.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the mass data in keyword format. Note that this contains the keyword header and the keyword cards. See also Mass.Keyword() and Mass.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var MassPart = function() {
    /// <signature>
    /// <summary>Create a new MassPart object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that mass part will be created in</param>
    /// <param name="option" type="Number" optional="false">Suffix for element mass part. Can be MassPart.PART or MassPart.SET.</param>
    /// <param name="id" type="Number" optional="false">Part or part set ID.</param>
    /// <param name="addmass" type="Number" optional="true">Added translational mass.</param>
    /// <param name="finmass" type="Number" optional="true">Final translational mass.</param>
    /// <returns type="MassPart"/>
    /// </signature>
    /// <field name='addmass' static='false' type='Number'>Added translational mass to be distributed to the nodes of the part or part set ID.</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the mass part</field>
    /// <field name='exists' static='false' type='Boolean'>true if mass part exists, false if referred to but not defined. (read only)</field>
    /// <field name='finmass' static='false' type='Number'>Final translational mass of the part or part set ID.</field>
    /// <field name='id' static='false' type='Number'>Part or part set ID if the SET option is active.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the mass part is in.</field>
    /// <field name='lcid' static='false' type='Number'>Optional load curve ID to scale the added mass at time = 0.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the element mass part is in.</field>
    /// <field name='mwd' static='false' type='Number'>Optional flag for mass-weighted distribution.</field>
    /// <field name='option' static='false' type='Number'>The Element Mass Part option. Can be MassPart.PART or MassPart.SET</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the mass part (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='PART' static='true' type='Number'>Element is *ELEMENT_MASS_PART.</field>
    /// <field name='SET' static='true' type='Number'>Element is *ELEMENT_MASS_PART_SET.</field>
}

MassPart.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the element mass part</summary>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the element mass parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all element mass parts will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged element mass parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged element mass parts will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the element mass parts that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the element mass part is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

MassPart.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the element mass part.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the element mass part</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the element mass part.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="MassPart"/>
    /// </signature>
}

MassPart.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a mass part.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the mass part will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="MassPart"/>
    /// </signature>
}

MassPart.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for element mass part. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for element mass part. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the element mass part colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the element mass part.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

MassPart.First = function() {
    /// <signature>
    /// <summary>Returns the first element mass part in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first element mass part in</param>
    /// <returns type="MassPart"/>
    /// </signature>
}

MassPart.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the element mass parts in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all element mass parts will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the element mass parts</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the element mass part is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the element mass part</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

MassPart.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each element mass part in the model. Note that ForEach has been designed to make looping over element mass parts as fast as possible and so has some limitations. Firstly, a single temporary MassPart object is created and on each function call it is updated with the current element mass part data. This means that you should not try to store the MassPart object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new element mass parts inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all element mass parts are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each element mass part</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of MassPart objects for all of the element mass parts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get element mass parts from</param>
    /// <returns type="Array" elementType="MassPart"/>
    /// </signature>
}

MassPart.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of MassPart objects for all of the flagged element mass parts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get element mass parts from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the element mass parts that you want to retrieve</param>
    /// <returns type="Array" elementType="MassPart"/>
    /// </signature>
}

MassPart.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the MassPart object for a element mass part ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the element mass part in</param>
    /// <param name="number" type="Number" optional="false">number of the element mass part you want the MassPart object for</param>
    /// <returns type="MassPart"/>
    /// </signature>
}

MassPart.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a MassPart property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the MassPart.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">element mass part property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

MassPart.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this mass part (*ELEMENT_MASS_PART) Note that a carriage return is not added. See also MassPart.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

MassPart.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the mass part. Note that a carriage return is not added. See also MassPart.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

MassPart.Last = function() {
    /// <signature>
    /// <summary>Returns the last element mass part in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last element mass part in</param>
    /// <returns type="MassPart"/>
    /// </signature>
}

MassPart.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next element mass part in the model.</summary>
    /// <returns type="MassPart"/>
    /// </signature>
}

MassPart.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a element mass part.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only element mass parts from that model can be picked. If the argument is a Flag then only element mass parts that are flagged with limit can be selected. If omitted, or null, any element mass parts from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="MassPart"/>
    /// </signature>
}

MassPart.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous element mass part in the model.</summary>
    /// <returns type="MassPart"/>
    /// </signature>
}

MassPart.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select element mass parts using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting element mass parts</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only element mass parts from that model can be selected. If the argument is a Flag then only element mass parts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any element mass parts can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MassPart.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the element mass part.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the element mass part</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the element mass part. The element mass part will be sketched until you either call MassPart.Unsketch(), MassPart.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the element mass part is sketched. If omitted redraw is true. If you want to sketch several element mass parts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged element mass parts in the model. The element mass parts will be sketched until you either call MassPart.Unsketch(), MassPart.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged element mass parts will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the element mass parts that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the element mass parts are sketched. If omitted redraw is true. If you want to sketch flagged element mass parts several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of element mass parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing element mass parts should be counted. If false or omitted referenced but undefined element mass parts will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MassPart.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the element mass part</summary>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the element mass parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all element mass parts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged element mass parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged element mass parts will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the element mass parts that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the element mass parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all element mass parts will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the element mass parts</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the element mass part.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the element mass part is unsketched. If omitted redraw is true. If you want to unsketch several element mass parts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all element mass parts.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all element mass parts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the element mass parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged element mass parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all element mass parts will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the element mass parts that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the element mass parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="MassPart"/>
    /// </signature>
}

MassPart.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for element mass part. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

MassPart.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this element mass part.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

MassPart.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the mass part data in keyword format. Note that this contains the keyword header and the keyword cards. See also MassPart.Keyword() and MassPart.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Material = function() {
    /// <signature>
    /// <summary>Create a new Material object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that material will be created in</param>
    /// <param name="mid" type="Number" optional="false">Material number or character label</param>
    /// <param name="type" type="String" optional="false">Material type. Either give the LS-DYNA material name or 3 digit number.</param>
    /// <returns type="Material"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the material</field>
    /// <field name='cols' static='false' type='Number'>The number of columns of data the material has (read only)</field>
    /// <field name='exists' static='false' type='Boolean'>true if material exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the material is in.</field>
    /// <field name='label' static='false' type='Number'>Material number. Also see the mid property which is an alternative name for this.</field>
    /// <field name='mid' static='false' type='Number'>Material number. Also see the label property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the material is in.</field>
    /// <field name='optionalCards' static='false' type='Number'>The number of optional extra cards that this material definition can have (read only). Also see Material.AddOptionalCards()</field>
    /// <field name='properties' static='false' type='Number'>The total number of properties that the material has</field>
    /// <field name='rows' static='false' type='Number'>The number of rows of data the material has (read only)</field>
    /// <field name='title' static='false' type='String'>Material title</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the material (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='type' static='false' type='String'>The material type (e.g. 'ELASTIC', 'RIGID' etc).</field>
}

Material.prototype.AddOptionalCards = function() {
    /// <signature>
    /// <summary>Adds any optional cards for the material. Some materials have extra optional cards in the input. If they are there LS-DYNA will read them but they are not required input. For example a material could have three required cards and one extra optional card. If PRIMER reads this material from a keyword file and it only has the three required cards then the properties in the material will only be defined for those cards. i.e. there will not be any properties in the material for the extra optional line. If you edit the material interactively in PRIMER then the extra optional card will be shown so you can add values if required. When writing the material to a keyword file the extra optional card will be omitted if none of the fields are used. If you want to add one of the properties for the extra optional card in JavaScript this method will ensure that the extra card is defined and the properties added to the material as zero values. You can then use Material.SetPropertyByIndex(), Material.SetPropertyByName() or Material.SetPropertyByRowCol() as normal to set the properties. Also see the optionalCards property.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the material</summary>
    /// <returns type="null"/>
    /// </signature>
}

Material.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the materials in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all materials will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged materials in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged materials will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the materials that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the material is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Material.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the material.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the material</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the material.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Material"/>
    /// </signature>
}

Material.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a material.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the material will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Material"/>
    /// </signature>
}

Material.prototype.Density = function() {
    /// <signature>
    /// <summary>Get the density material.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for material. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for material. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the material colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the material.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Material.First = function() {
    /// <signature>
    /// <summary>Returns the first material in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first material in</param>
    /// <returns type="Material"/>
    /// </signature>
}

Material.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free material label in the model. Also see Material.LastFreeLabel(), Material.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free material label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Material.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the materials in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all materials will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the materials</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the material is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the material</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Material.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each material in the model. Note that ForEach has been designed to make looping over materials as fast as possible and so has some limitations. Firstly, a single temporary Material object is created and on each function call it is updated with the current material data. This means that you should not try to store the Material object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new materials inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all materials are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each material</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Material objects for all of the materials in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get materials from</param>
    /// <returns type="Array" elementType="Material"/>
    /// </signature>
}

Material.prototype.GetErosionPropertyByName = function() {
    /// <signature>
    /// <summary>Returns the value of Erosion property string acronym for this Material object or null if Erosion is not set on Material or no such Erosion property exists.</summary>
    /// <param name="acronym" type="String" optional="false">The acronym of the Erosion property value to retrieve</param>
    /// <param name="idam_index" type="Number" optional="true">Required if property is one of IDAM cards pair property (for IDAM value less than zero) . If the argument is not given, returns the property value for first IDAM cards Pair. The index value starts from zero.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Material.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Material objects for all of the flagged materials in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get materials from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the materials that you want to retrieve</param>
    /// <returns type="Array" elementType="Material"/>
    /// </signature>
}

Material.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Material object for a material ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the material in</param>
    /// <param name="number" type="Number" optional="false">number of the material you want the Material object for</param>
    /// <returns type="Material"/>
    /// </signature>
}

Material.prototype.GetMaterialErosionExists = function() {
    /// <signature>
    /// <summary>Checks if the Erosion properties are defined for this Material object.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Material.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Material property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Material.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">material property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Material.prototype.GetPropertyByIndex = function() {
    /// <signature>
    /// <summary>Returns the value of property at index index for this Material object or null if no property exists.</summary>
    /// <param name="index" type="Number" optional="false">The index of the property value to retrieve. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for a material may not have adjacent indices.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.GetPropertyByName = function() {
    /// <signature>
    /// <summary>Returns the value of property string acronym for this Material object or null if no property exists.</summary>
    /// <param name="acronym" type="String" optional="false">The acronym of the property value to retrieve</param>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.GetPropertyByRowCol = function() {
    /// <signature>
    /// <summary>Returns the value of the property for row and col for this Material object or null if no property exists. Note that rows and columns start at 0.</summary>
    /// <param name="row" type="Number" optional="false">The row of the property value to retrieve</param>
    /// <param name="col" type="Number" optional="false">The column of the property value to retrieve</param>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.GetPropertyNameForIndex = function() {
    /// <signature>
    /// <summary>Returns the name of the property at index index for this Material object or null if there is no property.</summary>
    /// <param name="index" type="Number" optional="false">The index of the property name to retrieve. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for a material may not have adjacent indices.</param>
    /// <returns type="String"/>
    /// </signature>
}

Material.prototype.GetPropertyNameForRowCol = function() {
    /// <signature>
    /// <summary>Returns the name of the property at row and col for this Material object or null if there is no property. Note that rows and columns start at 0.</summary>
    /// <param name="row" type="Number" optional="false">The row of the property name to retrieve</param>
    /// <param name="col" type="Number" optional="false">The column of the property name to retrieve</param>
    /// <returns type="String"/>
    /// </signature>
}

Material.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this material (e.g. *MAT_RIGID, *MAT_ELASTIC etc). Note that a carriage return is not added. See also Material.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Material.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the material. Note that a carriage return is not added. See also Material.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Material.Last = function() {
    /// <signature>
    /// <summary>Returns the last material in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last material in</param>
    /// <returns type="Material"/>
    /// </signature>
}

Material.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free material label in the model. Also see Material.FirstFreeLabel(), Material.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free material label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next material in the model.</summary>
    /// <returns type="Material"/>
    /// </signature>
}

Material.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) material label in the model. Also see Material.FirstFreeLabel(), Material.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free material label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Material.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a material.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only materials from that model can be picked. If the argument is a Flag then only materials that are flagged with limit can be selected. If omitted, or null, any materials from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Material"/>
    /// </signature>
}

Material.prototype.PoissonsRatio = function() {
    /// <signature>
    /// <summary>Get Poissons ratio for the material.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous material in the model.</summary>
    /// <returns type="Material"/>
    /// </signature>
}

Material.prototype.RemoveMaterialErosion = function() {
    /// <signature>
    /// <summary>Removes the Erosion properties for this Material object.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Material.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the materials in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all materials will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged materials in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged materials will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the materials that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select materials using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting materials</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only materials from that model can be selected. If the argument is a Flag then only materials that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any materials can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.SetErosionPropertyByName = function() {
    /// <signature>
    /// <summary>Sets the value of Erosion property string acronym for this Material object</summary>
    /// <param name="acronym" type="String" optional="false">The acronym of the property value to set</param>
    /// <param name="value" type="Number" optional="false">The value of the property to set.</param>
    /// <param name="idam_index" type="Number" optional="true">Required if property is one of IDAM cards pair property (for IDAM value less than zero) . If the argument is not given, set the property values for first IDAM cards Pair. The index value starts from zero.</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the material.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the material</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.SetMaterialErosion = function() {
    /// <signature>
    /// <summary>Initializes the Erosion properties for this Material object.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.SetPropertyByIndex = function() {
    /// <signature>
    /// <summary>Sets the value of property at index index for this Material object</summary>
    /// <param name="index" type="Number" optional="false">The index of the property value to set. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for a material may not have adjacent indices.</param>
    /// <param name="value" type="Number" optional="false">The value of the property to set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.SetPropertyByName = function() {
    /// <signature>
    /// <summary>Sets the value of property string acronym for this Material object</summary>
    /// <param name="acronym" type="String" optional="false">The acronym of the property value to set</param>
    /// <param name="value" type="Number" optional="false">The value of the property to set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.SetPropertyByRowCol = function() {
    /// <signature>
    /// <summary>Sets the value of the property for row and col for this Material object.Note that rows and columns start at 0.</summary>
    /// <param name="row" type="Number" optional="false">The row of the property value to set</param>
    /// <param name="col" type="Number" optional="false">The column of the property value to set</param>
    /// <param name="value" type="Number" optional="false">The value of the property to set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the material. The material will be sketched until you either call Material.Unsketch(), Material.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the material is sketched. If omitted redraw is true. If you want to sketch several materials and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged materials in the model. The materials will be sketched until you either call Material.Unsketch(), Material.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged materials will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the materials that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the materials are sketched. If omitted redraw is true. If you want to sketch flagged materials several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of materials in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing materials should be counted. If false or omitted referenced but undefined materials will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the material</summary>
    /// <returns type="null"/>
    /// </signature>
}

Material.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the materials in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all materials will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged materials in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged materials will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the materials that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the materials in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all materials will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the materials</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the material.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the material is unsketched. If omitted redraw is true. If you want to unsketch several materials and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all materials.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all materials will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the materials are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged materials in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all materials will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the materials that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the materials are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Material"/>
    /// </signature>
}

Material.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for material. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Material.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this material.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Material.prototype.YieldStress = function() {
    /// <signature>
    /// <summary>Get Yield stress for the material.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.YoungsModulus = function() {
    /// <signature>
    /// <summary>Get Youngs modulus for the material.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Material.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the material data in keyword format. Note that this contains the keyword header and the keyword cards. See also Material.Keyword() and Material.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Mechanism = function() {
    /// <field name='assemblies' static='false' type='Number'>Number of assemblies defined. (read only)</field>
    /// <field name='connections' static='false' type='Number'>Number of connections defined. (read only)</field>
    /// <field name='exists' static='false' type='Boolean'>true if mechanism exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Number'>Mechanism number. Also see the label property which is an alternative name for this. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the mechanism is in.</field>
    /// <field name='label' static='false' type='Number'>Mechanism number. Also see the id property which is an alternative name for this. (read only)</field>
    /// <field name='model' static='false' type='Number'>The Model number that the mechanism is in.</field>
    /// <field name='points' static='false' type='Number'>Number of reference points defined. (read only)</field>
    /// <field name='title' static='false' type='String'>Mechanism title.</field>
    /// <field name='COUPLER' static='true' type='Number'>Coupler mechanism connection</field>
    /// <field name='HINGE' static='true' type='Number'>Hinge mechanism connection</field>
    /// <field name='LINE' static='true' type='Number'>Line mechanism connection</field>
    /// <field name='PIN' static='true' type='Number'>Pin mechanism connection</field>
    /// <field name='ROTATION' static='true' type='Number'>Rotational coupling on mechanism coupler</field>
    /// <field name='TRANSLATION' static='true' type='Number'>Translational coupling on mechanism coupler</field>
}

Mechanism.prototype.AddNodeSetToAssembly = function() {
    /// <signature>
    /// <summary>Add node set to assembly</summary>
    /// <param name="index" type="Number" optional="false">The index of the assembly in which you want to add node set. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies</param>
    /// <param name="nsid" type="Number" optional="false">The node set ID that you want to add.</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.AddPartSetToAssembly = function() {
    /// <signature>
    /// <summary>Add part set to assembly</summary>
    /// <param name="index" type="Number" optional="false">The index of the assembly in which you want to add part set. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies</param>
    /// <param name="psid" type="Number" optional="false">The part set ID that you want to add.</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.AddPartToAssembly = function() {
    /// <signature>
    /// <summary>Add part to assembly</summary>
    /// <param name="index" type="Number" optional="false">The index of the assembly in which you want to add part. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies</param>
    /// <param name="pid" type="Number" optional="false">The part ID that you want to add.</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the mechanism</summary>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the mechanisms in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all mechanisms will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged mechanisms in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged mechanisms will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the mechanisms that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the mechanism is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Mechanism.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the mechanism.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the mechanism</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the mechanism.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Mechanism"/>
    /// </signature>
}

Mechanism.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for mechanism. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.First = function() {
    /// <signature>
    /// <summary>Returns the first mechanism in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first mechanism in</param>
    /// <returns type="Mechanism"/>
    /// </signature>
}

Mechanism.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free mechanism label in the model. Also see Mechanism.LastFreeLabel(), Mechanism.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free mechanism label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mechanism.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the mechanisms in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all mechanisms will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the mechanisms</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the mechanism is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the mechanism</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Mechanism.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each mechanism in the model. Note that ForEach has been designed to make looping over mechanisms as fast as possible and so has some limitations. Firstly, a single temporary Mechanism object is created and on each function call it is updated with the current mechanism data. This means that you should not try to store the Mechanism object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new mechanisms inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all mechanisms are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each mechanism</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Mechanism objects for all of the mechanisms in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get mechanisms from</param>
    /// <returns type="Array" elementType="Mechanism"/>
    /// </signature>
}

Mechanism.prototype.GetAssembly = function() {
    /// <signature>
    /// <summary>Returns the information for an assembly</summary>
    /// <param name="index" type="Number" optional="false">The index of the assembly you want the coordinates for. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies</param>
    /// <returns type="Object"/>
    /// </signature>
}

Mechanism.prototype.GetConnection = function() {
    /// <signature>
    /// <summary>Returns the information for a connection</summary>
    /// <param name="index" type="Number" optional="false">The index of the connection you want the information for. Note that connections start at 0, not 1. 0 &lt;= index &lt; connections</param>
    /// <returns type="Object"/>
    /// </signature>
}

Mechanism.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Mechanism objects for all of the flagged mechanisms in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get mechanisms from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the mechanisms that you want to retrieve</param>
    /// <returns type="Array" elementType="Mechanism"/>
    /// </signature>
}

Mechanism.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Mechanism object for a mechanism ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the mechanism in</param>
    /// <param name="number" type="Number" optional="false">number of the mechanism you want the Mechanism object for</param>
    /// <returns type="Mechanism"/>
    /// </signature>
}

Mechanism.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Mechanism property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Mechanism.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">mechanism property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Mechanism.prototype.GetPoint = function() {
    /// <signature>
    /// <summary>Returns the information for a reference point</summary>
    /// <param name="index" type="Number" optional="false">The index of the reference point you want the information for. Note that reference points start at 0, not 1. 0 &lt;= index &lt; points</param>
    /// <returns type="Object"/>
    /// </signature>
}

Mechanism.prototype.GetPointData = function() {
    /// <signature>
    /// <summary>Returns the coordinates of a reference point</summary>
    /// <param name="rpt" type="Number" optional="false">The reference point you want the coordinates for. Note that reference points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Mechanism.prototype.GetPointTitle = function() {
    /// <signature>
    /// <summary>Returns the title of a reference point</summary>
    /// <param name="rpt" type="Number" optional="false">The reference point you want the title for. Note that reference points start at 0, not 1.</param>
    /// <returns type="String"/>
    /// </signature>
}

Mechanism.Last = function() {
    /// <signature>
    /// <summary>Returns the last mechanism in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last mechanism in</param>
    /// <returns type="Mechanism"/>
    /// </signature>
}

Mechanism.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free mechanism label in the model. Also see Mechanism.FirstFreeLabel(), Mechanism.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free mechanism label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mechanism.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next mechanism in the model.</summary>
    /// <returns type="Mechanism"/>
    /// </signature>
}

Mechanism.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) mechanism label in the model. Also see Mechanism.FirstFreeLabel(), Mechanism.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free mechanism label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mechanism.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a mechanism.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only mechanisms from that model can be picked. If the argument is a Flag then only mechanisms that are flagged with limit can be selected. If omitted, or null, any mechanisms from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Mechanism"/>
    /// </signature>
}

Mechanism.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous mechanism in the model.</summary>
    /// <returns type="Mechanism"/>
    /// </signature>
}

Mechanism.prototype.RemoveConnection = function() {
    /// <signature>
    /// <summary>Removes a connection from a mechanism</summary>
    /// <param name="index" type="Number" optional="false">The index of the connection you want to remove. Note that connections start at 0, not 1. 0 &lt;= index &lt; connections</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.RemoveNodeSetFromAssembly = function() {
    /// <signature>
    /// <summary>Remove node set from assembly</summary>
    /// <param name="index" type="Number" optional="false">The index of the assembly from which you want to remove the node set. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies</param>
    /// <param name="nsid" type="Number" optional="false">The node set ID that you want to remove.</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.RemovePartFromAssembly = function() {
    /// <signature>
    /// <summary>Remove part from assembly</summary>
    /// <param name="index" type="Number" optional="false">The index of the assembly from which you want to remove the part. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies</param>
    /// <param name="pid" type="Number" optional="false">The part ID that you want to remove.</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.RemovePartSetFromAssembly = function() {
    /// <signature>
    /// <summary>Remove part set from assembly</summary>
    /// <param name="index" type="Number" optional="false">The index of the assembly from which you want to remove the part set. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies</param>
    /// <param name="psid" type="Number" optional="false">The part set ID that you want to remove.</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.RemovePoint = function() {
    /// <signature>
    /// <summary>Removes a reference point from a mechanism</summary>
    /// <param name="index" type="Number" optional="false">The index of the reference point you want to remove. Note that reference points start at 0, not 1. 0 &lt;= index &lt; points</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the mechanisms in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all mechanisms will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged mechanisms in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged mechanisms will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the mechanisms that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select mechanisms using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting mechanisms</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only mechanisms from that model can be selected. If the argument is a Flag then only mechanisms that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any mechanisms can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mechanism.prototype.SetConnection = function() {
    /// <signature>
    /// <summary>Sets the data for a connection in a mechanism</summary>
    /// <param name="index" type="Number" optional="false">The index of the connection you want to set. Note that connections start at 0, not 1. To add a new connection use index connections</param>
    /// <param name="data" type="Object" optional="false">Object containing the connection data. The properties can be:</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the mechanism.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the mechanism</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.SetPoint = function() {
    /// <signature>
    /// <summary>Sets the data for a reference point in a mechanism</summary>
    /// <param name="index" type="Number" optional="false">The index of the reference point you want to set. Note that reference points start at 0, not 1. To add a new point use index points</param>
    /// <param name="data" type="Object" optional="false">Object containing the reference point data. The properties can be:</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the mechanism. The mechanism will be sketched until you either call Mechanism.Unsketch(), Mechanism.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the mechanism is sketched. If omitted redraw is true. If you want to sketch several mechanisms and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged mechanisms in the model. The mechanisms will be sketched until you either call Mechanism.Unsketch(), Mechanism.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged mechanisms will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the mechanisms that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the mechanisms are sketched. If omitted redraw is true. If you want to sketch flagged mechanisms several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of mechanisms in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing mechanisms should be counted. If false or omitted referenced but undefined mechanisms will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Mechanism.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the mechanism</summary>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the mechanisms in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all mechanisms will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged mechanisms in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged mechanisms will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the mechanisms that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the mechanisms in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all mechanisms will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the mechanisms</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the mechanism.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the mechanism is unsketched. If omitted redraw is true. If you want to unsketch several mechanisms and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all mechanisms.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all mechanisms will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the mechanisms are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged mechanisms in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all mechanisms will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the mechanisms that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the mechanisms are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Mechanism"/>
    /// </signature>
}

Mechanism.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for mechanism. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Mechanism.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this mechanism.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

var Model = function() {
    /// <signature>
    /// <summary>Create a new model in PRIMER</summary>
    /// <param name="number" type="Number" optional="true">Model number to create. If omitted the next free model number will be used.</param>
    /// <returns type="Model"/>
    /// </signature>
    /// <field name='binary' static='false' type='Boolean'>If model is in binary then it will be 1(true) else 0(false).</field>
    /// <field name='comments' static='false' type='String'>Comments stored at the top of the master model file.</field>
    /// <field name='compress' static='false' type='Boolean'>If model is compressed then it will be 1(true) else 0(false).</field>
    /// <field name='compressMode' static='false' type='Number'>This option can be used to know the mode of compression. Can be Model.INDIVIDUAL_GZIP or Model.INDIVIDUAL_ZIP or Model.PACKAGED_ZIP</field>
    /// <field name='control' static='false' type='Control'>Control cards for model. See Control for more details.</field>
    /// <field name='damping' static='false' type='Damping'>Damping cards for model. See Damping for more details.</field>
    /// <field name='database' static='false' type='Database'>Database cards for model. See Database for more details.</field>
    /// <field name='fileStartAscii' static='false' type='Boolean'>If the beginning of the master file (*CONTROL etc) is in ascii then 1(true) else 0(false)(NOTE: If master file is ascii then fileStartAscii won't be checked and show 0(false)).</field>
    /// <field name='filename' static='false' type='String'>Name of file that model was read from (blank if model created)</field>
    /// <field name='id' static='false' type='Boolean'>If ID flag set for *KEYWORD card</field>
    /// <field name='layer' static='false' type='Number'>The current layer for the model. This is the label of the Include file or 0 for the main file. See also Include.MakeCurrentLayer()</field>
    /// <field name='loadBody' static='false' type='LoadBody'>LoadBody cards for model. See LoadBody for more details.</field>
    /// <field name='masterAscii' static='false' type='Boolean'>If master file is in ascii then 1(true) else 0(false).</field>
    /// <field name='num' static='false' type='String'>Model num (for _ID)</field>
    /// <field name='number' static='false' type='Number'>Model number</field>
    /// <field name='path' static='false' type='String'>Path that model was read from (blank if model created)</field>
    /// <field name='project' static='false' type='String'>Model project (for _ID)</field>
    /// <field name='readlog' static='false' type='String'>Full path of the readlog file</field>
    /// <field name='stage' static='false' type='String'>Model stage (for _ID)</field>
    /// <field name='title' static='false' type='String'>Model title</field>
    /// <field name='visible' static='false' type='Boolean'>Model visibility flag</field>
    /// <field name='ABAQUS' static='true' type='Number'>ABAQUS input file</field>
    /// <field name='CENTRE_AT_COFG' static='true' type='Number'>Uses the centre at centre of gravity in calculation of inertia properties.</field>
    /// <field name='COMPRESS_KEEP' static='true' type='Number'>Keeps the keyout compression format same as that of what was read in.</field>
    /// <field name='COMPRESS_OFF' static='true' type='Number'>Switches off compression during keyout.</field>
    /// <field name='COMPRESS_ON' static='true' type='Number'>Switches on compression during keyout.</field>
    /// <field name='DISCARD_MASTER_CLASH' static='true' type='Number'>Merge option - discard master items only on clash</field>
    /// <field name='DISCARD_SLAVE_CLASH' static='true' type='Number'>Merge option - discard slave items only on clash</field>
    /// <field name='GLOBAL_AXES' static='true' type='Number'>GLOBAL AXES</field>
    /// <field name='IGES' static='true' type='Number'>IGES 5.3 geometry file</field>
    /// <field name='IGNORE_CLASH' static='true' type='Number'>Renumber option - Ignore clashes.</field>
    /// <field name='INCREASE_MASTER_ALWAYS' static='true' type='Number'>Merge option - increase master items always</field>
    /// <field name='INCREASE_MASTER_CLASH' static='true' type='Number'>Merge option - increase master items only on clash</field>
    /// <field name='INCREASE_SLAVE_ALWAYS' static='true' type='Number'>Merge option - increase slave items always</field>
    /// <field name='INCREASE_SLAVE_CLASH' static='true' type='Number'>Merge option - increase slave items only on clash</field>
    /// <field name='INDIVIDUAL_GZIP' static='true' type='Number'>Each file 'name.key' is 'gzipped' to become the individual file 'name.key.gz'</field>
    /// <field name='INDIVIDUAL_ZIP' static='true' type='Number'>Each file 'name.key' is 'zipped' to become the individual file 'name.key.zip'</field>
    /// <field name='KEEP_ORIGINAL' static='true' type='Number'>Each file 'name.key' is written using its original compression: uncompressed, '.gz. or '.zip' format</field>
    /// <field name='LOCAL_AXES' static='true' type='Number'>LOCAL AXES</field>
    /// <field name='LSDYNA' static='true' type='Number'>LS-DYNA keyword file</field>
    /// <field name='MOVE_CLASH_UP' static='true' type='Number'>Renumber option - Move clashing &gt; higest label.</field>
    /// <field name='NASTRAN' static='true' type='Number'>NASTRAN bulk data file</field>
    /// <field name='PACKAGED_ZIP' static='true' type='Number'>Suitable for models with include files where the entire model is packed into a single .zip file, preserving its directory structure.</field>
    /// <field name='PRINCIPAL_AXES' static='true' type='Number'>PRINCIPAL AXES</field>
    /// <field name='RADIOSS' static='true' type='Number'>RADIOSS block format file</field>
    /// <field name='REMOVE_FROM_SETS' static='true' type='Number'>Only deletes items within the include selected but may remove items from sets in other includes.</field>
    /// <field name='REMOVE_INCLUDE_ONLY' static='true' type='Number'>Only deletes items within the include selected without removing items from sets in other includes.</field>
    /// <field name='REMOVE_JUNIOR' static='true' type='Number'>Delete items in other includes if they 'belong' to items in this include file but are considered to be 'junior' in the standard PRIMER hierarchy.</field>
    /// <field name='RENUMBER_TO_FREE' static='true' type='Number'>Renumber option - Renumber to next free label.</field>
    /// <field name='SHIFT_ALL_UP' static='true' type='Number'>Renumber option - Shift upwards to make space.</field>
    /// <field name='USER_DEFINED_CENTRE' static='true' type='Number'>Uses the user defined centre in calculation of inertia properties.</field>
}

Model.prototype.AreaVolumeFlagged = function() {
    /// <signature>
    /// <summary>Calculates the Area/Volume of the selected items. Note: The area calculation is based only on shell elements, and the volume calculation is based only on solid elements.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag set on entities you wish to calculate area/volume for</param>
    /// <returns type="Object"/>
    /// </signature>
}

Model.prototype.Attached = function() {
    /// <signature>
    /// <summary>Finds attached items to flagged items. The attached items are flagged with the same flag.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag set on items that you want to find attached to</param>
    /// <param name="redraw" type="Boolean" optional="true">If true, the display will be updated to display only the original flagged items and the attached items.</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.Autofix = function() {
    /// <signature>
    /// <summary>Autofix option does a model check and autofixes all the fixable errors in the model</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks a model in PRIMER</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all models</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged items in the model.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag set on items that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.CentreOfGravity = function() {
    /// <signature>
    /// <summary>Returns the centre of gravity for a model</summary>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Model.prototype.Check = function() {
    /// <signature>
    /// <summary>Checks a model, writing any errors to file.</summary>
    /// <param name="filename" type="String" optional="false">Name of file to write errors to</param>
    /// <param name="detailed" type="Boolean" optional="true">If set to "true", detailed error messages are given.</param>
    /// <param name="json" type="Boolean" optional="true">If set, output in filename will be written in JSON format. If omitted json will be set to false. If JSON format is written then detailed will automatically be set. Note that when writing JSON format the labels produced can be strings instead of integers in some rare cases. If you are writing a script to read a JSON file, it must be able to cope with this. Specifically if the item is a character label the label will be a string. For child collect sets the label will be a string of the format 'X_Y' where X is the parent set label and Y will be the child set number (1, 2, 3 ...). In this case use Set.GetCollectChild() to get the object.</param>
    /// <param name="include" type="Boolean" optional="true">If set, error messages will be written in include by include layout. This option is not applicable if JSON is set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears the flagging for a model in PRIMER. See also Model.PropagateFlag(), Model.SetFlag(), global.AllocateFlag() and global.ReturnFlag().</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copy model to the next free model in PRIMER</summary>
    /// <param name="update" type="Boolean" optional="true">If the graphics should be updated after the model is copied. If omitted update will be set to false</param>
    /// <returns type="Model"/>
    /// </signature>
}

Model.prototype.CopyFlagged = function() {
    /// <signature>
    /// <summary>Copy flagged items in a model to the next free model in PRIMER</summary>
    /// <param name="flag" type="Flag" optional="false">Flag set on items that you want to copy</param>
    /// <param name="update" type="Boolean" optional="true">If the graphics should be updated after the model is copied. If omitted update will be set to false</param>
    /// <returns type="Model"/>
    /// </signature>
}

Model.prototype.Delete = function() {
    /// <signature>
    /// <summary>Deletes a model in PRIMERDo not use the Model object after calling this method.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.DeleteAll = function() {
    /// <signature>
    /// <summary>Deletes all existing models from PRIMER</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.DeleteFlagged = function() {
    /// <signature>
    /// <summary>Deletes all of the flagged items in the model. Note that this may not actually delete all of the items. For example if a node is flagged but the node is used in a shell which is not flagged then the node will not be deleted.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag set on items that you want to delete</param>
    /// <param name="recursive" type="Boolean" optional="true">If deletion is recursive (for example, if a shell is deleted with recursion on the shell nodes will be deleted if possible). If omitted recursive will be set to true.</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.DeleteInclude = function() {
    /// <signature>
    /// <summary>Tries to delete an include file from the model. Note that this may not actually delete the include file. For example if some of the items in the include file are required by other things in different includes then the include file will not be deleted.</summary>
    /// <param name="Include label" type="Number" optional="false">label of include file that you want to delete</param>
    /// <param name="method" type="Number" optional="true">Method for deleting items. Must be Model.REMOVE_FROM_SETS (default), Model.REMOVE_JUNIOR or Model.REMOVE_INCLUDE_ONLY. Model.REMOVE_FROM_SETS will only delete items within the include selected but may remove items from sets in other includes. Model.REMOVE_JUNIOR may delete items in other includes - this will happen if they 'belong' to items in this include and are considered 'junior' Model.REMOVE_INCLUDE_ONLY does the same as Model.REMOVE_FROM_SETS but will not remove items from sets in other includes.</param>
    /// <param name="force" type="Boolean" optional="true">Forcible deletion option (for example, a node is deleted even when it is referenced by a shell which is not deleted). This will remove the include file (not just the contents) from the model. If this argument is omitted, force will be set to false.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Model.prototype.FindElemEnd = function() {
    /// <signature>
    /// <summary>Tidy memory allocation incurred by function which finds elements within a box. See also Model.FindElemInit()</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.FindElemInit = function() {
    /// <signature>
    /// <summary>Initialize setup so that all flagged beams, shells, solids, tshells in model can be tested to see if they are within box. See also Shell.FindShellInBox() Tshell.FindTshellInBox() Solid.FindSolidInBox() Beam.FindBeamInBox() To return memory Model.FindElemEnd()</summary>
    /// <param name="flag" type="Flag" optional="true">If omitted all shells, solids, tshells, beams will be considered.</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.First = function() {
    /// <signature>
    /// <summary>Returns the Model object for the first model in PRIMER (or null if there are no models)</summary>
    /// <returns type="Model"/>
    /// </signature>
}

Model.FirstFreeItemLabel = function() {
    /// <signature>
    /// <summary>Returns the first free label for an item type in the model. Also see Model.LastFreeItemLabel() and Model.NextFreeItemLabel().</summary>
    /// <param name="type" type="String" optional="false">The type of the item (for a list of types see Appendix I of the PRIMER manual).</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Model.prototype.FlagDuplicate = function() {
    /// <signature>
    /// <summary>Flag all nodes referenced in two different includes</summary>
    /// <param name="flag" type="Flag" optional="false">Flag which will be used to flag the "duplicate" nodes</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Model objects for all the models in PRIMER</summary>
    /// <returns type="Array" elementType="Model"/>
    /// </signature>
}

Model.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Model object for a model ID or null if model does not exist</summary>
    /// <param name="model number" type="Number" optional="false">number of the model you want the Model object for</param>
    /// <returns type="Model"/>
    /// </signature>
}

Model.prototype.GetIncludeTransformOffsets = function() {
    /// <signature>
    /// <summary>Looks at all of the items in the model and determines values for IDNOFF, IDEOFF, IDPOFF etc that could be used with Model.ImportIncludeTransform to guarantee that there would not be any clashes with existing items in the model.</summary>
    /// <returns type="Object"/>
    /// </signature>
}

Model.prototype.Hide = function() {
    /// <signature>
    /// <summary>Hides a model in PRIMER</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.Import = function() {
    /// <signature>
    /// <summary>Imports a file into model m. The model can already contain items. However, note that if the file cannot be imported because of a label clash or other problem PRIMER may delete the model and the script will terminate. Note prior to v17 of PRIMER imported data would always be imported to the master model, irrespective of the current layer. From v17 onwards this has been corrected and the current layer is used to determine the destination of imported data.</summary>
    /// <param name="filename" type="String" optional="false">Filename of the LS-Dyna keyword file you want to import</param>
    /// <returns type="Number"/>
    /// </signature>
}

Model.prototype.ImportInclude = function() {
    /// <signature>
    /// <summary>Imports a keyword file or an Include object from different model as a new include or into an existing include file for model m. The labels of any items in the imported include contents that clash with existing labels will automatically be renumbered with one exception. The behaviour for *SET_COLLECT cards can be controlled with Options.merge_set_collect.</summary>
    /// <param name="source" type="String" optional="false">Can either be a Filename of the LS-Dyna include file you want to import, OR Include object of another model you want to import</param>
    /// <param name="target" type="Include" optional="true">Include file object of current model if the Import has to be done in an existing include .</param>
    /// <returns type="Include"/>
    /// </signature>
}

Model.prototype.ImportIncludeTransform = function() {
    /// <signature>
    /// <summary>Imports a file as an include transform file for model m. The labels of any items in the include file will be renumbered by idnoff, ideoff etc.</summary>
    /// <param name="filename" type="String" optional="false">Filename of the LS-Dyna include file you want to import</param>
    /// <param name="idnoff" type="Number" optional="false">Offset for nodes in the file</param>
    /// <param name="ideoff" type="Number" optional="false">Offset for elements in the file</param>
    /// <param name="idpoff" type="Number" optional="false">Offset for parts in the file</param>
    /// <param name="idmoff" type="Number" optional="false">Offset for materials in the file</param>
    /// <param name="idsoff" type="Number" optional="false">Offset for sets in the file</param>
    /// <param name="idfoff" type="Number" optional="false">Offset for functions and tables in the file</param>
    /// <param name="iddoff" type="Number" optional="false">Offset for defines in the file</param>
    /// <param name="idroff" type="Number" optional="false">Offset for other labels in the file</param>
    /// <returns type="Include"/>
    /// </signature>
}

Model.Last = function() {
    /// <signature>
    /// <summary>Returns the Model object for the last model in PRIMER (or null if there are no models)</summary>
    /// <returns type="Model"/>
    /// </signature>
}

Model.LastFreeItemLabel = function() {
    /// <signature>
    /// <summary>Returns the last free label for an item type in the model. Also see Model.FirstFreeItemLabel() and Model.NextFreeItemLabel().</summary>
    /// <param name="type" type="String" optional="false">The type of the item (for a list of types see Appendix I of the PRIMER manual).</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Model.prototype.Mass = function() {
    /// <signature>
    /// <summary>Returns the mass for a model</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Model.prototype.MassPropCalc = function() {
    /// <signature>
    /// <summary>Calculates the Mass, CoG, and Intertia Tensor of the flagged items and returns an object with the above properties.</summary>
    /// <param name="flag" type="Flag" optional="false">Calculate mass propetries of flagged items</param>
    /// <returns type="Object"/>
    /// </signature>
}

Model.Merge = function() {
    /// <signature>
    /// <summary>Merge 2 models together to make a new model.</summary>
    /// <param name="Master Model" type="Model" optional="false">Master Model for merge.</param>
    /// <param name="Slave Model" type="Model" optional="false">Slave Model for merge.</param>
    /// <param name="Option to fix clashes" type="Number" optional="true">Type of fix. Can be Model.INCREASE_SLAVE_ALWAYS, Model.INCREASE_SLAVE_CLASH, Model.DISCARD_SLAVE_CLASH, Model.INCREASE_MASTER_ALWAYS, Model.INCREASE_MASTER_CLASH or Model.DISCARD_MASTER_CLASH</param>
    /// <param name="Merge nodes flag" type="Boolean" optional="true">If this flag is set to true, Primer will merge nodes after the model merge.</param>
    /// <param name="dist (required if merge nodes flag used)" type="Number" optional="true">Nodes closer than dist will be potentially merged.</param>
    /// <param name="label" type="Number" optional="true">Label to keep after merge. If &gt; 0 then highest label kept. If &lt;= 0 then lowest kept. If omitted the lowest label will be kept.</param>
    /// <param name="position" type="Number" optional="true">Position to merge at. If &gt; 0 then merged at highest label position. If &lt; 0 then merged at lowest label position. If 0 then merged at midpoint. If omitted the merge will be done at the lowest label.</param>
    /// <returns type="Model"/>
    /// </signature>
}

Model.prototype.MergeNodes = function() {
    /// <signature>
    /// <summary>Attempts to merge nodes on items flagged with flag for this model in PRIMER. Merging nodes on *AIRBAG_SHELL_REFERENCE_GEOMETRY can be controlled by using Options.node_replace_asrg. Also see Node.Merge().</summary>
    /// <param name="flag" type="Flag" optional="false">Flag set on items to merge nodes</param>
    /// <param name="dist" type="Number" optional="false">Nodes closer than dist will be potentially merged.</param>
    /// <param name="label" type="Number" optional="true">Label to keep after merge. If &gt; 0 then highest label kept. If &lt;= 0 then lowest kept. If omitted the lowest label will be kept.</param>
    /// <param name="position" type="Number" optional="true">Position to merge at. If &gt; 0 then merged at highest label position. If &lt; 0 then merged at lowest label position. If 0 then merged at midpoint. If omitted the merge will be done at the lowest label.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Model.NextFreeItemLabel = function() {
    /// <signature>
    /// <summary>Returns the next free label for an item type in the model. Also see Model.FirstFreeItemLabel() and Model.LastFreeItemLabel().</summary>
    /// <param name="type" type="String" optional="false">The type of the item (for a list of types see Appendix I of the PRIMER manual).</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Model.prototype.PopulateInitialVelocities = function() {
    /// <signature>
    /// <summary>Populate the initial velocity field (nvels) for all nodes of the model</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.PropagateFlag = function() {
    /// <signature>
    /// <summary>Propagates the flagging for a model in PRIMER. For example if a part in the model is flagged, this will flag the elements in the part, the nodes on those elements... See also Model.ClearFlag(), Model.SetFlag(), global.AllocateFlag() and global.ReturnFlag().</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to propagate</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.Read = function() {
    /// <signature>
    /// <summary>Reads a file into the first free model in PRIMER</summary>
    /// <param name="filename" type="String" optional="false">Filename you want to read</param>
    /// <param name="filetype" type="Number" optional="true">Filetype you want to read. Can be Model.LSDYNA, Model.ABAQUS, Model.NASTRAN, Model.RADIOSS or Model.IGES. If omitted the file is assumed to be a DYNA3D file. For Model.NASTRAN there are options that change how the model is read. See Options for details.</param>
    /// <param name="number" type="Number" optional="true">Model number to read file into. If omitted the next free model number will be used.</param>
    /// <returns type="Model"/>
    /// </signature>
}

Model.prototype.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the items in the model.</summary>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged items in the model.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag set on items that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <param name="mode" type="Number" optional="true">Renumber mode. Can be Model.IGNORE_CLASH, Model.MOVE_CLASH_UP, Model.SHIFT_ALL_UP, or Model.RENUMBER_TO_FREE(Default),</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select a model using standard PRIMER object menus. If there are no models in memory then Select returns null. If only one model is present then the model object is returned. If there is more than one model in memory then an object menu is mapped allowing the user to choose a model.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Model"/>
    /// </signature>
}

Model.prototype.SetColour = function() {
    /// <signature>
    /// <summary>Sets the colour of the model.</summary>
    /// <param name="colour" type="Number" optional="false">The colour you want to set the model to</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets the flagging for a model in PRIMER. See also Model.PropagateFlag(), Model.ClearFlag(), global.AllocateFlag() and global.ReturnFlag().</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.Show = function() {
    /// <signature>
    /// <summary>Shows a model in PRIMER</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of models.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Model.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks a model in PRIMER</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all models</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged items in the model.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag set on items that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all of the sketched items in the model.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the items are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.UpdateGraphics = function() {
    /// <signature>
    /// <summary>Updates the graphics for a model in PRIMER</summary>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.UsesLargeLabels = function() {
    /// <signature>
    /// <summary>Checks to see if a model uses large labels</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Model.prototype.Write = function() {
    /// <signature>
    /// <summary>Writes a model in PRIMER to file</summary>
    /// <param name="filename" type="String" optional="false">Filename of the LS-Dyna keyword file you want to write</param>
    /// <param name="options" type="Object" optional="true">Options specifying how the file should be written out. If omitted the default values below will be used. The properties available are:</param>
    /// <returns type="null"/>
    /// </signature>
}

Model.prototype.Write_#deprecated = function() {
    /// <signature>
    /// <summary>Writes a model in PRIMER to file</summary>
    /// <param name="filename" type="String" optional="false">Filename of the LS-Dyna keyword file you want to write</param>
    /// <param name="method" type="Number" optional="true">The method used to write include files. Can be Include.MASTER_ONLY, Include.MERGE, Include.NOT_WRITTEN, Include.SUBDIR (default) or Include.SAME_DIR</param>
    /// <param name="path" type="Number" optional="true">The method used to write include paths. Can be Include.ABSOLUTE (default) or Include.RELATIVE</param>
    /// <param name="separator" type="Number" optional="true">The directory separator used when writing include files. Can be Include.NATIVE (default), Include.UNIX or Include.WINDOWS</param>
    /// <param name="version" type="String" optional="true">The LS-DYNA version used to write the file. Can be "971R5", "971R4", "971R3", "970v6763" etc (see the version popup in Model-&gt;Write '&gt;&gt;&gt; LS-Dyna output options' for a full list). See also Options.dyna_version</param>
    /// <param name="large" type="Boolean" optional="true">If true then large format will be used to write the file. If false (default) then the normal LS-DYNA format will be used. Note that large format is only available from version R7.1 and above.</param>
    /// <returns type="null"/>
    /// </signature>
}

var MorphBox = function() {
    /// <signature>
    /// <summary>Create a new MorphBox object around flagged items.</summary>
    /// <param name="Model" type="Model" optional="false">Model that morph box will be created in</param>
    /// <param name="label" type="Number" optional="false">MorphBox number</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the entities (for example nodes, elements and/or parts) that you want to create the box around</param>
    /// <param name="options" type="Object" optional="true">Options to create the box. Currently the only available properties are:</param>
    /// <returns type="MorphBox"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if morph box exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the morph box is in.</field>
    /// <field name='label' static='false' type='Number'>MorphBox number.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the box is in.</field>
    /// <field name='nx' static='false' type='Number'>Number of morph points in parametric X direction (read only)</field>
    /// <field name='ny' static='false' type='Number'>Number of morph points in parametric Y direction (read only)</field>
    /// <field name='nz' static='false' type='Number'>Number of morph points in parametric Z direction (read only)</field>
    /// <field name='setid' static='false' type='Number'>ID for node set of nodes dragged with the box (read only). This will be a *SET_NODE_COLUMN containing the nodes together with their parametric coordinates in X, Y, Z. It is strongly discouraged to edit the contents of this set or the column data manually.</field>
}

MorphBox.prototype.ApplyMorphing = function() {
    /// <signature>
    /// <summary>Recalculates the X, Y and Z coordinates of all nodes linked to the morph box by the *SET_NODE_COLUMN. This should be called when coordinates of morph points have changed and you wish to apply the morphing. If several morph point positions on the same box change, then it is more speed-efficient to call this function only once for the box.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to apply the morphing to several boxes and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using Model.UpdateGraphics().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the box</summary>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boxs will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the box is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

MorphBox.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the box.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the box</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the box.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="MorphBox"/>
    /// </signature>
}

MorphBox.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for box. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.First = function() {
    /// <signature>
    /// <summary>Returns the first box in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first box in</param>
    /// <returns type="MorphBox"/>
    /// </signature>
}

MorphBox.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free box label in the model. Also see MorphBox.LastFreeLabel(), MorphBox.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free box label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphBox.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the boxs in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the boxs</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.FlagAllMorphedConnections = function() {
    /// <signature>
    /// <summary>Flags all connections, in a given model, that have been morphed since their last remake. This includes connections that have been morphed by a morph box that has since been deleted.</summary>
    /// <param name="model" type="Model" optional="false">Model containing desired connections.</param>
    /// <param name="flag" type="Number" optional="false">Flag to mark morphed connections.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

MorphBox.prototype.FlagMorphedConnections = function() {
    /// <signature>
    /// <summary>Flags all connections that have been morphed, by a givine morph box, since their last remake. A connection could be morphed by one morph box and not another, therefore calling this function on two boxes that share a connection may produce different results depending on which box the function is called for. E.g. morb1 and morb2 share conx1, morb1 gets morphed whereas morb2 remains unchanged. Calling this function for morb1 will flag conx1, however calling the function for morb2 won't flag conx1.</summary>
    /// <param name="flag" type="Number" optional="false">Flag to mark morphed connections.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

MorphBox.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the box is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the box</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

MorphBox.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each box in the model. Note that ForEach has been designed to make looping over boxs as fast as possible and so has some limitations. Firstly, a single temporary MorphBox object is created and on each function call it is updated with the current box data. This means that you should not try to store the MorphBox object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boxs inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each box</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of MorphBox objects for all of the boxs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boxs from</param>
    /// <returns type="Array" elementType="MorphBox"/>
    /// </signature>
}

MorphBox.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of MorphBox objects for all of the flagged boxs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boxs from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to retrieve</param>
    /// <returns type="Array" elementType="MorphBox"/>
    /// </signature>
}

MorphBox.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the MorphBox object for a box ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the box in</param>
    /// <param name="number" type="Number" optional="false">number of the box you want the MorphBox object for</param>
    /// <returns type="MorphBox"/>
    /// </signature>
}

MorphBox.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a MorphBox property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the MorphBox.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">box property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

MorphBox.prototype.GetPoint = function() {
    /// <signature>
    /// <summary>Returns the morph point ID on the morph box at indices in X, Y and Z directions.</summary>
    /// <param name="xindex" type="Number" optional="false">Index of the point in X direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric X coordinate and box.nx-1 for the points with the highest X.</param>
    /// <param name="yindex" type="Number" optional="false">Index of the point in Y direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric Y coordinate and box.ny-1 for the points with the highest Y.</param>
    /// <param name="zindex" type="Number" optional="false">Index of the point in Z direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric Z coordinate and box.nz-1 for the points with the highest Z.</param>
    /// <returns type="MorphPoint"/>
    /// </signature>
}

MorphBox.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this morph box (*MORPH_BOX or *MORPH_BOX_HIGH_ORDER). Note that a carriage return is not added. See also MorphBox.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

MorphBox.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the morph box. Note that a carriage return is not added. See also MorphBox.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

MorphBox.Last = function() {
    /// <signature>
    /// <summary>Returns the last box in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last box in</param>
    /// <returns type="MorphBox"/>
    /// </signature>
}

MorphBox.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free box label in the model. Also see MorphBox.FirstFreeLabel(), MorphBox.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free box label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphBox.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next box in the model.</summary>
    /// <returns type="MorphBox"/>
    /// </signature>
}

MorphBox.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) box label in the model. Also see MorphBox.FirstFreeLabel(), MorphBox.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free box label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphBox.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a box.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boxs from that model can be picked. If the argument is a Flag then only boxs that are flagged with limit can be selected. If omitted, or null, any boxs from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="MorphBox"/>
    /// </signature>
}

MorphBox.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous box in the model.</summary>
    /// <returns type="MorphBox"/>
    /// </signature>
}

MorphBox.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boxs will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.Reset = function() {
    /// <signature>
    /// <summary>Resets the morph box to its initial position and updates the coordinates of all its nodes.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to reset several boxes and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using Model.UpdateGraphics().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select boxs using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting boxs</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boxs from that model can be selected. If the argument is a Flag then only boxs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boxs can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphBox.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the box.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the box</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.SetMorphConnections = function() {
    /// <signature>
    /// <summary>Turns Morph Connections on/off.</summary>
    /// <param name="status" type="Boolean" optional="false">true turns Morph Connections on. false turns Morph Connections off.</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.SetPointID = function() {
    /// <signature>
    /// <summary>Replaces the morph point ID on the array, whose size depends on the orders in X, Y and Z directions, with the given new ID.</summary>
    /// <param name="xindex" type="Number" optional="false">Index of the point in X direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric X coordinate and box.nx-1 for the points with the highest X.</param>
    /// <param name="yindex" type="Number" optional="false">Index of the point in Y direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric Y coordinate and box.ny-1 for the points with the highest Y.</param>
    /// <param name="zindex" type="Number" optional="false">Index of the point in Z direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric Z coordinate and box.nz-1 for the points with the highest Z.</param>
    /// <param name="id" type="Number" optional="false">New MorphPoint id.</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the box. The box will be sketched until you either call MorphBox.Unsketch(), MorphBox.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the box is sketched. If omitted redraw is true. If you want to sketch several boxs and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged boxs in the model. The boxs will be sketched until you either call MorphBox.Unsketch(), MorphBox.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boxs will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boxs are sketched. If omitted redraw is true. If you want to sketch flagged boxs several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing boxs should be counted. If false or omitted referenced but undefined boxs will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphBox.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the box</summary>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged boxs will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all boxs will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the boxs</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the box.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the box is unsketched. If omitted redraw is true. If you want to unsketch several boxs and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all boxs.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boxs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged boxs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boxs will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boxs that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boxs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.UpdateParametricCoordinates = function() {
    /// <signature>
    /// <summary>Recalculates parametric X, Y, Z coordinates for each node in the *SET_NODE_COLUMN associated with the morph box. This needs to be called whenever morph points on the box or their coordinates have been changed manually and you wish to keep all nodes at their intrinsic global X, Y, Z coordinates. Provided Morph Connections is on (see MorphBox.SetMorphConnections()), this will also force PRIMER to recalculate the parametric coordinates for any connections in the morph box next time one of its morph points is moved.</summary>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="MorphBox"/>
    /// </signature>
}

MorphBox.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for box. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphBox.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this box.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

MorphBox.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the morph box data in keyword format. Note that this contains the keyword header and the keyword cards. See also MorphBox.Keyword() and MorphBox.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var MorphFlow = function() {
    /// <signature>
    /// <summary>Create a new MorphFlow object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that morph flow will be created in</param>
    /// <param name="name" type="String" optional="false">MorphFlow name</param>
    /// <returns type="MorphFlow"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if morph flow exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the morph flow is in.</field>
    /// <field name='max' static='false' type='Number'>Maximum value for type set to "CONTINUOUS" or "STEP" when written as design variable for LS-OPT.</field>
    /// <field name='min' static='false' type='Number'>Minimum value for type set to "CONTINUOUS" or "STEP" when written as design variable for LS-OPT.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the flow is in.</field>
    /// <field name='name' static='false' type='String'>Name of the morph flow. If the flow is used for applying LS-OPT variables, this should match the variable name in the listing file written by LS-OPT.</field>
    /// <field name='npoints' static='false' type='Number'>Number of morph points referenced by the flow. (read only)</field>
    /// <field name='nvals' static='false' type='Number'>Number of values in the list when type is set to "DISCRETE". (read only)</field>
    /// <field name='step' static='false' type='Number'>Step size for type set to "STEP" when written as design variable for LS-OPT.</field>
    /// <field name='type' static='false' type='String'>Range type for the morph flow. This should be "CONTINUOUS", "STEP" or "DISCRETE" and may be used for LS-OPT when writing design variable files from morph flows.</field>
}

MorphFlow.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the flow</summary>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the flows in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all flows will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged flows in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged flows will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the flows that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the flow is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

MorphFlow.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the flow.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the flow</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the flow.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a morph flow card.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the morph flow card will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for flow. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.First = function() {
    /// <signature>
    /// <summary>Returns the first flow in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first flow in</param>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the flows in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all flows will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the flows</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the flow is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the flow</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

MorphFlow.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each flow in the model. Note that ForEach has been designed to make looping over flows as fast as possible and so has some limitations. Firstly, a single temporary MorphFlow object is created and on each function call it is updated with the current flow data. This means that you should not try to store the MorphFlow object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new flows inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all flows are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each flow</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of MorphFlow objects for all of the flows in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get flows from</param>
    /// <returns type="Array" elementType="MorphFlow"/>
    /// </signature>
}

MorphFlow.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of MorphFlow objects for all of the flagged flows in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get flows from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the flows that you want to retrieve</param>
    /// <returns type="Array" elementType="MorphFlow"/>
    /// </signature>
}

MorphFlow.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the MorphFlow object for a flow ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the flow in</param>
    /// <param name="number" type="Number" optional="false">number of the flow you want the MorphFlow object for</param>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.GetFromName = function() {
    /// <signature>
    /// <summary>Returns the stored MorphFlow object for a morph flow name. WARNING: This assumes that there is at most one morph flow with a given name. Otherwise this function only returns the first occurrence.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the morph flow in</param>
    /// <param name="morph flow name" type="String" optional="false">name of the morph flow you want the MorphFlow object for</param>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a MorphFlow property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the MorphFlow.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">flow property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

MorphFlow.prototype.GetRow = function() {
    /// <signature>
    /// <summary>Returns the data for a row in the morph flow.</summary>
    /// <param name="row" type="Number" optional="false">The row you want the data for. Note row indices start at 0.</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

MorphFlow.prototype.GetValue = function() {
    /// <signature>
    /// <summary>Get the value at given index on the morph flow with type "DISCRETE".</summary>
    /// <param name="index" type="Number" optional="false">The index where you are extracting the value. Note row indices start at 0.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphFlow.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this morph flow (*MORPH_FLOW). Note that a carriage return is not added. See also MorphFlow.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

MorphFlow.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the morph flow. Note that a carriage return is not added. See also MorphFlow.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

MorphFlow.Last = function() {
    /// <signature>
    /// <summary>Returns the last flow in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last flow in</param>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next flow in the model.</summary>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a flow.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only flows from that model can be picked. If the argument is a Flag then only flows that are flagged with limit can be selected. If omitted, or null, any flows from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous flow in the model.</summary>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.prototype.RemoveRow = function() {
    /// <signature>
    /// <summary>Removes the data (a morph point ID and its three vector components) for a row in *MORPH_FLOW.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to remove the data for. Note that row indices start at 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.RemoveValue = function() {
    /// <signature>
    /// <summary>Removes the value at given index in *MORPH_FLOW with type "DISCRETE".</summary>
    /// <param name="index" type="Number" optional="false">The index where you are removing the value. Note that indices start at 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select flows using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting flows</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only flows from that model can be selected. If the argument is a Flag then only flows that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any flows can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphFlow.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the flow.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the flow</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.SetRow = function() {
    /// <signature>
    /// <summary>Sets the data for a row in *MORPH_FLOW.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to set the data for. Note that row indices start at 0.</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">The data you want to set the row to. It should be of length 4 having the morph point ID at index 0, and the vector components at indices 1, 2, 3.</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.SetValue = function() {
    /// <signature>
    /// <summary>Sets the value at given index in a *MORPH_FLOW with type "DISCRETE".</summary>
    /// <param name="index" type="Number" optional="false">The row you want to set the data for. Note that row indices start at 0.</param>
    /// <param name="value" type="Number" optional="false">The new value to insert into the list.</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the flow. The flow will be sketched until you either call MorphFlow.Unsketch(), MorphFlow.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the flow is sketched. If omitted redraw is true. If you want to sketch several flows and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged flows in the model. The flows will be sketched until you either call MorphFlow.Unsketch(), MorphFlow.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged flows will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the flows that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the flows are sketched. If omitted redraw is true. If you want to sketch flagged flows several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of flows in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing flows should be counted. If false or omitted referenced but undefined flows will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphFlow.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the flow</summary>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the flows in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all flows will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged flows in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged flows will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the flows that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the flows in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all flows will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the flows</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the flow.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the flow is unsketched. If omitted redraw is true. If you want to unsketch several flows and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all flows.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all flows will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the flows are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged flows in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all flows will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the flows that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the flows are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="MorphFlow"/>
    /// </signature>
}

MorphFlow.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for flow. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphFlow.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this flow.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

MorphFlow.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the morph flow data in keyword format. Note that this contains the keyword header and the keyword cards. See also MorphFlow.Keyword() and MorphFlow.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var MorphPoint = function() {
    /// <signature>
    /// <summary>Create a new MorphPoint object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that morph point will be created in</param>
    /// <param name="label" type="Number" optional="false">MorphPoint number</param>
    /// <param name="x" type="Number" optional="false">X coordinate</param>
    /// <param name="y" type="Number" optional="false">Y coordinate</param>
    /// <param name="z" type="Number" optional="false">Z coordinate</param>
    /// <returns type="MorphPoint"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if morph point exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the morph point is in.</field>
    /// <field name='label' static='false' type='Number'>MorphPoint number.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the point is in.</field>
    /// <field name='x' static='false' type='Number'>X coordinate</field>
    /// <field name='y' static='false' type='Number'>Y coordinate</field>
    /// <field name='z' static='false' type='Number'>Z coordinate</field>
}

MorphPoint.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the point</summary>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the points in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all points will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged points in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged points will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the points that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the point is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

MorphPoint.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the point.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the point</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the point.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="MorphPoint"/>
    /// </signature>
}

MorphPoint.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for point. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.First = function() {
    /// <signature>
    /// <summary>Returns the first point in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first point in</param>
    /// <returns type="MorphPoint"/>
    /// </signature>
}

MorphPoint.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free point label in the model. Also see MorphPoint.LastFreeLabel(), MorphPoint.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free point label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphPoint.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the points in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all points will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the points</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the point is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the point</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

MorphPoint.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each point in the model. Note that ForEach has been designed to make looping over points as fast as possible and so has some limitations. Firstly, a single temporary MorphPoint object is created and on each function call it is updated with the current point data. This means that you should not try to store the MorphPoint object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new points inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all points are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each point</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of MorphPoint objects for all of the points in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get points from</param>
    /// <returns type="Array" elementType="MorphPoint"/>
    /// </signature>
}

MorphPoint.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of MorphPoint objects for all of the flagged points in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get points from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the points that you want to retrieve</param>
    /// <returns type="Array" elementType="MorphPoint"/>
    /// </signature>
}

MorphPoint.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the MorphPoint object for a point ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the point in</param>
    /// <param name="number" type="Number" optional="false">number of the point you want the MorphPoint object for</param>
    /// <returns type="MorphPoint"/>
    /// </signature>
}

MorphPoint.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a MorphPoint property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the MorphPoint.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">point property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

MorphPoint.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this morph point (*MORPH_POINT). Note that a carriage return is not added. See also MorphPoint.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

MorphPoint.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the morph point. Note that a carriage return is not added. See also MorphPoint.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

MorphPoint.Last = function() {
    /// <signature>
    /// <summary>Returns the last point in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last point in</param>
    /// <returns type="MorphPoint"/>
    /// </signature>
}

MorphPoint.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free point label in the model. Also see MorphPoint.FirstFreeLabel(), MorphPoint.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free point label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphPoint.MoveFlagged = function() {
    /// <signature>
    /// <summary>This function moves a selection of flagged morph points by a given vector and interpolates the movement of other morph points in the same way as this happens on the interactive morph panel. Note that the interpolation depends on the settings which can be switched on the interactive morph panel or by preferences. To apply the movement to the nodes in the box(es), you will need to call MorphBox.ApplyMorphing() at least for all relevant boxes or (if that is easier) for all morph boxes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged morph points are in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the morph points explicitly selected to move</param>
    /// <param name="dx" type="Number" optional="false">X component of vector to be moved along</param>
    /// <param name="dy" type="Number" optional="false">Y component of vector to be moved along</param>
    /// <param name="dz" type="Number" optional="false">Z component of vector to be moved along</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next point in the model.</summary>
    /// <returns type="MorphPoint"/>
    /// </signature>
}

MorphPoint.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) point label in the model. Also see MorphPoint.FirstFreeLabel(), MorphPoint.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free point label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphPoint.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a point.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only points from that model can be picked. If the argument is a Flag then only points that are flagged with limit can be selected. If omitted, or null, any points from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="MorphPoint"/>
    /// </signature>
}

MorphPoint.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous point in the model.</summary>
    /// <returns type="MorphPoint"/>
    /// </signature>
}

MorphPoint.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the points in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all points will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged points in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged points will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the points that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select points using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting points</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only points from that model can be selected. If the argument is a Flag then only points that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any points can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphPoint.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the point.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the point</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the point. The point will be sketched until you either call MorphPoint.Unsketch(), MorphPoint.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the point is sketched. If omitted redraw is true. If you want to sketch several points and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged points in the model. The points will be sketched until you either call MorphPoint.Unsketch(), MorphPoint.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged points will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the points that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the points are sketched. If omitted redraw is true. If you want to sketch flagged points several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of points in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing points should be counted. If false or omitted referenced but undefined points will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

MorphPoint.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the point</summary>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the points in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all points will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged points in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged points will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the points that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the points in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all points will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the points</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the point.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the point is unsketched. If omitted redraw is true. If you want to unsketch several points and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all points.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all points will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the points are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged points in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all points will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the points that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the points are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="MorphPoint"/>
    /// </signature>
}

MorphPoint.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for point. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

MorphPoint.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this point.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

MorphPoint.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the morph point data in keyword format. Note that this contains the keyword header and the keyword cards. See also MorphPoint.Keyword() and MorphPoint.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var NodalForceGroup = function() {
    /// <signature>
    /// <summary>Create a new NodalForceGroup object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that nodal force group will be created in</param>
    /// <param name="nsid" type="Number" optional="false">Set Node Set ID.</param>
    /// <param name="cid" type="Number" optional="true">Coordinate System ID.</param>
    /// <returns type="NodalForceGroup"/>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>Coordinate System ID.</field>
    /// <field name='exists' static='false' type='Boolean'>true if Nodal Force Group exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Number'>Database Nodal Force Group number (identical to label).</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the Nodal Force Group is in.</field>
    /// <field name='label' static='false' type='Number'>Database Nodal Force Group number.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the nodal force group is in.</field>
    /// <field name='nsid' static='false' type='Number'>Set Node Set ID.</field>
}

NodalForceGroup.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the nodal force group</summary>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the nodal force groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal force groups will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged nodal force groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged nodal force groups will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal force groups that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the nodal force group is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

NodalForceGroup.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the nodal force group.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the nodal force group</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the nodal force group.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for nodal force group. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.First = function() {
    /// <signature>
    /// <summary>Returns the first nodal force group in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first nodal force group in</param>
    /// <returns type="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the nodal force groups in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal force groups will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the nodal force groups</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the nodal force group is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the nodal force group</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

NodalForceGroup.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each nodal force group in the model. Note that ForEach has been designed to make looping over nodal force groups as fast as possible and so has some limitations. Firstly, a single temporary NodalForceGroup object is created and on each function call it is updated with the current nodal force group data. This means that you should not try to store the NodalForceGroup object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new nodal force groups inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal force groups are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each nodal force group</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of NodalForceGroup objects for all of the nodal force groups in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get nodal force groups from</param>
    /// <returns type="Array" elementType="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of NodalForceGroup objects for all of the flagged nodal force groups in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get nodal force groups from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal force groups that you want to retrieve</param>
    /// <returns type="Array" elementType="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the NodalForceGroup object for a nodal force group ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the nodal force group in</param>
    /// <param name="number" type="Number" optional="false">number of the nodal force group you want the NodalForceGroup object for</param>
    /// <returns type="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a NodalForceGroup property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the NodalForceGroup.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">nodal force group property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

NodalForceGroup.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this nodal force group. Note that a carriage return is not added. See also NodalForceGroup.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

NodalForceGroup.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the nodal force group. Note that a carriage return is not added. See also NodalForceGroup.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

NodalForceGroup.Last = function() {
    /// <signature>
    /// <summary>Returns the last nodal force group in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last nodal force group in</param>
    /// <returns type="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next nodal force group in the model.</summary>
    /// <returns type="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a nodal force group.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only nodal force groups from that model can be picked. If the argument is a Flag then only nodal force groups that are flagged with limit can be selected. If omitted, or null, any nodal force groups from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous nodal force group in the model.</summary>
    /// <returns type="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select nodal force groups using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting nodal force groups</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only nodal force groups from that model can be selected. If the argument is a Flag then only nodal force groups that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any nodal force groups can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodalForceGroup.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the nodal force group.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the nodal force group</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the nodal force group. The nodal force group will be sketched until you either call NodalForceGroup.Unsketch(), NodalForceGroup.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal force group is sketched. If omitted redraw is true. If you want to sketch several nodal force groups and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged nodal force groups in the model. The nodal force groups will be sketched until you either call NodalForceGroup.Unsketch(), NodalForceGroup.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged nodal force groups will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal force groups that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal force groups are sketched. If omitted redraw is true. If you want to sketch flagged nodal force groups several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of nodal force groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing nodal force groups should be counted. If false or omitted referenced but undefined nodal force groups will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodalForceGroup.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the nodal force group</summary>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the nodal force groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal force groups will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged nodal force groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged nodal force groups will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal force groups that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the nodal force groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all nodal force groups will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the nodal force groups</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the nodal force group.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal force group is unsketched. If omitted redraw is true. If you want to unsketch several nodal force groups and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all nodal force groups.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal force groups will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal force groups are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged nodal force groups in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal force groups will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal force groups that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal force groups are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="NodalForceGroup"/>
    /// </signature>
}

NodalForceGroup.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for nodal force group. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalForceGroup.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this nodal force group.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

NodalForceGroup.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the nodal force group data in keyword format. Note that this contains the keyword header and the keyword cards. See also NodalForceGroup.Keyword() and NodalForceGroup.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var NodalRigidBody = function() {
    /// <signature>
    /// <summary>Create a new NodalRigidBody object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that nrb will be created in</param>
    /// <param name="nsid" type="Number" optional="false">Nodal set ID</param>
    /// <param name="pid" type="Number" optional="true">NodalRigidBody ID of the NRB. Also see the label property which is an alternative name for this.</param>
    /// <param name="cid" type="Number" optional="true">Coordinate system ID</param>
    /// <param name="pnode" type="Number" optional="true">Optional nodal point</param>
    /// <param name="iprt" type="Number" optional="true">Print flag</param>
    /// <param name="drflag" type="Number" optional="true">Displacement release flag</param>
    /// <param name="rrflag" type="Number" optional="true">Rotation release flag</param>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
    /// <field name='cid' static='false' type='Number'>Coordinate system ID</field>
    /// <field name='cmo' static='false' type='Number'>Centre of mass option</field>
    /// <field name='con1' static='false' type='Number'>First retraint parameter</field>
    /// <field name='con2' static='false' type='Number'>Second retraint parameter</field>
    /// <field name='drflag' static='false' type='Number'>Displacement release flag</field>
    /// <field name='exists' static='false' type='Boolean'>true if nrb exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the nrb is in.</field>
    /// <field name='inertia' static='false' type='Boolean'>Flag to turn on or off _INERTIA option</field>
    /// <field name='iprt' static='false' type='Number'>Print flag</field>
    /// <field name='ixx' static='false' type='Number'>Ixx component of inertia tensor</field>
    /// <field name='ixy' static='false' type='Number'>Ixy component of inertia tensor</field>
    /// <field name='ixz' static='false' type='Number'>Ixz component of inertia tensor</field>
    /// <field name='iyy' static='false' type='Number'>Iyy component of inertia tensor</field>
    /// <field name='iyz' static='false' type='Number'>Iyz component of inertia tensor</field>
    /// <field name='izz' static='false' type='Number'>Izz component of inertia tensor</field>
    /// <field name='label' static='false' type='Number'>NodalRigidBody ID of the NRB. Also see the pid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the nodal rigid body is in.</field>
    /// <field name='nodeid' static='false' type='Number'>Optional node point</field>
    /// <field name='nsid' static='false' type='Number'>Nodal set ID</field>
    /// <field name='pid' static='false' type='Number'>NodalRigidBody ID of the NRB. Also see the label property which is an alternative name for this.</field>
    /// <field name='pnode' static='false' type='Number'>Optional nodal point</field>
    /// <field name='rrflag' static='false' type='Number'>Rotation release flag</field>
    /// <field name='spc' static='false' type='Boolean'>Flag to turn on or off _SPC option</field>
    /// <field name='tm' static='false' type='Number'>Translational mass</field>
    /// <field name='vrx' static='false' type='Number'>X rigid body rotational velocity</field>
    /// <field name='vry' static='false' type='Number'>Y rigid body rotational velocity</field>
    /// <field name='vrz' static='false' type='Number'>Z rigid body rotational velocity</field>
    /// <field name='vtx' static='false' type='Number'>X rigid body translational velocity</field>
    /// <field name='vty' static='false' type='Number'>Y rigid body translational velocity</field>
    /// <field name='vtz' static='false' type='Number'>Z rigid body translational velocity</field>
    /// <field name='xc' static='false' type='Number'>X coordinate centre of mass</field>
    /// <field name='xl' static='false' type='Number'>X coordinate of local x axis</field>
    /// <field name='xlip' static='false' type='Number'>X coordinate of local in plane vector</field>
    /// <field name='yc' static='false' type='Number'>Y coordinate centre of mass</field>
    /// <field name='yl' static='false' type='Number'>Y coordinate of local x axis</field>
    /// <field name='ylip' static='false' type='Number'>Y coordinate of local in plane vector</field>
    /// <field name='zc' static='false' type='Number'>Z coordinate centre of mass</field>
    /// <field name='zl' static='false' type='Number'>Z coordinate of local x axis</field>
    /// <field name='zlip' static='false' type='Number'>Z coordinate of local in plane vector</field>
}

NodalRigidBody.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the nodal rigid body</summary>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the nodal rigid bodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal rigid bodys will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged nodal rigid bodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged nodal rigid bodys will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal rigid bodys that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the nodal rigid body is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

NodalRigidBody.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the nodal rigid body.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the nodal rigid body</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the nodal rigid body.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a nrb.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the nrb will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for nodal rigid body. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.First = function() {
    /// <signature>
    /// <summary>Returns the first nodal rigid body in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first nodal rigid body in</param>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free nodal rigid body label in the model. Also see NodalRigidBody.LastFreeLabel(), NodalRigidBody.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free nodal rigid body label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodalRigidBody.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the nodal rigid bodys in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal rigid bodys will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the nodal rigid bodys</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the nodal rigid body is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the nodal rigid body</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

NodalRigidBody.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each nodal rigid body in the model. Note that ForEach has been designed to make looping over nodal rigid bodys as fast as possible and so has some limitations. Firstly, a single temporary NodalRigidBody object is created and on each function call it is updated with the current nodal rigid body data. This means that you should not try to store the NodalRigidBody object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new nodal rigid bodys inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal rigid bodys are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each nodal rigid body</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of NodalRigidBody objects for all of the nodal rigid bodys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get nodal rigid bodys from</param>
    /// <returns type="Array" elementType="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of NodalRigidBody objects for all of the flagged nodal rigid bodys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get nodal rigid bodys from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal rigid bodys that you want to retrieve</param>
    /// <returns type="Array" elementType="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the NodalRigidBody object for a nodal rigid body ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the nodal rigid body in</param>
    /// <param name="number" type="Number" optional="false">number of the nodal rigid body you want the NodalRigidBody object for</param>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a NodalRigidBody property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the NodalRigidBody.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">nodal rigid body property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

NodalRigidBody.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this nrb (*CONSTRAINED_NODAL_RIGID_BODY_xxxx). Note that a carriage return is not added. See also NodalRigidBody.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

NodalRigidBody.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the nrb. Note that a carriage return is not added. See also NodalRigidBody.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

NodalRigidBody.Last = function() {
    /// <signature>
    /// <summary>Returns the last nodal rigid body in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last nodal rigid body in</param>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free nodal rigid body label in the model. Also see NodalRigidBody.FirstFreeLabel(), NodalRigidBody.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free nodal rigid body label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodalRigidBody.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next nodal rigid body in the model.</summary>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) nodal rigid body label in the model. Also see NodalRigidBody.FirstFreeLabel(), NodalRigidBody.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free nodal rigid body label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodalRigidBody.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a nodal rigid body.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only nodal rigid bodys from that model can be picked. If the argument is a Flag then only nodal rigid bodys that are flagged with limit can be selected. If omitted, or null, any nodal rigid bodys from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous nodal rigid body in the model.</summary>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the nodal rigid bodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal rigid bodys will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged nodal rigid bodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged nodal rigid bodys will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal rigid bodys that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select nodal rigid bodys using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting nodal rigid bodys</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only nodal rigid bodys from that model can be selected. If the argument is a Flag then only nodal rigid bodys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any nodal rigid bodys can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodalRigidBody.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the nodal rigid body.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the nodal rigid body</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the nodal rigid body. The nodal rigid body will be sketched until you either call NodalRigidBody.Unsketch(), NodalRigidBody.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal rigid body is sketched. If omitted redraw is true. If you want to sketch several nodal rigid bodys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged nodal rigid bodys in the model. The nodal rigid bodys will be sketched until you either call NodalRigidBody.Unsketch(), NodalRigidBody.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged nodal rigid bodys will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal rigid bodys that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal rigid bodys are sketched. If omitted redraw is true. If you want to sketch flagged nodal rigid bodys several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of nodal rigid bodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing nodal rigid bodys should be counted. If false or omitted referenced but undefined nodal rigid bodys will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodalRigidBody.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the nodal rigid body</summary>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the nodal rigid bodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal rigid bodys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged nodal rigid bodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged nodal rigid bodys will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal rigid bodys that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the nodal rigid bodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all nodal rigid bodys will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the nodal rigid bodys</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the nodal rigid body.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal rigid body is unsketched. If omitted redraw is true. If you want to unsketch several nodal rigid bodys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all nodal rigid bodys.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal rigid bodys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal rigid bodys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged nodal rigid bodys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodal rigid bodys will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodal rigid bodys that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodal rigid bodys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="NodalRigidBody"/>
    /// </signature>
}

NodalRigidBody.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for nodal rigid body. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

NodalRigidBody.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this nodal rigid body.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

NodalRigidBody.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the nrb data in keyword format. Note that this contains the keyword header and the keyword cards. See also NodalRigidBody.Keyword() and NodalRigidBody.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Node = function() {
    /// <signature>
    /// <summary>Create a new Node object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that node will be created in</param>
    /// <param name="nid" type="Number" optional="false">Node number</param>
    /// <param name="x" type="Number" optional="false">X coordinate</param>
    /// <param name="y" type="Number" optional="false">Y coordinate</param>
    /// <param name="z" type="Number" optional="false">Z coordinate</param>
    /// <param name="tc" type="Number" optional="true">Translational constraint (0-7). If omitted tc will be set to 0.</param>
    /// <param name="rc" type="Number" optional="true">Rotational constraint (0-7). If omitted rc will be set to 0.</param>
    /// <returns type="Node"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the node</field>
    /// <field name='exists' static='false' type='Boolean'>true if node exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the node is in.</field>
    /// <field name='label' static='false' type='Number'>Node number. Also see the nid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the node is in.</field>
    /// <field name='ndof' static='false' type='Number'>Number of degrees of freedom (SCALAR and SCALAR_VALUE only).</field>
    /// <field name='nid' static='false' type='Number'>Node number. Also see the label property which is an alternative name for this.</field>
    /// <field name='rc' static='false' type='Number'>Rotational constraint (0-7)</field>
    /// <field name='scalar' static='false' type='Number'>The type of the node. Can be false (*NODE), Node.SCALAR (*NODE_SCALAR) or Node.SCALAR_VALUE (*NODE_SCALAR_VALUE)</field>
    /// <field name='tc' static='false' type='Number'>Translational constraint (0-7)</field>
    /// <field name='x' static='false' type='Number'>X coordinate</field>
    /// <field name='x1' static='false' type='Number'>Initial value of 1st degree of freedom (SCALAR_VALUE only).</field>
    /// <field name='x2' static='false' type='Number'>Initial value of 2nd degree of freedom (SCALAR_VALUE only).</field>
    /// <field name='x3' static='false' type='Number'>Initial value of 3rd degree of freedom (SCALAR_VALUE only).</field>
    /// <field name='y' static='false' type='Number'>Y coordinate</field>
    /// <field name='z' static='false' type='Number'>Z coordinate</field>
    /// <field name='SCALAR' static='true' type='Number'>Node is *NODE_SCALAR.</field>
    /// <field name='SCALAR_VALUE' static='true' type='Number'>Node is *NODE_SCALAR_VALUE.</field>
}

Node.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the node</summary>
    /// <returns type="null"/>
    /// </signature>
}

Node.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodes will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged nodes will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodes that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the node is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Node.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the node.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the node</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the node.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Node"/>
    /// </signature>
}

Node.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a node.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the node will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Node"/>
    /// </signature>
}

Node.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for node. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for node. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the node colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the node.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Node.First = function() {
    /// <signature>
    /// <summary>Returns the first node in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first node in</param>
    /// <returns type="Node"/>
    /// </signature>
}

Node.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free node label in the model. Also see Node.LastFreeLabel(), Node.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free node label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Node.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the nodes in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodes will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the nodes</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the node is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the node</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Node.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each node in the model. Note that ForEach has been designed to make looping over nodes as fast as possible and so has some limitations. Firstly, a single temporary Node object is created and on each function call it is updated with the current node data. This means that you should not try to store the Node object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new nodes inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodes are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each node</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Node objects for all of the nodes in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get nodes from</param>
    /// <returns type="Array" elementType="Node"/>
    /// </signature>
}

Node.prototype.GetAttachedShells = function() {
    /// <signature>
    /// <summary>Returns the shells that are attached to the node.</summary>
    /// <param name="recursive" type="Boolean" optional="true">If recursive is false then only the shells actually attached to the node will be returned (this could also be done by using the Xrefs class but this method is provided for convenience. If recursive is true then PRIMER will keep finding attached shells until no more can be found. If omitted recursive will be false.</param>
    /// <returns type="Array" elementType="Shell"/>
    /// </signature>
}

Node.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Node objects for all of the flagged nodes in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get nodes from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodes that you want to retrieve</param>
    /// <returns type="Array" elementType="Node"/>
    /// </signature>
}

Node.prototype.GetFreeEdgeNodes = function() {
    /// <signature>
    /// <summary>If the node is on a shell free edge and that edge forms a loop like the boundary of a hole, then GetFreeEdgeNodes returns all of the nodes on the hole/boundary in order. Note that a free edge is a shell edge which is only used by one shell, whereas edges in the middle of a shell part will have got more than one adjacent shell and are therefore not free edges. If every node on a boundary belongs to exactly two free edges, then this function returns the array as described. In more involved combinatorics of shells, for example multiple parts sharing nodes along their boundaries, there can be one, three or more free edges at a node, and this function should not be used. If you only need to know whether or not a node is on a free edge, you should find the shells attached to it by cross references with Xrefs.GetItemID and see whether these shells have got other nodes in common as well. If nodes along an edge of a shell only appear in that one shell, this is a free edge.</summary>
    /// <returns type="Array" elementType="Node"/>
    /// </signature>
}

Node.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Node object for a node ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the node in</param>
    /// <param name="number" type="Number" optional="false">number of the node you want the Node object for</param>
    /// <returns type="Node"/>
    /// </signature>
}

Node.prototype.GetInitialVelocities = function() {
    /// <signature>
    /// <summary>Returns the initial velocity of the node. You need to be sure the field nvels of the node is populate before to use GetInitialVelocities. To do so you can use  Model.PopNodeVels .</summary>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Node.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Node property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Node.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">node property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Node.prototype.GetReferenceGeometry = function() {
    /// <signature>
    /// <summary>Returns the airbag reference geometry of the node</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Node.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this node (*NODE, *NODE_SCALAR or *NODE_SCALAR_VALUE). Note that a carriage return is not added. See also Node.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Node.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the node. Note that a carriage return is not added. See also Node.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Node.Last = function() {
    /// <signature>
    /// <summary>Returns the last node in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last node in</param>
    /// <returns type="Node"/>
    /// </signature>
}

Node.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free node label in the model. Also see Node.FirstFreeLabel(), Node.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free node label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Node.Merge = function() {
    /// <signature>
    /// <summary>Attempts to merge nodes flagged with flag for a model in PRIMER. Merging nodes on *AIRBAG_SHELL_REFERENCE_GEOMETRY can be controlled by using Options.node_replace_asrg. Also see Model.MergeNodes().</summary>
    /// <param name="Model" type="Model" optional="false">Model that the nodes will be merged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on nodes to nodes</param>
    /// <param name="dist" type="Number" optional="false">Nodes closer than dist will be potentially merged.</param>
    /// <param name="label" type="Number" optional="true">Label to keep after merge. If &gt; 0 then highest label kept. If &lt;= 0 then lowest kept. If omitted the lowest label will be kept.</param>
    /// <param name="position" type="Number" optional="true">Position to merge at. If &gt; 0 then merged at highest label position. If &lt; 0 then merged at lowest label position. If 0 then merged at midpoint. If omitted the merge will be done at the lowest label.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Node.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next node in the model.</summary>
    /// <returns type="Node"/>
    /// </signature>
}

Node.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) node label in the model. Also see Node.FirstFreeLabel(), Node.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free node label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Node.prototype.NodalMass = function() {
    /// <signature>
    /// <summary>Get the mass of a node. This will be the sum of the structural element mass attached to the node plus any lumped mass. If called on the node of a PART_INERTIA or NRBC_INERTIA, this function will return the mass of the part/nrbc, as 'nodal mass' has no meaning in this context.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Node.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a node.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only nodes from that model can be picked. If the argument is a Flag then only nodes that are flagged with limit can be selected. If omitted, or null, any nodes from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Node"/>
    /// </signature>
}

Node.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous node in the model.</summary>
    /// <returns type="Node"/>
    /// </signature>
}

Node.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodes will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged nodes will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodes that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select nodes using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting nodes</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only nodes from that model can be selected. If the argument is a Flag then only nodes that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any nodes can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Node.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the node.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the node</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the node. The node will be sketched until you either call Node.Unsketch(), Node.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the node is sketched. If omitted redraw is true. If you want to sketch several nodes and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged nodes in the model. The nodes will be sketched until you either call Node.Unsketch(), Node.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged nodes will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodes that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodes are sketched. If omitted redraw is true. If you want to sketch flagged nodes several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing nodes should be counted. If false or omitted referenced but undefined nodes will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Node.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the node</summary>
    /// <returns type="null"/>
    /// </signature>
}

Node.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodes will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged nodes will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodes that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all nodes will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the nodes</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the node.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the node is unsketched. If omitted redraw is true. If you want to unsketch several nodes and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all nodes.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodes will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged nodes in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all nodes will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the nodes that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Node"/>
    /// </signature>
}

Node.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for node. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Node.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this node.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Node.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the node data in keyword format. Note that this contains the keyword header and the keyword cards. See also Node.Keyword() and Node.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var NodeSet = function() {
    /// <signature>
    /// <summary>Create a new NodeSet object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained node set will be created in</param>
    /// <param name="nsid" type="Number" optional="false">Set Node ID.</param>
    /// <param name="dof" type="Number" optional="false">Degree of freedom.</param>
    /// <param name="tf" type="Number" optional="false">Failure time.</param>
    /// <param name="label" type="Number" optional="true">Constrained node set number.</param>
    /// <returns type="NodeSet"/>
    /// </signature>
    /// <field name='cnsid' static='false' type='Number'>Constrained node set number (identical to label).</field>
    /// <field name='dof' static='false' type='Number'>Degree of freedom.</field>
    /// <field name='exists' static='false' type='Boolean'>true if constrained node set exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the constrained node set is in.</field>
    /// <field name='label' static='false' type='Number'>Constrained node set number.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the node set is in.</field>
    /// <field name='nsid' static='false' type='Number'>Set Node ID.</field>
    /// <field name='tf' static='false' type='Number'>Failure time.</field>
}

NodeSet.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the node set</summary>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the node sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all node sets will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged node sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged node sets will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the node sets that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the node set is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

NodeSet.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the node set.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the node set</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the node set.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="NodeSet"/>
    /// </signature>
}

NodeSet.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a node_set.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the node_set will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="NodeSet"/>
    /// </signature>
}

NodeSet.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for node set. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.First = function() {
    /// <signature>
    /// <summary>Returns the first node set in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first node set in</param>
    /// <returns type="NodeSet"/>
    /// </signature>
}

NodeSet.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free node set label in the model. Also see NodeSet.LastFreeLabel(), NodeSet.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free node set label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodeSet.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the node sets in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all node sets will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the node sets</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the node set is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the node set</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

NodeSet.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each node set in the model. Note that ForEach has been designed to make looping over node sets as fast as possible and so has some limitations. Firstly, a single temporary NodeSet object is created and on each function call it is updated with the current node set data. This means that you should not try to store the NodeSet object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new node sets inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all node sets are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each node set</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of NodeSet objects for all of the node sets in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get node sets from</param>
    /// <returns type="Array" elementType="NodeSet"/>
    /// </signature>
}

NodeSet.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of NodeSet objects for all of the flagged node sets in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get node sets from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the node sets that you want to retrieve</param>
    /// <returns type="Array" elementType="NodeSet"/>
    /// </signature>
}

NodeSet.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the NodeSet object for a node set ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the node set in</param>
    /// <param name="number" type="Number" optional="false">number of the node set you want the NodeSet object for</param>
    /// <returns type="NodeSet"/>
    /// </signature>
}

NodeSet.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a NodeSet property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the NodeSet.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">node set property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

NodeSet.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this node_set (*CONSTRAINED_NODE_SET). Note that a carriage return is not added. See also NodeSet.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

NodeSet.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the node_set. Note that a carriage return is not added. See also NodeSet.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

NodeSet.Last = function() {
    /// <signature>
    /// <summary>Returns the last node set in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last node set in</param>
    /// <returns type="NodeSet"/>
    /// </signature>
}

NodeSet.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free node set label in the model. Also see NodeSet.FirstFreeLabel(), NodeSet.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free node set label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodeSet.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next node set in the model.</summary>
    /// <returns type="NodeSet"/>
    /// </signature>
}

NodeSet.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) node set label in the model. Also see NodeSet.FirstFreeLabel(), NodeSet.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free node set label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodeSet.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a node set.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only node sets from that model can be picked. If the argument is a Flag then only node sets that are flagged with limit can be selected. If omitted, or null, any node sets from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="NodeSet"/>
    /// </signature>
}

NodeSet.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous node set in the model.</summary>
    /// <returns type="NodeSet"/>
    /// </signature>
}

NodeSet.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the node sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all node sets will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged node sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged node sets will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the node sets that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select node sets using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting node sets</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only node sets from that model can be selected. If the argument is a Flag then only node sets that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any node sets can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodeSet.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the node set.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the node set</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the node set. The node set will be sketched until you either call NodeSet.Unsketch(), NodeSet.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the node set is sketched. If omitted redraw is true. If you want to sketch several node sets and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged node sets in the model. The node sets will be sketched until you either call NodeSet.Unsketch(), NodeSet.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged node sets will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the node sets that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the node sets are sketched. If omitted redraw is true. If you want to sketch flagged node sets several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of node sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing node sets should be counted. If false or omitted referenced but undefined node sets will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

NodeSet.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the node set</summary>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the node sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all node sets will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged node sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged node sets will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the node sets that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the node sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all node sets will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the node sets</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the node set.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the node set is unsketched. If omitted redraw is true. If you want to unsketch several node sets and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all node sets.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all node sets will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the node sets are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged node sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all node sets will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the node sets that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the node sets are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="NodeSet"/>
    /// </signature>
}

NodeSet.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for node set. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

NodeSet.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this node set.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

NodeSet.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the node_set data in keyword format. Note that this contains the keyword header and the keyword cards. See also NodeSet.Keyword() and NodeSet.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Options = function() {
    /// <field name='airbag_colour' static='true' type='Number'>Airbag symbol colour</field>
    /// <field name='auto_confirm' static='true' type='Boolean'>If true then ${Program} will automatically confirm (i.e. press the OK button) on (most) message boxes that are mapped. If false (default) then the message boxes will be shown and wait for the user to press a button. This option may be useful to help automate an operation where ${Program} would normally show a message box and wait for the user to press a button.</field>
    /// <field name='background_colour' static='true' type='Number'>Colour of the background</field>
    /// <field name='browse_missing_include_file' static='true' type='Boolean'>If true (default) then PRIMER will popup a "BROWSE MISSING INCLUDE FILE" panel while reading the model. If false then it will throw an 'missing include file error' and continue reading the model.</field>
    /// <field name='connection_angle_tol' static='true' type='Number'>The angle tolerance used for spotwelds in the connections algorithm</field>
    /// <field name='connection_edge_dist' static='true' type='Number'>The edge distance used in the connections algorithm</field>
    /// <field name='connection_file' static='true' type='String'>The connection file to read/write</field>
    /// <field name='connection_max_thickness' static='true' type='Number'>The maximum thickness used in the connections algorithm</field>
    /// <field name='connection_model' static='true' type='Number'>The model number selected to make connections in</field>
    /// <field name='connection_part' static='true' type='Number'>The part ID selected for connections</field>
    /// <field name='connection_write_flag' static='true' type='Number'>Flag that will be set on selected connections when writing. This can be used in the user JavaScript to write connections to find which are selected.</field>
    /// <field name='contacts_colour' static='true' type='Number'>Contact surface colour</field>
    /// <field name='contour_text_size' static='true' type='Number'>Contour bar text size</field>
    /// <field name='convert_rbe2_cnrb' static='true' type='Boolean'>Convert all RBE2s to *CONSTRAINED_NODAL_RIGID_BODY</field>
    /// <field name='date_size' static='true' type='Number'>Size of date (clock) display</field>
    /// <field name='dyna_version' static='true' type='String'>The LS-DYNA version used to write keyword files. Can be "971R5", "971R4", "971R3", "970v6763" etc (see the version popup in Model-&gt;Write '&gt;&gt;&gt; LS-Dyna output options' for a full list). See also Model.Write and Include.Write</field>
    /// <field name='edge_angle' static='true' type='Number'>Feature edge critical angle</field>
    /// <field name='edges_ign_pt' static='true' type='Number'>Option for choosing how to draw free edges (can be set to TRUE or FALSE)</field>
    /// <field name='edit_keep_on_top' static='true' type='Boolean'>If true edit panels created from the Edit() or Create() methods will be kept on top of other windows. If false (default) then they can be lowered.</field>
    /// <field name='exception_messages' static='true' type='Boolean'>If true (default) error messages will be printed to the dialogue box/stdout when an exception occurs in the API. If false they will not be printed. This option may be useful if you are using try/catch to manage exceptions and you do not want any error messages to be printed.</field>
    /// <field name='extra_nodes_colour' static='true' type='Number'>Constrained extra nodes colour</field>
    /// <field name='feature_line' static='true' type='Number'>Switch ON/OFF feature line (can be set to TRUE or FALSE)</field>
    /// <field name='for_mom_colour' static='true' type='Number'>Nodal force/moment colour</field>
    /// <field name='graticule_text_size' static='true' type='Number'>Graticule text size</field>
    /// <field name='keyout_binary' static='true' type='Boolean'>If true then the output file will be written out in binary. If false (default) then an ascii file will be written.</field>
    /// <field name='keyout_compress_format' static='true' type='Number'>This option can be used to specify the mode of compression. Can be Model.INDIVIDUAL_GZIP, Model.INDIVIDUAL_ZIP or Model.PACKAGED_ZIP</field>
    /// <field name='keyout_compress_level' static='true' type='Number'>Compression level for .gz and .zip files. Must be in the range 1 to 9 with 1 being the least compression (fastest speed) to 9 being the greatest compression (slowest speed)</field>
    /// <field name='keyout_compress_switch' static='true' type='Number'>Switch to set the compression during keyout. Can be Model.COMPRESS_KEEP (default), Model.COMPRESS_OFF or Model.COMPRESS_ON</field>
    /// <field name='keyout_i10' static='true' type='Boolean'>If true then i10 format will be used to write the file. If false (default) then the normal LS-DYNA format will be used.</field>
    /// <field name='keyout_large' static='true' type='Boolean'>If true then large format will be used to write the file. If false (default) then the normal LS-DYNA format will be used. Note that large format is only available from version R7.1 and above.</field>
    /// <field name='keyout_method' static='true' type='Number'>The method used to write include files. Can be Include.MASTER_ONLY, Include.MERGE, Include.NOT_WRITTEN, Include.SUBDIR (default) or Include.SAME_DIR </field>
    /// <field name='keyout_parameter_values' static='true' type='Boolean'>This option can be used to specify how parameters are written. If true then the underlying values of any parameters will be written when they are used in data fields rather than '&amp;name'. If false (default) then '&amp;name' will be written.</field>
    /// <field name='keyout_path_type' static='true' type='Number'>The method used to write include paths. Can be Include.ABSOLUTE (default) or Include.RELATIVE </field>
    /// <field name='keyout_separator' static='true' type='Number'>The directory separator used when writing include files. Can be Include.NATIVE (default), Include.UNIX or Include.WINDOWS </field>
    /// <field name='label_colour' static='true' type='Number'>Colour of the label</field>
    /// <field name='label_size' static='true' type='Number'>Label size</field>
    /// <field name='mass_properties_centre_x' static='true' type='Number'>X-coordinate of user defined centre.</field>
    /// <field name='mass_properties_centre_y' static='true' type='Number'>Y-coordinate of user defined centre.</field>
    /// <field name='mass_properties_centre_z' static='true' type='Number'>Z-coordinate of user defined centre.</field>
    /// <field name='mass_properties_coordinate_system_type' static='true' type='Number'>Coordinate system selection: Model.GLOBAL_AXES, Model.LOCAL_AXES, Model.PRINCIPAL_AXES.</field>
    /// <field name='mass_properties_include_attached_mass_deformable_elems' static='true' type='Boolean'>Option to include lumped mass attached to the nodes of deformable elements. Default is OFF.</field>
    /// <field name='mass_properties_include_attached_mass_rigid_elems' static='true' type='Boolean'>Option to include lumped mass attached to the nodes of rigid elements. Default is OFF.</field>
    /// <field name='mass_properties_inertia_center' static='true' type='Number'>Option to set the centre used in inertia properties calculation. By default Centre at CofG is used. Available options are: Model.CENTRE_AT_COFG, Model.USER_DEFINED_CENTRE.</field>
    /// <field name='mass_properties_local_axes' static='true' type='Number'>CSYS ID when using local axes.</field>
    /// <field name='mass_properties_rigid_part_extra_nodes' static='true' type='Boolean'>Option to switch on/off mass of *CONSTRAINED_EXTRA_NODES associated with a rigid part. Default is ON.</field>
    /// <field name='mass_properties_rigid_part_slave_parts' static='true' type='Boolean'>Option to switch on/off mass of *CONSTRAINED_RIGID_BODIES associated with a rigid part. Default is ON .</field>
    /// <field name='max_widgets' static='true' type='Number'>The maximum number of Widgets that can be made for one Window. The default value is 1000</field>
    /// <field name='max_window_lines' static='true' type='Number'>The maximum number of lines that can be made for a Window.Error(), Window.Information(), Window.Message(), Window.Question() or Window.Warning() window. The default value is 25</field>
    /// <field name='merge_rbe_nodes' static='true' type='Boolean'>Merge duplicate RBE dependent nodes</field>
    /// <field name='merge_set_collect' static='true' type='Boolean'>If true then when merging models PRIMER will merge *SET_COLLECT cards which have the same label. If false (default) then they will be renumbered. This is also used with Model.ImportInclude. The default for this can be set using the primer*merge_set_collect preference.</field>
    /// <field name='model_tabs_active' static='true' type='Boolean'>If true (default) then Primer will show model tabs in the object selection menu. If false then Primer will hide model tabs in object selection menu.</field>
    /// <field name='node_colour' static='true' type='Number'>Nodes colour</field>
    /// <field name='node_replace_asrg' static='true' type='Boolean'>If true nodes in *AIRBAG_SHELL_REFERENCE_GEOMETRY can be replaced by node merge/replace. If false they will not be considered.</field>
    /// <field name='nrb_colour' static='true' type='Number'>Nodal rigid body colour</field>
    /// <field name='overlay_colour' static='true' type='Number'>Colour of the overlay</field>
    /// <field name='overlay_edges' static='true' type='Number'>Option for setting the overlay edges value (can be set to 0,1 or 2)</field>
    /// <field name='pick_window_position' static='true' type='Number'>Position that the pick window will be shown on the screen. It can be any combination (bitwise OR) of Window.LEFT, Window.CENTRE, Window.RIGHT, Window.TOP, Window.MIDDLE and Window.BOTTOM or a Window object. If a window obect is used the pick window will be shown in the middle of that window. The default is Window.RIGHT|Window.TOP.</field>
    /// <field name='property_parameter_names' static='true' type='Boolean'>If true object properties which are parameters will be returned as parameter names. If false object properties which are parameters will be returned as parameter values.</field>
    /// <field name='reset_cwd' static='true' type='Boolean'>If true then the current working directory will not be changed after selecting a file. If false (default) then the current working directory will be changed after selecting a file. This option only applies to Windows machines.</field>
    /// <field name='retain_mid_nodes' static='true' type='Boolean'>Retain mid-side nodes for higher order elements</field>
    /// <field name='rigid_bodies_colour' static='true' type='Number'>Constrained rigid body colour</field>
    /// <field name='rot_vels_colour' static='true' type='Number'>Rotational velocity colour</field>
    /// <field name='sketch_colour' static='true' type='Number'>Colour of the sketch</field>
    /// <field name='solid_spotweld_diameter' static='true' type='Number'>The default diameter of solid spotwelds.</field>
    /// <field name='spotweld_element_type' static='true' type='Number'>The default type of spotweld to make. can be: Conx.SPOTWELD_BEAM, Conx.SPOTWELD_SOLID1, Conx.SPOTWELD_SOLID4, Conx.SPOTWELD_SOLID8, Conx.SPOTWELD_SOLID12 or Conx.SPOTWELD_SOLID16</field>
    /// <field name='spotweldbeam_colour_from_panels' static='true' type='Number'>Spotweld beam/solid colour</field>
    /// <field name='spr_colour_from_node_sets' static='true' type='Number'>Constrained SPR/SPR2/SPR3 colour</field>
    /// <field name='text_colour' static='true' type='Number'>Colour of the text</field>
    /// <field name='timehist_blks_colour' static='true' type='Number'>Time history block colour</field>
    /// <field name='tracer_partl_colour' static='true' type='Number'>Tracer particle colour</field>
    /// <field name='trans_vels_colour' static='true' type='Number'>Translational velocity colour</field>
    /// <field name='x_sections_colour' static='true' type='Number'>Cross-section colour</field>
}

var Parameter = function() {
    /// <signature>
    /// <summary>Create a new Parameter object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that parameter will be created in</param>
    /// <param name="name" type="String" optional="false">Parameter name</param>
    /// <param name="type" type="Number" optional="false">Can be Parameter.INTEGER, Parameter.REAL or Parameter.CHARACTER.</param>
    /// <param name="expression" type="Boolean" optional="false">true if *PARAMETER_EXPRESSION, false otherwise.</param>
    /// <param name="value" type="Number" optional="false">Parameter value. The value will be a string for character parameters or parameter expressions, or a number for integer or real parameters.</param>
    /// <param name="suffix" type="Number" optional="true">Keyword suffix Can be Parameter.LOCAL for *PARAMETER_..._LOCAL, Parameter.MUTABLE for *PARAMETER_..._MUTABLE. These may be bitwise ORed together, ie Parameter.LOCAL | Parameter.MUTABLE. If omitted the parameter will not be local or mutable.</param>
    /// <returns type="Parameter"/>
    /// </signature>
    /// <field name='expression' static='false' type='Boolean'>true if this parameter is a *PARAMETER_EXPRESSION, false otherwise.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the parameter is in.</field>
    /// <field name='local' static='false' type='Boolean'>true if this parameter is a *PARAMETER_... _LOCAL, false otherwise.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the parameter is in.</field>
    /// <field name='mutable' static='false' type='Boolean'>true if this parameter is a *PARAMETER_... _MUTABLE, false otherwise.</field>
    /// <field name='name' static='false' type='String'>Parameter name.</field>
    /// <field name='type' static='false' type='Number'>Can be Parameter.INTEGER, Parameter.REAL or Parameter.CHARACTER.</field>
    /// <field name='value' static='false' type='Number'>Parameter value. The value will be a string for parameter expressions, or a number for normal parameters.</field>
    /// <field name='CHARACTER' static='true' type='Number'>Parameter is a character.</field>
    /// <field name='INTEGER' static='true' type='Number'>Parameter is an integer.</field>
    /// <field name='LOCAL' static='true' type='Number'>Parameter has _LOCAL suffix (used in suffix argument for constructor).</field>
    /// <field name='MUTABLE' static='true' type='Number'>Parameter has _MUTABLE suffix (used in suffix argument for constructor).</field>
    /// <field name='REAL' static='true' type='Number'>Parameter is a real.</field>
}

Parameter.AutoReorder = function() {
    /// <signature>
    /// <summary>Auto Reorders all the parameters in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that contains all parameters that will be re-ordered</param>
    /// <returns type="null"/>
    /// </signature>
}

Parameter.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the parameter.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the parameter</param>
    /// <returns type="null"/>
    /// </signature>
}

Parameter.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the parameters in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all parameters will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the parameters</param>
    /// <returns type="null"/>
    /// </signature>
}

Parameter.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the parameter is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the parameter</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Parameter.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Parameter objects for all of the parameters in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get parameters from</param>
    /// <returns type="Array" elementType="Parameter"/>
    /// </signature>
}

Parameter.GetAllOfName = function() {
    /// <signature>
    /// <summary>Returns an array of Parameter objects for all parameters in a model matching Name. If none are found that match it will return NULL. (Multiple parameters of the same name may exist if they use the _LOCAL or _MUTABLE suffices. PRIMER will also store multiple illegal instances of parameter name, using the instance as determined by the PARAMETER_DUPLICATION card.)</summary>
    /// <param name="Model" type="Model" optional="false">Model to get parameters from</param>
    /// <returns type="Array" elementType="Parameter"/>
    /// </signature>
}

Parameter.GetFromName = function() {
    /// <signature>
    /// <summary>Returns the stored Parameter object for a parameter name. WARNING: if more than one parameter Name exists (eg _LOCAL, _MUTABLE) then only the first occurrence is returned. To return all parameters matching Name use GetAllOfName() instead.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the parameter in</param>
    /// <param name="parameter name" type="String" optional="false">name of the parameter you want the Parameter object for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Parameter.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this parameter (*PARAMETER, *PARAMETER_EXPRESSION). Note that a carriage return is not added. See also Parameter.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Parameter.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the parameter. Note that a carriage return is not added. See also Parameter.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Parameter.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the parameter.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the parameter</param>
    /// <returns type="null"/>
    /// </signature>
}

Parameter.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the parameters in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all parameters will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the parameters</param>
    /// <returns type="null"/>
    /// </signature>
}

Parameter.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this parameter.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Parameter.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the parameter data in keyword format. Note that this contains the keyword header and the keyword cards. See also Parameter.Keyword() and Parameter.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Part = function() {
    /// <signature>
    /// <summary>Create a new Part object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that part will be created in</param>
    /// <param name="pid" type="Number" optional="false">Part number</param>
    /// <param name="secid" type="Number" optional="false">Section number or character label</param>
    /// <param name="mid" type="Number" optional="false">Material number or character label</param>
    /// <param name="heading" type="String" optional="true">Title for the part</param>
    /// <returns type="Part"/>
    /// </signature>
    /// <field name='adpopt' static='false' type='Number'>Adaptivity flag</field>
    /// <field name='ansid' static='false' type='Number'>Attachment node set ID</field>
    /// <field name='attachment_nodes' static='false' type='Boolean'>If _ATTACHMENT_NODES option is set. Can be true or false</field>
    /// <field name='averaged' static='false' type='Boolean'>If _AVERAGED option is set. Can be true or false</field>
    /// <field name='cadname' static='false' type='String'>CAD name stored for Part (or null if doesn't exist). This property is only used by PRIMER.</field>
    /// <field name='cid' static='false' type='Number'>Coordinate system number</field>
    /// <field name='cmsn' static='false' type='Number'>CAL3D/MADYMO number</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the part</field>
    /// <field name='composite' static='false' type='Boolean'>If _COMPOSITE option is set. Can be true or false</field>
    /// <field name='composite_long' static='false' type='Boolean'>If _COMPOSITE_LONG option is set. Can be true or false</field>
    /// <field name='contact' static='false' type='Boolean'>If _CONTACT option is set. Can be true or false</field>
    /// <field name='dc' static='false' type='Number'>Exponential decay coefficient</field>
    /// <field name='element_type' static='false' type='String'>The type of elements the Part contains. e.g. "SHELL", "SOLID" or null if empty/no section (read only).</field>
    /// <field name='elform' static='false' type='Number'>Element formulation</field>
    /// <field name='eosid' static='false' type='Number'>Equation of state number/string</field>
    /// <field name='exists' static='false' type='Boolean'>true if part exists, false if referred to but not defined. (read only)</field>
    /// <field name='fd' static='false' type='Number'>Dynamic coefficient of friction</field>
    /// <field name='fs' static='false' type='Number'>Static coefficient of friction</field>
    /// <field name='grav' static='false' type='Number'>Gravity loading</field>
    /// <field name='heading' static='false' type='String'>Part heading</field>
    /// <field name='hgid' static='false' type='Number'>Hourglass number/string</field>
    /// <field name='hmname' static='false' type='String'>Hypermesh comment read from keyword file for Part (or null if doesn't exist).</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the part is in.</field>
    /// <field name='inertia' static='false' type='Boolean'>If _INERTIA option is set. Can be true or false</field>
    /// <field name='ircs' static='false' type='Number'>Flag for inertia tensor reference coordinate system</field>
    /// <field name='ixx' static='false' type='Number'>Ixx component of inertia tensor</field>
    /// <field name='ixy' static='false' type='Number'>Ixy component of inertia tensor</field>
    /// <field name='ixz' static='false' type='Number'>Ixz component of inertia tensor</field>
    /// <field name='iyy' static='false' type='Number'>Iyy component of inertia tensor</field>
    /// <field name='iyz' static='false' type='Number'>Iyz component of inertia tensor</field>
    /// <field name='izz' static='false' type='Number'>Izz component of inertia tensor</field>
    /// <field name='label' static='false' type='Number'>Part number. Also see the pid property which is an alternative name for this.</field>
    /// <field name='marea' static='false' type='Number'>Non structural mass per unit area</field>
    /// <field name='mdep' static='false' type='Number'>MADYMO ellipse/plane number</field>
    /// <field name='mid' static='false' type='Number'>Material number/string</field>
    /// <field name='model' static='false' type='Number'>The Model number that the part is in.</field>
    /// <field name='movopt' static='false' type='Number'>Flag to deactivate moving for merged rigid bodies</field>
    /// <field name='nip' static='false' type='Number'>Number of integration points (layers) present for _COMPOSITE parts</field>
    /// <field name='nloc' static='false' type='Number'>Location of reference surface</field>
    /// <field name='nodeid' static='false' type='Number'>Node ID for centre of rigid body</field>
    /// <field name='optt' static='false' type='Number'>Contact thickness</field>
    /// <field name='pid' static='false' type='Number'>Part number. Also see the label property which is an alternative name for this.</field>
    /// <field name='prbf' static='false' type='Number'>Print flag for RBDOUT and MATSUM files</field>
    /// <field name='print' static='false' type='Boolean'>If _PRINT option is set. Can be true or false</field>
    /// <field name='reposition' static='false' type='Boolean'>If _REPOSITION option is set. Can be true or false</field>
    /// <field name='rigid' static='false' type='Boolean'>true if part is rigid, false if deformable. (read only)</field>
    /// <field name='secid' static='false' type='Number'>Section number/string</field>
    /// <field name='sft' static='false' type='Number'>Thickness scale factor</field>
    /// <field name='shrf' static='false' type='Number'>Shear correction factor</field>
    /// <field name='ssf' static='false' type='Number'>Scale factor on default slave penalty stiffness</field>
    /// <field name='thshel' static='false' type='Number'>Thermal shell formulation</field>
    /// <field name='tm' static='false' type='Number'>total mass</field>
    /// <field name='tmid' static='false' type='Number'>Thermal material number/string</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the part (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='tshear' static='false' type='Number'>Flag for transverse shear strain distribution</field>
    /// <field name='tshell' static='false' type='Boolean'>If _COMPOSITE_TSHELL option is set. Can be true or false</field>
    /// <field name='vc' static='false' type='Number'>Coefficient for viscous friction</field>
    /// <field name='vrx' static='false' type='Number'>x rotational velocity</field>
    /// <field name='vry' static='false' type='Number'>y rotational velocity</field>
    /// <field name='vrz' static='false' type='Number'>z rotational velocity</field>
    /// <field name='vtx' static='false' type='Number'>x translational velocity</field>
    /// <field name='vty' static='false' type='Number'>y translational velocity</field>
    /// <field name='vtz' static='false' type='Number'>z translational velocity</field>
    /// <field name='xc' static='false' type='Number'>x coordinate of centre of mass</field>
    /// <field name='xl' static='false' type='Number'>x coordinate of local x axis</field>
    /// <field name='xlip' static='false' type='Number'>x coordinate of vector in local xy plane</field>
    /// <field name='yc' static='false' type='Number'>y coordinate of centre of mass</field>
    /// <field name='yl' static='false' type='Number'>y coordinate of local x axis</field>
    /// <field name='ylip' static='false' type='Number'>y coordinate of vector in local xy plane</field>
    /// <field name='zc' static='false' type='Number'>z coordinate of centre of mass</field>
    /// <field name='zl' static='false' type='Number'>z coordinate of local x axis</field>
    /// <field name='zlip' static='false' type='Number'>z coordinate of vector in local xy plane</field>
}

Part.AllTableProperties = function() {
    /// <signature>
    /// <summary>Returns all of the properties available in the part table for the parts. The table values are returned in an array of objects (an object for each part). The object property names are the same as the table headers but spaces are replaced with underscore characters and characters other than 0-9, a-z and A-Z are removed to ensure that the property name is valid in JavaScript. If a table value is undefined the property value will be the JavaScript undefined value. If the table value is a valid number it will be a number, otherwise the value will returned as a string.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged parts are in</param>
    /// <returns type="Array" elementType="Object"/>
    /// </signature>
}

Part.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the part</summary>
    /// <returns type="null"/>
    /// </signature>
}

Part.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all parts will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged parts will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the parts that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the part is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Part.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.CentreOfGravity = function() {
    /// <signature>
    /// <summary>Returns the centre of gravity for a part.</summary>
    /// <param name="options" type="Object" optional="true">Options specifying how the mass calculation should be done.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Part.prototype.CentreOfGravity_#deprecated = function() {
    /// <signature>
    /// <summary>Returns the centre of gravity for a part. Rigid parts will always include mass of slave parts. Mass is transferred from deformable to rigid when nodes attach.</summary>
    /// <param name="option" type="Boolean" optional="true">If set, centre of gravity calculation for deformable parts includes lumped mass, mass of nodal rigid bodies and timestep added mass.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Part.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the part.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the part</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.ClosestNode = function() {
    /// <signature>
    /// <summary>Finds the Node on the part closest to a coordinate.</summary>
    /// <param name="x" type="Number" optional="false">X coordinate of point</param>
    /// <param name="y" type="Number" optional="false">Y coordinate of point</param>
    /// <param name="z" type="Number" optional="false">Z coordinate of point</param>
    /// <returns type="Number"/>
    /// </signature>
}

Part.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the part.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Part"/>
    /// </signature>
}

Part.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a part.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the part will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Part"/>
    /// </signature>
}

Part.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for part. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for part. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the part colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the part.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Part.First = function() {
    /// <signature>
    /// <summary>Returns the first part in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first part in</param>
    /// <returns type="Part"/>
    /// </signature>
}

Part.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free part label in the model. Also see Part.LastFreeLabel(), Part.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free part label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Part.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the parts in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all parts will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the parts</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.FlagVisible = function() {
    /// <signature>
    /// <summary>Flags all the unblanked parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model for which all unblanked parts will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the unblanked parts</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the part is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the part</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Part.FlaggedTableProperties = function() {
    /// <signature>
    /// <summary>Returns all of the properties available in the part table for the flagged parts. The table values are returned in an array of objects (an object for each part). The object property names are the same as the table headers but spaces are replaced with underscore characters and characters other than 0-9, a-z and A-Z are removed to ensure that the property name is valid in JavaScript. If a table value is undefined the property value will be the JavaScript undefined value. If the table value is a valid number it will be a number, otherwise the value will returned as a string.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged parts are in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the parts that you want properties for</param>
    /// <returns type="Array" elementType="Object"/>
    /// </signature>
}

Part.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each part in the model. Note that ForEach has been designed to make looping over parts as fast as possible and so has some limitations. Firstly, a single temporary Part object is created and on each function call it is updated with the current part data. This means that you should not try to store the Part object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new parts inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all parts are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each part</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Part objects for all of the parts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get parts from</param>
    /// <returns type="Array" elementType="Part"/>
    /// </signature>
}

Part.prototype.GetCompositeData = function() {
    /// <signature>
    /// <summary>Returns the composite data for an integration point in *PART_COMPOSITE.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want the data for. Note that integration points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Part.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Part objects for all of the flagged parts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get parts from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the parts that you want to retrieve</param>
    /// <returns type="Array" elementType="Part"/>
    /// </signature>
}

Part.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Part object for a part ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the part in</param>
    /// <param name="number" type="Number" optional="false">number of the part you want the Part object for</param>
    /// <returns type="Part"/>
    /// </signature>
}

Part.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Part property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Part.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">part property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Part.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this part (*PART, *PART_SCALAR or *PART_SCALAR_VALUE). Note that a carriage return is not added. See also Part.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Part.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the part. Note that a carriage return is not added. See also Part.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Part.Last = function() {
    /// <signature>
    /// <summary>Returns the last part in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last part in</param>
    /// <returns type="Part"/>
    /// </signature>
}

Part.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free part label in the model. Also see Part.FirstFreeLabel(), Part.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free part label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Part.prototype.Mass = function() {
    /// <signature>
    /// <summary>Returns the mass properties for a part.</summary>
    /// <returns type="Object"/>
    /// </signature>
}

Part.prototype.MaxMin = function() {
    /// <signature>
    /// <summary>Returns the max and min boundas of a part</summary>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Part.MeasurePartToPart = function() {
    /// <signature>
    /// <summary>This static method measures the distance between two part objects contained in the same model or in two different models</summary>
    /// <param name="part1" type="Part" optional="false">Part to measure from</param>
    /// <param name="part2" type="Part" optional="false">Part to measure to</param>
    /// <returns type="Object"/>
    /// </signature>
}

Part.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next part in the model.</summary>
    /// <returns type="Part"/>
    /// </signature>
}

Part.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) part label in the model. Also see Part.FirstFreeLabel(), Part.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free part label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Part.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a part.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only parts from that model can be picked. If the argument is a Flag then only parts that are flagged with limit can be selected. If omitted, or null, any parts from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Part"/>
    /// </signature>
}

Part.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous part in the model.</summary>
    /// <returns type="Part"/>
    /// </signature>
}

Part.prototype.RemoveCompositeData = function() {
    /// <signature>
    /// <summary>Removes the composite data for an integration point in *PART_COMPOSITE.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want to remove. Note that integration points start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all parts will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged parts will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the parts that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select parts using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting parts</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only parts from that model can be selected. If the argument is a Flag then only parts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any parts can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Part.prototype.SetCompositeData = function() {
    /// <signature>
    /// <summary>Sets the composite data for an integration point in *PART_COMPOSITE.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want to set the data for. Note that integration points start at 0, not 1.</param>
    /// <param name="mid" type="Number" optional="false">Material ID for the integration point.</param>
    /// <param name="thick" type="Number" optional="false">Thickness of the integration point.</param>
    /// <param name="beta" type="Number" optional="false">Material angle of the integration point.</param>
    /// <param name="tmid (optinal)" type="Number" optional="false">Thermal material ID for the integration point.</param>
    /// <param name="plyid" type="Number" optional="true">Ply ID for the integration point. This should be used if the _COMPOSITE_LONG option is set for the part.</param>
    /// <param name="shrfac" type="Number" optional="false">Transverse shear stress scale factor.</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the part.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the part</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the part. The part will be sketched until you either call Part.Unsketch(), Part.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the part is sketched. If omitted redraw is true. If you want to sketch several parts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged parts in the model. The parts will be sketched until you either call Part.Unsketch(), Part.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged parts will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the parts that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the parts are sketched. If omitted redraw is true. If you want to sketch flagged parts several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.TableProperties = function() {
    /// <signature>
    /// <summary>Returns all of the properties available for the part in the part table. The table values are returned in an object. The object property names are the same as the table headers but spaces are replaced with underscore characters and characters other than 0-9, a-z and A-Z are removed to ensure that the property name is valid in JavaScript. If a table value is undefined the property value will be the JavaScript undefined value. If the table value is a valid number it will be a number, otherwise the value will returned as a string.</summary>
    /// <returns type="Object"/>
    /// </signature>
}

Part.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing parts should be counted. If false or omitted referenced but undefined parts will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Part.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the part</summary>
    /// <returns type="null"/>
    /// </signature>
}

Part.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all parts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged parts will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the parts that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all parts will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the parts</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the part.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the part is unsketched. If omitted redraw is true. If you want to unsketch several parts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all parts.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all parts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all parts will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the parts that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Part"/>
    /// </signature>
}

Part.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for part. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Part.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this part.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Part.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the part data in keyword format. Note that this contains the keyword header and the keyword cards. See also Part.Keyword() and Part.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var PopupWindow = function() {
    /// <signature>
    /// <summary>Create a new PopupWindow object.</summary>
    /// <returns type="PopupWindow"/>
    /// </signature>
    /// <field name='persistent' static='false' type='Boolean'>If the popup window will remain mapped when a button is pressed in it. By default (false) when a button is pressed in the popup window the popup will be unmapped. If set to true then the popup will remain mapped until the user clicks out of the window or hides it by calling Hide()</field>
}

PopupWindow.prototype.Hide = function() {
    /// <signature>
    /// <summary>Hides (unmaps) the popup window.</summary>
    /// <returns type="null"/>
    /// </signature>
}

var PrescribedAccelerometerRigid = function() {
    /// <signature>
    /// <summary>Create a new PrescribedAccelerometerRigid object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that prescribed accelerometer rigid will be created in</param>
    /// <param name="pid" type="Number" optional="false">Part ID for rigid body whose motion is prescribed.</param>
    /// <param name="solv" type="Number" optional="true">Solver type</param>
    /// <returns type="PrescribedAccelerometerRigid"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if prescribed accelerometer rigid exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the prescribed accelerometer rigid is in.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the prescribed accelerometer rigid is in.</field>
    /// <field name='nrow' static='false' type='Number'>Number of accelerometer cards. (read only)</field>
    /// <field name='pid' static='false' type='Number'>Part ID for rigid body whose motion is prescribed.</field>
    /// <field name='solv' static='false' type='Number'>Solver type: 1 for Gaussian elimination or 2 for linear regression.</field>
}

PrescribedAccelerometerRigid.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the prescribed accelerometer rigid.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the prescribed accelerometer rigid</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the prescribed accelerometer rigid.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a boundary prescribed accelerometer rigid definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the prescribed accelerometer rigid will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for prescribed accelerometer rigid. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.First = function() {
    /// <signature>
    /// <summary>Returns the first prescribed accelerometer rigid in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first prescribed accelerometer rigid in</param>
    /// <returns type="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the prescribed accelerometer rigids in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all prescribed accelerometer rigids will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the prescribed accelerometer rigids</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the prescribed accelerometer rigid is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the prescribed accelerometer rigid</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

PrescribedAccelerometerRigid.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each prescribed accelerometer rigid in the model. Note that ForEach has been designed to make looping over prescribed accelerometer rigids as fast as possible and so has some limitations. Firstly, a single temporary PrescribedAccelerometerRigid object is created and on each function call it is updated with the current prescribed accelerometer rigid data. This means that you should not try to store the PrescribedAccelerometerRigid object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new prescribed accelerometer rigids inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all prescribed accelerometer rigids are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each prescribed accelerometer rigid</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of PrescribedAccelerometerRigid objects for all of the prescribed accelerometer rigids in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get prescribed accelerometer rigids from</param>
    /// <returns type="Array" elementType="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of PrescribedAccelerometerRigid objects for all of the flagged prescribed accelerometer rigids in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get prescribed accelerometer rigids from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the prescribed accelerometer rigids that you want to retrieve</param>
    /// <returns type="Array" elementType="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the PrescribedAccelerometerRigid object for a prescribed accelerometer rigid ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the prescribed accelerometer rigid in</param>
    /// <param name="number" type="Number" optional="false">number of the prescribed accelerometer rigid you want the PrescribedAccelerometerRigid object for</param>
    /// <returns type="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a PrescribedAccelerometerRigid property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the PrescribedAccelerometerRigid.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">prescribed accelerometer rigid property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.GetRow = function() {
    /// <signature>
    /// <summary>Returns the data for a row in the prescribed accelerometer rigid.</summary>
    /// <param name="row" type="Number" optional="false">The row you want the data for. Note row indices start at 0.</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this prescribed accelerometer rigid. Note that a carriage return is not added. See also PrescribedAccelerometerRigid.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the prescribed accelerometer rigid. Note that a carriage return is not added. See also PrescribedAccelerometerRigid.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

PrescribedAccelerometerRigid.Last = function() {
    /// <signature>
    /// <summary>Returns the last prescribed accelerometer rigid in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last prescribed accelerometer rigid in</param>
    /// <returns type="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next prescribed accelerometer rigid in the model.</summary>
    /// <returns type="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous prescribed accelerometer rigid in the model.</summary>
    /// <returns type="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.RemoveRow = function() {
    /// <signature>
    /// <summary>Removes the data for a row in *BOUNDARY_PRESCRIBED_ACCELEROMETER_RIGID.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to remove the data for. Note that row indices start at 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select prescribed accelerometer rigids using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting prescribed accelerometer rigids</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only prescribed accelerometer rigids from that model can be selected. If the argument is a Flag then only prescribed accelerometer rigids that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any prescribed accelerometer rigids can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the prescribed accelerometer rigid.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the prescribed accelerometer rigid</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.SetRow = function() {
    /// <signature>
    /// <summary>Sets the data for a row in *BOUNDARY_PRESCRIBED_ACCELEROMETER_RIGID.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to set the data for. Note that row indices start at 0.</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">The data you want to set the row to</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of prescribed accelerometer rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing prescribed accelerometer rigids should be counted. If false or omitted referenced but undefined prescribed accelerometer rigids will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedAccelerometerRigid.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the prescribed accelerometer rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all prescribed accelerometer rigids will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the prescribed accelerometer rigids</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="PrescribedAccelerometerRigid"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for prescribed accelerometer rigid. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this prescribed accelerometer rigid.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

PrescribedAccelerometerRigid.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the prescribed accelerometer rigid data in keyword format. Note that this contains the keyword header and the keyword cards. See also PrescribedAccelerometerRigid.Keyword() and PrescribedAccelerometerRigid.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var PrescribedFinalGeometry = function() {
    /// <signature>
    /// <summary>Create a new PrescribedFinalGeometry object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that PrescribedFinalGeometry will be created in</param>
    /// <param name="bpfgid" type="PrescribedFinalGeometry" optional="false">PrescribedFinalGeometry number.</param>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
    /// <field name='bpfgid' static='false' type='Number'>PrescribedFinalGeometry number. Also see the label property which is an alternative name for this.</field>
    /// <field name='deathd' static='false' type='Number'>Default death time.</field>
    /// <field name='exists' static='false' type='Boolean'>true if boundary prescribed final_geometry exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Number'>PrescribedFinalGeometry number. Also see the label property which is an alternative name for this.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the boundary prescribed final_geometry is in.</field>
    /// <field name='label' static='false' type='Number'>PrescribedFinalGeometry number. Also see the bpfgid property which is an alternative name for this.</field>
    /// <field name='lcidf' static='false' type='Number'>Default loadcurve number.</field>
    /// <field name='lines' static='false' type='Number'>Number of lines of nodal data on the card.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the boundary prescribed final geometry is in.</field>
}

PrescribedFinalGeometry.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the boundary prescribed final geometry</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the boundary prescribed final geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed final geometrys will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged boundary prescribed final geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boundary prescribed final geometrys will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed final geometrys that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the boundary prescribed final geometry is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the boundary prescribed final geometry.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the boundary prescribed final geometry</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the boundary prescribed final geometry.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a bpfg.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the bpfg will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for boundary prescribed final geometry. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.First = function() {
    /// <signature>
    /// <summary>Returns the first boundary prescribed final geometry in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first boundary prescribed final geometry in</param>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free boundary prescribed final geometry label in the model. Also see PrescribedFinalGeometry.LastFreeLabel(), PrescribedFinalGeometry.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free boundary prescribed final geometry label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedFinalGeometry.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the boundary prescribed final geometrys in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed final geometrys will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the boundary prescribed final geometrys</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the boundary prescribed final geometry is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the boundary prescribed final geometry</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

PrescribedFinalGeometry.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each boundary prescribed final geometry in the model. Note that ForEach has been designed to make looping over boundary prescribed final geometrys as fast as possible and so has some limitations. Firstly, a single temporary PrescribedFinalGeometry object is created and on each function call it is updated with the current boundary prescribed final geometry data. This means that you should not try to store the PrescribedFinalGeometry object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boundary prescribed final geometrys inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed final geometrys are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each boundary prescribed final geometry</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of PrescribedFinalGeometry objects for all of the boundary prescribed final geometrys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boundary prescribed final geometrys from</param>
    /// <returns type="Array" elementType="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.GetData = function() {
    /// <signature>
    /// <summary>Returns data for open-ended cards for a given row number in *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY.</summary>
    /// <param name="index" type="Number" optional="false">Index of open-ended card you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt; lines</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

PrescribedFinalGeometry.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of PrescribedFinalGeometry objects for all of the flagged boundary prescribed final geometrys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boundary prescribed final geometrys from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed final geometrys that you want to retrieve</param>
    /// <returns type="Array" elementType="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the PrescribedFinalGeometry object for a boundary prescribed final geometry ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the boundary prescribed final geometry in</param>
    /// <param name="number" type="Number" optional="false">number of the boundary prescribed final geometry you want the PrescribedFinalGeometry object for</param>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a PrescribedFinalGeometry property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the PrescribedFinalGeometry.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">boundary prescribed final geometry property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this PrescribedFinalGeometry (*BOUNDARY_PRESCRIBED_FINAL_GEOMETRY). Note that a carriage return is not added. See also PrescribedFinalGeometry.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the PrescribedFinalGeometry. Note that a carriage return is not added. See also PrescribedFinalGeometry.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

PrescribedFinalGeometry.Last = function() {
    /// <signature>
    /// <summary>Returns the last boundary prescribed final geometry in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last boundary prescribed final geometry in</param>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free boundary prescribed final geometry label in the model. Also see PrescribedFinalGeometry.FirstFreeLabel(), PrescribedFinalGeometry.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free boundary prescribed final geometry label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next boundary prescribed final geometry in the model.</summary>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) boundary prescribed final geometry label in the model. Also see PrescribedFinalGeometry.FirstFreeLabel(), PrescribedFinalGeometry.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free boundary prescribed final geometry label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedFinalGeometry.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a boundary prescribed final geometry.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boundary prescribed final geometrys from that model can be picked. If the argument is a Flag then only boundary prescribed final geometrys that are flagged with limit can be selected. If omitted, or null, any boundary prescribed final geometrys from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous boundary prescribed final geometry in the model.</summary>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.RemoveData = function() {
    /// <signature>
    /// <summary>Removes a line of data for a *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY.</summary>
    /// <param name="index" type="Number" optional="false">The index of the *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY data to remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; lines</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the boundary prescribed final geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed final geometrys will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged boundary prescribed final geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boundary prescribed final geometrys will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed final geometrys that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select boundary prescribed final geometrys using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting boundary prescribed final geometrys</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boundary prescribed final geometrys from that model can be selected. If the argument is a Flag then only boundary prescribed final geometrys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boundary prescribed final geometrys can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.SetData = function() {
    /// <signature>
    /// <summary>Sets a line of data for a *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY.</summary>
    /// <param name="index" type="Number" optional="false">The index of the *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY data to set. Note that indices start at 0, not 1. 0 &lt;= index &lt;= lines</param>
    /// <param name="nid" type="Number" optional="false">Node or negative node set number.</param>
    /// <param name="x" type="Number" optional="false">X coordinates of final geometry.</param>
    /// <param name="y" type="Number" optional="false">Y coordinates of final geometry.</param>
    /// <param name="z" type="Number" optional="false">Z coordinates of final geometry.</param>
    /// <param name="lcid" type="Number" optional="true">Loadcurve number.</param>
    /// <param name="death" type="Number" optional="true">Death time.</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the boundary prescribed final geometry.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the boundary prescribed final geometry</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the boundary prescribed final geometry. The boundary prescribed final geometry will be sketched until you either call PrescribedFinalGeometry.Unsketch(), PrescribedFinalGeometry.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed final geometry is sketched. If omitted redraw is true. If you want to sketch several boundary prescribed final geometrys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged boundary prescribed final geometrys in the model. The boundary prescribed final geometrys will be sketched until you either call PrescribedFinalGeometry.Unsketch(), PrescribedFinalGeometry.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boundary prescribed final geometrys will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed final geometrys that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed final geometrys are sketched. If omitted redraw is true. If you want to sketch flagged boundary prescribed final geometrys several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of boundary prescribed final geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing boundary prescribed final geometrys should be counted. If false or omitted referenced but undefined boundary prescribed final geometrys will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the boundary prescribed final geometry</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the boundary prescribed final geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed final geometrys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged boundary prescribed final geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged boundary prescribed final geometrys will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed final geometrys that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the boundary prescribed final geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all boundary prescribed final geometrys will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the boundary prescribed final geometrys</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the boundary prescribed final geometry.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed final geometry is unsketched. If omitted redraw is true. If you want to unsketch several boundary prescribed final geometrys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all boundary prescribed final geometrys.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed final geometrys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed final geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged boundary prescribed final geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed final geometrys will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed final geometrys that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed final geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="PrescribedFinalGeometry"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for boundary prescribed final geometry. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this boundary prescribed final geometry.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

PrescribedFinalGeometry.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the PrescribedFinalGeometry data in keyword format. Note that this contains the keyword header and the keyword cards. See also PrescribedFinalGeometry.Keyword() and PrescribedFinalGeometry.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var PrescribedMotion = function() {
    /// <signature>
    /// <summary>Create a new PrescribedMotion object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that PrescribedMotion will be created in</param>
    /// <param name="typeid" type="Number" optional="false">Node ID, node set ID or part ID</param>
    /// <param name="dof" type="Number" optional="false">Degree of freedom</param>
    /// <param name="vad" type="Number" optional="false">Velocity/acceleration/displacement flag</param>
    /// <param name="lcid" type="Number" optional="false">Load curve for motion</param>
    /// <param name="type" type="Number" optional="false">Specify the type of prescribed motion (Can be PrescribedMotion.NODE, PrescribedMotion.SET, PrescribedMotion.RIGID, PrescribedMotion.RIGID_LOCAL, PrescribedMotion.NRBC, PrescribedMotion.NRBC_LOCAL, PrescribedMotion.SET_SEGMENT or PrescribedMotion.SET_LINE)</param>
    /// <param name="label" type="Number" optional="true">PrescribedMotion number</param>
    /// <param name="heading" type="String" optional="true">Title for the PrescribedMotion</param>
    /// <returns type="PrescribedMotion"/>
    /// </signature>
    /// <field name='birth' static='false' type='Number'>Birth time</field>
    /// <field name='bndout2dynain' static='false' type='Boolean'>true if _BNDOUT2DYNAIN option is set, false if not</field>
    /// <field name='death' static='false' type='Number'>Death time</field>
    /// <field name='dof' static='false' type='Number'>Degree of freedom</field>
    /// <field name='exists' static='false' type='Boolean'>true if boundary prescribed motion exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>PrescribedMotion heading</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the boundary prescribed motion is in.</field>
    /// <field name='label' static='false' type='Number'>PrescribedMotion number.</field>
    /// <field name='lcid' static='false' type='Number'>Load curve of motion vs. time</field>
    /// <field name='model' static='false' type='Number'>The Model number that the boundary prescribed motion is in.</field>
    /// <field name='mrb' static='false' type='Number'>Master rigid body for measuring relative displacement</field>
    /// <field name='nbeg' static='false' type='Number'>Node ID of a starting node. Used for PrescribedMotion.SET_LINE</field>
    /// <field name='nend' static='false' type='Number'>Node ID of a ending node. Used for PrescribedMotion.SET_LINE</field>
    /// <field name='node1' static='false' type='Number'>Optional orientation node for relative displacement</field>
    /// <field name='node2' static='false' type='Number'>Optional orientation node for relative displacement</field>
    /// <field name='offset1' static='false' type='Number'>Offset 1 for types 9-11</field>
    /// <field name='offset2' static='false' type='Number'>Offset 2 for types 9-11</field>
    /// <field name='prmr' static='false' type='String'>String representing the name of the parameter to be output to the dynain file. Used when PrescribedMotion.bndout2dynain is set to true.</field>
    /// <field name='sf' static='false' type='Number'>Load curve scale factor</field>
    /// <field name='type' static='false' type='Number'>The Prescribed motion type. Can be PrescribedMotion.NODE, PrescribedMotion.SET, PrescribedMotion.RIGID, PrescribedMotion.RIGID_LOCAL, PrescribedMotion.NRBC, PrescribedMotion.NRBC_LOCAL, PrescribedMotion.SET_SEGMENT or PrescribedMotion.SET_LINE</field>
    /// <field name='typeid' static='false' type='Number'>Node ID, node set ID, part ID or NRB</field>
    /// <field name='vad' static='false' type='Number'>Velocity/acceleration/displacement flag</field>
    /// <field name='vid' static='false' type='Number'>Vector ID</field>
    /// <field name='NODE' static='true' type='Number'>Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_NODE.</field>
    /// <field name='NRBC' static='true' type='Number'>Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_RIGID, with an NRB, not a part.</field>
    /// <field name='NRBC_LOCAL' static='true' type='Number'>Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_RIGID_LOCAL, with an NRB, not a part.</field>
    /// <field name='RIGID' static='true' type='Number'>Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_RIGID.</field>
    /// <field name='RIGID_LOCAL' static='true' type='Number'>Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_RIGID_LOCAL.</field>
    /// <field name='SET' static='true' type='Number'>Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_SET.</field>
    /// <field name='SET_LINE' static='true' type='Number'>Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_SET_LINE.</field>
    /// <field name='SET_SEGMENT' static='true' type='Number'>Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_SET_SEGMENT.</field>
}

PrescribedMotion.AnimationBackward = function() {
    /// <signature>
    /// <summary>Moves backward one frame of a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.AnimationBegin = function() {
    /// <signature>
    /// <summary>Begins a PrescribedMotion animation. This MUST be called before any of the other Animation methods. Also see the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.</summary>
    /// <param name="Model" type="Model" optional="false">Model that PrescribedMotions are in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the PrescribedMotions that you want to animate</param>
    /// <returns type="Object"/>
    /// </signature>
}

PrescribedMotion.AnimationFinish = function() {
    /// <signature>
    /// <summary>Finishes a PrescribedMotion animation. This MUST be called to finish animating. This will restore nodal coordinates but will not perform a graphics update. Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating.</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.AnimationForward = function() {
    /// <signature>
    /// <summary>Moves forward one frame of a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.AnimationGetData = function() {
    /// <signature>
    /// <summary>Returns the animation data (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.</summary>
    /// <returns type="Object"/>
    /// </signature>
}

PrescribedMotion.AnimationPause = function() {
    /// <signature>
    /// <summary>Pauses playback of a PrescribedMotion animation. Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.AnimationPlay = function() {
    /// <signature>
    /// <summary>Starts playback of a PrescribedMotion animation. Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.This method should only be used from a script which implements a user interface so you can actually stop the animation! Don't forget to add a pause/stop button that calls PrescribedMotion.AnimationPause()!</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.AnimationSetData = function() {
    /// <signature>
    /// <summary>Sets the current animation data (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.</summary>
    /// <param name="data" type="Object" optional="false">data returned from PrescribedMotion.AnimationBegin() or PrescribedMotion.AnimationGetData()</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.AnimationToEnd = function() {
    /// <signature>
    /// <summary>Moves to the end of a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.AnimationToStart = function() {
    /// <signature>
    /// <summary>Moves to the start of a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.AnimationToTime = function() {
    /// <signature>
    /// <summary>Moves to a specific time in a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the boundary prescribed motion</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the boundary prescribed motions in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed motions will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged boundary prescribed motions in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boundary prescribed motions will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed motions that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the boundary prescribed motion is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

PrescribedMotion.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the boundary prescribed motion.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the boundary prescribed motion</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the boundary prescribed motion.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for boundary prescribed motion. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.First = function() {
    /// <signature>
    /// <summary>Returns the first boundary prescribed motion in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first boundary prescribed motion in</param>
    /// <returns type="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free boundary prescribed motion label in the model. Also see PrescribedMotion.LastFreeLabel(), PrescribedMotion.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free boundary prescribed motion label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedMotion.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the boundary prescribed motions in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed motions will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the boundary prescribed motions</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the boundary prescribed motion is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the boundary prescribed motion</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

PrescribedMotion.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each boundary prescribed motion in the model. Note that ForEach has been designed to make looping over boundary prescribed motions as fast as possible and so has some limitations. Firstly, a single temporary PrescribedMotion object is created and on each function call it is updated with the current boundary prescribed motion data. This means that you should not try to store the PrescribedMotion object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boundary prescribed motions inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed motions are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each boundary prescribed motion</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of PrescribedMotion objects for all of the boundary prescribed motions in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boundary prescribed motions from</param>
    /// <returns type="Array" elementType="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of PrescribedMotion objects for all of the flagged boundary prescribed motions in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boundary prescribed motions from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed motions that you want to retrieve</param>
    /// <returns type="Array" elementType="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the PrescribedMotion object for a boundary prescribed motion ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the boundary prescribed motion in</param>
    /// <param name="number" type="Number" optional="false">number of the boundary prescribed motion you want the PrescribedMotion object for</param>
    /// <returns type="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a PrescribedMotion property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the PrescribedMotion.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">boundary prescribed motion property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

PrescribedMotion.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this PrescribedMotion (*BOUNDARY_PRESCRIBED_MOTION_xxxx). Note that a carriage return is not added. See also PrescribedMotion.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

PrescribedMotion.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the PrescribedMotion. Note that a carriage return is not added. See also PrescribedMotion.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

PrescribedMotion.Last = function() {
    /// <signature>
    /// <summary>Returns the last boundary prescribed motion in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last boundary prescribed motion in</param>
    /// <returns type="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free boundary prescribed motion label in the model. Also see PrescribedMotion.FirstFreeLabel(), PrescribedMotion.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free boundary prescribed motion label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedMotion.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next boundary prescribed motion in the model.</summary>
    /// <returns type="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) boundary prescribed motion label in the model. Also see PrescribedMotion.FirstFreeLabel(), PrescribedMotion.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free boundary prescribed motion label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedMotion.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a boundary prescribed motion.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boundary prescribed motions from that model can be picked. If the argument is a Flag then only boundary prescribed motions that are flagged with limit can be selected. If omitted, or null, any boundary prescribed motions from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous boundary prescribed motion in the model.</summary>
    /// <returns type="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the boundary prescribed motions in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed motions will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged boundary prescribed motions in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boundary prescribed motions will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed motions that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select boundary prescribed motions using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting boundary prescribed motions</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boundary prescribed motions from that model can be selected. If the argument is a Flag then only boundary prescribed motions that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boundary prescribed motions can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedMotion.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the boundary prescribed motion.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the boundary prescribed motion</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the boundary prescribed motion. The boundary prescribed motion will be sketched until you either call PrescribedMotion.Unsketch(), PrescribedMotion.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed motion is sketched. If omitted redraw is true. If you want to sketch several boundary prescribed motions and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged boundary prescribed motions in the model. The boundary prescribed motions will be sketched until you either call PrescribedMotion.Unsketch(), PrescribedMotion.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boundary prescribed motions will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed motions that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed motions are sketched. If omitted redraw is true. If you want to sketch flagged boundary prescribed motions several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of boundary prescribed motions in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing boundary prescribed motions should be counted. If false or omitted referenced but undefined boundary prescribed motions will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedMotion.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the boundary prescribed motion</summary>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the boundary prescribed motions in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed motions will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged boundary prescribed motions in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged boundary prescribed motions will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed motions that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the boundary prescribed motions in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all boundary prescribed motions will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the boundary prescribed motions</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the boundary prescribed motion.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed motion is unsketched. If omitted redraw is true. If you want to unsketch several boundary prescribed motions and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all boundary prescribed motions.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed motions will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed motions are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged boundary prescribed motions in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary prescribed motions will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary prescribed motions that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the boundary prescribed motions are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="PrescribedMotion"/>
    /// </signature>
}

PrescribedMotion.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for boundary prescribed motion. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedMotion.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this boundary prescribed motion.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

PrescribedMotion.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the PrescribedMotion data in keyword format. Note that this contains the keyword header and the keyword cards. See also PrescribedMotion.Keyword() and PrescribedMotion.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var PrescribedOrientationRigid = function() {
    /// <signature>
    /// <summary>Create a new PrescribedOrientationRigid object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that prescribed orientation rigid will be created in</param>
    /// <param name="option" type="Number" optional="false">Suffix for boundary prescribed orientation rigid. Can be PrescribedOrientationRigid.DIRCOS PrescribedOrientationRigid.ANGLES PrescribedOrientationRigid.EULERP PrescribedOrientationRigid.VECTOR</param>
    /// <param name="pidb" type="Number" optional="false">Part ID for rigid body B whose orientation is prescribed.</param>
    /// <param name="label" type="Number" optional="true">PrescribedOrientationRigid number</param>
    /// <param name="heading" type="String" optional="true">Title for the PrescribedOrientationRigid</param>
    /// <returns type="PrescribedOrientationRigid"/>
    /// </signature>
    /// <field name='birth' static='false' type='Number'>Time prior to which the body moves freely under the action of other agents.</field>
    /// <field name='body' static='false' type='Number'>Reference axes: 0 for rotations about axes fixed in PIDA or 1 for those fixed in PIDB.</field>
    /// <field name='death' static='false' type='Number'>Time when the body is freed from the restriction.</field>
    /// <field name='exists' static='false' type='Boolean'>true if prescribed orientation rigid exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>PrescribedOrientationRigid heading</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the prescribed orientation rigid is in.</field>
    /// <field name='intrp' static='false' type='Number'>Interpolation method: 1 for linear interpolation or 2 for cubic spline interpolation.</field>
    /// <field name='intrp_1' static='false' type='Number'>Interpolation method: 1 for linear interpolation or 2 for cubic spline interpolation.</field>
    /// <field name='iseq' static='false' type='Number'>Specifies the sequence in which the rotations are performed.</field>
    /// <field name='ishft' static='false' type='Number'>Angle shift: 1 for unaltered angle curves or 2 for angle data shift in LCIDQi curves eliminating discontinuities.</field>
    /// <field name='lcidc11' static='false' type='Number'>Load curve ID specifying direction cosine C11 as function of time.</field>
    /// <field name='lcidc12' static='false' type='Number'>Load curve ID specifying direction cosine C12 as function of time.</field>
    /// <field name='lcidc13' static='false' type='Number'>Load curve ID specifying direction cosine C13 as function of time.</field>
    /// <field name='lcidc21' static='false' type='Number'>Load curve ID specifying direction cosine C21 as function of time.</field>
    /// <field name='lcidc22' static='false' type='Number'>Load curve ID specifying direction cosine C22 as function of time.</field>
    /// <field name='lcidc23' static='false' type='Number'>Load curve ID specifying direction cosine C23 as function of time.</field>
    /// <field name='lcidc31' static='false' type='Number'>Load curve ID specifying direction cosine C31 as function of time.</field>
    /// <field name='lcidc32' static='false' type='Number'>Load curve ID specifying direction cosine C32 as function of time.</field>
    /// <field name='lcidc33' static='false' type='Number'>Load curve ID specifying direction cosine C33 as function of time.</field>
    /// <field name='lcide1' static='false' type='Number'>Load curve ID specifying Euler parameter e1 as function of time.</field>
    /// <field name='lcide2' static='false' type='Number'>Load curve ID specifying Euler parameter e2 as function of time.</field>
    /// <field name='lcide3' static='false' type='Number'>Load curve ID specifying Euler parameter e3 as function of time.</field>
    /// <field name='lcide4' static='false' type='Number'>Load curve ID specifying Euler parameter e4 as function of time.</field>
    /// <field name='lcidq1' static='false' type='Number'>Load curve ID specifying orientation angle q1 as function of time.</field>
    /// <field name='lcidq2' static='false' type='Number'>Load curve ID specifying orientation angle q2 as function of time.</field>
    /// <field name='lcidq3' static='false' type='Number'>Load curve ID specifying orientation angle q3 as function of time.</field>
    /// <field name='lcids' static='false' type='Number'>Load curve ID specifying spin speed of PIDB about axis parallel to vector.</field>
    /// <field name='lcidv1' static='false' type='Number'>Load curve ID specifying vector measure number v1 as function of time.</field>
    /// <field name='lcidv2' static='false' type='Number'>Load curve ID specifying vector measure number v2 as function of time.</field>
    /// <field name='lcidv3' static='false' type='Number'>Load curve ID specifying vector measure number v3 as function of time.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the prescribed orientation rigid is in.</field>
    /// <field name='option' static='false' type='Number'>The Boundary Prescribed Orientation Rigid option. Can be PrescribedOrientationRigid.DIRCOS, PrescribedOrientationRigid.ANGLES, PrescribedOrientationRigid.EULERP or PrescribedOrientationRigid.VECTOR.</field>
    /// <field name='pida' static='false' type='Number'>Part ID for rigid body A.</field>
    /// <field name='pidb' static='false' type='Number'>Part ID for rigid body B whose orientation is prescribed.</field>
    /// <field name='toffset' static='false' type='Number'>Time offset flag.</field>
    /// <field name='valspin' static='false' type='Number'>Constant value for spin speed of PIDB about axis parallel to vector. Used when LCIDS is 0.</field>
    /// <field name='ANGLES' static='true' type='Number'>Boundary is *BOUNDARY_PRESCRIBED_ORIENTATION_RIGID_ANGLES.</field>
    /// <field name='DIRCOS' static='true' type='Number'>Boundary is *BOUNDARY_PRESCRIBED_ORIENTATION_RIGID_DIRCOS.</field>
    /// <field name='EULERP' static='true' type='Number'>Boundary is *BOUNDARY_PRESCRIBED_ORIENTATION_RIGID_EULERP.</field>
    /// <field name='VECTOR' static='true' type='Number'>Boundary is *BOUNDARY_PRESCRIBED_ORIENTATION_RIGID_VECTOR.</field>
}

PrescribedOrientationRigid.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the prescribed orientation rigid.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the prescribed orientation rigid</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the prescribed orientation rigid.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a boundary prescribed orientation rigid definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the prescribed orientation rigid will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for prescribed orientation rigid. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.First = function() {
    /// <signature>
    /// <summary>Returns the first prescribed orientation rigid in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first prescribed orientation rigid in</param>
    /// <returns type="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the prescribed orientation rigids in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all prescribed orientation rigids will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the prescribed orientation rigids</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the prescribed orientation rigid is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the prescribed orientation rigid</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

PrescribedOrientationRigid.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each prescribed orientation rigid in the model. Note that ForEach has been designed to make looping over prescribed orientation rigids as fast as possible and so has some limitations. Firstly, a single temporary PrescribedOrientationRigid object is created and on each function call it is updated with the current prescribed orientation rigid data. This means that you should not try to store the PrescribedOrientationRigid object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new prescribed orientation rigids inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all prescribed orientation rigids are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each prescribed orientation rigid</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of PrescribedOrientationRigid objects for all of the prescribed orientation rigids in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get prescribed orientation rigids from</param>
    /// <returns type="Array" elementType="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of PrescribedOrientationRigid objects for all of the flagged prescribed orientation rigids in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get prescribed orientation rigids from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the prescribed orientation rigids that you want to retrieve</param>
    /// <returns type="Array" elementType="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the PrescribedOrientationRigid object for a prescribed orientation rigid ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the prescribed orientation rigid in</param>
    /// <param name="number" type="Number" optional="false">number of the prescribed orientation rigid you want the PrescribedOrientationRigid object for</param>
    /// <returns type="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a PrescribedOrientationRigid property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the PrescribedOrientationRigid.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">prescribed orientation rigid property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this prescribed orientation rigid. Note that a carriage return is not added. See also PrescribedOrientationRigid.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the prescribed orientation rigid. Note that a carriage return is not added. See also PrescribedOrientationRigid.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

PrescribedOrientationRigid.Last = function() {
    /// <signature>
    /// <summary>Returns the last prescribed orientation rigid in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last prescribed orientation rigid in</param>
    /// <returns type="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next prescribed orientation rigid in the model.</summary>
    /// <returns type="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous prescribed orientation rigid in the model.</summary>
    /// <returns type="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select prescribed orientation rigids using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting prescribed orientation rigids</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only prescribed orientation rigids from that model can be selected. If the argument is a Flag then only prescribed orientation rigids that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any prescribed orientation rigids can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the prescribed orientation rigid.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the prescribed orientation rigid</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the prescribed orientation rigid. The prescribed orientation rigid will be sketched until you either call PrescribedOrientationRigid.Unsketch(), PrescribedOrientationRigid.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the prescribed orientation rigid is sketched. If omitted redraw is true. If you want to sketch several prescribed orientation rigids and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged prescribed orientation rigids in the model. The prescribed orientation rigids will be sketched until you either call PrescribedOrientationRigid.Unsketch(), PrescribedOrientationRigid.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged prescribed orientation rigids will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the prescribed orientation rigids that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the prescribed orientation rigids are sketched. If omitted redraw is true. If you want to sketch flagged prescribed orientation rigids several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of prescribed orientation rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing prescribed orientation rigids should be counted. If false or omitted referenced but undefined prescribed orientation rigids will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

PrescribedOrientationRigid.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the prescribed orientation rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all prescribed orientation rigids will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the prescribed orientation rigids</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the prescribed orientation rigid.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the prescribed orientation rigid is unsketched. If omitted redraw is true. If you want to unsketch several prescribed orientation rigids and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all prescribed orientation rigids.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all prescribed orientation rigids will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the prescribed orientation rigids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged prescribed orientation rigids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all prescribed orientation rigids will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the prescribed orientation rigids that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the prescribed orientation rigids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="PrescribedOrientationRigid"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for prescribed orientation rigid. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this prescribed orientation rigid.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

PrescribedOrientationRigid.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the prescribed orientation rigid data in keyword format. Note that this contains the keyword header and the keyword cards. See also PrescribedOrientationRigid.Keyword() and PrescribedOrientationRigid.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Pretensioner = function() {
    /// <signature>
    /// <summary>Create a new Seatbelt Pretensioner object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that pretensioner will be created in</param>
    /// <param name="sbprid" type="Number" optional="false">Pretensioner number.</param>
    /// <param name="sbprty" type="Number" optional="false">Pretensioner type.</param>
    /// <param name="sbrid" type="Number" optional="false">Retractor number.</param>
    /// <param name="ptlcid" type="Number" optional="false">Loadcurve of pull-in vs time</param>
    /// <param name="sbsid1" type="Number" optional="false">Sensor number 1</param>
    /// <param name="sbsid2" type="Number" optional="true">Sensor number 2</param>
    /// <param name="sbsid3" type="Number" optional="true">Sensor number 3</param>
    /// <param name="sbsid4" type="Number" optional="true">Sensor number 4</param>
    /// <param name="time" type="Number" optional="true">Time between sensor triggering and pretensioner acting.</param>
    /// <param name="lmtfrc" type="Number" optional="true">Limiting force</param>
    /// <returns type="Pretensioner"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the pretensioner</field>
    /// <field name='exists' static='false' type='Boolean'>true if pretensioner exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the pretensioner is in.</field>
    /// <field name='label' static='false' type='Number'>Pretensioner number. Also see the sbprid property which is an alternative name for this.</field>
    /// <field name='lmtfrc' static='false' type='Number'>Limiting force</field>
    /// <field name='model' static='false' type='Number'>The Model number that the pretensioner is in.</field>
    /// <field name='ptlcid' static='false' type='Number'>Loadcurve of pull-in vs time</field>
    /// <field name='sbprid' static='false' type='Number'>Pretensioner number. Also see the label property which is an alternative name for this.</field>
    /// <field name='sbprty' static='false' type='Number'>Pretensioner type.</field>
    /// <field name='sbrid' static='false' type='Number'>Retractor number.</field>
    /// <field name='sbsid1' static='false' type='Number'>Sensor number 1</field>
    /// <field name='sbsid2' static='false' type='Number'>Sensor number 2</field>
    /// <field name='sbsid3' static='false' type='Number'>Sensor number 3</field>
    /// <field name='sbsid4' static='false' type='Number'>Sensor number 4</field>
    /// <field name='time' static='false' type='Number'>Time between sensor triggering and pretensioner acting.</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the pretensioner (0-100) 0% is opaque, 100% is transparent.</field>
}

Pretensioner.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the pretensioner</summary>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the pretensioners in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all pretensioners will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged pretensioners in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged pretensioners will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the pretensioners that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the pretensioner is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Pretensioner.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the pretensioner.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the pretensioner</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the pretensioner.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Pretensioner"/>
    /// </signature>
}

Pretensioner.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a pretensioner.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the pretensioner will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Pretensioner"/>
    /// </signature>
}

Pretensioner.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for pretensioner. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for pretensioner. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the pretensioner colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the pretensioner.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Pretensioner.First = function() {
    /// <signature>
    /// <summary>Returns the first pretensioner in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first pretensioner in</param>
    /// <returns type="Pretensioner"/>
    /// </signature>
}

Pretensioner.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free pretensioner label in the model. Also see Pretensioner.LastFreeLabel(), Pretensioner.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free pretensioner label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Pretensioner.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the pretensioners in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all pretensioners will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the pretensioners</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the pretensioner is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the pretensioner</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Pretensioner.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each pretensioner in the model. Note that ForEach has been designed to make looping over pretensioners as fast as possible and so has some limitations. Firstly, a single temporary Pretensioner object is created and on each function call it is updated with the current pretensioner data. This means that you should not try to store the Pretensioner object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new pretensioners inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all pretensioners are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each pretensioner</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Pretensioner objects for all of the pretensioners in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get pretensioners from</param>
    /// <returns type="Array" elementType="Pretensioner"/>
    /// </signature>
}

Pretensioner.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Pretensioner objects for all of the flagged pretensioners in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get pretensioners from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the pretensioners that you want to retrieve</param>
    /// <returns type="Array" elementType="Pretensioner"/>
    /// </signature>
}

Pretensioner.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Pretensioner object for a pretensioner ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the pretensioner in</param>
    /// <param name="number" type="Number" optional="false">number of the pretensioner you want the Pretensioner object for</param>
    /// <returns type="Pretensioner"/>
    /// </signature>
}

Pretensioner.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Pretensioner property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Pretensioner.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">pretensioner property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Pretensioner.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this pretensioner (*ELEMENT_SEATBELT_PRETEROMETER) Note that a carriage return is not added. See also Pretensioner.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Pretensioner.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the pretensioner. Note that a carriage return is not added. See also Pretensioner.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Pretensioner.Last = function() {
    /// <signature>
    /// <summary>Returns the last pretensioner in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last pretensioner in</param>
    /// <returns type="Pretensioner"/>
    /// </signature>
}

Pretensioner.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free pretensioner label in the model. Also see Pretensioner.FirstFreeLabel(), Pretensioner.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free pretensioner label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Pretensioner.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next pretensioner in the model.</summary>
    /// <returns type="Pretensioner"/>
    /// </signature>
}

Pretensioner.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) pretensioner label in the model. Also see Pretensioner.FirstFreeLabel(), Pretensioner.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free pretensioner label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Pretensioner.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a pretensioner.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only pretensioners from that model can be picked. If the argument is a Flag then only pretensioners that are flagged with limit can be selected. If omitted, or null, any pretensioners from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Pretensioner"/>
    /// </signature>
}

Pretensioner.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous pretensioner in the model.</summary>
    /// <returns type="Pretensioner"/>
    /// </signature>
}

Pretensioner.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the pretensioners in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all pretensioners will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged pretensioners in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged pretensioners will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the pretensioners that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select pretensioners using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting pretensioners</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only pretensioners from that model can be selected. If the argument is a Flag then only pretensioners that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any pretensioners can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Pretensioner.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the pretensioner.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the pretensioner</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the pretensioner. The pretensioner will be sketched until you either call Pretensioner.Unsketch(), Pretensioner.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the pretensioner is sketched. If omitted redraw is true. If you want to sketch several pretensioners and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged pretensioners in the model. The pretensioners will be sketched until you either call Pretensioner.Unsketch(), Pretensioner.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged pretensioners will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the pretensioners that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the pretensioners are sketched. If omitted redraw is true. If you want to sketch flagged pretensioners several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of pretensioners in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing pretensioners should be counted. If false or omitted referenced but undefined pretensioners will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Pretensioner.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the pretensioner</summary>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the pretensioners in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all pretensioners will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged pretensioners in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged pretensioners will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the pretensioners that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the pretensioners in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all pretensioners will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the pretensioners</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the pretensioner.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the pretensioner is unsketched. If omitted redraw is true. If you want to unsketch several pretensioners and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all pretensioners.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all pretensioners will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the pretensioners are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged pretensioners in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all pretensioners will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the pretensioners that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the pretensioners are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Pretensioner"/>
    /// </signature>
}

Pretensioner.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for pretensioner. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Pretensioner.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this pretensioner.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Pretensioner.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the pretensioner data in keyword format. Note that this contains the keyword header and the keyword cards. See also Pretensioner.Keyword() and Pretensioner.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var ReferenceGeometry = function() {
    /// <signature>
    /// <summary>Create a new ReferenceGeometry object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that ReferenceGeometry will be created in</param>
    /// <param name="aid" type="Number" optional="true">ReferenceGeometry number to set _ID suffix</param>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
    /// <field name='aid' static='false' type='Number'>ReferenceGeometry number. Also see the label property which is an alternative name for this.</field>
    /// <field name='birth' static='false' type='Boolean'>Turns _BIRTH on or off</field>
    /// <field name='birth_time' static='false' type='Number'>Birth time</field>
    /// <field name='exists' static='false' type='Boolean'>true if airbag reference geometry exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Boolean'>Turns _ID on or OFF</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the airbag reference geometry is in.</field>
    /// <field name='label' static='false' type='Number'>ReferenceGeometry number. Also see the label property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the airbag reference geometry is in.</field>
    /// <field name='nido' static='false' type='Number'>Node number for origin</field>
    /// <field name='rdt' static='false' type='Boolean'>Turns _RDT on or OFF</field>
    /// <field name='sx' static='false' type='Number'>Scale factor in X direction</field>
    /// <field name='sy' static='false' type='Number'>Scale factor in Y direction</field>
    /// <field name='sz' static='false' type='Number'>Scale factor in Z direction</field>
}

ReferenceGeometry.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the airbag reference geometry.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the airbag reference geometry</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the airbag reference geometry.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an ardt.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the ardt will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for airbag reference geometry. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.First = function() {
    /// <signature>
    /// <summary>Returns the first airbag reference geometry in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first airbag reference geometry in</param>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free airbag reference geometry label in the model. Also see ReferenceGeometry.LastFreeLabel(), ReferenceGeometry.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free airbag reference geometry label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ReferenceGeometry.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the airbag reference geometrys in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag reference geometrys will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the airbag reference geometrys</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the airbag reference geometry is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the airbag reference geometry</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

ReferenceGeometry.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each airbag reference geometry in the model. Note that ForEach has been designed to make looping over airbag reference geometrys as fast as possible and so has some limitations. Firstly, a single temporary ReferenceGeometry object is created and on each function call it is updated with the current airbag reference geometry data. This means that you should not try to store the ReferenceGeometry object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new airbag reference geometrys inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag reference geometrys are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each airbag reference geometry</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of ReferenceGeometry objects for all of the airbag reference geometrys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get airbag reference geometrys from</param>
    /// <returns type="Array" elementType="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of ReferenceGeometry objects for all of the flagged airbag reference geometrys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get airbag reference geometrys from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbag reference geometrys that you want to retrieve</param>
    /// <returns type="Array" elementType="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the ReferenceGeometry object for a airbag reference geometry ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the airbag reference geometry in</param>
    /// <param name="number" type="Number" optional="false">number of the airbag reference geometry you want the ReferenceGeometry object for</param>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.prototype.GetNode = function() {
    /// <signature>
    /// <summary>Returns the reference geometry coordinates for the node</summary>
    /// <param name="nid" type="Number" optional="false">Node ID</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

ReferenceGeometry.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a ReferenceGeometry property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ReferenceGeometry.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">airbag reference geometry property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

ReferenceGeometry.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this reference_geometry (*AIRBAG_REFERENCE_GEOMETRY). Note that a carriage return is not added. See also ReferenceGeometry.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ReferenceGeometry.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the reference_geometry. Note that a carriage return is not added. See also ReferenceGeometry.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ReferenceGeometry.Last = function() {
    /// <signature>
    /// <summary>Returns the last airbag reference geometry in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last airbag reference geometry in</param>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free airbag reference geometry label in the model. Also see ReferenceGeometry.FirstFreeLabel(), ReferenceGeometry.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free airbag reference geometry label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ReferenceGeometry.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next airbag reference geometry in the model.</summary>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) airbag reference geometry label in the model. Also see ReferenceGeometry.FirstFreeLabel(), ReferenceGeometry.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free airbag reference geometry label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ReferenceGeometry.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a airbag reference geometry.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only airbag reference geometrys from that model can be picked. If the argument is a Flag then only airbag reference geometrys that are flagged with limit can be selected. If omitted, or null, any airbag reference geometrys from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous airbag reference geometry in the model.</summary>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.prototype.RemoveNode = function() {
    /// <signature>
    /// <summary>Removes a node from the reference geometry if it is on it</summary>
    /// <param name="nid" type="Number" optional="false">Node ID</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the airbag reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag reference geometrys will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged airbag reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged airbag reference geometrys will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbag reference geometrys that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select airbag reference geometrys using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting airbag reference geometrys</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only airbag reference geometrys from that model can be selected. If the argument is a Flag then only airbag reference geometrys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any airbag reference geometrys can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ReferenceGeometry.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the airbag reference geometry.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the airbag reference geometry</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.SetNode = function() {
    /// <signature>
    /// <summary>Adds a node to the reference geometry if not already there, otherwise just changes the coordinates</summary>
    /// <param name="nid" type="Number" optional="false">Node ID</param>
    /// <param name="x" type="Number" optional="false">X reference coordinate</param>
    /// <param name="y" type="Number" optional="false">Y reference coordinate</param>
    /// <param name="z" type="Number" optional="false">Z reference coordinate</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the airbag reference geometry. The airbag reference geometry will be sketched until you either call ReferenceGeometry.Unsketch(), ReferenceGeometry.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag reference geometry is sketched. If omitted redraw is true. If you want to sketch several airbag reference geometrys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged airbag reference geometrys in the model. The airbag reference geometrys will be sketched until you either call ReferenceGeometry.Unsketch(), ReferenceGeometry.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged airbag reference geometrys will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbag reference geometrys that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag reference geometrys are sketched. If omitted redraw is true. If you want to sketch flagged airbag reference geometrys several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.Spool = function() {
    /// <signature>
    /// <summary>Spools a reference geometry, entry by entry. See also ReferenceGeometry.StartSpool</summary>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

ReferenceGeometry.prototype.StartSpool = function() {
    /// <signature>
    /// <summary>Starts a reference geometry spooling operation. See also ReferenceGeometry.Spool</summary>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of airbag reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing airbag reference geometrys should be counted. If false or omitted referenced but undefined airbag reference geometrys will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ReferenceGeometry.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the airbag reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all airbag reference geometrys will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the airbag reference geometrys</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the airbag reference geometry.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag reference geometry is unsketched. If omitted redraw is true. If you want to unsketch several airbag reference geometrys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all airbag reference geometrys.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag reference geometrys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag reference geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged airbag reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag reference geometrys will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbag reference geometrys that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag reference geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="ReferenceGeometry"/>
    /// </signature>
}

ReferenceGeometry.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for airbag reference geometry. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

ReferenceGeometry.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this airbag reference geometry.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

ReferenceGeometry.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the ReferenceGeometry data in keyword format. Note that this contains the keyword header and the keyword cards. See also ReferenceGeometry.Keyword() and ReferenceGeometry.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Retractor = function() {
    /// <signature>
    /// <summary>Create a new Seatbelt Retractor object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that retractor will be created in</param>
    /// <param name="sbrid" type="Number" optional="false">Retractor number.</param>
    /// <param name="sbrnid" type="Number" optional="false">Node number (or Set Node number if negative).</param>
    /// <param name="sbid" type="Number" optional="false">Seatbelt number. (or Set Shell number if sbrnid is negative)</param>
    /// <param name="llcid" type="Number" optional="false">Loadcurve for loading (pull-out vs force)</param>
    /// <param name="sid1" type="Number" optional="false">Sensor number 1</param>
    /// <param name="sid2" type="Number" optional="true">Sensor number 2</param>
    /// <param name="sid3" type="Number" optional="true">Sensor number 3</param>
    /// <param name="sid4" type="Number" optional="true">Sensor number 4</param>
    /// <param name="tdel" type="Number" optional="true">Time delay after sensor triggers.</param>
    /// <param name="pull" type="Number" optional="true">Amount of pull out between time delay ending and retractor locking.</param>
    /// <param name="ulcid" type="Number" optional="true">Loadcurve for unloading (pull-out vs force)</param>
    /// <param name="lfed" type="Number" optional="true">Fed length</param>
    /// <returns type="Retractor"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the retractor</field>
    /// <field name='dsid' static='false' type='Number'>Retractor deactivation Sensor</field>
    /// <field name='exists' static='false' type='Boolean'>true if retractor exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the retractor is in.</field>
    /// <field name='label' static='false' type='Number'>Retractor number. Also see the sbrid property which is an alternative name for this.</field>
    /// <field name='lfed' static='false' type='Number'>Fed length</field>
    /// <field name='llcid' static='false' type='Number'>Loadcurve for loading (pull-out vs force)</field>
    /// <field name='model' static='false' type='Number'>The Model number that the retractor is in.</field>
    /// <field name='pull' static='false' type='Number'>Amount of pull out between time delay ending and retractor locking</field>
    /// <field name='sbid' static='false' type='Number'>Seatbelt1D number (or Set Shell number if sbrnid is negative).</field>
    /// <field name='sbrid' static='false' type='Number'>Retractor number. Also see the label property which is an alternative name for this.</field>
    /// <field name='sbrnid' static='false' type='Number'>Node number (or Set Node number if negative).</field>
    /// <field name='shell_seatbelt' static='false' type='Boolean'>true if retractor is used for shell (2D) seatbelt elements. (read only)</field>
    /// <field name='sid1' static='false' type='Number'>Sensor number 1</field>
    /// <field name='sid2' static='false' type='Number'>Sensor number 2</field>
    /// <field name='sid3' static='false' type='Number'>Sensor number 3</field>
    /// <field name='sid4' static='false' type='Number'>Sensor number 4</field>
    /// <field name='tdel' static='false' type='Number'>Time delay after sensor triggers</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the retractor (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='ulcid' static='false' type='Number'>Loadcurve for unloading (pull-out vs force)</field>
}

Retractor.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the retractor</summary>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the retractors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all retractors will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged retractors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged retractors will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the retractors that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the retractor is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Retractor.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the retractor.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the retractor</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the retractor.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Retractor"/>
    /// </signature>
}

Retractor.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a retractor.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the retractor will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Retractor"/>
    /// </signature>
}

Retractor.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for retractor. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for retractor. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the retractor colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the retractor.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Retractor.First = function() {
    /// <signature>
    /// <summary>Returns the first retractor in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first retractor in</param>
    /// <returns type="Retractor"/>
    /// </signature>
}

Retractor.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free retractor label in the model. Also see Retractor.LastFreeLabel(), Retractor.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free retractor label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Retractor.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the retractors in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all retractors will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the retractors</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the retractor is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the retractor</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Retractor.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each retractor in the model. Note that ForEach has been designed to make looping over retractors as fast as possible and so has some limitations. Firstly, a single temporary Retractor object is created and on each function call it is updated with the current retractor data. This means that you should not try to store the Retractor object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new retractors inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all retractors are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each retractor</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Retractor objects for all of the retractors in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get retractors from</param>
    /// <returns type="Array" elementType="Retractor"/>
    /// </signature>
}

Retractor.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Retractor objects for all of the flagged retractors in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get retractors from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the retractors that you want to retrieve</param>
    /// <returns type="Array" elementType="Retractor"/>
    /// </signature>
}

Retractor.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Retractor object for a retractor ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the retractor in</param>
    /// <param name="number" type="Number" optional="false">number of the retractor you want the Retractor object for</param>
    /// <returns type="Retractor"/>
    /// </signature>
}

Retractor.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Retractor property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Retractor.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">retractor property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Retractor.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this retractor (*ELEMENT_SEATBELT_RETREROMETER) Note that a carriage return is not added. See also Retractor.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Retractor.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the retractor. Note that a carriage return is not added. See also Retractor.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Retractor.Last = function() {
    /// <signature>
    /// <summary>Returns the last retractor in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last retractor in</param>
    /// <returns type="Retractor"/>
    /// </signature>
}

Retractor.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free retractor label in the model. Also see Retractor.FirstFreeLabel(), Retractor.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free retractor label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Retractor.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next retractor in the model.</summary>
    /// <returns type="Retractor"/>
    /// </signature>
}

Retractor.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) retractor label in the model. Also see Retractor.FirstFreeLabel(), Retractor.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free retractor label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Retractor.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a retractor.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only retractors from that model can be picked. If the argument is a Flag then only retractors that are flagged with limit can be selected. If omitted, or null, any retractors from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Retractor"/>
    /// </signature>
}

Retractor.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous retractor in the model.</summary>
    /// <returns type="Retractor"/>
    /// </signature>
}

Retractor.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the retractors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all retractors will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged retractors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged retractors will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the retractors that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select retractors using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting retractors</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only retractors from that model can be selected. If the argument is a Flag then only retractors that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any retractors can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Retractor.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the retractor.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the retractor</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the retractor. The retractor will be sketched until you either call Retractor.Unsketch(), Retractor.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the retractor is sketched. If omitted redraw is true. If you want to sketch several retractors and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged retractors in the model. The retractors will be sketched until you either call Retractor.Unsketch(), Retractor.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged retractors will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the retractors that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the retractors are sketched. If omitted redraw is true. If you want to sketch flagged retractors several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of retractors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing retractors should be counted. If false or omitted referenced but undefined retractors will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Retractor.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the retractor</summary>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the retractors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all retractors will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged retractors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged retractors will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the retractors that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the retractors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all retractors will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the retractors</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the retractor.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the retractor is unsketched. If omitted redraw is true. If you want to unsketch several retractors and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all retractors.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all retractors will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the retractors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged retractors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all retractors will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the retractors that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the retractors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Retractor"/>
    /// </signature>
}

Retractor.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for retractor. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Retractor.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this retractor.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Retractor.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the retractor data in keyword format. Note that this contains the keyword header and the keyword cards. See also Retractor.Keyword() and Retractor.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var RigidBodies = function() {
    /// <signature>
    /// <summary>Create a new RigidBodies object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained rigid bodies will be created in</param>
    /// <param name="pidm" type="Number" optional="false">Master rigid body part ID.</param>
    /// <param name="pids" type="Number" optional="false">Slave rigid body part ID.</param>
    /// <param name="iflag" type="Number" optional="false">Flag for adding slave mass properties to part inertia.</param>
    /// <returns type="RigidBodies"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if constrained rigid bodies exists, false if referred to but not defined. (read only)</field>
    /// <field name='iflag' static='false' type='Number'>Flag for adding slave mass properties to part inertia.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the constrained rigid bodies is in.</field>
    /// <field name='label' static='false' type='Number'>The label the constrained rigid bodies has in PRIMER (read only)</field>
    /// <field name='model' static='false' type='Number'>The Model number that the rigid body merge is in.</field>
    /// <field name='pidm' static='false' type='Number'>Master rigid body part ID.</field>
    /// <field name='pids' static='false' type='Number'>Slave rigid body part ID.</field>
}

RigidBodies.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the rigid body merge</summary>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the rigid body merges in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigid body merges will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged rigid body merges in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged rigid body merges will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigid body merges that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the rigid body merge is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

RigidBodies.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the rigid body merge.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the rigid body merge</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the rigid body merge.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="RigidBodies"/>
    /// </signature>
}

RigidBodies.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a constrained rigid bodies definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the constrained rigid bodies definition will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="RigidBodies"/>
    /// </signature>
}

RigidBodies.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for rigid body merge. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.First = function() {
    /// <signature>
    /// <summary>Returns the first rigid body merge in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first rigid body merge in</param>
    /// <returns type="RigidBodies"/>
    /// </signature>
}

RigidBodies.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the rigid body merges in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigid body merges will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the rigid body merges</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the rigid body merge is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the rigid body merge</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

RigidBodies.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each rigid body merge in the model. Note that ForEach has been designed to make looping over rigid body merges as fast as possible and so has some limitations. Firstly, a single temporary RigidBodies object is created and on each function call it is updated with the current rigid body merge data. This means that you should not try to store the RigidBodies object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new rigid body merges inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigid body merges are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each rigid body merge</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of RigidBodies objects for all of the rigid body merges in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get rigid body merges from</param>
    /// <returns type="Array" elementType="RigidBodies"/>
    /// </signature>
}

RigidBodies.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of RigidBodies objects for all of the flagged rigid body merges in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get rigid body merges from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigid body merges that you want to retrieve</param>
    /// <returns type="Array" elementType="RigidBodies"/>
    /// </signature>
}

RigidBodies.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the RigidBodies object for a rigid body merge ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the rigid body merge in</param>
    /// <param name="number" type="Number" optional="false">number of the rigid body merge you want the RigidBodies object for</param>
    /// <returns type="RigidBodies"/>
    /// </signature>
}

RigidBodies.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a RigidBodies property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the RigidBodies.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">rigid body merge property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

RigidBodies.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this constrained rigid bodies (*CONSTRAINED_RIGID_BODIES). Note that a carriage return is not added. See also RigidBodies.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

RigidBodies.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the constrained rigid bodies. Note that a carriage return is not added. See also RigidBodies.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

RigidBodies.Last = function() {
    /// <signature>
    /// <summary>Returns the last rigid body merge in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last rigid body merge in</param>
    /// <returns type="RigidBodies"/>
    /// </signature>
}

RigidBodies.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next rigid body merge in the model.</summary>
    /// <returns type="RigidBodies"/>
    /// </signature>
}

RigidBodies.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a rigid body merge.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only rigid body merges from that model can be picked. If the argument is a Flag then only rigid body merges that are flagged with limit can be selected. If omitted, or null, any rigid body merges from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="RigidBodies"/>
    /// </signature>
}

RigidBodies.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous rigid body merge in the model.</summary>
    /// <returns type="RigidBodies"/>
    /// </signature>
}

RigidBodies.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select rigid body merges using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting rigid body merges</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only rigid body merges from that model can be selected. If the argument is a Flag then only rigid body merges that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any rigid body merges can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

RigidBodies.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the rigid body merge.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the rigid body merge</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the rigid body merge. The rigid body merge will be sketched until you either call RigidBodies.Unsketch(), RigidBodies.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigid body merge is sketched. If omitted redraw is true. If you want to sketch several rigid body merges and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged rigid body merges in the model. The rigid body merges will be sketched until you either call RigidBodies.Unsketch(), RigidBodies.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged rigid body merges will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigid body merges that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigid body merges are sketched. If omitted redraw is true. If you want to sketch flagged rigid body merges several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of rigid body merges in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing rigid body merges should be counted. If false or omitted referenced but undefined rigid body merges will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

RigidBodies.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the rigid body merge</summary>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the rigid body merges in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigid body merges will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged rigid body merges in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged rigid body merges will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigid body merges that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the rigid body merges in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all rigid body merges will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the rigid body merges</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the rigid body merge.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigid body merge is unsketched. If omitted redraw is true. If you want to unsketch several rigid body merges and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all rigid body merges.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigid body merges will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigid body merges are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged rigid body merges in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigid body merges will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigid body merges that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigid body merges are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="RigidBodies"/>
    /// </signature>
}

RigidBodies.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for rigid body merge. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

RigidBodies.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this rigid body merge.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

RigidBodies.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the constrained rigid bodies data in keyword format. Note that this contains the keyword header and the keyword cards. See also RigidBodies.Keyword() and RigidBodies.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Rigidwall = function() {
    /// <signature>
    /// <summary>Create a new Rigidwall object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that Rigidwall will be created in</param>
    /// <param name="type" type="Number" optional="false">Specify the type of rigidwall (Can be Rigidwall.FLAT, Rigidwall.PRISM, Rigidwall.CYLINDER, Rigidwall.SPHERE, Rigidwall.PLANAR)</param>
    /// <param name="nsid" type="Number" optional="true">Node set number.</param>
    /// <param name="rwid" type="Number" optional="true">Rigidwall number</param>
    /// <param name="heading" type="String" optional="true">Title for the Rigidwall</param>
    /// <returns type="Rigidwall"/>
    /// </signature>
    /// <field name='birth' static='false' type='Number'>Birth time.</field>
    /// <field name='boxid' static='false' type='Number'>Box for nodes.</field>
    /// <field name='d1' static='false' type='Number'>X component of vector defn.</field>
    /// <field name='d2' static='false' type='Number'>Y component of vector defn.</field>
    /// <field name='d3' static='false' type='Number'>Z component of vector defn.</field>
    /// <field name='death' static='false' type='Number'>Death time.</field>
    /// <field name='decaya' static='false' type='Number'>Friction decay const in local A dir.</field>
    /// <field name='decayb' static='false' type='Number'>Friction decay const in local B dir.</field>
    /// <field name='dfrica' static='false' type='Number'>Dynamic friction coeff in local A dir.</field>
    /// <field name='dfricb' static='false' type='Number'>Dynamic friction coeff in local B dir.</field>
    /// <field name='display' static='false' type='Boolean'>DISPLAY flag.</field>
    /// <field name='e' static='false' type='Number'>Young's modulus of rigidwall (for _DISPLAY option).</field>
    /// <field name='exists' static='false' type='Boolean'>true if rigidwall exists, false if referred to but not defined. (read only)</field>
    /// <field name='finite' static='false' type='Boolean'>Finite flag.</field>
    /// <field name='forces' static='false' type='Boolean'>Forces flag.</field>
    /// <field name='fric' static='false' type='Number'>Friction coefficient.</field>
    /// <field name='heading' static='false' type='String'>Rigidwall heading</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the rigidwall is in.</field>
    /// <field name='label' static='false' type='Number'>Rigidwall number.</field>
    /// <field name='lcid' static='false' type='Number'>Vel/disp vs time curve number.</field>
    /// <field name='lencyl' static='false' type='Number'>Length of cylinder.</field>
    /// <field name='lenl' static='false' type='Number'>Length of L edge.</field>
    /// <field name='lenm' static='false' type='Number'>Length of M edge.</field>
    /// <field name='lenp' static='false' type='Number'>Length of prism in -ve N.</field>
    /// <field name='mass' static='false' type='Number'>Mass of moving wall.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the rigidwall is in.</field>
    /// <field name='motion' static='false' type='Boolean'>Motion flag.</field>
    /// <field name='moving' static='false' type='Boolean'>Moving flag.</field>
    /// <field name='n1' static='false' type='Number'>1st node for visualisation.</field>
    /// <field name='n2' static='false' type='Number'>2nd node for visualisation.</field>
    /// <field name='n3' static='false' type='Number'>3rd node for visualisation.</field>
    /// <field name='n4' static='false' type='Number'>4th node for visualisation.</field>
    /// <field name='node1' static='false' type='Number'>Node 1 for vector defn.</field>
    /// <field name='node2' static='false' type='Number'>Node 2 for vector defn.</field>
    /// <field name='nsegs' static='false' type='Number'>Number of subsections.</field>
    /// <field name='nsid' static='false' type='Number'>Slave node set included in wall.</field>
    /// <field name='nsidex' static='false' type='Number'>Slave node set exempted from wall.</field>
    /// <field name='offset' static='false' type='Number'>Offset for planar option.</field>
    /// <field name='opt' static='false' type='Number'>Motion type.</field>
    /// <field name='ortho' static='false' type='Boolean'>Ortho flag.</field>
    /// <field name='pid' static='false' type='Number'>Part ID for display of geometric rigidwall (for _DISPLAY option).</field>
    /// <field name='pr' static='false' type='Number'>Poisson's ratio of rigidwall (for _DISPLAY option).</field>
    /// <field name='radcyl' static='false' type='Number'>Radius of cylinder.</field>
    /// <field name='radsph' static='false' type='Number'>Radius of sphere.</field>
    /// <field name='ro' static='false' type='Number'>Density of rigidwall (for _DISPLAY option).</field>
    /// <field name='rwid' static='false' type='Number'>Rigidwall number (identical to label).</field>
    /// <field name='rwksf' static='false' type='Number'>Stiffness scaling factor.</field>
    /// <field name='sfrica' static='false' type='Number'>Static friction coeff in local A dir.</field>
    /// <field name='sfricb' static='false' type='Number'>Static friction coeff in local B dir.</field>
    /// <field name='soft' static='false' type='Number'>No. of cycles to zero relative velocity.</field>
    /// <field name='ssid' static='false' type='Number'>Segment set number.</field>
    /// <field name='type' static='false' type='Number'>The rigidwall type. Can be Rigidwall.FLAT, Rigidwall.PRISM, Rigidwall.CYLINDER, Rigidwall.SPHERE, Rigidwall.PLANAR,</field>
    /// <field name='v0' static='false' type='Number'>Initial velocity.</field>
    /// <field name='vx' static='false' type='Number'>X component of motion vector.</field>
    /// <field name='vy' static='false' type='Number'>Y component of motion vector.</field>
    /// <field name='vz' static='false' type='Number'>Z component of motion vector.</field>
    /// <field name='wvel' static='false' type='Number'>Velocity at which nodes weld to wall.</field>
    /// <field name='xh' static='false' type='Number'>Head X coord of outward normal.</field>
    /// <field name='xhev' static='false' type='Number'>Head X coord of edge I vector.</field>
    /// <field name='xt' static='false' type='Number'>Tail X coord of outward normal.</field>
    /// <field name='yh' static='false' type='Number'>Head Y coord of outward normal.</field>
    /// <field name='yhev' static='false' type='Number'>Head Y coord of edge I vector.</field>
    /// <field name='yt' static='false' type='Number'>Tail Y coord of outward normal.</field>
    /// <field name='zh' static='false' type='Number'>Head Z coord of outward normal.</field>
    /// <field name='zhev' static='false' type='Number'>Head Z coord of edge I vector.</field>
    /// <field name='zt' static='false' type='Number'>Tail Z coord of outward normal.</field>
    /// <field name='CYLINDER' static='true' type='Number'>Rigidwall is *RIGIDWALL_GEOMETRIC_CYLINDER.</field>
    /// <field name='FLAT' static='true' type='Number'>Rigidwall is *RIGIDWALL_GEOMETRIC_FLAT.</field>
    /// <field name='PLANAR' static='true' type='Number'>Rigidwall is *RIGIDWALL_PLANAR.</field>
    /// <field name='PRISM' static='true' type='Number'>Rigidwall is *RIGIDWALL_GEOMETRIC_PRISM.</field>
    /// <field name='SPHERE' static='true' type='Number'>Rigidwall is *RIGIDWALL_GEOMETRIC_SPHERE.</field>
}

Rigidwall.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the rigidwall</summary>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the rigidwalls in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigidwalls will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged rigidwalls in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged rigidwalls will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigidwalls that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the rigidwall is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Rigidwall.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the rigidwall.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the rigidwall</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the rigidwall.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Rigidwall"/>
    /// </signature>
}

Rigidwall.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a rigidwall.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the rigidwall will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Rigidwall"/>
    /// </signature>
}

Rigidwall.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for rigidwall. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.FindNodesBehind = function() {
    /// <signature>
    /// <summary>Flags nodes that are behind a rigidwall</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to be set on nodes behind rigidwall.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Rigidwall.First = function() {
    /// <signature>
    /// <summary>Returns the first rigidwall in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first rigidwall in</param>
    /// <returns type="Rigidwall"/>
    /// </signature>
}

Rigidwall.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free rigidwall label in the model. Also see Rigidwall.LastFreeLabel(), Rigidwall.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free rigidwall label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Rigidwall.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the rigidwalls in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigidwalls will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the rigidwalls</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the rigidwall is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the rigidwall</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Rigidwall.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each rigidwall in the model. Note that ForEach has been designed to make looping over rigidwalls as fast as possible and so has some limitations. Firstly, a single temporary Rigidwall object is created and on each function call it is updated with the current rigidwall data. This means that you should not try to store the Rigidwall object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new rigidwalls inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigidwalls are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each rigidwall</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Rigidwall objects for all of the rigidwalls in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get rigidwalls from</param>
    /// <returns type="Array" elementType="Rigidwall"/>
    /// </signature>
}

Rigidwall.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Rigidwall objects for all of the flagged rigidwalls in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get rigidwalls from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigidwalls that you want to retrieve</param>
    /// <returns type="Array" elementType="Rigidwall"/>
    /// </signature>
}

Rigidwall.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Rigidwall object for a rigidwall ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the rigidwall in</param>
    /// <param name="number" type="Number" optional="false">number of the rigidwall you want the Rigidwall object for</param>
    /// <returns type="Rigidwall"/>
    /// </signature>
}

Rigidwall.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Rigidwall property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Rigidwall.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">rigidwall property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Rigidwall.prototype.GetRow = function() {
    /// <signature>
    /// <summary>Returns the data for an NSEGS card row in the rigidwall.</summary>
    /// <param name="row" type="Number" optional="false">The row you want the data for. Note row indices start at 0.</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Rigidwall.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this Rigidwall (*RIGIDWALL). Note that a carriage return is not added. See also Rigidwall.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Rigidwall.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the Rigidwall. Note that a carriage return is not added. See also Rigidwall.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Rigidwall.Last = function() {
    /// <signature>
    /// <summary>Returns the last rigidwall in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last rigidwall in</param>
    /// <returns type="Rigidwall"/>
    /// </signature>
}

Rigidwall.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free rigidwall label in the model. Also see Rigidwall.FirstFreeLabel(), Rigidwall.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free rigidwall label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Rigidwall.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next rigidwall in the model.</summary>
    /// <returns type="Rigidwall"/>
    /// </signature>
}

Rigidwall.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) rigidwall label in the model. Also see Rigidwall.FirstFreeLabel(), Rigidwall.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free rigidwall label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Rigidwall.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a rigidwall.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only rigidwalls from that model can be picked. If the argument is a Flag then only rigidwalls that are flagged with limit can be selected. If omitted, or null, any rigidwalls from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Rigidwall"/>
    /// </signature>
}

Rigidwall.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous rigidwall in the model.</summary>
    /// <returns type="Rigidwall"/>
    /// </signature>
}

Rigidwall.prototype.RemoveRow = function() {
    /// <signature>
    /// <summary>Removes an NSEGS card row in the *RIGIDWALL.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to remove the data for. Note that row indices start at 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the rigidwalls in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigidwalls will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged rigidwalls in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged rigidwalls will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigidwalls that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select rigidwalls using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting rigidwalls</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only rigidwalls from that model can be selected. If the argument is a Flag then only rigidwalls that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any rigidwalls can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Rigidwall.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the rigidwall.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the rigidwall</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.SetRow = function() {
    /// <signature>
    /// <summary>Sets the data for an NSEGS card row in the *RIGIDWALL.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to set the data for. Note that row indices start at 0.</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">The data you want to set the row to</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the rigidwall. The rigidwall will be sketched until you either call Rigidwall.Unsketch(), Rigidwall.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigidwall is sketched. If omitted redraw is true. If you want to sketch several rigidwalls and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged rigidwalls in the model. The rigidwalls will be sketched until you either call Rigidwall.Unsketch(), Rigidwall.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged rigidwalls will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigidwalls that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigidwalls are sketched. If omitted redraw is true. If you want to sketch flagged rigidwalls several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of rigidwalls in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing rigidwalls should be counted. If false or omitted referenced but undefined rigidwalls will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Rigidwall.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the rigidwall</summary>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the rigidwalls in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigidwalls will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged rigidwalls in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged rigidwalls will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigidwalls that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the rigidwalls in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all rigidwalls will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the rigidwalls</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the rigidwall.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigidwall is unsketched. If omitted redraw is true. If you want to unsketch several rigidwalls and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all rigidwalls.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigidwalls will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigidwalls are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged rigidwalls in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all rigidwalls will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the rigidwalls that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the rigidwalls are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Rigidwall"/>
    /// </signature>
}

Rigidwall.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for rigidwall. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Rigidwall.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this rigidwall.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Rigidwall.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the Rigidwall data in keyword format. Note that this contains the keyword header and the keyword cards. See also Rigidwall.Keyword() and Rigidwall.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Seatbelt1D = function() {
    /// <signature>
    /// <summary>Create a new Seatbelt1D object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that seatbelt will be created in</param>
    /// <param name="eid" type="Number" optional="false">Seatbelt ID.</param>
    /// <param name="pid" type="Number" optional="false">Part number.</param>
    /// <param name="n1" type="Number" optional="false">Node 1 ID</param>
    /// <param name="n2" type="Number" optional="false">Node 2 ID</param>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the seatbelt</field>
    /// <field name='eid' static='false' type='Number'>Seatbelt1D number. Also see the label property which is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if seatbelt exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the seatbelt is in.</field>
    /// <field name='label' static='false' type='Number'>Seatbelt1D number. Also see the eid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the seatbelt is in.</field>
    /// <field name='n1' static='false' type='Number'>Node 1 ID</field>
    /// <field name='n2' static='false' type='Number'>Node 2 ID</field>
    /// <field name='pid' static='false' type='Number'>Part ID</field>
    /// <field name='sbrid' static='false' type='Number'>Retractor ID</field>
    /// <field name='slen' static='false' type='Number'>Initial slack length</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the seatbelt (0-100) 0% is opaque, 100% is transparent.</field>
}

Seatbelt1D.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the seatbelt</summary>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged seatbelts will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the seatbelt is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Seatbelt1D.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the seatbelt.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the seatbelt</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the seatbelt.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a 2 noded seatbelt.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the seatbelt will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for seatbelt. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for seatbelt. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the seatbelt colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the seatbelt.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt1D.First = function() {
    /// <signature>
    /// <summary>Returns the first seatbelt in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first seatbelt in</param>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free seatbelt label in the model. Also see Seatbelt1D.LastFreeLabel(), Seatbelt1D.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free seatbelt label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt1D.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the seatbelts in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the seatbelts</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the seatbelt is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the seatbelt</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Seatbelt1D.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each seatbelt in the model. Note that ForEach has been designed to make looping over seatbelts as fast as possible and so has some limitations. Firstly, a single temporary Seatbelt1D object is created and on each function call it is updated with the current seatbelt data. This means that you should not try to store the Seatbelt1D object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new seatbelts inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each seatbelt</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Seatbelt1D objects for all of the seatbelts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get seatbelts from</param>
    /// <returns type="Array" elementType="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Seatbelt1D objects for all of the flagged seatbelts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get seatbelts from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to retrieve</param>
    /// <returns type="Array" elementType="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Seatbelt1D object for a seatbelt ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the seatbelt in</param>
    /// <param name="number" type="Number" optional="false">number of the seatbelt you want the Seatbelt1D object for</param>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Seatbelt1D property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Seatbelt1D.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">seatbelt property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Seatbelt1D.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this seatbelt (*ELEMENT_SEATBELT) Note that a carriage return is not added. See also Seatbelt1D.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Seatbelt1D.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the seatbelt. Note that a carriage return is not added. See also Seatbelt1D.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Seatbelt1D.Last = function() {
    /// <signature>
    /// <summary>Returns the last seatbelt in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last seatbelt in</param>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free seatbelt label in the model. Also see Seatbelt1D.FirstFreeLabel(), Seatbelt1D.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free seatbelt label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt1D.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next seatbelt in the model.</summary>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) seatbelt label in the model. Also see Seatbelt1D.FirstFreeLabel(), Seatbelt1D.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free seatbelt label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt1D.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a seatbelt.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only seatbelts from that model can be picked. If the argument is a Flag then only seatbelts that are flagged with limit can be selected. If omitted, or null, any seatbelts from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous seatbelt in the model.</summary>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged seatbelts will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select seatbelts using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting seatbelts</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only seatbelts from that model can be selected. If the argument is a Flag then only seatbelts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any seatbelts can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt1D.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the seatbelt.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the seatbelt</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the seatbelt. The seatbelt will be sketched until you either call Seatbelt1D.Unsketch(), Seatbelt1D.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelt is sketched. If omitted redraw is true. If you want to sketch several seatbelts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged seatbelts in the model. The seatbelts will be sketched until you either call Seatbelt1D.Unsketch(), Seatbelt1D.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged seatbelts will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelts are sketched. If omitted redraw is true. If you want to sketch flagged seatbelts several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.Timestep = function() {
    /// <signature>
    /// <summary>Calculates the timestep for the seatbelt</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt1D.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing seatbelts should be counted. If false or omitted referenced but undefined seatbelts will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt1D.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the seatbelt</summary>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged seatbelts will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all seatbelts will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the seatbelts</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the seatbelt.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelt is unsketched. If omitted redraw is true. If you want to unsketch several seatbelts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all seatbelts.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Seatbelt1D"/>
    /// </signature>
}

Seatbelt1D.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for seatbelt. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt1D.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this seatbelt.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Seatbelt1D.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the seatbelt data in keyword format. Note that this contains the keyword header and the keyword cards. See also Seatbelt1D.Keyword() and Seatbelt1D.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Seatbelt2D = function() {
    /// <signature>
    /// <summary>Create a new Seatbelt2D object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that seatbelt will be created in</param>
    /// <param name="eid" type="Number" optional="false">Seatbelt ID.</param>
    /// <param name="pid" type="Number" optional="false">Part number.</param>
    /// <param name="n1" type="Number" optional="false">Node 1 ID</param>
    /// <param name="n2" type="Number" optional="false">Node 2 ID</param>
    /// <param name="n3" type="Number" optional="false">Node 3 ID</param>
    /// <param name="n4" type="Number" optional="false">Node 4 ID</param>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the seatbelt</field>
    /// <field name='eid' static='false' type='Number'>Seatbelt2D number. Also see the label property which is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if seatbelt exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the seatbelt is in.</field>
    /// <field name='label' static='false' type='Number'>Seatbelt2D number. Also see the eid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the seatbelt is in.</field>
    /// <field name='n1' static='false' type='Number'>Node 1 ID</field>
    /// <field name='n2' static='false' type='Number'>Node 2 ID</field>
    /// <field name='n3' static='false' type='Number'>Node 3 ID</field>
    /// <field name='n4' static='false' type='Number'>Node 4 ID</field>
    /// <field name='pid' static='false' type='Number'>Part ID</field>
    /// <field name='sbrid' static='false' type='Number'>Retractor ID</field>
    /// <field name='slen' static='false' type='Number'>Initial slack length</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the seatbelt (0-100) 0% is opaque, 100% is transparent.</field>
}

Seatbelt2D.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the seatbelt</summary>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged seatbelts will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the seatbelt is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Seatbelt2D.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the seatbelt.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the seatbelt</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the seatbelt.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a 2 noded seatbelt.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the seatbelt will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for seatbelt. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for seatbelt. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the seatbelt colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the seatbelt.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt2D.First = function() {
    /// <signature>
    /// <summary>Returns the first seatbelt in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first seatbelt in</param>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free seatbelt label in the model. Also see Seatbelt2D.LastFreeLabel(), Seatbelt2D.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free seatbelt label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt2D.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the seatbelts in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the seatbelts</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the seatbelt is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the seatbelt</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Seatbelt2D.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each seatbelt in the model. Note that ForEach has been designed to make looping over seatbelts as fast as possible and so has some limitations. Firstly, a single temporary Seatbelt2D object is created and on each function call it is updated with the current seatbelt data. This means that you should not try to store the Seatbelt2D object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new seatbelts inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each seatbelt</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Seatbelt2D objects for all of the seatbelts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get seatbelts from</param>
    /// <returns type="Array" elementType="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Seatbelt2D objects for all of the flagged seatbelts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get seatbelts from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to retrieve</param>
    /// <returns type="Array" elementType="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Seatbelt2D object for a seatbelt ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the seatbelt in</param>
    /// <param name="number" type="Number" optional="false">number of the seatbelt you want the Seatbelt2D object for</param>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Seatbelt2D property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Seatbelt2D.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">seatbelt property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Seatbelt2D.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this seatbelt (*ELEMENT_SEATBELT) Note that a carriage return is not added. See also Seatbelt2D.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Seatbelt2D.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the seatbelt. Note that a carriage return is not added. See also Seatbelt2D.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Seatbelt2D.Last = function() {
    /// <signature>
    /// <summary>Returns the last seatbelt in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last seatbelt in</param>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free seatbelt label in the model. Also see Seatbelt2D.FirstFreeLabel(), Seatbelt2D.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free seatbelt label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt2D.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next seatbelt in the model.</summary>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) seatbelt label in the model. Also see Seatbelt2D.FirstFreeLabel(), Seatbelt2D.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free seatbelt label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt2D.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a seatbelt.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only seatbelts from that model can be picked. If the argument is a Flag then only seatbelts that are flagged with limit can be selected. If omitted, or null, any seatbelts from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous seatbelt in the model.</summary>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select seatbelts using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting seatbelts</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only seatbelts from that model can be selected. If the argument is a Flag then only seatbelts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any seatbelts can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt2D.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the seatbelt.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the seatbelt</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the seatbelt. The seatbelt will be sketched until you either call Seatbelt2D.Unsketch(), Seatbelt2D.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelt is sketched. If omitted redraw is true. If you want to sketch several seatbelts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged seatbelts in the model. The seatbelts will be sketched until you either call Seatbelt2D.Unsketch(), Seatbelt2D.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged seatbelts will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelts are sketched. If omitted redraw is true. If you want to sketch flagged seatbelts several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing seatbelts should be counted. If false or omitted referenced but undefined seatbelts will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Seatbelt2D.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the seatbelt</summary>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged seatbelts will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all seatbelts will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the seatbelts</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the seatbelt.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelt is unsketched. If omitted redraw is true. If you want to unsketch several seatbelts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all seatbelts.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged seatbelts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all seatbelts will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the seatbelts that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the seatbelts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Seatbelt2D"/>
    /// </signature>
}

Seatbelt2D.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for seatbelt. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Seatbelt2D.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this seatbelt.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Seatbelt2D.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the seatbelt data in keyword format. Note that this contains the keyword header and the keyword cards. See also Seatbelt2D.Keyword() and Seatbelt2D.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Section = function() {
    /// <signature>
    /// <summary>Create a new Section object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that section will be created in</param>
    /// <param name="secid" type="Number" optional="false">Section number or character label</param>
    /// <param name="type" type="Number" optional="false">Section type. Can be Section.BEAM, Section.DISCRETE, Section.POINT_SOURCE, Section.SEATBELT, Section.SHELL, Section.SOLID, Section.SPH or Section.TSHELL</param>
    /// <param name="title" type="String" optional="true">Title for the section</param>
    /// <returns type="Section"/>
    /// </signature>
    /// <field name='a' static='false' type='Number'>Cross sectional area</field>
    /// <field name='aafac' static='false' type='Number'>ALE advection factor(SHELL, SOLID)</field>
    /// <field name='aet' static='false' type='Number'>Ambient element type (ALE1D, ALE2D, SOLID)</field>
    /// <field name='afac' static='false' type='Number'>Smoothing weight factor - Simple average (SHELL, SOLID)</field>
    /// <field name='aisc' static='false' type='Boolean'>If _AISC option is set. Can be true or false</field>
    /// <field name='aisc_label' static='false' type='String'>AISC section label</field>
    /// <field name='ale' static='false' type='Boolean'>If _ALE option is set. Can be true or false (SHELL, SOLID)</field>
    /// <field name='aleform' static='false' type='Number'>ALE formulation (ALE1D, ALE2D)</field>
    /// <field name='area' static='false' type='Number'>Optional cross sectional area used in contact</field>
    /// <field name='baselm' static='false' type='Number'>Base element type for XFEM (SHELL)</field>
    /// <field name='bfac' static='false' type='Number'>Smoothing weight factor - Volume weighting (SHELL, SOLID)</field>
    /// <field name='ca' static='false' type='Number'>Cable area</field>
    /// <field name='cdl' static='false' type='Number'>Deflection limit in compression</field>
    /// <field name='cfac' static='false' type='Number'>Smoothing weight factor - Isoparametric (SHELL, SOLID)</field>
    /// <field name='cid' static='false' type='Number'>Coordinate system ID for orientation</field>
    /// <field name='cl' static='false' type='Number'>Clearance</field>
    /// <field name='cmid' static='false' type='Number'>Cohesive material (SHELL, SOLID)</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the section</field>
    /// <field name='cslh' static='false' type='Number'>Smoothing length constant</field>
    /// <field name='cst' static='false' type='Number'>Cross section type</field>
    /// <field name='d1' static='false' type='Number'>Input parameter 1 for section type</field>
    /// <field name='d2' static='false' type='Number'>Input parameter 2 for section type</field>
    /// <field name='d3' static='false' type='Number'>Input parameter 3 for section type</field>
    /// <field name='d4' static='false' type='Number'>Input parameter 4 for section type</field>
    /// <field name='d5' static='false' type='Number'>Input parameter 5 for section type</field>
    /// <field name='d6' static='false' type='Number'>Input parameter 6 for section type</field>
    /// <field name='death' static='false' type='Number'>Time imposed SPH approximation is stopped</field>
    /// <field name='dfac' static='false' type='Number'>Smoothing weight factor - Equipotential (SHELL, SOLID)</field>
    /// <field name='dofn1' static='false' type='Number'>Active degree of freedom at node 1</field>
    /// <field name='dofn2' static='false' type='Number'>Active degree of freedom at node 2</field>
    /// <field name='domint' static='false' type='Number'>Domain integration in XFEM (SHELL)</field>
    /// <field name='dro' static='false' type='Number'>Displacement/rotation option</field>
    /// <field name='ds' static='false' type='Number'>Displacement jump</field>
    /// <field name='dx' static='false' type='Number'>Normalized dilation parameter of kernel function in X (SHELL, SOLID)</field>
    /// <field name='dy' static='false' type='Number'>Normalized dilation parameter of kernel function in Y (SHELL, SOLID)</field>
    /// <field name='dz' static='false' type='Number'>Normalized dilation parameter of kernel function in Z (SOLID)</field>
    /// <field name='ecut' static='false' type='Number'>Minimum distance to the node that a crack surface can cut to the edge</field>
    /// <field name='edgset' static='false' type='Number'>Edge node set</field>
    /// <field name='efac' static='false' type='Number'>Smoothing weight factor - Equilibrium (SHELL)</field>
    /// <field name='efg' static='false' type='Boolean'>If _EFG option is set. Can be true or false (SHELL, SOLID)</field>
    /// <field name='elform' static='false' type='Number'>Element formulation (ALE1D, ALE2D, BEAM, SHELL, SOLID, TSHELL)</field>
    /// <field name='ellipse' static='false' type='Boolean'>If _ELLIPSE option is set (was _TENSOR pre R8). Can be true or false</field>
    /// <field name='end' static='false' type='Number'>End time for smoothing (SHELL, SOLID)</field>
    /// <field name='exists' static='false' type='Boolean'>true if section exists, false if referred to but not defined. (read only)</field>
    /// <field name='failcr' static='false' type='Number'>Different failure criteria (SHELL)</field>
    /// <field name='fd' static='false' type='Number'>Failure deflection</field>
    /// <field name='fs' static='false' type='Number'>SPG Failure strain if IDAM = 1 (SOLID)</field>
    /// <field name='hmax' static='false' type='Number'>Max smoothing length scale factor</field>
    /// <field name='hmin' static='false' type='Number'>Min smoothing length scale factor</field>
    /// <field name='hxcslh' static='false' type='Number'>Constant for smoothing length in X for tensor/ellipse case</field>
    /// <field name='hxini' static='false' type='Number'>Initial smoothing length in X for tensor/ellipse case</field>
    /// <field name='hycslh' static='false' type='Number'>Constant for smoothing length in Y for tensor/ellipse case</field>
    /// <field name='hyini' static='false' type='Number'>Initial smoothing length in Y for tensor/ellipse case</field>
    /// <field name='hzcslh' static='false' type='Number'>Constant for smoothing length in Z for tensor/ellipse case</field>
    /// <field name='hzini' static='false' type='Number'>Initial smoothing length in Z for tensor/ellipse case</field>
    /// <field name='ibr' static='false' type='Number'>Branching</field>
    /// <field name='icomp' static='false' type='Number'>Composite flag (SHELL, TSHELL)</field>
    /// <field name='idam' static='false' type='Number'>SPG Option of damage mechanism (SOLID)</field>
    /// <field name='idila' static='false' type='Number'>Normalized dilation parameter definition (SOLID)</field>
    /// <field name='idim' static='false' type='Number'>Domain integration method (SOLID)</field>
    /// <field name='idof' static='false' type='Number'>Thickness field value</field>
    /// <field name='iebt' static='false' type='Number'>Essential boundary condition treatment (SOLID)</field>
    /// <field name='iform' static='false' type='Number'>SPH element formulation</field>
    /// <field name='ihgf' static='false' type='Number'>Flag for using hourglass stabilization (SHELL, SOLID)</field>
    /// <field name='iken' static='false' type='Number'>approximation</field>
    /// <field name='iloc' static='false' type='Number'>Coordinate system option (SHELL)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the section is in.</field>
    /// <field name='iner' static='false' type='Number'>Mass moment of inertia</field>
    /// <field name='interaction' static='false' type='Boolean'>If _INTERACTION option is set. Can be true or false</field>
    /// <field name='iovpr' static='false' type='Number'>Print flag for the elbow ovalization degrees of freedom (elform 14)</field>
    /// <field name='iprstr' static='false' type='Number'>Flag for adding stress due to pressure into the material routine (elform 14)</field>
    /// <field name='ips' static='false' type='Number'>Pressure smoothing/recovery</field>
    /// <field name='irr' static='false' type='Number'>Irr</field>
    /// <field name='ispline' static='false' type='Number'>EFG kernel function definition (SHELL, SOLID)</field>
    /// <field name='iss' static='false' type='Number'>Iss</field>
    /// <field name='ist' static='false' type='Number'>Ist</field>
    /// <field name='itaj' static='false' type='Number'>Flag for setting up finite element matrices (SHELL, SOLID)</field>
    /// <field name='itb' static='false' type='Number'>SPG Stabilization flag (SOLID)</field>
    /// <field name='ithelfm' static='false' type='Number'>THERMAL shell formulation (SHELL)</field>
    /// <field name='itoff' static='false' type='Number'>Option to specify torsional behaviour for spotwelds</field>
    /// <field name='itorm' static='false' type='Number'>Itorm</field>
    /// <field name='itt' static='false' type='Number'>Itt</field>
    /// <field name='iunf' static='false' type='Number'>Flag for using nodal fibre vectors (SHELL)</field>
    /// <field name='iw' static='false' type='Number'>Warping constant</field>
    /// <field name='iwr' static='false' type='Number'>Warping constant</field>
    /// <field name='iyr' static='false' type='Number'>IYR integral</field>
    /// <field name='izr' static='false' type='Number'>IZR integral</field>
    /// <field name='j' static='false' type='Number'>torsional constant</field>
    /// <field name='kd' static='false' type='Number'>Dynamic magnification factor</field>
    /// <field name='kernel' static='false' type='Number'>SPG kernel type approximation (SOLID)</field>
    /// <field name='label' static='false' type='Number'>Section ID (all types). Also see the secid property which is an alternative name for this.</field>
    /// <field name='lcidt' static='false' type='Number'>Temperature loadcurve ID</field>
    /// <field name='lcidvel' static='false' type='Number'>Inlet flow velocity loadcurve ID</field>
    /// <field name='lcidvolr' static='false' type='Number'>Relative volume loadcurve ID</field>
    /// <field name='lcmdot1' static='false' type='Number'>Mass flowrate loadcurve for gas 1</field>
    /// <field name='lcmdot2' static='false' type='Number'>Mass flowrate loadcurve for gas 2</field>
    /// <field name='lcmdot3' static='false' type='Number'>Mass flowrate loadcurve for gas 3</field>
    /// <field name='lcmdot4' static='false' type='Number'>Mass flowrate loadcurve for gas 4</field>
    /// <field name='lcmdot5' static='false' type='Number'>Mass flowrate loadcurve for gas 5</field>
    /// <field name='lcmdot6' static='false' type='Number'>Mass flowrate loadcurve for gas 6</field>
    /// <field name='lcmdot7' static='false' type='Number'>Mass flowrate loadcurve for gas 7</field>
    /// <field name='lcmdot8' static='false' type='Number'>Mass flowrate loadcurve for gas 8</field>
    /// <field name='lmc' static='false' type='Number'>Number of property parameters (SHELL, SOLID)</field>
    /// <field name='lprint' static='false' type='Number'>Debug printout option (SHELL)</field>
    /// <field name='lscale' static='false' type='Number'>SPG length scale for displacement regularisation (SOLID)</field>
    /// <field name='marea' static='false' type='Number'>Non structural mass per unit area</field>
    /// <field name='mixture' static='false' type='Boolean'>If _MIXTURE option is set. Can be true or false</field>
    /// <field name='model' static='false' type='Number'>The Model number that the section is in.</field>
    /// <field name='nhsv' static='false' type='Number'>Number of history variables (SHELL, SOLID)</field>
    /// <field name='nidlc001' static='false' type='Number'>1st node ID defining a local coordinate</field>
    /// <field name='nidlc002' static='false' type='Number'>2nd node ID defining a local coordinate</field>
    /// <field name='nidlc003' static='false' type='Number'>3rd node ID defining a local coordinate</field>
    /// <field name='nip' static='false' type='Number'>Number of integration points (SHELL, SOLID, TSHELL)</field>
    /// <field name='nipp' static='false' type='Number'>Number of in-plane integration points (SHELL)</field>
    /// <field name='nloc' static='false' type='Number'>Location of reference surface</field>
    /// <field name='nsloc' static='false' type='Number'>Location of s reference surface</field>
    /// <field name='nsm' static='false' type='Number'>Non structural mass per unit length</field>
    /// <field name='ntloc' static='false' type='Number'>Location of t reference surface</field>
    /// <field name='nxdof' static='false' type='Number'>Number of extra degrees of freedom per node (SHELL, SOLID)</field>
    /// <field name='offset' static='false' type='Number'>Offset for cable</field>
    /// <field name='points' static='false' type='Number'>Number of point sources</field>
    /// <field name='pr' static='false' type='Number'>Pressure inside elements (elform 14)</field>
    /// <field name='print' static='false' type='Number'>Output spot force resultants from spotwelds</field>
    /// <field name='propcr' static='false' type='Number'>Not used (SHELL)</field>
    /// <field name='propt' static='false' type='Number'>Printout option (SHELL, TSHELL)</field>
    /// <field name='qr' static='false' type='Number'>Quadrature rule (BEAM, SHELL, TSHELL)</field>
    /// <field name='rampt' static='false' type='Number'>Ramp up time for dynamic relaxation</field>
    /// <field name='rrcon' static='false' type='Number'>r rotational constraint</field>
    /// <field name='sa' static='false' type='Number'>Shear area</field>
    /// <field name='scoor' static='false' type='Number'>Location of triad for discrete beam</field>
    /// <field name='secid' static='false' type='Number'>Section ID (all types). Also see the label property which is an alternative name for this.</field>
    /// <field name='setyp' static='false' type='Number'>2D solid element type</field>
    /// <field name='sf' static='false' type='Number'>Failure strain</field>
    /// <field name='shrf' static='false' type='Number'>Shear correction factor (BEAM, SHELL, TSHELL)</field>
    /// <field name='smstep' static='false' type='Number'>SPG Interval of timestep to conduction displ regularisation (SOLID)</field>
    /// <field name='sphini' static='false' type='Number'>Optional initial smoothing length</field>
    /// <field name='srcon' static='false' type='Number'>s rotational constraint</field>
    /// <field name='start' static='false' type='Number'>Time imposed SPH approximation is activated (SPH) orStart time for smoothing (SHELL, SOLID)</field>
    /// <field name='stime' static='false' type='Number'>Time to switch from stabilized EFG to standard EFG formulation</field>
    /// <field name='stress' static='false' type='Number'>Initial stress for dynamic relaxation</field>
    /// <field name='stretch' static='false' type='Number'>SPG stretching parameter if IDAM = 1 (SOLID)</field>
    /// <field name='stype' static='false' type='String'>Section type</field>
    /// <field name='swtime' static='false' type='Number'>SPG Time to switch from updated Lagrangian to Eulerian kernel (SOLID)</field>
    /// <field name='t1' static='false' type='Number'>Thickness at Node 1</field>
    /// <field name='t2' static='false' type='Number'>Thickness at Node 2</field>
    /// <field name='t3' static='false' type='Number'>Thickness at Node 3</field>
    /// <field name='t4' static='false' type='Number'>Thickness at Node 4</field>
    /// <field name='tdl' static='false' type='Number'>Deflection limit in tension</field>
    /// <field name='tensor' static='false' type='Boolean'>If _TENSOR option is set (_ELLIPSE from R8 onwards). Can be true or false</field>
    /// <field name='thermal' static='false' type='Boolean'>If _THERMAL option is set. Can be true or false (SHELL)</field>
    /// <field name='thick' static='false' type='Number'>Thickness (ALE1D, SEATBELT)</field>
    /// <field name='title' static='false' type='String'>Section title (all types)</field>
    /// <field name='toldef' static='false' type='Number'>Deformation tolerance (SOLID)</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the section (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='trcon' static='false' type='Number'>t rotational constraint</field>
    /// <field name='ts1' static='false' type='Number'>s thickness or outer diameter at N1</field>
    /// <field name='ts2' static='false' type='Number'>s thickness or outer diameter at N2</field>
    /// <field name='tshear' static='false' type='Number'>Flag for transverse shear strain or stress distribution</field>
    /// <field name='tt1' static='false' type='Number'>t thickness or inner diameter at N1</field>
    /// <field name='tt2' static='false' type='Number'>t thickness or inner diameter at N2</field>
    /// <field name='type' static='false' type='Number'>Section type. Can be Section.ALE1D, Section.ALE2D, Section.BEAM, Section.DISCRETE, Section.POINT_SOURCE, Section.SEATBELT, Section.SHELL, Section.SOLID, Section.SPH or Section.TSHELL</field>
    /// <field name='user' static='false' type='Boolean'>If _USER option is set. Can be true or false</field>
    /// <field name='v0' static='false' type='Number'>Test velocity</field>
    /// <field name='vol' static='false' type='Number'>Volume of discrete beam</field>
    /// <field name='xfem' static='false' type='Boolean'>If _THERMAL option is set. Can be true or false (SHELL)</field>
    /// <field name='ys' static='false' type='Number'>s coordinate of shear centre of cross section</field>
    /// <field name='zs' static='false' type='Number'>t coordinate of shear centre of cross section</field>
    /// <field name='ALE1D' static='true' type='Number'>Section ale1d type</field>
    /// <field name='ALE2D' static='true' type='Number'>Section ale2d type</field>
    /// <field name='BEAM' static='true' type='Number'>Section beam type</field>
    /// <field name='DISCRETE' static='true' type='Number'>Section discrete type</field>
    /// <field name='POINT_SOURCE' static='true' type='Number'>Section point source type</field>
    /// <field name='SEATBELT' static='true' type='Number'>Section seatbelt type</field>
    /// <field name='SHELL' static='true' type='Number'>Section shell type</field>
    /// <field name='SOLID' static='true' type='Number'>Section solid type</field>
    /// <field name='SPH' static='true' type='Number'>Section sph type</field>
    /// <field name='TSHELL' static='true' type='Number'>Section thick shell type</field>
}

Section.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the section</summary>
    /// <returns type="null"/>
    /// </signature>
}

Section.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sections will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sections will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sections that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the section is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Section.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the section.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the section</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the section.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Section"/>
    /// </signature>
}

Section.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a section.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the sect will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Section"/>
    /// </signature>
}

Section.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for section. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for section. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the section colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the section.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Section.First = function() {
    /// <signature>
    /// <summary>Returns the first section in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first section in</param>
    /// <returns type="Section"/>
    /// </signature>
}

Section.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free section label in the model. Also see Section.LastFreeLabel(), Section.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free section label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Section.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the sections in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sections will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the sections</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the section is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the section</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Section.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each section in the model. Note that ForEach has been designed to make looping over sections as fast as possible and so has some limitations. Firstly, a single temporary Section object is created and on each function call it is updated with the current section data. This means that you should not try to store the Section object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new sections inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all sections are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each section</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Section objects for all of the sections in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sections from</param>
    /// <returns type="Array" elementType="Section"/>
    /// </signature>
}

Section.prototype.GetBetaData = function() {
    /// <signature>
    /// <summary>Returns the beta angle data for an integration point in *SECTION_SHELL or *SECTION_TSHELL.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want the data for. Note that integration points start at 0, not 1.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Section.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Section objects for all of the flagged sections in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sections from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sections that you want to retrieve</param>
    /// <returns type="Array" elementType="Section"/>
    /// </signature>
}

Section.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Section object for a section ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the section in</param>
    /// <param name="number" type="Number" optional="false">number of the section you want the Section object for</param>
    /// <returns type="Section"/>
    /// </signature>
}

Section.prototype.GetLmcData = function() {
    /// <signature>
    /// <summary>Returns the LMC property parameter for *SECTION_SHELL or *SECTION_SOLID.</summary>
    /// <param name="i" type="Number" optional="false">The point you want the parameter for. Note that points start at 0, not 1.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Section.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Section property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Section.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">section property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Section.prototype.GetPointData = function() {
    /// <signature>
    /// <summary>Returns the point data for a single point in *SECTION_POINT_SOURCE.</summary>
    /// <param name="ipt" type="Number" optional="false">The point you want the data for. Note that integration points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Section.prototype.GetUserData = function() {
    /// <signature>
    /// <summary>Returns the user defined data for an integration point in *SECTION_SHELL and *SECTION_SOLID.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want the data for. Note that integration points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Section.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this section (*SECT, *SECT_SCALAR or *SECT_SCALAR_VALUE). Note that a carriage return is not added. See also Section.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Section.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the section. Note that a carriage return is not added. See also Section.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Section.Last = function() {
    /// <signature>
    /// <summary>Returns the last section in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last section in</param>
    /// <returns type="Section"/>
    /// </signature>
}

Section.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free section label in the model. Also see Section.FirstFreeLabel(), Section.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free section label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Section.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next section in the model.</summary>
    /// <returns type="Section"/>
    /// </signature>
}

Section.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) section label in the model. Also see Section.FirstFreeLabel(), Section.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free section label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Section.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a section.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sections from that model can be picked. If the argument is a Flag then only sections that are flagged with limit can be selected. If omitted, or null, any sections from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Section"/>
    /// </signature>
}

Section.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous section in the model.</summary>
    /// <returns type="Section"/>
    /// </signature>
}

Section.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sections will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sections will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sections that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select sections using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting sections</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sections from that model can be selected. If the argument is a Flag then only sections that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sections can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Section.prototype.SetBetaData = function() {
    /// <signature>
    /// <summary>Sets the beta angle for an integration point in *SECTION_SHELL or *SECTION_TSHELL.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want to set the data for. Note that integration points start at 0, not 1.</param>
    /// <param name="beta" type="Number" optional="false">Beta angle for the integration point.</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the section.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the section</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.SetLmcData = function() {
    /// <signature>
    /// <summary>Sets the lmc parameter for a point in *SECTION_SHELL or *SECTION_SOLID.</summary>
    /// <param name="ipt" type="Number" optional="false">The point you want to set the data for. Note that points start at 0, not 1.</param>
    /// <param name="lmc" type="Number" optional="false">Lmc parameter for the point.</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.SetPointData = function() {
    /// <signature>
    /// <summary>Sets the data for a single point in *SECTION_POINT_SOURCE.</summary>
    /// <param name="ipt" type="Number" optional="false">The point you want to set the data for. Note that integration points start at 0, not 1.</param>
    /// <param name="nodeid" type="Number" optional="false">Node ID for the point.</param>
    /// <param name="vecid" type="Number" optional="false">Vector ID for the point.</param>
    /// <param name="area" type="Number" optional="false">Orifice area for the point.</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.SetUserData = function() {
    /// <signature>
    /// <summary>Sets the user defined data for an integration point in *SECTION_SHELL and *SECTION_SOLID.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want to set the data for. Note that integration points start at 0, not 1.</param>
    /// <param name="xi" type="Number" optional="false">First isoparametric coordinate.</param>
    /// <param name="eta" type="Number" optional="false">Second isoparametric coordinate.</param>
    /// <param name="zeta (SOLID) orwgt (SHELL)" type="Number" optional="false">Second isoparametric coordinate (SOLID) orIsoparametric weight (SHELL)</param>
    /// <param name="wgt (SOLID only)" type="Number" optional="false">Isoparametric weight (SOLID)</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the section. The section will be sketched until you either call Section.Unsketch(), Section.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the section is sketched. If omitted redraw is true. If you want to sketch several sections and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged sections in the model. The sections will be sketched until you either call Section.Unsketch(), Section.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sections will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sections that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sections are sketched. If omitted redraw is true. If you want to sketch flagged sections several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing sections should be counted. If false or omitted referenced but undefined sections will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Section.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the section</summary>
    /// <returns type="null"/>
    /// </signature>
}

Section.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sections will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged sections will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sections that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all sections will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the sections</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the section.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the section is unsketched. If omitted redraw is true. If you want to unsketch several sections and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all sections.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sections will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sections will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sections that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Section"/>
    /// </signature>
}

Section.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for section. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Section.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this section.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Section.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the section data in keyword format. Note that this contains the keyword header and the keyword cards. See also Section.Keyword() and Section.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Sensor = function() {
    /// <signature>
    /// <summary>Create a new Seatbelt Sensor object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that sensor will be created in</param>
    /// <param name="sbsid" type="Number" optional="false">Sensor number.</param>
    /// <param name="sbstyp" type="Number" optional="false">Sensor type</param>
    /// <param name="sbsfl" type="Number" optional="true">Sensor flag. Default 0.</param>
    /// <param name="nid" type="Number" optional="true">Optional node ID: Compulsory for types 1 and 4.</param>
    /// <param name="nid2" type="Number" optional="true">Optional node ID 2: Compulsory for type 4.</param>
    /// <returns type="Sensor"/>
    /// </signature>
    /// <field name='acc' static='false' type='Number'>Activating acceleration.</field>
    /// <field name='atime' static='false' type='Number'>Time over which acceleration must be exceeded.</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the sensor</field>
    /// <field name='dmn' static='false' type='Number'>Minimum distance</field>
    /// <field name='dmx' static='false' type='Number'>Maximum distance</field>
    /// <field name='dof' static='false' type='Number'>Degree of freedom.</field>
    /// <field name='exists' static='false' type='Boolean'>true if sensor exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the sensor is in.</field>
    /// <field name='label' static='false' type='Number'>Sensor number. Also see the sbacid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the sensor is in.</field>
    /// <field name='nid' static='false' type='Number'>Node number.</field>
    /// <field name='nid1' static='false' type='Number'>Node number 1</field>
    /// <field name='nid2' static='false' type='Number'>Node number 2</field>
    /// <field name='pulmn' static='false' type='Number'>Maximum pull-out</field>
    /// <field name='pulmx' static='false' type='Number'>Maximum pull-out</field>
    /// <field name='pulrat' static='false' type='Number'>Rate of pull-out (length/time units)</field>
    /// <field name='pultim' static='false' type='Number'>Time over which rate of pull#out must be exceeded</field>
    /// <field name='sbrid' static='false' type='Number'>Retractor number (for sbstyp = 2 OR 5).</field>
    /// <field name='sbsfl' static='false' type='Number'>Sensor flag.</field>
    /// <field name='sbsid' static='false' type='Number'>Sensor number. Also see the label property which is an alternative name for this.</field>
    /// <field name='sbstyp' static='false' type='Number'>Sensor type.</field>
    /// <field name='time' static='false' type='Number'>Time at which sensor triggers</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the sensor (0-100) 0% is opaque, 100% is transparent.</field>
}

Sensor.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the sensor</summary>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the sensors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sensors will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged sensors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sensors will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sensors that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the sensor is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Sensor.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the sensor.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the sensor</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the sensor.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Sensor"/>
    /// </signature>
}

Sensor.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a sensor.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the sensor will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Sensor"/>
    /// </signature>
}

Sensor.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for sensor. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for sensor. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the sensor colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the sensor.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Sensor.First = function() {
    /// <signature>
    /// <summary>Returns the first sensor in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first sensor in</param>
    /// <returns type="Sensor"/>
    /// </signature>
}

Sensor.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free sensor label in the model. Also see Sensor.LastFreeLabel(), Sensor.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free sensor label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sensor.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the sensors in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sensors will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the sensors</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the sensor is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the sensor</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Sensor.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each sensor in the model. Note that ForEach has been designed to make looping over sensors as fast as possible and so has some limitations. Firstly, a single temporary Sensor object is created and on each function call it is updated with the current sensor data. This means that you should not try to store the Sensor object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new sensors inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all sensors are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each sensor</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Sensor objects for all of the sensors in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sensors from</param>
    /// <returns type="Array" elementType="Sensor"/>
    /// </signature>
}

Sensor.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Sensor objects for all of the flagged sensors in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sensors from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sensors that you want to retrieve</param>
    /// <returns type="Array" elementType="Sensor"/>
    /// </signature>
}

Sensor.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Sensor object for a sensor ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the sensor in</param>
    /// <param name="number" type="Number" optional="false">number of the sensor you want the Sensor object for</param>
    /// <returns type="Sensor"/>
    /// </signature>
}

Sensor.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Sensor property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Sensor.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">sensor property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Sensor.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this sensor (*ELEMENT_SEATBELT_SENSEROMETER) Note that a carriage return is not added. See also Sensor.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Sensor.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the sensor. Note that a carriage return is not added. See also Sensor.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Sensor.Last = function() {
    /// <signature>
    /// <summary>Returns the last sensor in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last sensor in</param>
    /// <returns type="Sensor"/>
    /// </signature>
}

Sensor.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free sensor label in the model. Also see Sensor.FirstFreeLabel(), Sensor.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free sensor label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sensor.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next sensor in the model.</summary>
    /// <returns type="Sensor"/>
    /// </signature>
}

Sensor.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) sensor label in the model. Also see Sensor.FirstFreeLabel(), Sensor.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free sensor label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sensor.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a sensor.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sensors from that model can be picked. If the argument is a Flag then only sensors that are flagged with limit can be selected. If omitted, or null, any sensors from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Sensor"/>
    /// </signature>
}

Sensor.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous sensor in the model.</summary>
    /// <returns type="Sensor"/>
    /// </signature>
}

Sensor.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the sensors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sensors will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged sensors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sensors will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sensors that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select sensors using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting sensors</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sensors from that model can be selected. If the argument is a Flag then only sensors that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sensors can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sensor.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the sensor.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the sensor</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the sensor. The sensor will be sketched until you either call Sensor.Unsketch(), Sensor.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sensor is sketched. If omitted redraw is true. If you want to sketch several sensors and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged sensors in the model. The sensors will be sketched until you either call Sensor.Unsketch(), Sensor.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sensors will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sensors that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sensors are sketched. If omitted redraw is true. If you want to sketch flagged sensors several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of sensors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing sensors should be counted. If false or omitted referenced but undefined sensors will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sensor.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the sensor</summary>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the sensors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sensors will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged sensors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged sensors will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sensors that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the sensors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all sensors will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the sensors</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the sensor.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sensor is unsketched. If omitted redraw is true. If you want to unsketch several sensors and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all sensors.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sensors will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sensors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged sensors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sensors will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sensors that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sensors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Sensor"/>
    /// </signature>
}

Sensor.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for sensor. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Sensor.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this sensor.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Sensor.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the sensor data in keyword format. Note that this contains the keyword header and the keyword cards. See also Sensor.Keyword() and Sensor.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var SensorControl = function() {
    /// <signature>
    /// <summary>Create a new SensorControl object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that *SENSOR_CONTROL will be created in</param>
    /// <param name="Sensor control ID" type="Number" optional="false">SensorControl id.</param>
    /// <param name="Type" type="String" optional="false">Entity type to be controlled. Can be "AIRBAG", "BAGVENTPOP", "BELTPRET", "BELTRETRA", "BELTSLIP", "CONTACT", "CONTACT2D", "DEF2RIG", "DISC-ELE", "DISC-ELES", "ELESET", "FUNCTION", "JOINT", "JOINTSTIFF", "M PRESSURE", "RWALL", "SPC", "SPOTWELD".</param>
    /// <param name="Type ID" type="Number" optional="true">ID of entity to be controlled if type is not FUNCTION or input value for FUNCTION.</param>
    /// <param name="estyp" type="String" optional="true">Element Set Type to be controlled. Can be "BEAM", "DISC", "SHELL", "SOLID", "TSHELL". Required only if Type argument is "ELESET".</param>
    /// <returns type="SensorControl"/>
    /// </signature>
    /// <field name='cntlid' static='false' type='Number'>SensorControl number. The label property is an alternative name for this.</field>
    /// <field name='estyp' static='false' type='String'>Element Set Type to be controlled. Can be "BEAM", "DISC", "SHELL", "SOLID", "TSHELL".</field>
    /// <field name='exists' static='false' type='Boolean'>true if *SENSOR_CONTROL exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the *SENSOR_CONTROL is in.</field>
    /// <field name='initstt' static='false' type='String'>Initial status. Can be "On" or "Off".</field>
    /// <field name='label' static='false' type='Number'>SensorControl number. The cntlid property is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the *SENSOR_CONTROL is in.</field>
    /// <field name='nrep' static='false' type='Number'>Number of repeat of cycle of switches.</field>
    /// <field name='swit1' static='false' type='Number'>ID of 1st switch.</field>
    /// <field name='swit2' static='false' type='Number'>ID of 2nd switch.</field>
    /// <field name='swit3' static='false' type='Number'>ID of 3rd switch.</field>
    /// <field name='swit4' static='false' type='Number'>ID of 4th switch.</field>
    /// <field name='swit5' static='false' type='Number'>ID of 5th switch.</field>
    /// <field name='swit6' static='false' type='Number'>ID of 6th switch.</field>
    /// <field name='swit7' static='false' type='Number'>ID of 7th switch.</field>
    /// <field name='timeoff' static='false' type='Number'>Flag for offset of time in curve.</field>
    /// <field name='type' static='false' type='String'>Entity to be controlled. Can be "AIRBAG", "BAGVENTPOP", "BELTPRET", "BELTRETRA", "BELTSLIP", "CONTACT", "CONTACT2D", "DEF2RIG", "DISC-ELE", "DISC-ELES", "ELESET", "FUNCTION", "JOINT", "JOINTSTIFF", "LOADTHM", "M PRESSURE", "RWALL", "SPC", "SPOTWELD".</field>
    /// <field name='typeid' static='false' type='Number'>ID of entity to be controlled if type is not FUNCTION or input value for FUNCTION.</field>
}

SensorControl.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the *SENSOR_CONTROL.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the *SENSOR_CONTROL</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the *SENSOR_CONTROL.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="SensorControl"/>
    /// </signature>
}

SensorControl.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a *SENSOR_CONTROL.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the *SENSOR_CONTROL will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="SensorControl"/>
    /// </signature>
}

SensorControl.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for *SENSOR_CONTROL. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.First = function() {
    /// <signature>
    /// <summary>Returns the first *SENSOR_CONTROL in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first *SENSOR_CONTROL in</param>
    /// <returns type="SensorControl"/>
    /// </signature>
}

SensorControl.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free *SENSOR_CONTROL label in the model. Also see SensorControl.LastFreeLabel(), SensorControl.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free *SENSOR_CONTROL label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorControl.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the *SENSOR_CONTROLs in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *SENSOR_CONTROLs will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the *SENSOR_CONTROLs</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the *SENSOR_CONTROL is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the *SENSOR_CONTROL</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

SensorControl.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each *SENSOR_CONTROL in the model. Note that ForEach has been designed to make looping over *SENSOR_CONTROLs as fast as possible and so has some limitations. Firstly, a single temporary SensorControl object is created and on each function call it is updated with the current *SENSOR_CONTROL data. This means that you should not try to store the SensorControl object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new *SENSOR_CONTROLs inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all *SENSOR_CONTROLs are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each *SENSOR_CONTROL</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of SensorControl objects for all of the *SENSOR_CONTROLs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get *SENSOR_CONTROLs from</param>
    /// <returns type="Array" elementType="SensorControl"/>
    /// </signature>
}

SensorControl.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of SensorControl objects for all of the flagged *SENSOR_CONTROLs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get *SENSOR_CONTROLs from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *SENSOR_CONTROLs that you want to retrieve</param>
    /// <returns type="Array" elementType="SensorControl"/>
    /// </signature>
}

SensorControl.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the SensorControl object for a *SENSOR_CONTROL ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the *SENSOR_CONTROL in</param>
    /// <param name="number" type="Number" optional="false">number of the *SENSOR_CONTROL you want the SensorControl object for</param>
    /// <returns type="SensorControl"/>
    /// </signature>
}

SensorControl.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a SensorControl property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the SensorControl.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">*SENSOR_CONTROL property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

SensorControl.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this *SENSOR_CONTROL. Note that a carriage return is not added. See also SensorControl.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

SensorControl.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the *SENSOR_CONTROL. Note that a carriage return is not added. See also SensorControl.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

SensorControl.Last = function() {
    /// <signature>
    /// <summary>Returns the last *SENSOR_CONTROL in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last *SENSOR_CONTROL in</param>
    /// <returns type="SensorControl"/>
    /// </signature>
}

SensorControl.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free *SENSOR_CONTROL label in the model. Also see SensorControl.FirstFreeLabel(), SensorControl.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free *SENSOR_CONTROL label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorControl.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next *SENSOR_CONTROL in the model.</summary>
    /// <returns type="SensorControl"/>
    /// </signature>
}

SensorControl.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) *SENSOR_CONTROL label in the model. Also see SensorControl.FirstFreeLabel(), SensorControl.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free *SENSOR_CONTROL label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorControl.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous *SENSOR_CONTROL in the model.</summary>
    /// <returns type="SensorControl"/>
    /// </signature>
}

SensorControl.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the *SENSOR_CONTROLs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *SENSOR_CONTROLs will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged *SENSOR_CONTROLs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged *SENSOR_CONTROLs will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *SENSOR_CONTROLs that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select *SENSOR_CONTROLs using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting *SENSOR_CONTROLs</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only *SENSOR_CONTROLs from that model can be selected. If the argument is a Flag then only *SENSOR_CONTROLs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any *SENSOR_CONTROLs can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorControl.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the *SENSOR_CONTROL.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the *SENSOR_CONTROL</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the *SENSOR_CONTROL. The *SENSOR_CONTROL will be sketched until you either call SensorControl.Unsketch(), SensorControl.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the *SENSOR_CONTROL is sketched. If omitted redraw is true. If you want to sketch several *SENSOR_CONTROLs and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged *SENSOR_CONTROLs in the model. The *SENSOR_CONTROLs will be sketched until you either call SensorControl.Unsketch(), SensorControl.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged *SENSOR_CONTROLs will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *SENSOR_CONTROLs that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the *SENSOR_CONTROLs are sketched. If omitted redraw is true. If you want to sketch flagged *SENSOR_CONTROLs several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of *SENSOR_CONTROLs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing *SENSOR_CONTROLs should be counted. If false or omitted referenced but undefined *SENSOR_CONTROLs will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorControl.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the *SENSOR_CONTROLs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all *SENSOR_CONTROLs will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the *SENSOR_CONTROLs</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the *SENSOR_CONTROL.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the *SENSOR_CONTROL is unsketched. If omitted redraw is true. If you want to unsketch several *SENSOR_CONTROLs and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all *SENSOR_CONTROLs.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *SENSOR_CONTROLs will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the *SENSOR_CONTROLs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged *SENSOR_CONTROLs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *SENSOR_CONTROLs will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *SENSOR_CONTROLs that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the *SENSOR_CONTROLs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="SensorControl"/>
    /// </signature>
}

SensorControl.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for *SENSOR_CONTROL. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorControl.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this *SENSOR_CONTROL.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

SensorControl.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the sensor control data in keyword format. Note that this contains the keyword header and the keyword cards. See also SensorControl.Keyword() and SensorControl.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var SensorSwitch = function() {
    /// <signature>
    /// <summary>Create a new SensorSwitch object.</summary>
    /// <param name="Option" type="Number" optional="false">SENSOR_SWITCH suffix. Can be SensorSwitch.SWITCH, SensorSwitch.SWITCH_CALC_LOGIC or SensorSwitch.SWITCH_SHELL_TO_VENT.</param>
    /// <param name="Model" type="Model" optional="false">Model that *SENSOR_SWITCH will be created in</param>
    /// <param name="Switch ID" type="Number" optional="false">SensorSwitch id. This is required for the SensorSwitch.SWITCH and SensorSwitch.SWITCH_CALC_LOGIC options and ignored for SensorSwitch.SWITCH_SHELL_TO_VENT.</param>
    /// <returns type="SensorSwitch"/>
    /// </signature>
    /// <field name='c23' static='false' type='Number'>Vent coefficient if positive or user defined load curve ID if negative.</field>
    /// <field name='exists' static='false' type='Boolean'>true if *SENSOR_SWITCH exists, false if referred to but not defined. (read only)</field>
    /// <field name='filtrid' static='false' type='Number'>Filter ID.</field>
    /// <field name='id' static='false' type='Number'>Part set ID or Part ID.</field>
    /// <field name='id_flag' static='false' type='Boolean'>Turns _TITLE/_ID ON or OFF. Used only for SensorSwitch.SWITCH_SHELL_TO_VENT.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the *SENSOR_SWITCH is in.</field>
    /// <field name='itype' static='false' type='Number'>0 for Part, 1 for Part Set.</field>
    /// <field name='label' static='false' type='Number'>SensorSwitch number. The switid property is an alternative name for this.</field>
    /// <field name='logic' static='false' type='String'>Logic operator.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the *SENSOR_SWITCH is in.</field>
    /// <field name='nrow' static='false' type='Number'>Number of Shell Fail Time Cards.</field>
    /// <field name='option' static='false' type='Number'>SENSOR_SWITCH suffix. Can be SensorSwitch.SWITCH, SensorSwitch.SWITCH_CALC_LOGIC or SensorSwitch.SWITCH_SHELL_TO_VENT.</field>
    /// <field name='sensid' static='false' type='Number'>ID of the sensor whose value will be compared.</field>
    /// <field name='swit1' static='false' type='Number'>Positive sensor switch ID for "AND", negative ID for "OR".</field>
    /// <field name='swit2' static='false' type='Number'>Positive sensor switch ID for "AND", negative ID for "OR".</field>
    /// <field name='swit3' static='false' type='Number'>Positive sensor switch ID for "AND", negative ID for "OR".</field>
    /// <field name='swit4' static='false' type='Number'>Positive sensor switch ID for "AND", negative ID for "OR".</field>
    /// <field name='swit5' static='false' type='Number'>Positive sensor switch ID for "AND", negative ID for "OR".</field>
    /// <field name='swit6' static='false' type='Number'>Positive sensor switch ID for "AND", negative ID for "OR".</field>
    /// <field name='swit7' static='false' type='Number'>Positive sensor switch ID for "AND", negative ID for "OR".</field>
    /// <field name='switid' static='false' type='Number'>SensorSwitch number. The label property is an alternative name for this.</field>
    /// <field name='timwin' static='false' type='Number'>Trigger status change when the value given by the sensor is less/greater (depending on logic) than value for duration defined by timwin.</field>
    /// <field name='title' static='false' type='String'>SensorSwitch title. Used only for SensorSwitch.SWITCH_SHELL_TO_VENT.</field>
    /// <field name='type' static='false' type='String'>Type used for sensor. Can either be "SENSOR" or "TIME"</field>
    /// <field name='value' static='false' type='Number'>Critical value.</field>
    /// <field name='SWITCH' static='true' type='Number'>Sensor switch is *SENSOR_SWITCH.</field>
    /// <field name='SWITCH_CALC_LOGIC' static='true' type='Number'>Sensor switch is *SENSOR_SWITCH_CALC-LOGIC.</field>
    /// <field name='SWITCH_SHELL_TO_VENT' static='true' type='Number'>Sensor switch is *SENSOR_SWITCH_SHELL_TO_VENT.</field>
}

SensorSwitch.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the *SENSOR_SWITCH.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the *SENSOR_SWITCH</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the *SENSOR_SWITCH.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a *SENSOR_SWITCH.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the *SENSOR_SWITCH will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for *SENSOR_SWITCH. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.First = function() {
    /// <signature>
    /// <summary>Returns the first *SENSOR_SWITCH in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first *SENSOR_SWITCH in</param>
    /// <returns type="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free *SENSOR_SWITCH label in the model. Also see SensorSwitch.LastFreeLabel(), SensorSwitch.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free *SENSOR_SWITCH label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorSwitch.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the *SENSOR_SWITCHs in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *SENSOR_SWITCHs will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the *SENSOR_SWITCHs</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the *SENSOR_SWITCH is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the *SENSOR_SWITCH</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

SensorSwitch.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each *SENSOR_SWITCH in the model. Note that ForEach has been designed to make looping over *SENSOR_SWITCHs as fast as possible and so has some limitations. Firstly, a single temporary SensorSwitch object is created and on each function call it is updated with the current *SENSOR_SWITCH data. This means that you should not try to store the SensorSwitch object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new *SENSOR_SWITCHs inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all *SENSOR_SWITCHs are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each *SENSOR_SWITCH</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of SensorSwitch objects for all of the *SENSOR_SWITCHs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get *SENSOR_SWITCHs from</param>
    /// <returns type="Array" elementType="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of SensorSwitch objects for all of the flagged *SENSOR_SWITCHs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get *SENSOR_SWITCHs from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *SENSOR_SWITCHs that you want to retrieve</param>
    /// <returns type="Array" elementType="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the SensorSwitch object for a *SENSOR_SWITCH ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the *SENSOR_SWITCH in</param>
    /// <param name="number" type="Number" optional="false">number of the *SENSOR_SWITCH you want the SensorSwitch object for</param>
    /// <returns type="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a SensorSwitch property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the SensorSwitch.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">*SENSOR_SWITCH property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

SensorSwitch.prototype.GetRow = function() {
    /// <signature>
    /// <summary>Returns the data for a row in the SENSOR_SWITCH_SHELL_TO_VENT.</summary>
    /// <param name="row" type="Number" optional="false">The row you want the data for. Note row indices start at 0.</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

SensorSwitch.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this *SENSOR_SWITCH. Note that a carriage return is not added. See also SensorSwitch.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

SensorSwitch.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the *SENSOR_SWITCH. Note that a carriage return is not added. See also SensorSwitch.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

SensorSwitch.Last = function() {
    /// <signature>
    /// <summary>Returns the last *SENSOR_SWITCH in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last *SENSOR_SWITCH in</param>
    /// <returns type="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free *SENSOR_SWITCH label in the model. Also see SensorSwitch.FirstFreeLabel(), SensorSwitch.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free *SENSOR_SWITCH label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorSwitch.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next *SENSOR_SWITCH in the model.</summary>
    /// <returns type="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) *SENSOR_SWITCH label in the model. Also see SensorSwitch.FirstFreeLabel(), SensorSwitch.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free *SENSOR_SWITCH label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorSwitch.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous *SENSOR_SWITCH in the model.</summary>
    /// <returns type="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.prototype.RemoveRow = function() {
    /// <signature>
    /// <summary>Removes the data for a row in *SENSOR_SWITCH_SHELL_TO_VENT.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to remove the data for. Note that row indices start at 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the *SENSOR_SWITCHs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all *SENSOR_SWITCHs will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged *SENSOR_SWITCHs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged *SENSOR_SWITCHs will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the *SENSOR_SWITCHs that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select *SENSOR_SWITCHs using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting *SENSOR_SWITCHs</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only *SENSOR_SWITCHs from that model can be selected. If the argument is a Flag then only *SENSOR_SWITCHs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any *SENSOR_SWITCHs can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorSwitch.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the *SENSOR_SWITCH.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the *SENSOR_SWITCH</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.prototype.SetRow = function() {
    /// <signature>
    /// <summary>Sets the data for a row in *SENSOR_SWITCH_SHELL_TO_VENT.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to set the data for. Note that row indices start at 0.</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">An array containing the row variables SSID, FTIME and C23V.</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of *SENSOR_SWITCHs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing *SENSOR_SWITCHs should be counted. If false or omitted referenced but undefined *SENSOR_SWITCHs will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

SensorSwitch.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the *SENSOR_SWITCHs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all *SENSOR_SWITCHs will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the *SENSOR_SWITCHs</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="SensorSwitch"/>
    /// </signature>
}

SensorSwitch.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for *SENSOR_SWITCH. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

SensorSwitch.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this *SENSOR_SWITCH.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

SensorSwitch.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the sensor switch data in keyword format. Note that this contains the keyword header and the keyword cards. See also SensorSwitch.Keyword() and SensorSwitch.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Set = function() {
    /// <signature>
    /// <summary>Create a new Set object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that set will be created in</param>
    /// <param name="sid" type="Number" optional="false">Set number</param>
    /// <param name="type" type="Number" optional="false">Type of set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <param name="title" type="String" optional="true">Title for the set</param>
    /// <param name="option" type="Number" optional="true">Set type. Can be Set.ADD, Set.INTERSECT, Set.GENERAL or Set.GENERATE</param>
    /// <returns type="Set"/>
    /// </signature>
    /// <field name='add' static='false' type='Boolean'>If _ADD option is active.</field>
    /// <field name='advanced' static='false' type='Boolean'>If _ADD_ADVANCED option is active.</field>
    /// <field name='collect' static='false' type='Boolean'>If _COLLECT option is active. To manage _COLLECT sets PRIMER creates a 'parent' set that can be used to sketch/view all of the items from the _COLLECT sets with the same label. PRIMER then manages each _COLLECT set with the same label as a 'child' of this 'parent' set. Also see collect_children and GetCollectChild. If the collect property is unset for a child collect set then a new label will be assigned for the child set. If the collect property is unset for a parent collect set then all of the child sets will be reassigned new labels.</field>
    /// <field name='collect_children' static='false' type='Number'>The number of child _COLLECT sets if _COLLECT option is active.</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the set</field>
    /// <field name='column' static='false' type='Boolean'>If _COLUMN option is active.</field>
    /// <field name='da1' static='false' type='Number'>The first default attribute for the set (only valid for Set.NODE, Set.PART, Set.SEGMENT, Set.SEGMENT_2D and Set.SHELL)</field>
    /// <field name='da2' static='false' type='Number'>The second default attribute for the set (only valid for Set.NODE, Set.PART, Set.SEGMENT, Set.SEGMENT_2D and Set.SHELL)</field>
    /// <field name='da3' static='false' type='Number'>The third default attribute for the set (only valid for Set.NODE, Set.PART, Set.SEGMENT, Set.SEGMENT_2D and Set.SHELL)</field>
    /// <field name='da4' static='false' type='Number'>The fourth default attribute for the set (only valid for Set.NODE, Set.PART, Set.SEGMENT, Set.SEGMENT_2D and Set.SHELL)</field>
    /// <field name='exists' static='false' type='Boolean'>true if set exists, false if referred to but not defined. (read only)</field>
    /// <field name='general' static='false' type='Boolean'>If _GENERAL option is active.</field>
    /// <field name='general_lines' static='false' type='Number'>Number of lines of data for _GENERAL set (if _GENERAL option is active).</field>
    /// <field name='generate' static='false' type='Boolean'>If _GENERATE option is active.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the set is in.</field>
    /// <field name='increment' static='false' type='Boolean'>If _GENERATE_INCREMENT option is active.</field>
    /// <field name='intersect' static='false' type='Boolean'>If _INTERSECT option is active.</field>
    /// <field name='label' static='false' type='Number'>Set number. Also see the sid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the set is in.</field>
    /// <field name='sid' static='false' type='Number'>Set number. Also see the label property which is an alternative name for this.</field>
    /// <field name='smooth' static='false' type='Boolean'>If _LIST_SMOOTH option is active.</field>
    /// <field name='solver' static='false' type='String'>Solver to attach to set. Can be "MECH", "CESE", "EM", "ICFD" or blank (only valid for Set.NODE, Set.PART, Set.SEGMENT and Set.SOLID).</field>
    /// <field name='title' static='false' type='String'>Set title</field>
    /// <field name='total' static='false' type='Number'>The total number of items in the set. Note that for _GENERAL and _GENERATE sets this is expensive to compute.</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the set (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='type' static='false' type='Number'>Set type. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</field>
    /// <field name='2D_SEGMENT' static='true' type='Number'>Please use Set.SEGMENT_2D instead.</field>
    /// <field name='ADD' static='true' type='Number'>Set type is *SET_XYZ_ADD.</field>
    /// <field name='ALL_TYPES' static='true' type='Number'>All set types - used in blanking etc.</field>
    /// <field name='BEAM' static='true' type='Number'>Set beam type</field>
    /// <field name='BOX' static='true' type='Number'>Set box type</field>
    /// <field name='DISCRETE' static='true' type='Number'>Set discrete type</field>
    /// <field name='GENERAL' static='true' type='Number'>Set type is *SET_XYZ_GENERAL.</field>
    /// <field name='GENERATE' static='true' type='Number'>Set type is *SET_XYZ_GENERATE.</field>
    /// <field name='INTERSECT' static='true' type='Number'>Set type is *SET_XYZ_INTERSECT.</field>
    /// <field name='MM_GROUP' static='true' type='Number'>Set multi-material group type</field>
    /// <field name='MODE' static='true' type='Number'>Set mode type</field>
    /// <field name='NODE' static='true' type='Number'>Set node type</field>
    /// <field name='PART' static='true' type='Number'>Set part type</field>
    /// <field name='PART_TREE' static='true' type='Number'>Set part tree type</field>
    /// <field name='SEGMENT' static='true' type='Number'>Set segment type</field>
    /// <field name='SEGMENT_2D' static='true' type='Number'>Set segment 2d type</field>
    /// <field name='SHELL' static='true' type='Number'>Set shell type</field>
    /// <field name='SOLID' static='true' type='Number'>Set solid type</field>
    /// <field name='TSHELL' static='true' type='Number'>Set thick shell type</field>
}

Set.prototype.Add = function() {
    /// <signature>
    /// <summary>Adds an item to the set. This cannot be used for _COLUMN and _GENERAL sets. For segment sets four nodes must be given to define a segment to add to the set.</summary>
    /// <param name="id1" type="Number" optional="false">id of the item to add to the set (normal, _ADD or _ADD_ADVANCED sets) orStart ID (_GENERATE sets)</param>
    /// <param name="id2 (only for SEGMENT, _GENERATE, _GENERATE_INCREMENT and _ADD_ADVANCED sets)" type="Number" optional="false">type of the item to add to the set [1-7] (_ADD_ADVANCED sets) orEnd ID (_GENERATE sets)</param>
    /// <param name="id3 (only for SEGMENT and _GENERATE_INCREMENT sets)" type="Number" optional="false">Increment for _GENERATE_INCREMENT sets, otherwise id of the item to add to the set.</param>
    /// <param name="id4 (only for SEGMENT sets)" type="Number" optional="false">id of the item to add to the set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.AddCollectChild = function() {
    /// <signature>
    /// <summary>Adds a child collect set to the set. The child set label will be changed to be the same as the parent set and it will become a child. Also see Set.collect_children and Set.GetCollectChild.</summary>
    /// <param name="set" type="Set" optional="false">Set to be added as a child collect set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.AddFlagged = function() {
    /// <signature>
    /// <summary>Adds flagged items to the set. This cannot be used for _GENERAL or _GENERATE sets and cannot be used for segment sets</summary>
    /// <param name="flag" type="Flag" optional="false">Flag for items to add to the set</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sets will be blanked in</param>
    /// <param name="type" type="Number" optional="true">Type of sets to blank. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If omitted sets of all types will be blanked.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sets will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sets that you want to blank</param>
    /// <param name="type" type="Number" optional="true">Type of sets to blank. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If set, only flagged sets of this type will be blanked. If omitted flagged sets of all types will be blanked.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the set is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Set.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the set.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the set</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Contains = function() {
    /// <signature>
    /// <summary>Checks if an item is in the set. This cannot be used for ADD_ADVANCED, _GENERAL or _GENERATE sets and cannot be used for segment sets</summary>
    /// <param name="id" type="Number" optional="false">id of the item to check.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Set.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the set.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. To set current include, use  Include.MakeCurrentLayer() .</param>
    /// <returns type="Set"/>
    /// </signature>
}

Set.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a set.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the set will be created in</param>
    /// <param name="type" type="Number" optional="false">Type of the set that you want to create. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Set"/>
    /// </signature>
}

Set.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to edit the set.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Empty = function() {
    /// <signature>
    /// <summary>Removes all items from the set. This cannot be used for _GENERATE sets and cannot be used for segment sets</summary>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for a set. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.First = function() {
    /// <signature>
    /// <summary>Returns the first set in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first set in</param>
    /// <param name="type" type="Number" optional="false">Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <returns type="Set"/>
    /// </signature>
}

Set.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free set label in the model. Also see Set.LastFreeLabel(), Set.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free Set label in</param>
    /// <param name="type" type="Number" optional="false">Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Set.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the sets in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sets will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the sets</param>
    /// <param name="type" type="Number" optional="true">Type of the set. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If set, only sets of this type will be flagged. If omitted sets of all types will be flagged.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the set is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the set</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Set.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Set objects for all of the sets in a models in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sets from</param>
    /// <param name="type" type="Number" optional="false">Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <returns type="Array" elementType="Set"/>
    /// </signature>
}

Set.prototype.GetCollectChild = function() {
    /// <signature>
    /// <summary>Returns a child collect set. Also see Set.collect_children and Set.AddCollectChild.</summary>
    /// <param name="number" type="Number" optional="false">The index of the child collect set to return. Note that indices start at 0, not 1</param>
    /// <returns type="Set"/>
    /// </signature>
}

Set.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Set objects for all of the flagged sets in a models in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sets from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the set that you want to retrieve</param>
    /// <param name="type" type="Number" optional="false">Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <returns type="Array" elementType="Set"/>
    /// </signature>
}

Set.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Set object for a set ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the set in</param>
    /// <param name="set number" type="Number" optional="false">number of the set you want the Set object for</param>
    /// <param name="type" type="Number" optional="false">Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <returns type="Set"/>
    /// </signature>
}

Set.prototype.GetGeneralData = function() {
    /// <signature>
    /// <summary>Returns a line of data for a GENERAL set.</summary>
    /// <param name="index" type="Number" optional="false">The index of the GENERAL data to return. Note that indices start at 0, not 1. 0 &lt;= index &lt; general_lines</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Set.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this set (*SET_NODE etc). Note that a carriage return is not added. See also Set.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Set.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the set. Note that a carriage return is not added. See also Set.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Set.Last = function() {
    /// <signature>
    /// <summary>Returns the last set in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last set in</param>
    /// <param name="type" type="Number" optional="false">Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <returns type="Set"/>
    /// </signature>
}

Set.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free set label in the model. Also see Set.FirstFreeLabel(), Set.NextFreeLabel() and Model.LastFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free Set label in</param>
    /// <param name="type" type="Number" optional="false">Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Set.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next set in the model.</summary>
    /// <returns type="Set"/>
    /// </signature>
}

Set.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free set label in the model. Also see Set.FirstFreeLabel(), Set.LastFreeLabel() and Model.NextFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free Set label in</param>
    /// <param name="type" type="Number" optional="false">Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Set.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a set.</summary>
    /// <param name="type" type="Number" optional="false">Type of sets to pick. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL.</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sets from that model can be picked. If the argument is a Flag then only sets that are flagged with limit can be selected. If omitted, or null, any sets from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Set"/>
    /// </signature>
}

Set.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous set in the model.</summary>
    /// <returns type="Set"/>
    /// </signature>
}

Set.prototype.RebuildCache = function() {
    /// <signature>
    /// <summary>Rebuilds the cache for a set. As sets can be built using complex combinations of _GENERAL, _ADD, _INTERSECT options etc Primer creates a 'cache' for the set to speed up set drawing and usage. During normal interactive use this cache is rebuilt as necessary but in JavaScript it is possible for the cache to become out of date (e.g. you change a box position in JavaScript that is used by a *SET_GENERAL). Calling this forces the cache to be rebuilt.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Remove = function() {
    /// <signature>
    /// <summary>Removes an item from the set. If the item is not in the set nothing is done. This cannot be used for ADD_ADVANCED, _COLUMN, _GENERAL or _GENERATE sets and cannot be used for segment sets</summary>
    /// <param name="id" type="Number" optional="false">id of the item to remove from the set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.RemoveFlagged = function() {
    /// <signature>
    /// <summary>Removes flagged items from the set. This cannot be used for _GENERAL or _GENERATE sets and cannot be used for segment sets</summary>
    /// <param name="flag" type="Flag" optional="false">Flag for items to remove from the set</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.RemoveGeneralData = function() {
    /// <signature>
    /// <summary>Removes a line of data from a GENERAL set.</summary>
    /// <param name="index" type="Number" optional="false">The index of the GENERAL data to remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; general_lines</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sets will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <param name="type" type="Number" optional="true">Type of sets to renumber. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If omitted sets of all types will be blanked.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sets will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sets that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <param name="type" type="Number" optional="true">Type of sets to renumber. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If omitted sets of all types will be blanked.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select sets using standard PRIMER object menus.</summary>
    /// <param name="type" type="Number" optional="false">Type of sets to pick. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL.</param>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting sets</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sets from that model can be selected. If the argument is a Flag then only sets that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sets from any model can be selected.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Set.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the set.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the set</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.SetGeneralData = function() {
    /// <signature>
    /// <summary>Sets a line of data for a GENERAL set.</summary>
    /// <param name="index" type="Number" optional="false">The index of the GENERAL data to set. Note that indices start at 0, not 1. 0 &lt;= index &lt;= general_lines</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">Array containing GENERAL data to set.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the set. The set will be sketched until you either call Set.Unsketch(), Set.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the set is sketched. If omitted redraw is true. If you want to sketch several sets and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sets will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sets that you want to sketch</param>
    /// <param name="type" type="Number" optional="true">Type of sets to sketch. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If set, only flagged sets of this type will be sketched. If omitted flagged sets of all types will be sketched.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is true. If you want to do several (un)sketches and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Spool = function() {
    /// <signature>
    /// <summary>Spools a set, entry by entry. See also Set.StartSpool</summary>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Set.prototype.StartSpool = function() {
    /// <signature>
    /// <summary>Starts a set spooling operation. See also Set.Spool</summary>
    /// <param name="raw" type="Boolean" optional="true">If true then the raw data from _GENERATE, _ADD and _INTERSECT sets will be returned instead of expanding the data ranges or child set contents. If omitted raw will be false.</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sets will be unblanked in</param>
    /// <param name="type" type="Number" optional="true">Type of sets to unblank. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If omitted sets of all types will be blanked.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged sets will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sets that you want to unblank</param>
    /// <param name="type" type="Number" optional="true">Type of sets to unblank. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If set, only flagged sets of this type will be unblanked. If omitted flagged sets of all types will be unblanked.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the sets in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all sets will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the sets</param>
    /// <param name="type" type="Number" optional="true">Type of the set. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the set.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the set is unsketched. If omitted redraw is true. If you want to unsketch several sets and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all sets.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sets will be unsketched in</param>
    /// <param name="type" type="Number" optional="true">Type of sets to unsketch. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If omitted sets of all types will be unsketched.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sets are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged sets.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sets will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sets that you want to unsketch</param>
    /// <param name="type" type="Number" optional="true">Type of sets to unsketch. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If omitted sets of all types will be unsketched.</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sets are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for a set. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Set.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this set.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Set.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the set data in keyword format. Note that this contains the keyword header and the keyword cards. See also Set.Keyword() and Set.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Shell = function() {
    /// <signature>
    /// <summary>Create a new Shell object. Use either 3, 4, 6 or 8 nodes when creating a new shell. If you are creating a 3 noded shell either only give 3 nodes or give 4 nodes but make nodes 3 and 4 the same number. Similarly, 6 noded shells can be created with 6 node arguments or with 8 nodes but nodes 3 and 4 the same number and nodes 7 and 8 the same number.</summary>
    /// <param name="Model" type="Model" optional="false">Model that shell will be created in</param>
    /// <param name="eid" type="Number" optional="false">Shell number</param>
    /// <param name="pid" type="Number" optional="false">Part number</param>
    /// <param name="n1" type="Number" optional="false">Node number 1</param>
    /// <param name="n2" type="Number" optional="false">Node number 2</param>
    /// <param name="n3" type="Number" optional="false">Node number 3</param>
    /// <param name="n4" type="Number" optional="true">Node number 4</param>
    /// <param name="n5" type="Number" optional="true">Node number 5</param>
    /// <param name="n6" type="Number" optional="true">Node number 6</param>
    /// <param name="n7" type="Number" optional="true">Node number 7</param>
    /// <param name="n8" type="Number" optional="true">Node number 8</param>
    /// <returns type="Shell"/>
    /// </signature>
    /// <field name='beta' static='false' type='Number'>Offset angle. If non zero then the _BETA option is assumed. Note: If this option is set then mcid should be 0</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the shell</field>
    /// <field name='composite' static='false' type='Boolean'>If COMPOSITE option is set. Can be true or false</field>
    /// <field name='composite_long' static='false' type='Boolean'>If COMPOSITE_LONG option is set. Can be true or false</field>
    /// <field name='dof' static='false' type='Boolean'>If DOF option is set. Can be true or false</field>
    /// <field name='edges' static='false' type='Number'>Bitwise code of Shell.EDGE_1, Shell.EDGE_2, Shell.EDGE_3 and Shell.EDGE_4 representing which edges of the shell are free edges (read only)</field>
    /// <field name='eid' static='false' type='Number'>Shell number. Also see the label property which is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if shell exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the shell is in.</field>
    /// <field name='label' static='false' type='Number'>Shell number. Also see the eid property which is an alternative name for this.</field>
    /// <field name='mcid' static='false' type='Number'>Material coordinate system ID. If non zero then the _MCID option is assumed. Note: If this option is set then beta should be 0.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the shell is in.</field>
    /// <field name='n1' static='false' type='Number'>Node number 1</field>
    /// <field name='n2' static='false' type='Number'>Node number 2</field>
    /// <field name='n3' static='false' type='Number'>Node number 3</field>
    /// <field name='n4' static='false' type='Number'>Node number 4</field>
    /// <field name='n5' static='false' type='Number'>Node number 5</field>
    /// <field name='n6' static='false' type='Number'>Node number 6</field>
    /// <field name='n7' static='false' type='Number'>Node number 7</field>
    /// <field name='n8' static='false' type='Number'>Node number 8</field>
    /// <field name='nip' static='false' type='Boolean'>Number of integration points for composite shell</field>
    /// <field name='nodes' static='false' type='Number'>Number of nodes shell has (read only)</field>
    /// <field name='ns1' static='false' type='Number'>Scalar Node number 1</field>
    /// <field name='ns2' static='false' type='Number'>Scalar Node number 2</field>
    /// <field name='ns3' static='false' type='Number'>Scalar Node number 3</field>
    /// <field name='ns4' static='false' type='Number'>Scalar Node number 4</field>
    /// <field name='offset' static='false' type='Number'>Offset distance. If non zero then the _OFFSET option is assumed</field>
    /// <field name='pid' static='false' type='Number'>Part number</field>
    /// <field name='shl4_to_shl8' static='false' type='Boolean'>If SHL4_TO_SHL8 option is set. Can be true or false</field>
    /// <field name='thic1' static='false' type='Number'>Thickness at node 1</field>
    /// <field name='thic2' static='false' type='Number'>Thickness at node 2</field>
    /// <field name='thic3' static='false' type='Number'>Thickness at node 3</field>
    /// <field name='thic4' static='false' type='Number'>Thickness at node 4</field>
    /// <field name='thic5' static='false' type='Number'>Thickness at node 5 (if 8 noded shell)</field>
    /// <field name='thic6' static='false' type='Number'>Thickness at node 6 (if 8 noded shell)</field>
    /// <field name='thic7' static='false' type='Number'>Thickness at node 7 (if 8 noded shell)</field>
    /// <field name='thic8' static='false' type='Number'>Thickness at node 8 (if 8 noded shell)</field>
    /// <field name='thickness' static='false' type='Boolean'>If _THICKNESS option is set. Can be true or false</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the shell (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='EDGE_1' static='true' type='Number'>Edge 1 of shell</field>
    /// <field name='EDGE_2' static='true' type='Number'>Edge 2 of shell</field>
    /// <field name='EDGE_3' static='true' type='Number'>Edge 3 of shell</field>
    /// <field name='EDGE_4' static='true' type='Number'>Edge 4 of shell</field>
}

Shell.prototype.Angles = function() {
    /// <signature>
    /// <summary>Calculates the minimum and maximum internal angles (in degrees) for the shell</summary>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Shell.prototype.Area = function() {
    /// <signature>
    /// <summary>Calculates the area for the shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.AspectRatio = function() {
    /// <signature>
    /// <summary>Calculates the aspect ratio for the shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the shell</summary>
    /// <returns type="null"/>
    /// </signature>
}

Shell.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged shells will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the shells that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the shell is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Shell.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the shell</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.CoordsToIsoparametric = function() {
    /// <signature>
    /// <summary>Calculates the isoparametric coordinates for a point on the shell.</summary>
    /// <param name="x" type="Number" optional="false">X coordinate of point</param>
    /// <param name="y" type="Number" optional="false">Y coordinate of point</param>
    /// <param name="z" type="Number" optional="false">Z coordinate of point</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Shell.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the shell.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Shell"/>
    /// </signature>
}

Shell.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a shell.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the shell will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Shell"/>
    /// </signature>
}

Shell.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.ElemCut = function() {
    /// <signature>
    /// <summary>Returns coordinates of the intersections between a shell and a database cross section.</summary>
    /// <param name="Database cross section label" type="Number" optional="false">The label of the database cross section.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Shell.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for shell. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the shell colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the shell.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.FillAttachedHole = function() {
    /// <signature>
    /// <summary>Fills in (meshes) a hole attached to the shell.</summary>
    /// <param name="pid" type="Number" optional="false">The Part number that the new shells will be created in.</param>
    /// <param name="size" type="Number" optional="false">The size for created elements.</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.FillHolesOnFlagged = function() {
    /// <signature>
    /// <summary>Fills multiple holes using flagged shells.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells are in.</param>
    /// <param name="Flag" type="Flag" optional="false">flag bit</param>
    /// <param name="RemeshHole" type="Boolean" optional="false">TRUE if elements around the hole should be remeshed</param>
    /// <param name="pid" type="Number" optional="true">Needs to be specified if RemeshHole is FALSE. Specifies the Part id where the mesh is filled</param>
    /// <param name="Max Hole Size" type="Number" optional="true">Maximum size of the hole which is to be filled. If omitted a default size of 20.0 will be set</param>
    /// <param name="Mesh Element size" type="Number" optional="true">Element size of the mesh which fills the hole. If omitted a default size of 10.0 will be set</param>
    /// <param name="planarSurface" type="Boolean" optional="true">Needs to be specified if RemeshHole is TRUE. TRUE if we need to Use planar surface</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.FindShellEnd_#deprecated = function() {
    /// <signature>
    /// <summary>Tidy memory allocation incurred by function which finds shells within a box. Now replaced by model member function Model.FindElemEnd()</summary>
    /// <returns type="null"/>
    /// </signature>
}

Shell.FindShellInBox = function() {
    /// <signature>
    /// <summary>Returns an array of Shell objects for the shells within a box. This requires a previous (outside loop) call to function FindShellInit(m) or m.FindElemInit() where the process is initialized for flagged shells in the model (typically all shells) and m.FindElemEnd() to close the process. Please note this function provides a list of all shells that could potentially be in the box (using computationally cheap bounding box comparison) it is not a rigorous test of whether the shell is actually in the box. See also Shell.FindShellInit() See also Model.FindElemInit() See also Model.FindElemEnd()</summary>
    /// <param name="Model" type="Model" optional="false">Model designated model</param>
    /// <param name="xmin" type="Number" optional="false">Minimum bound in global x</param>
    /// <param name="xmax" type="Number" optional="false">Maximum bound in global x</param>
    /// <param name="ymin" type="Number" optional="false">Minimum bound in global y</param>
    /// <param name="ymax" type="Number" optional="false">Maximum bound in global y</param>
    /// <param name="zmin" type="Number" optional="false">Minimum bound in global z</param>
    /// <param name="zmax" type="Number" optional="false">Maximum bound in global z</param>
    /// <param name="sflag" type="Number" optional="true">Optional flag to restrict shells considered</param>
    /// <param name="sthick" type="Number" optional="true">Optional flag to consider thickness for shells</param>
    /// <returns type="Array" elementType="Shell"/>
    /// </signature>
}

Shell.FindShellInit = function() {
    /// <signature>
    /// <summary>Initialize setup so that all flagged shells in model can be tested to see if they are within box. See also Shell.FindShellInBox() See also Model.FindElemInit() See also Model.FindElemEnd()</summary>
    /// <param name="Model" type="Model" optional="false">Model in which shells have been flagged</param>
    /// <param name="flag" type="Flag" optional="true">Optional flag that has been set on the shells, if unsupplied all shells considered</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.First = function() {
    /// <signature>
    /// <summary>Returns the first shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first shell in</param>
    /// <returns type="Shell"/>
    /// </signature>
}

Shell.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free shell label in the model. Also see Shell.LastFreeLabel(), Shell.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the shells in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the shells</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the shell is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the shell</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Shell.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each shell in the model. Note that ForEach has been designed to make looping over shells as fast as possible and so has some limitations. Firstly, a single temporary Shell object is created and on each function call it is updated with the current shell data. This means that you should not try to store the Shell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new shells inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each shell</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Shell objects for all of the shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get shells from</param>
    /// <returns type="Array" elementType="Shell"/>
    /// </signature>
}

Shell.prototype.GetAttachedShells = function() {
    /// <signature>
    /// <summary>Returns the shells that are attached to the shell. Note that 'attached' means that the shells must share 2 nodes.</summary>
    /// <param name="tolerance" type="Number" optional="true">This tolerance can be used to limit the selection to shells whose normal vector is within this tolerance (in degrees) of the original shell. If omitted the tolerance is 180 degrees.</param>
    /// <param name="recursive" type="Boolean" optional="true">If recursive is false then only the shells actually attached to the shell will be returned (this could also be done by using the Xrefs class but this method is provided for convenience. If recursive is true then PRIMER will keep finding attached shells until no more can be found. If omitted recursive will be false.</param>
    /// <returns type="Array" elementType="Shell"/>
    /// </signature>
}

Shell.prototype.GetCompositeData = function() {
    /// <signature>
    /// <summary>Returns the composite data for an integration point in *ELEMENT_SHELL_COMPOSITE.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want the data for. Note that integration points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Shell.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Shell objects for all of the flagged shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get shells from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the shells that you want to retrieve</param>
    /// <returns type="Array" elementType="Shell"/>
    /// </signature>
}

Shell.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Shell object for a shell ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the shell in</param>
    /// <param name="number" type="Number" optional="false">number of the shell you want the Shell object for</param>
    /// <returns type="Shell"/>
    /// </signature>
}

Shell.prototype.GetNodeIDs = function() {
    /// <signature>
    /// <summary>Returns the labels of the nodes on the shell as an array. See also Shell.GetNodes()</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.GetNodes = function() {
    /// <signature>
    /// <summary>Returns the nodes on the shell as an array of Node objects. See also Shell.GetNodeIDs()</summary>
    /// <returns type="Array" elementType="Node"/>
    /// </signature>
}

Shell.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Shell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Shell.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">shell property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Shell.prototype.GetShellReferenceGeometry = function() {
    /// <signature>
    /// <summary>Returns the airbag shell reference geometry of the shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.IsoparametricToCoords = function() {
    /// <signature>
    /// <summary>Calculates the coordinates for a point on the shell from the isoparametric coords.</summary>
    /// <param name="s" type="Number" optional="false">First isoparametric coordinate</param>
    /// <param name="t" type="Number" optional="false">Second isoparametric coordinate</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Shell.prototype.Jacobian = function() {
    /// <signature>
    /// <summary>Calculates the jacobian for the shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this shell (*SHELL, *SHELL_SCALAR or *SHELL_SCALAR_VALUE). Note that a carriage return is not added. See also Shell.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Shell.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the shell. Note that a carriage return is not added. See also Shell.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Shell.Last = function() {
    /// <signature>
    /// <summary>Returns the last shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last shell in</param>
    /// <returns type="Shell"/>
    /// </signature>
}

Shell.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free shell label in the model. Also see Shell.FirstFreeLabel(), Shell.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.Length = function() {
    /// <signature>
    /// <summary>Calculates the minimum length for the shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.MakeConsistentNormalsFlagged = function() {
    /// <signature>
    /// <summary>Make all the flagged SHELL normals consistent with a selected one, the Seed Element.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells are in.</param>
    /// <param name="Flag" type="Flag" optional="false">flag bit</param>
    /// <param name="Shell label" type="Number" optional="true">The label of the seed shell. If omitted, or null, the first flagged shell is used as the seed shell.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Shell.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next shell in the model.</summary>
    /// <returns type="Shell"/>
    /// </signature>
}

Shell.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) shell label in the model. Also see Shell.FirstFreeLabel(), Shell.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.NormalVector = function() {
    /// <signature>
    /// <summary>Calculates the unit normal vector for the shell.</summary>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Shell.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a shell.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only shells from that model can be picked. If the argument is a Flag then only shells that are flagged with limit can be selected. If omitted, or null, any shells from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Shell"/>
    /// </signature>
}

Shell.PickIsoparametric = function() {
    /// <signature>
    /// <summary>Allows the user to pick a point on a shell. The isoparametric coordinates of the point picked on the shell are returned as well as the shell picked. These coordinates are suitable for using in the function Shell.IsoparametricToCoords(). See also Shell.Pick()</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only shells from that model can be picked. If the argument is a Flag then only shells that are flagged with limit can be selected. If omitted, or null, any shells from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Shell.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous shell in the model.</summary>
    /// <returns type="Shell"/>
    /// </signature>
}

Shell.prototype.RemoveCompositeData = function() {
    /// <signature>
    /// <summary>Removes the composite data for an integration point in *ELEMENT_SHELL_COMPOSITE.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want to remove. Note that integration points start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged shells will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the shells that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.ReverseNormal = function() {
    /// <signature>
    /// <summary>Reverse shell normal.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to reverse several shell normals and only redraw after the last one then use false for all redraws apart from the last one.</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.ReverseNormalsFlagged = function() {
    /// <signature>
    /// <summary>Reverse all the flagged shell normals</summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells are in.</param>
    /// <param name="Flag" type="Flag" optional="false">flag bit</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select shells using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting shells</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only shells from that model can be selected. If the argument is a Flag then only shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any shells can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.SetCompositeData = function() {
    /// <signature>
    /// <summary>Sets the composite data for an integration point in *ELEMENT_SHELL_COMPOSITE.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want to set the data for. Note that integration points start at 0, not 1.</param>
    /// <param name="mid" type="Number" optional="false">Material ID for the integration point.</param>
    /// <param name="thick" type="Number" optional="false">Thickness of the integration point.</param>
    /// <param name="beta" type="Number" optional="false">Material angle of the integration point.</param>
    /// <param name="plyid" type="Number" optional="true">Ply ID for the integration point. This should be used if the _COMPOSITE_LONG option is set for the shell.</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the shell</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the shell. The shell will be sketched until you either call Shell.Unsketch(), Shell.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the shell is sketched. If omitted redraw is true. If you want to sketch several shells and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged shells in the model. The shells will be sketched until you either call Shell.Unsketch(), Shell.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged shells will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the shells that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the shells are sketched. If omitted redraw is true. If you want to sketch flagged shells several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.Skew = function() {
    /// <signature>
    /// <summary>Calculates the skew for the shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.Taper = function() {
    /// <signature>
    /// <summary>Calculates the taper for the shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.TiedNodeCheck = function() {
    /// <signature>
    /// <summary>Checks if nodes of shell are tied by contact or directly attached (non-zero option1).</summary>
    /// <param name="Contact label" type="Number" optional="false">The label of the tied contact. If zero the tied contact is found for the shell by reverse lookup.</param>
    /// <param name="Flag" type="Flag" optional="false">flag bit</param>
    /// <param name="Option1" type="Number" optional="false">Directly tied node (logical OR) 0:NONE 1:NRB/C_EXNO 2:BEAM 4:SHELL 8:SOLID 16:TSHELL</param>
    /// <param name="Option2" type="Number" optional="false">0:No action 1: report error if directly attached node (acc. option1) captured by contact</param>
    /// <returns type="String"/>
    /// </signature>
}

Shell.prototype.Timestep = function() {
    /// <signature>
    /// <summary>Calculates the timestep for the shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing shells should be counted. If false or omitted referenced but undefined shells will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the shell</summary>
    /// <returns type="null"/>
    /// </signature>
}

Shell.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged shells will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the shells that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all shells will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the shells</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the shell.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the shell is unsketched. If omitted redraw is true. If you want to unsketch several shells and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all shells.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all shells will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the shells that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Shell"/>
    /// </signature>
}

Shell.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Shell.prototype.Warpage = function() {
    /// <signature>
    /// <summary>Calculates the warpage for the shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Shell.prototype.WeightingFactors = function() {
    /// <signature>
    /// <summary>Calculates the weighting factors for a point on the shell from the isoparametric coords.</summary>
    /// <param name="s" type="Number" optional="false">First isoparametric coordinate</param>
    /// <param name="t" type="Number" optional="false">Second isoparametric coordinate</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Shell.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this shell.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Shell.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the shell data in keyword format. Note that this contains the keyword header and the keyword cards. See also Shell.Keyword() and Shell.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var ShellReferenceGeometry = function() {
    /// <signature>
    /// <summary>Create a new ShellReferenceGeometry object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that ShellReferenceGeometry will be created in</param>
    /// <param name="aid" type="Number" optional="true">ShellReferenceGeometry number to set _ID suffix</param>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
    /// <field name='aid' static='false' type='Number'>ShellReferenceGeometry number. Also see the label property which is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if airbag shell reference geometry exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Boolean'>Turns _ID on or OFF</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the airbag shell reference geometry is in.</field>
    /// <field name='label' static='false' type='Number'>ShellReferenceGeometry number. Also see the label property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the airbag shell reference geometry is in.</field>
    /// <field name='nid' static='false' type='Number'>Node number for origin</field>
    /// <field name='rdt' static='false' type='Boolean'>Turns _RDT on or OFF</field>
    /// <field name='sx' static='false' type='Number'>Scale factor in X direction</field>
    /// <field name='sy' static='false' type='Number'>Scale factor in Y direction</field>
    /// <field name='sz' static='false' type='Number'>Scale factor in Z direction</field>
}

ShellReferenceGeometry.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the airbag shell reference geometry.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the airbag shell reference geometry</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the airbag shell reference geometry.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an asrg.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the asrg will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for airbag shell reference geometry. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.First = function() {
    /// <signature>
    /// <summary>Returns the first airbag shell reference geometry in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first airbag shell reference geometry in</param>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free airbag shell reference geometry label in the model. Also see ShellReferenceGeometry.LastFreeLabel(), ShellReferenceGeometry.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free airbag shell reference geometry label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ShellReferenceGeometry.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the airbag shell reference geometrys in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag shell reference geometrys will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the airbag shell reference geometrys</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the airbag shell reference geometry is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the airbag shell reference geometry</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

ShellReferenceGeometry.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each airbag shell reference geometry in the model. Note that ForEach has been designed to make looping over airbag shell reference geometrys as fast as possible and so has some limitations. Firstly, a single temporary ShellReferenceGeometry object is created and on each function call it is updated with the current airbag shell reference geometry data. This means that you should not try to store the ShellReferenceGeometry object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new airbag shell reference geometrys inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag shell reference geometrys are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each airbag shell reference geometry</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of ShellReferenceGeometry objects for all of the airbag shell reference geometrys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get airbag shell reference geometrys from</param>
    /// <returns type="Array" elementType="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of ShellReferenceGeometry objects for all of the flagged airbag shell reference geometrys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get airbag shell reference geometrys from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbag shell reference geometrys that you want to retrieve</param>
    /// <returns type="Array" elementType="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the ShellReferenceGeometry object for a airbag shell reference geometry ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the airbag shell reference geometry in</param>
    /// <param name="number" type="Number" optional="false">number of the airbag shell reference geometry you want the ShellReferenceGeometry object for</param>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a ShellReferenceGeometry property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ShellReferenceGeometry.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">airbag shell reference geometry property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.GetShell = function() {
    /// <signature>
    /// <summary>Returns the shell reference geometry nodes and pid for the shell</summary>
    /// <param name="eid" type="Number" optional="false">Shell element ID</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this shell_reference_geometry (*AIRBAG_SHELL_REFERENCE_GEOMETRY). Note that a carriage return is not added. See also ShellReferenceGeometry.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the shell_reference_geometry. Note that a carriage return is not added. See also ShellReferenceGeometry.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

ShellReferenceGeometry.Last = function() {
    /// <signature>
    /// <summary>Returns the last airbag shell reference geometry in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last airbag shell reference geometry in</param>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free airbag shell reference geometry label in the model. Also see ShellReferenceGeometry.FirstFreeLabel(), ShellReferenceGeometry.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free airbag shell reference geometry label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next airbag shell reference geometry in the model.</summary>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) airbag shell reference geometry label in the model. Also see ShellReferenceGeometry.FirstFreeLabel(), ShellReferenceGeometry.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free airbag shell reference geometry label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

ShellReferenceGeometry.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a airbag shell reference geometry.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only airbag shell reference geometrys from that model can be picked. If the argument is a Flag then only airbag shell reference geometrys that are flagged with limit can be selected. If omitted, or null, any airbag shell reference geometrys from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous airbag shell reference geometry in the model.</summary>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.RemoveShell = function() {
    /// <signature>
    /// <summary>Removes a shell from the shell reference geometry if it is on it</summary>
    /// <param name="eid" type="Number" optional="false">Element ID</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the airbag shell reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag shell reference geometrys will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged airbag shell reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged airbag shell reference geometrys will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbag shell reference geometrys that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select airbag shell reference geometrys using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting airbag shell reference geometrys</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only airbag shell reference geometrys from that model can be selected. If the argument is a Flag then only airbag shell reference geometrys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any airbag shell reference geometrys can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the airbag shell reference geometry.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the airbag shell reference geometry</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.SetShell = function() {
    /// <signature>
    /// <summary>Adds a shell to the shell reference geometry if not already there, otherwise just changes the reference nodes</summary>
    /// <param name="eid" type="Number" optional="false">Element ID</param>
    /// <param name="n1" type="Number" optional="false">Nodal point 1</param>
    /// <param name="n2" type="Number" optional="false">Nodal point 2</param>
    /// <param name="n3" type="Number" optional="false">Nodal point 3</param>
    /// <param name="n4" type="Number" optional="false">Nodal point 4</param>
    /// <param name="pid" type="Number" optional="true">Part ID (ignored by LS-DYNA). If omitted pid will be zero.</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the airbag shell reference geometry. The airbag shell reference geometry will be sketched until you either call ShellReferenceGeometry.Unsketch(), ShellReferenceGeometry.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag shell reference geometry is sketched. If omitted redraw is true. If you want to sketch several airbag shell reference geometrys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged airbag shell reference geometrys in the model. The airbag shell reference geometrys will be sketched until you either call ShellReferenceGeometry.Unsketch(), ShellReferenceGeometry.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged airbag shell reference geometrys will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbag shell reference geometrys that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag shell reference geometrys are sketched. If omitted redraw is true. If you want to sketch flagged airbag shell reference geometrys several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Spool = function() {
    /// <signature>
    /// <summary>Spools a shell reference geometry, entry by entry. See also ShellReferenceGeometry.StartSpool</summary>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.StartSpool = function() {
    /// <signature>
    /// <summary>Starts a shell reference geometry spooling operation. See also ShellReferenceGeometry.Spool</summary>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of airbag shell reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing airbag shell reference geometrys should be counted. If false or omitted referenced but undefined airbag shell reference geometrys will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

ShellReferenceGeometry.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the airbag shell reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all airbag shell reference geometrys will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the airbag shell reference geometrys</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the airbag shell reference geometry.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag shell reference geometry is unsketched. If omitted redraw is true. If you want to unsketch several airbag shell reference geometrys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all airbag shell reference geometrys.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag shell reference geometrys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag shell reference geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged airbag shell reference geometrys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all airbag shell reference geometrys will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the airbag shell reference geometrys that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the airbag shell reference geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="ShellReferenceGeometry"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for airbag shell reference geometry. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this airbag shell reference geometry.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

ShellReferenceGeometry.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the ShellReferenceGeometry data in keyword format. Note that this contains the keyword header and the keyword cards. See also ShellReferenceGeometry.Keyword() and ShellReferenceGeometry.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Slipring = function() {
    /// <signature>
    /// <summary>Create a new Seatbelt Slipring object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that slipring will be created in</param>
    /// <param name="sbsrid" type="Number" optional="false">Slipring number.</param>
    /// <param name="sbid1" type="Number" optional="false">Seatbelt number 1</param>
    /// <param name="sbid2" type="Number" optional="false">Seatbelt number 2</param>
    /// <param name="sbrnid" type="Number" optional="false">Slipring Node number</param>
    /// <returns type="Slipring"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the slipring</field>
    /// <field name='dc' static='false' type='Number'>Optional decay constant to allow a smooth transition between the static and dynamic friction coefficients.</field>
    /// <field name='direct' static='false' type='Number'>Direction of belt movement</field>
    /// <field name='exists' static='false' type='Boolean'>true if slipring exists, false if referred to but not defined. (read only)</field>
    /// <field name='fc' static='false' type='Number'>Coulomb dynamic friction coefficient</field>
    /// <field name='fcs' static='false' type='Number'>Coulomb static friction coefficient</field>
    /// <field name='funcid' static='false' type='Number'>Function ID to determine friction coefficient</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the slipring is in.</field>
    /// <field name='k' static='false' type='Number'>Optional coefficient for determining the Coulomb friction coefficient related to angle alpha</field>
    /// <field name='label' static='false' type='Number'>Slipring number. Also see the sbsrid property which is an alternative name for this.</field>
    /// <field name='lcnffd' static='false' type='Number'>Loadcurve for Coulomb dynamic friction</field>
    /// <field name='lcnffs' static='false' type='Number'>Loadcurve for Coulomb static friction</field>
    /// <field name='ltime' static='false' type='Number'>Slipring lockup time</field>
    /// <field name='model' static='false' type='Number'>The Model number that the slipring is in.</field>
    /// <field name='onid' static='false' type='Number'>Orientation Node number</field>
    /// <field name='sbid1' static='false' type='Number'>Seatbelt number 1 (or Set Shell number if sbrnid is negative).</field>
    /// <field name='sbid2' static='false' type='Number'>Seatbelt number 2 (or Set Shell number if sbrnid is negative).</field>
    /// <field name='sbrnid' static='false' type='Number'>Node number (or Set Node number if negative)</field>
    /// <field name='sbsrid' static='false' type='Number'>Slipring number. Also see the label property which is an alternative name for this.</field>
    /// <field name='shell_seatbelt' static='false' type='Boolean'>true if slipring is used for shell (2D) seatbelt elements. (read only)</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the slipring (0-100) 0% is opaque, 100% is transparent.</field>
}

Slipring.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the slipring</summary>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the sliprings in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sliprings will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged sliprings in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sliprings will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sliprings that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the slipring is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Slipring.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the slipring.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the slipring</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the slipring.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Slipring"/>
    /// </signature>
}

Slipring.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a slipring.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the slipring will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Slipring"/>
    /// </signature>
}

Slipring.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for slipring. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for slipring. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the slipring colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the slipring.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Slipring.First = function() {
    /// <signature>
    /// <summary>Returns the first slipring in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first slipring in</param>
    /// <returns type="Slipring"/>
    /// </signature>
}

Slipring.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free slipring label in the model. Also see Slipring.LastFreeLabel(), Slipring.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free slipring label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Slipring.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the sliprings in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sliprings will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the sliprings</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the slipring is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the slipring</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Slipring.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each slipring in the model. Note that ForEach has been designed to make looping over sliprings as fast as possible and so has some limitations. Firstly, a single temporary Slipring object is created and on each function call it is updated with the current slipring data. This means that you should not try to store the Slipring object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new sliprings inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all sliprings are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each slipring</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Slipring objects for all of the sliprings in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sliprings from</param>
    /// <returns type="Array" elementType="Slipring"/>
    /// </signature>
}

Slipring.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Slipring objects for all of the flagged sliprings in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sliprings from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sliprings that you want to retrieve</param>
    /// <returns type="Array" elementType="Slipring"/>
    /// </signature>
}

Slipring.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Slipring object for a slipring ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the slipring in</param>
    /// <param name="number" type="Number" optional="false">number of the slipring you want the Slipring object for</param>
    /// <returns type="Slipring"/>
    /// </signature>
}

Slipring.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Slipring property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Slipring.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">slipring property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Slipring.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this slipring (*ELEMENT_SEATBELT_SLIPEROMETER) Note that a carriage return is not added. See also Slipring.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Slipring.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the slipring. Note that a carriage return is not added. See also Slipring.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Slipring.Last = function() {
    /// <signature>
    /// <summary>Returns the last slipring in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last slipring in</param>
    /// <returns type="Slipring"/>
    /// </signature>
}

Slipring.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free slipring label in the model. Also see Slipring.FirstFreeLabel(), Slipring.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free slipring label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Slipring.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next slipring in the model.</summary>
    /// <returns type="Slipring"/>
    /// </signature>
}

Slipring.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) slipring label in the model. Also see Slipring.FirstFreeLabel(), Slipring.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free slipring label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Slipring.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a slipring.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sliprings from that model can be picked. If the argument is a Flag then only sliprings that are flagged with limit can be selected. If omitted, or null, any sliprings from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Slipring"/>
    /// </signature>
}

Slipring.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous slipring in the model.</summary>
    /// <returns type="Slipring"/>
    /// </signature>
}

Slipring.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the sliprings in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sliprings will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged sliprings in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sliprings will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sliprings that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select sliprings using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting sliprings</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sliprings from that model can be selected. If the argument is a Flag then only sliprings that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sliprings can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Slipring.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the slipring.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the slipring</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the slipring. The slipring will be sketched until you either call Slipring.Unsketch(), Slipring.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the slipring is sketched. If omitted redraw is true. If you want to sketch several sliprings and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged sliprings in the model. The sliprings will be sketched until you either call Slipring.Unsketch(), Slipring.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sliprings will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sliprings that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sliprings are sketched. If omitted redraw is true. If you want to sketch flagged sliprings several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of sliprings in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing sliprings should be counted. If false or omitted referenced but undefined sliprings will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Slipring.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the slipring</summary>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the sliprings in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sliprings will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged sliprings in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged sliprings will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sliprings that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the sliprings in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all sliprings will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the sliprings</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the slipring.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the slipring is unsketched. If omitted redraw is true. If you want to unsketch several sliprings and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all sliprings.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sliprings will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sliprings are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged sliprings in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sliprings will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sliprings that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sliprings are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Slipring"/>
    /// </signature>
}

Slipring.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for slipring. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Slipring.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this slipring.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Slipring.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the slipring data in keyword format. Note that this contains the keyword header and the keyword cards. See also Slipring.Keyword() and Slipring.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Solid = function() {
    /// <signature>
    /// <summary>Create a new Solid object. Use either 4, 6, 8 or 10 nodes when creating a new solid. If you are creating a 4 noded solid either only give 4 nodes or give 8 nodes but make nodes 4 to 8 the same number. If you are creating a 6 noded solid either only give 6 nodes or give 8 nodes but make nodes 5 and 6 the same number and nodes 7 and 8 the same number.</summary>
    /// <param name="Model" type="Model" optional="false">Model that solid will be created in</param>
    /// <param name="eid" type="Number" optional="false">Solid number</param>
    /// <param name="pid" type="Number" optional="false">Part number</param>
    /// <param name="n1" type="Number" optional="false">Node number 1</param>
    /// <param name="n2" type="Number" optional="false">Node number 2</param>
    /// <param name="n3" type="Number" optional="false">Node number 3</param>
    /// <param name="n4" type="Number" optional="false">Node number 4</param>
    /// <param name="n5" type="Number" optional="true">Node number 5</param>
    /// <param name="n6" type="Number" optional="true">Node number 6</param>
    /// <param name="n7" type="Number" optional="true">Node number 7</param>
    /// <param name="n8" type="Number" optional="true">Node number 8</param>
    /// <param name="n9" type="Number" optional="true">Node number 9</param>
    /// <param name="n10" type="Number" optional="true">Node number 10</param>
    /// <param name="n11" type="Number" optional="true">Node number 11</param>
    /// <param name="n12" type="Number" optional="true">Node number 12</param>
    /// <param name="n13" type="Number" optional="true">Node number 13</param>
    /// <param name="n14" type="Number" optional="true">Node number 14</param>
    /// <param name="n15" type="Number" optional="true">Node number 15</param>
    /// <param name="n16" type="Number" optional="true">Node number 16</param>
    /// <param name="n17" type="Number" optional="true">Node number 17</param>
    /// <param name="n18" type="Number" optional="true">Node number 18</param>
    /// <param name="n19" type="Number" optional="true">Node number 19</param>
    /// <param name="n20" type="Number" optional="true">Node number 20</param>
    /// <param name="n21" type="Number" optional="true">Node number 21</param>
    /// <param name="n22" type="Number" optional="true">Node number 22</param>
    /// <param name="n23" type="Number" optional="true">Node number 23</param>
    /// <param name="n24" type="Number" optional="true">Node number 24</param>
    /// <param name="n25" type="Number" optional="true">Node number 25</param>
    /// <param name="n26" type="Number" optional="true">Node number 26</param>
    /// <param name="n27" type="Number" optional="true">Node number 27</param>
    /// <returns type="Solid"/>
    /// </signature>
    /// <field name='a1' static='false' type='Number'>x component of material direction a</field>
    /// <field name='a2' static='false' type='Number'>y component of material direction a</field>
    /// <field name='a3' static='false' type='Number'>z component of material direction a</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the solid</field>
    /// <field name='d1' static='false' type='Number'>x component of material in-plane vector</field>
    /// <field name='d2' static='false' type='Number'>y component of material in-plane vector</field>
    /// <field name='d3' static='false' type='Number'>z component of material in-plane vector</field>
    /// <field name='dof' static='false' type='Boolean'>If DOF option is set. Can be true or false</field>
    /// <field name='edges' static='false' type='Number'>Bitwise code of Solid.EDGE_1, Solid.EDGE_2, Solid.EDGE_3, Solid.EDGE_4, Solid.EDGE_5, Solid.EDGE_6, Solid.EDGE_7, Solid.EDGE_8, Solid.EDGE_9, Solid.EDGE_10, Solid.EDGE_11 and Solid.EDGE_12 representing which edges of the solid are free faces (read only)</field>
    /// <field name='eid' static='false' type='Number'>Solid number. Also see the label property which is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if solid exists, false if referred to but not defined. (read only)</field>
    /// <field name='faces' static='false' type='Number'>Bitwise code of Solid.FACE_1, Solid.FACE_2, Solid.FACE_3, Solid.FACE_4, Solid.FACE_5 and Solid.FACE_6 representing which faces of the solid are internal faces (read only). Note that this is calculated from the solids that are currently visible so blanking solids will affect this property once graphics have been updated.</field>
    /// <field name='h20' static='false' type='Boolean'>If _H20 option is set. Can be true or false</field>
    /// <field name='h27' static='false' type='Boolean'>If _H27 option is set. Can be true or false</field>
    /// <field name='h64' static='false' type='Boolean'>If _H64 option is set. Can be true or false</field>
    /// <field name='h8toh20' static='false' type='Boolean'>If _H8TOH20 option is set. Can be true or false</field>
    /// <field name='h8toh27' static='false' type='Boolean'>If _H8TOH27 option is set. Can be true or false</field>
    /// <field name='h8toh64' static='false' type='Boolean'>If _H8TOH64 option is set. Can be true or false</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the solid is in.</field>
    /// <field name='label' static='false' type='Number'>Solid number. Also see the eid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the solid is in.</field>
    /// <field name='n1' static='false' type='Number'>Node number 1</field>
    /// <field name='n10' static='false' type='Number'>Node number 10</field>
    /// <field name='n11' static='false' type='Number'>Node number 11</field>
    /// <field name='n12' static='false' type='Number'>Node number 12</field>
    /// <field name='n13' static='false' type='Number'>Node number 13</field>
    /// <field name='n14' static='false' type='Number'>Node number 14</field>
    /// <field name='n15' static='false' type='Number'>Node number 15</field>
    /// <field name='n16' static='false' type='Number'>Node number 16</field>
    /// <field name='n17' static='false' type='Number'>Node number 17</field>
    /// <field name='n18' static='false' type='Number'>Node number 18</field>
    /// <field name='n19' static='false' type='Number'>Node number 19</field>
    /// <field name='n2' static='false' type='Number'>Node number 2</field>
    /// <field name='n20' static='false' type='Number'>Node number 20</field>
    /// <field name='n21' static='false' type='Number'>Node number 21</field>
    /// <field name='n22' static='false' type='Number'>Node number 22</field>
    /// <field name='n23' static='false' type='Number'>Node number 23</field>
    /// <field name='n24' static='false' type='Number'>Node number 24</field>
    /// <field name='n25' static='false' type='Number'>Node number 25</field>
    /// <field name='n26' static='false' type='Number'>Node number 26</field>
    /// <field name='n27' static='false' type='Number'>Node number 27</field>
    /// <field name='n28' static='false' type='Number'>Node number 28</field>
    /// <field name='n29' static='false' type='Number'>Node number 29</field>
    /// <field name='n3' static='false' type='Number'>Node number 3</field>
    /// <field name='n30' static='false' type='Number'>Node number 30</field>
    /// <field name='n31' static='false' type='Number'>Node number 31</field>
    /// <field name='n32' static='false' type='Number'>Node number 32</field>
    /// <field name='n33' static='false' type='Number'>Node number 33</field>
    /// <field name='n34' static='false' type='Number'>Node number 34</field>
    /// <field name='n35' static='false' type='Number'>Node number 35</field>
    /// <field name='n36' static='false' type='Number'>Node number 36</field>
    /// <field name='n37' static='false' type='Number'>Node number 37</field>
    /// <field name='n38' static='false' type='Number'>Node number 38</field>
    /// <field name='n39' static='false' type='Number'>Node number 39</field>
    /// <field name='n4' static='false' type='Number'>Node number 4</field>
    /// <field name='n40' static='false' type='Number'>Node number 40</field>
    /// <field name='n41' static='false' type='Number'>Node number 41</field>
    /// <field name='n42' static='false' type='Number'>Node number 42</field>
    /// <field name='n43' static='false' type='Number'>Node number 43</field>
    /// <field name='n44' static='false' type='Number'>Node number 44</field>
    /// <field name='n45' static='false' type='Number'>Node number 45</field>
    /// <field name='n46' static='false' type='Number'>Node number 46</field>
    /// <field name='n47' static='false' type='Number'>Node number 47</field>
    /// <field name='n48' static='false' type='Number'>Node number 48</field>
    /// <field name='n49' static='false' type='Number'>Node number 49</field>
    /// <field name='n5' static='false' type='Number'>Node number 5</field>
    /// <field name='n50' static='false' type='Number'>Node number 50</field>
    /// <field name='n51' static='false' type='Number'>Node number 51</field>
    /// <field name='n52' static='false' type='Number'>Node number 52</field>
    /// <field name='n53' static='false' type='Number'>Node number 53</field>
    /// <field name='n54' static='false' type='Number'>Node number 54</field>
    /// <field name='n55' static='false' type='Number'>Node number 55</field>
    /// <field name='n56' static='false' type='Number'>Node number 56</field>
    /// <field name='n57' static='false' type='Number'>Node number 57</field>
    /// <field name='n58' static='false' type='Number'>Node number 58</field>
    /// <field name='n59' static='false' type='Number'>Node number 59</field>
    /// <field name='n6' static='false' type='Number'>Node number 6</field>
    /// <field name='n60' static='false' type='Number'>Node number 60</field>
    /// <field name='n61' static='false' type='Number'>Node number 61</field>
    /// <field name='n62' static='false' type='Number'>Node number 62</field>
    /// <field name='n63' static='false' type='Number'>Node number 63</field>
    /// <field name='n64' static='false' type='Number'>Node number 64</field>
    /// <field name='n7' static='false' type='Number'>Node number 7</field>
    /// <field name='n8' static='false' type='Number'>Node number 8</field>
    /// <field name='n9' static='false' type='Number'>Node number 9</field>
    /// <field name='nodes' static='false' type='Number'>Number of nodes solid has (read only)</field>
    /// <field name='ns1' static='false' type='Number'>Scalar Node number 1</field>
    /// <field name='ns2' static='false' type='Number'>Scalar Node number 2</field>
    /// <field name='ns3' static='false' type='Number'>Scalar Node number 3</field>
    /// <field name='ns4' static='false' type='Number'>Scalar Node number 4</field>
    /// <field name='ns5' static='false' type='Number'>Scalar Node number 5</field>
    /// <field name='ns6' static='false' type='Number'>Scalar Node number 6</field>
    /// <field name='ns7' static='false' type='Number'>Scalar Node number 7</field>
    /// <field name='ns8' static='false' type='Number'>Scalar Node number 8</field>
    /// <field name='ortho' static='false' type='Boolean'>If _ORTHO option is set. Can be true or false</field>
    /// <field name='p21' static='false' type='Boolean'>If _P21 option is set. Can be true or false</field>
    /// <field name='p40' static='false' type='Boolean'>If _P40 option is set. Can be true or false</field>
    /// <field name='pid' static='false' type='Number'>Part number</field>
    /// <field name='t15' static='false' type='Boolean'>If _T15 option is set. Can be true or false</field>
    /// <field name='t20' static='false' type='Boolean'>If _T20 option is set. Can be true or false</field>
    /// <field name='tet4totet10' static='false' type='Boolean'>If _TET4TOTET10 option is set. Can be true or false</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the solid (0-100) 0% is opaque, 100% is transparent.</field>
    /// <field name='EDGE_1' static='true' type='Number'>Edge 1 of solid</field>
    /// <field name='EDGE_10' static='true' type='Number'>Edge 10 of solid</field>
    /// <field name='EDGE_11' static='true' type='Number'>Edge 11 of solid</field>
    /// <field name='EDGE_12' static='true' type='Number'>Edge 12 of solid</field>
    /// <field name='EDGE_2' static='true' type='Number'>Edge 2 of solid</field>
    /// <field name='EDGE_3' static='true' type='Number'>Edge 3 of solid</field>
    /// <field name='EDGE_4' static='true' type='Number'>Edge 4 of solid</field>
    /// <field name='EDGE_5' static='true' type='Number'>Edge 5 of solid</field>
    /// <field name='EDGE_6' static='true' type='Number'>Edge 6 of solid</field>
    /// <field name='EDGE_7' static='true' type='Number'>Edge 7 of solid</field>
    /// <field name='EDGE_8' static='true' type='Number'>Edge 8 of solid</field>
    /// <field name='EDGE_9' static='true' type='Number'>Edge 9 of solid</field>
    /// <field name='FACE_1' static='true' type='Number'>Face 1 of solid</field>
    /// <field name='FACE_2' static='true' type='Number'>Face 2 of solid</field>
    /// <field name='FACE_3' static='true' type='Number'>Face 3 of solid</field>
    /// <field name='FACE_4' static='true' type='Number'>Face 4 of solid</field>
    /// <field name='FACE_5' static='true' type='Number'>Face 5 of solid</field>
    /// <field name='FACE_6' static='true' type='Number'>Face 6 of solid</field>
}

Solid.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the solid</summary>
    /// <returns type="null"/>
    /// </signature>
}

Solid.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the solids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all solids will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged solids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged solids will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the solids that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the solid is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Solid.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the solid.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the solid</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.CoordsToIsoparametric = function() {
    /// <signature>
    /// <summary>Calculates the isoparametric coordinates for a point on 3 or 4 noded segment</summary>
    /// <param name="Model" type="Model" optional="false">Model designated model</param>
    /// <param name="x" type="Number" optional="false">X coordinate of point</param>
    /// <param name="y" type="Number" optional="false">Y coordinate of point</param>
    /// <param name="z" type="Number" optional="false">Z coordinate of point</param>
    /// <param name="n1" type="Number" optional="false">node 1 of segment</param>
    /// <param name="n2" type="Number" optional="false">node 2 of segment</param>
    /// <param name="n3" type="Number" optional="false">node 3 of segment</param>
    /// <param name="n4" type="Number" optional="false">node 4 of segment</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

Solid.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the solid.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Solid"/>
    /// </signature>
}

Solid.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a solid.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the solid will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Solid"/>
    /// </signature>
}

Solid.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.ElemCut = function() {
    /// <signature>
    /// <summary>Returns coordinates of the intersections between a solid and a database cross section.</summary>
    /// <param name="Database cross section label" type="Number" optional="false">The label of the database cross section.</param>
    /// <returns type="Object"/>
    /// </signature>
}

Solid.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for solid. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for solid. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the solid colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the solid.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Solid.FindSolidEnd_#deprecated = function() {
    /// <signature>
    /// <summary>Tidy memory allocation incurred by function which finds solids within a box. Now replaced by model member function Model.FindElemEnd()</summary>
    /// <returns type="null"/>
    /// </signature>
}

Solid.FindSolidInBox = function() {
    /// <signature>
    /// <summary>Returns an array of Solid objects for the solids within a box. This requires a previous (outside loop) call to function FindSolidInit(m) or m.FindElemInit() where the process is initialized for flagged solids in the model (typically all solids) and m.FindElemEnd() to close the process. Please note this function provides a list of all solids that could potentially be in the box (using computationally cheap bounding box comparison) it is not a rigorous test of whether the solid is actually in the box. See also Solid.FindSolidInit() See also Model.FindElemInit() See also Model.FindElemEnd()</summary>
    /// <param name="Model" type="Model" optional="false">Model designated model</param>
    /// <param name="xmin" type="Number" optional="false">Minimum bound in global x</param>
    /// <param name="xmax" type="Number" optional="false">Maximum bound in global x</param>
    /// <param name="ymin" type="Number" optional="false">Minimum bound in global y</param>
    /// <param name="ymax" type="Number" optional="false">Maximum bound in global y</param>
    /// <param name="zmin" type="Number" optional="false">Minimum bound in global z</param>
    /// <param name="zmax" type="Number" optional="false">Maximum bound in global z</param>
    /// <param name="hflag" type="Number" optional="true">Optional flag to restrict solids considered</param>
    /// <returns type="Array" elementType="Solid"/>
    /// </signature>
}

Solid.FindSolidInit = function() {
    /// <signature>
    /// <summary>Initialize setup so that all flagged solids in model can be tested to see if they are within box. See also Solid.FindSolidInBox() See also Model.FindElemInit() See also Model.FindElemEnd()</summary>
    /// <param name="Model" type="Model" optional="false">Model in which solids have been flagged</param>
    /// <param name="flag" type="Flag" optional="true">Optional flag that has been set on the solids, if unsupplied all solids considered</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.First = function() {
    /// <signature>
    /// <summary>Returns the first solid in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first solid in</param>
    /// <returns type="Solid"/>
    /// </signature>
}

Solid.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free solid label in the model. Also see Solid.LastFreeLabel(), Solid.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free solid label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Solid.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the solids in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all solids will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the solids</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the solid is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the solid</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Solid.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each solid in the model. Note that ForEach has been designed to make looping over solids as fast as possible and so has some limitations. Firstly, a single temporary Solid object is created and on each function call it is updated with the current solid data. This means that you should not try to store the Solid object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new solids inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all solids are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each solid</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Solid objects for all of the solids in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get solids from</param>
    /// <returns type="Array" elementType="Solid"/>
    /// </signature>
}

Solid.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Solid objects for all of the flagged solids in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get solids from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the solids that you want to retrieve</param>
    /// <returns type="Array" elementType="Solid"/>
    /// </signature>
}

Solid.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Solid object for a solid ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the solid in</param>
    /// <param name="number" type="Number" optional="false">number of the solid you want the Solid object for</param>
    /// <returns type="Solid"/>
    /// </signature>
}

Solid.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Solid property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Solid.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">solid property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Solid.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this solid (*SOLID, *SOLID_SCALAR or *SOLID_SCALAR_VALUE). Note that a carriage return is not added. See also Solid.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Solid.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the solid. Note that a carriage return is not added. See also Solid.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Solid.Last = function() {
    /// <signature>
    /// <summary>Returns the last solid in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last solid in</param>
    /// <returns type="Solid"/>
    /// </signature>
}

Solid.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free solid label in the model. Also see Solid.FirstFreeLabel(), Solid.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free solid label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Solid.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next solid in the model.</summary>
    /// <returns type="Solid"/>
    /// </signature>
}

Solid.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) solid label in the model. Also see Solid.FirstFreeLabel(), Solid.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free solid label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Solid.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a solid.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only solids from that model can be picked. If the argument is a Flag then only solids that are flagged with limit can be selected. If omitted, or null, any solids from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Solid"/>
    /// </signature>
}

Solid.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous solid in the model.</summary>
    /// <returns type="Solid"/>
    /// </signature>
}

Solid.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the solids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all solids will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged solids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged solids will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the solids that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select solids using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting solids</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only solids from that model can be selected. If the argument is a Flag then only solids that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any solids can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Solid.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the solid.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the solid</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the solid. The solid will be sketched until you either call Solid.Unsketch(), Solid.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the solid is sketched. If omitted redraw is true. If you want to sketch several solids and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged solids in the model. The solids will be sketched until you either call Solid.Unsketch(), Solid.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged solids will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the solids that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the solids are sketched. If omitted redraw is true. If you want to sketch flagged solids several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.TetCollapse = function() {
    /// <signature>
    /// <summary>Calculates the tetrahedral collapse for the solid</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Solid.prototype.TiedNodeCheck = function() {
    /// <signature>
    /// <summary>Checks if nodes of solid are tied by contact or directly attached (non-zero option1).</summary>
    /// <param name="Contact label" type="Number" optional="false">The label of the tied contact. If zero the tied contact is found for the solid by reverse lookup.</param>
    /// <param name="Flag" type="Flag" optional="false">flag bit</param>
    /// <param name="Option1" type="Number" optional="false">Directly tied node (logical OR) 0:NONE 1:NRB/C_EXNO 2:BEAM 4:SHELL 8:SOLID 16:TSHELL</param>
    /// <param name="Option2" type="Number" optional="false">0:No action 1:report error if directly attached node (acc. option1) also captured by contact</param>
    /// <returns type="String"/>
    /// </signature>
}

Solid.prototype.Timestep = function() {
    /// <signature>
    /// <summary>Calculates the timestep for the solid</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Solid.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of solids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing solids should be counted. If false or omitted referenced but undefined solids will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Solid.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the solid</summary>
    /// <returns type="null"/>
    /// </signature>
}

Solid.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the solids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all solids will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged solids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged solids will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the solids that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the solids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all solids will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the solids</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the solid.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the solid is unsketched. If omitted redraw is true. If you want to unsketch several solids and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all solids.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all solids will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the solids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged solids in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all solids will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the solids that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the solids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Solid"/>
    /// </signature>
}

Solid.prototype.Volume = function() {
    /// <signature>
    /// <summary>Calculates the volume for the solid</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Solid.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for solid. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Solid.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this solid.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Solid.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the solid data in keyword format. Note that this contains the keyword header and the keyword cards. See also Solid.Keyword() and Solid.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Spc = function() {
    /// <signature>
    /// <summary>Create a new Spc object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that spc will be created in</param>
    /// <param name="nid" type="Number" optional="false">Node ID or node set ID</param>
    /// <param name="cid" type="Number" optional="false">Coordinate system ID</param>
    /// <param name="dofx" type="Number" optional="false">Translational constraint in local x direction</param>
    /// <param name="dofy" type="Number" optional="false">Translational constraint in local y direction</param>
    /// <param name="dofz" type="Number" optional="false">Translational constraint in local z direction</param>
    /// <param name="dofrx" type="Number" optional="false">Rotational constraint in local x direction</param>
    /// <param name="dofry" type="Number" optional="false">Rotational constraint in local y direction</param>
    /// <param name="dofrz" type="Number" optional="false">Rotational constraint in local z direction</param>
    /// <param name="type" type="Number" optional="false">Specify the type of boundary spc (Can be Spc.NODE or Spc.SET)</param>
    /// <param name="label" type="Number" optional="true">Spc number</param>
    /// <param name="heading" type="String" optional="true">Title for the spc</param>
    /// <returns type="Spc"/>
    /// </signature>
    /// <field name='bd_flag' static='false' type='Boolean'>true if _BIRTH_DEATH option is set, false if not</field>
    /// <field name='birth' static='false' type='Number'>Activation time for constraint</field>
    /// <field name='cid' static='false' type='Number'>Coordinate system ID</field>
    /// <field name='death' static='false' type='Number'>Deactivation time for constraint</field>
    /// <field name='dofrx' static='false' type='Number'>Rotational constraint in local x direction</field>
    /// <field name='dofry' static='false' type='Number'>Rotational constraint in local y direction</field>
    /// <field name='dofrz' static='false' type='Number'>Rotational constraint in local z direction</field>
    /// <field name='dofx' static='false' type='Number'>Translational constraint in local x direction</field>
    /// <field name='dofy' static='false' type='Number'>Translational constraint in local y direction</field>
    /// <field name='dofz' static='false' type='Number'>Translational constraint in local z direction</field>
    /// <field name='exists' static='false' type='Boolean'>true if spc exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>Spc heading</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the spc is in.</field>
    /// <field name='label' static='false' type='Number'>Spc number.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the boundary SPC is in.</field>
    /// <field name='nid' static='false' type='Number'>Node ID or node set ID</field>
    /// <field name='type' static='false' type='Number'>The Spc type. Can be Spc.NODE or Spc.SET.</field>
    /// <field name='NODE' static='true' type='Number'>SPC is *BOUNDARY_SPC_NODE.</field>
    /// <field name='ROTATIONAL' static='true' type='Number'>Sketch rotational degrees of freedom.</field>
    /// <field name='SET' static='true' type='Number'>SPC is *BOUNDARY_SPC_SET.</field>
    /// <field name='TRANSLATIONAL' static='true' type='Number'>Sketch translational degrees of freedom.</field>
}

Spc.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the boundary SPC</summary>
    /// <returns type="null"/>
    /// </signature>
}

Spc.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the boundary SPCs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary SPCs will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged boundary SPCs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boundary SPCs will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary SPCs that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the boundary SPC is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Spc.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the boundary SPC.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the boundary SPC</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the boundary SPC.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Spc"/>
    /// </signature>
}

Spc.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for boundary SPC. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.First = function() {
    /// <signature>
    /// <summary>Returns the first boundary SPC in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first boundary SPC in</param>
    /// <returns type="Spc"/>
    /// </signature>
}

Spc.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free boundary SPC label in the model. Also see Spc.LastFreeLabel(), Spc.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free boundary SPC label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spc.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the boundary SPCs in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary SPCs will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the boundary SPCs</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the boundary SPC is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the boundary SPC</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Spc.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each boundary SPC in the model. Note that ForEach has been designed to make looping over boundary SPCs as fast as possible and so has some limitations. Firstly, a single temporary Spc object is created and on each function call it is updated with the current boundary SPC data. This means that you should not try to store the Spc object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boundary SPCs inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary SPCs are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each boundary SPC</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Spc objects for all of the boundary SPCs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boundary SPCs from</param>
    /// <returns type="Array" elementType="Spc"/>
    /// </signature>
}

Spc.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Spc objects for all of the flagged boundary SPCs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get boundary SPCs from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary SPCs that you want to retrieve</param>
    /// <returns type="Array" elementType="Spc"/>
    /// </signature>
}

Spc.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Spc object for a boundary SPC ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the boundary SPC in</param>
    /// <param name="number" type="Number" optional="false">number of the boundary SPC you want the Spc object for</param>
    /// <returns type="Spc"/>
    /// </signature>
}

Spc.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Spc property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Spc.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">boundary SPC property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Spc.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this spc (*BOUNDARY_SPC_xxxx). Note that a carriage return is not added. See also Spc.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Spc.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the spc. Note that a carriage return is not added. See also Spc.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Spc.Last = function() {
    /// <signature>
    /// <summary>Returns the last boundary SPC in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last boundary SPC in</param>
    /// <returns type="Spc"/>
    /// </signature>
}

Spc.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free boundary SPC label in the model. Also see Spc.FirstFreeLabel(), Spc.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free boundary SPC label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spc.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next boundary SPC in the model.</summary>
    /// <returns type="Spc"/>
    /// </signature>
}

Spc.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) boundary SPC label in the model. Also see Spc.FirstFreeLabel(), Spc.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free boundary SPC label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spc.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a boundary SPC.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boundary SPCs from that model can be picked. If the argument is a Flag then only boundary SPCs that are flagged with limit can be selected. If omitted, or null, any boundary SPCs from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Spc"/>
    /// </signature>
}

Spc.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous boundary SPC in the model.</summary>
    /// <returns type="Spc"/>
    /// </signature>
}

Spc.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the boundary SPCs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary SPCs will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged boundary SPCs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boundary SPCs will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary SPCs that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select boundary SPCs using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting boundary SPCs</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only boundary SPCs from that model can be selected. If the argument is a Flag then only boundary SPCs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boundary SPCs can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spc.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the boundary SPC.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the boundary SPC</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the Boundary SPC. The SPC will be sketched until you do a graphics update or delete the model</summary>
    /// <param name="type" type="Number" optional="false">Type of constraints to be drawn. Can be Spc.TRANSLATIONAL or Spc.ROTATIONAL.</param>
    /// <param name="redraw" type="Boolean" optional="true">If set to true (or omitted) the plot will be redrawn each time. If sketching a large number of items, efficiency will be gained by setting the argument to false for all but the last item sketched. The final call will redraw.</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all the flagged boundary SPCs in the model and update the plot. The SPCs will be sketched until you do a graphics update or delete the model.</summary>
    /// <param name="type" type="Number" optional="false">Type of constraints to be drawn. Can be Spc.TRANSLATIONAL or Spc.ROTATIONAL.</param>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged boundary SPCs will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary SPCs that you want to sketch</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of boundary SPCs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing boundary SPCs should be counted. If false or omitted referenced but undefined boundary SPCs will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spc.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the boundary SPC</summary>
    /// <returns type="null"/>
    /// </signature>
}

Spc.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the boundary SPCs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all boundary SPCs will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged boundary SPCs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged boundary SPCs will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the boundary SPCs that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the boundary SPCs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all boundary SPCs will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the boundary SPCs</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the Spc.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If set to true (or omitted) the plot will be redrawn each time. If unsketching a large number of items, efficiency will be gained by setting the argument to false for all but the last item unsketched. The final call will redraw.</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all SPCs.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all SPCs will be unblanked in</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged SPCs.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all SPCs will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the SPCs that you want to unsketch</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Spc"/>
    /// </signature>
}

Spc.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for boundary SPC. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Spc.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this boundary SPC.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Spc.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the spc data in keyword format. Note that this contains the keyword header and the keyword cards. See also Spc.Keyword() and Spc.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Sph = function() {
    /// <signature>
    /// <summary>Create a new  object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that sph will be created in</param>
    /// <param name="nid" type="Number" optional="false">Node ID and Element ID are the same for the SPH option.</param>
    /// <param name="pid" type="Number" optional="false">Part ID to which this element belongs.</param>
    /// <param name="mass" type="Number" optional="false">Mass value.</param>
    /// <returns type="Sph"/>
    /// </signature>
    /// <field name='colour' static='false' type='Colour'>The colour of the sph element.</field>
    /// <field name='exists' static='false' type='Boolean'>true if sph exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the sph is in.</field>
    /// <field name='mass' static='false' type='Number'>Mass value.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the sph is in.</field>
    /// <field name='nid' static='false' type='Number'>Node ID.</field>
    /// <field name='pid' static='false' type='Number'>Part ID to which this element belongs.</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the sph (0-100) 0% is opaque, 100% is transparent.</field>
}

Sph.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the sph</summary>
    /// <returns type="null"/>
    /// </signature>
}

Sph.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the sphs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sphs will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged sphs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sphs will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sphs that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the sph is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Sph.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the sph.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the sph</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the sph.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Sph"/>
    /// </signature>
}

Sph.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an sph.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the sph will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Sph"/>
    /// </signature>
}

Sph.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for sph. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for sph. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the sph colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the sph.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Sph.First = function() {
    /// <signature>
    /// <summary>Returns the first sph in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first sph in</param>
    /// <returns type="Sph"/>
    /// </signature>
}

Sph.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free sph label in the model. Also see Sph.LastFreeLabel(), Sph.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free sph label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sph.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the sphs in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sphs will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the sphs</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the sph is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the sph</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Sph.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each sph in the model. Note that ForEach has been designed to make looping over sphs as fast as possible and so has some limitations. Firstly, a single temporary Sph object is created and on each function call it is updated with the current sph data. This means that you should not try to store the Sph object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new sphs inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all sphs are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each sph</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Sph objects for all of the sphs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sphs from</param>
    /// <returns type="Array" elementType="Sph"/>
    /// </signature>
}

Sph.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Sph objects for all of the flagged sphs in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get sphs from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sphs that you want to retrieve</param>
    /// <returns type="Array" elementType="Sph"/>
    /// </signature>
}

Sph.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Sph object for a sph ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the sph in</param>
    /// <param name="number" type="Number" optional="false">number of the sph you want the Sph object for</param>
    /// <returns type="Sph"/>
    /// </signature>
}

Sph.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Sph property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Sph.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">sph property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Sph.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this sph (*ELEMENT_SPH) Note that a carriage return is not added. See also Sph.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Sph.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the sph. Note that a carriage return is not added. See also Sph.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Sph.Last = function() {
    /// <signature>
    /// <summary>Returns the last sph in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last sph in</param>
    /// <returns type="Sph"/>
    /// </signature>
}

Sph.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free sph label in the model. Also see Sph.FirstFreeLabel(), Sph.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free sph label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sph.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next sph in the model.</summary>
    /// <returns type="Sph"/>
    /// </signature>
}

Sph.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) sph label in the model. Also see Sph.FirstFreeLabel(), Sph.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free sph label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sph.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a sph.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sphs from that model can be picked. If the argument is a Flag then only sphs that are flagged with limit can be selected. If omitted, or null, any sphs from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Sph"/>
    /// </signature>
}

Sph.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous sph in the model.</summary>
    /// <returns type="Sph"/>
    /// </signature>
}

Sph.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the sphs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sphs will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged sphs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sphs will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sphs that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select sphs using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting sphs</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only sphs from that model can be selected. If the argument is a Flag then only sphs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sphs can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sph.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the sph.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the sph</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the sph. The sph will be sketched until you either call Sph.Unsketch(), Sph.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sph is sketched. If omitted redraw is true. If you want to sketch several sphs and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged sphs in the model. The sphs will be sketched until you either call Sph.Unsketch(), Sph.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged sphs will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sphs that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sphs are sketched. If omitted redraw is true. If you want to sketch flagged sphs several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of sphs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing sphs should be counted. If false or omitted referenced but undefined sphs will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sph.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the sph</summary>
    /// <returns type="null"/>
    /// </signature>
}

Sph.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the sphs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sphs will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged sphs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged sphs will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sphs that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the sphs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all sphs will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the sphs</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the sph.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sph is unsketched. If omitted redraw is true. If you want to unsketch several sphs and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all sphs.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sphs will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sphs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged sphs in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all sphs will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the sphs that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the sphs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Sph"/>
    /// </signature>
}

Sph.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for sph. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Sph.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this sph.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Sph.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the sph data in keyword format. Note that this contains the keyword header and the keyword cards. See also Sph.Keyword() and Sph.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Spotweld = function() {
    /// <signature>
    /// <summary>Create a new Spotweld object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained spotweld will be created in</param>
    /// <param name="n1" type="Number" optional="false">Node ID 1</param>
    /// <param name="n2" type="Number" optional="false">Node ID 2</param>
    /// <param name="label" type="Number" optional="true">Constrained spotweld number</param>
    /// <returns type="Spotweld"/>
    /// </signature>
    /// <field name='ep' static='false' type='Number'>Effective plastic strain at failure</field>
    /// <field name='exists' static='false' type='Boolean'>true if constrained spotweld exists, false if referred to but not defined. (read only)</field>
    /// <field name='filtered_force' static='false' type='Boolean'>true if _FILTERED_FORCE option is set, false if not</field>
    /// <field name='id' static='false' type='Boolean'>true if _ID option is set, false if not</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the constrained spotweld is in.</field>
    /// <field name='label' static='false' type='Number'>Constrained spotweld number</field>
    /// <field name='m' static='false' type='Number'>Exponent for shear spotweld force</field>
    /// <field name='model' static='false' type='Number'>The Model number that the spotweld is in.</field>
    /// <field name='n' static='false' type='Number'>Exponent for normal spotweld force</field>
    /// <field name='n1' static='false' type='Number'>Node ID</field>
    /// <field name='n2' static='false' type='Number'>Node ID</field>
    /// <field name='nf' static='false' type='Number'>Number of force vectors stored for filtering</field>
    /// <field name='sn' static='false' type='Number'>Normal force at spotweld failure</field>
    /// <field name='ss' static='false' type='Number'>Shear force at spotweld failure</field>
    /// <field name='tf' static='false' type='Number'>Failure time for nodal constraint set</field>
    /// <field name='tw' static='false' type='Number'>Time window for filtering</field>
    /// <field name='wid' static='false' type='Number'>Constrained spotweld number (identical to label)</field>
}

Spotweld.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the spotweld</summary>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spotwelds will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged spotwelds will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spotwelds that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the spotweld is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Spotweld.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the spotweld.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the spotweld</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the spotweld.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Spotweld"/>
    /// </signature>
}

Spotweld.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a spotweld.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the spotweld will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Spotweld"/>
    /// </signature>
}

Spotweld.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for spotweld. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.First = function() {
    /// <signature>
    /// <summary>Returns the first spotweld in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first spotweld in</param>
    /// <returns type="Spotweld"/>
    /// </signature>
}

Spotweld.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free spotweld label in the model. Also see Spotweld.LastFreeLabel(), Spotweld.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free spotweld label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spotweld.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the spotwelds in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spotwelds will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the spotwelds</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the spotweld is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the spotweld</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Spotweld.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each spotweld in the model. Note that ForEach has been designed to make looping over spotwelds as fast as possible and so has some limitations. Firstly, a single temporary Spotweld object is created and on each function call it is updated with the current spotweld data. This means that you should not try to store the Spotweld object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new spotwelds inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all spotwelds are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each spotweld</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Spotweld objects for all of the spotwelds in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get spotwelds from</param>
    /// <returns type="Array" elementType="Spotweld"/>
    /// </signature>
}

Spotweld.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Spotweld objects for all of the flagged spotwelds in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get spotwelds from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spotwelds that you want to retrieve</param>
    /// <returns type="Array" elementType="Spotweld"/>
    /// </signature>
}

Spotweld.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Spotweld object for a spotweld ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the spotweld in</param>
    /// <param name="number" type="Number" optional="false">number of the spotweld you want the Spotweld object for</param>
    /// <returns type="Spotweld"/>
    /// </signature>
}

Spotweld.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Spotweld property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Spotweld.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">spotweld property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Spotweld.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this spotweld (*CONSTRAINED_SPOTWELD). Note that a carriage return is not added. See also Spotweld.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Spotweld.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the spotweld. Note that a carriage return is not added. See also Spotweld.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Spotweld.Last = function() {
    /// <signature>
    /// <summary>Returns the last spotweld in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last spotweld in</param>
    /// <returns type="Spotweld"/>
    /// </signature>
}

Spotweld.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free spotweld label in the model. Also see Spotweld.FirstFreeLabel(), Spotweld.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free spotweld label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spotweld.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next spotweld in the model.</summary>
    /// <returns type="Spotweld"/>
    /// </signature>
}

Spotweld.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) spotweld label in the model. Also see Spotweld.FirstFreeLabel(), Spotweld.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free spotweld label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spotweld.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a spotweld.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only spotwelds from that model can be picked. If the argument is a Flag then only spotwelds that are flagged with limit can be selected. If omitted, or null, any spotwelds from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Spotweld"/>
    /// </signature>
}

Spotweld.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous spotweld in the model.</summary>
    /// <returns type="Spotweld"/>
    /// </signature>
}

Spotweld.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spotwelds will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged spotwelds will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spotwelds that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select spotwelds using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting spotwelds</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only spotwelds from that model can be selected. If the argument is a Flag then only spotwelds that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any spotwelds can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spotweld.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the spotweld.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the spotweld</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the spotweld. The spotweld will be sketched until you either call Spotweld.Unsketch(), Spotweld.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spotweld is sketched. If omitted redraw is true. If you want to sketch several spotwelds and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged spotwelds in the model. The spotwelds will be sketched until you either call Spotweld.Unsketch(), Spotweld.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged spotwelds will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spotwelds that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spotwelds are sketched. If omitted redraw is true. If you want to sketch flagged spotwelds several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing spotwelds should be counted. If false or omitted referenced but undefined spotwelds will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spotweld.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the spotweld</summary>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spotwelds will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged spotwelds will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spotwelds that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all spotwelds will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the spotwelds</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the spotweld.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spotweld is unsketched. If omitted redraw is true. If you want to unsketch several spotwelds and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all spotwelds.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spotwelds will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spotwelds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged spotwelds in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spotwelds will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spotwelds that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spotwelds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Spotweld"/>
    /// </signature>
}

Spotweld.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for spotweld. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Spotweld.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this spotweld.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Spotweld.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the spotweld data in keyword format. Note that this contains the keyword header and the keyword cards. See also Spotweld.Keyword() and Spotweld.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Spr2 = function() {
    /// <signature>
    /// <summary>Create a new Spr2 object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained spr2 will be created in</param>
    /// <param name="mid" type="Number" optional="false">Master Sheet Part ID.</param>
    /// <param name="sid" type="Number" optional="false">Slave Sheet Part ID</param>
    /// <param name="nsid" type="Number" optional="false">Node Set ID of rivet location nodes.</param>
    /// <returns type="Spr2"/>
    /// </signature>
    /// <field name='alpha1' static='false' type='Number'>Dimensionless parameter scaling the effective displacement.</field>
    /// <field name='alpha2' static='false' type='Number'>Dimensionless parameter scaling the effective displacement.</field>
    /// <field name='alpha3' static='false' type='Number'>Dimensionless parameter scaling the effective displacement. ( GT.0: incremental update (default), LT.0: total update (recommended) )</field>
    /// <field name='d' static='false' type='Number'>Rivet diameter.</field>
    /// <field name='dens' static='false' type='Number'>Rivet density (necessary for time step calculation).</field>
    /// <field name='dn' static='false' type='Number'>Failure displacement in normal direction.</field>
    /// <field name='dt' static='false' type='Number'>Failure displacement in tangential direction.</field>
    /// <field name='exists' static='false' type='Boolean'>true if constrained spr2 exists, false if referred to but not defined. (read only)</field>
    /// <field name='expn' static='false' type='Number'>Exponent value for load function in normal direction.</field>
    /// <field name='expt' static='false' type='Number'>Exponent value for load function in tangential direction.</field>
    /// <field name='fn' static='false' type='Number'>Rivet strength in tension (pull-out).</field>
    /// <field name='ft' static='false' type='Number'>Rivet strength in pure shear.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the constrained spr2 is in.</field>
    /// <field name='intp' static='false' type='Number'>Flag for interpolation. Values can be Spr2.LINEAR, Spr2.UNIFORM or Spr2.INVERSE.</field>
    /// <field name='mid' static='false' type='Number'>Master Sheet Part ID.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the spr2 is in.</field>
    /// <field name='nsid' static='false' type='Number'>Node Set ID of rivet location nodes.</field>
    /// <field name='pidvb' static='false' type='Number'>Part ID for visualization beams representing SPR2 in postprocessing.</field>
    /// <field name='sid' static='false' type='Number'>Slave Sheet Part ID.</field>
    /// <field name='thick' static='false' type='Number'>Total thickness of master and slave sheet.</field>
    /// <field name='xin' static='false' type='Number'>Fraction of failure displacement at maximum normal force.</field>
    /// <field name='xit' static='false' type='Number'>Fraction of failure displacement at maximum tangential force.</field>
    /// <field name='xpid1' static='false' type='Number'>Extra Part ID 1 for multi-sheet connection.</field>
    /// <field name='xpid2' static='false' type='Number'>Extra Part ID 2 for multi-sheet connection.</field>
    /// <field name='xpid3' static='false' type='Number'>Extra Part ID 3 for multi-sheet connection.</field>
    /// <field name='xpid4' static='false' type='Number'>Extra Part ID 4 for multi-sheet connection.</field>
    /// <field name='INVERSE' static='true' type='Number'>Property INTP value EQ.2.0: Inverse distance weighting.</field>
    /// <field name='LINEAR' static='true' type='Number'>Property INTP value EQ.0.0: Linear (default).</field>
    /// <field name='UNIFORM' static='true' type='Number'>Property INTP value EQ.1.0: Uniform.</field>
}

Spr2.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the spr2</summary>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the spr2s in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spr2s will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged spr2s in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged spr2s will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spr2s that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the spr2 is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Spr2.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the spr2.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the spr2</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the spr2.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Spr2"/>
    /// </signature>
}

Spr2.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for spr2. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.First = function() {
    /// <signature>
    /// <summary>Returns the first spr2 in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first spr2 in</param>
    /// <returns type="Spr2"/>
    /// </signature>
}

Spr2.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the spr2s in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spr2s will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the spr2s</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the spr2 is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the spr2</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Spr2.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each spr2 in the model. Note that ForEach has been designed to make looping over spr2s as fast as possible and so has some limitations. Firstly, a single temporary Spr2 object is created and on each function call it is updated with the current spr2 data. This means that you should not try to store the Spr2 object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new spr2s inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all spr2s are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each spr2</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Spr2 objects for all of the spr2s in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get spr2s from</param>
    /// <returns type="Array" elementType="Spr2"/>
    /// </signature>
}

Spr2.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Spr2 objects for all of the flagged spr2s in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get spr2s from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spr2s that you want to retrieve</param>
    /// <returns type="Array" elementType="Spr2"/>
    /// </signature>
}

Spr2.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Spr2 object for a spr2 ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the spr2 in</param>
    /// <param name="number" type="Number" optional="false">number of the spr2 you want the Spr2 object for</param>
    /// <returns type="Spr2"/>
    /// </signature>
}

Spr2.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Spr2 property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Spr2.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">spr2 property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Spr2.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this spr2 (*CONSTRAINED_SPR2). Note that a carriage return is not added. See also Spr2.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Spr2.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the spr2. Note that a carriage return is not added. See also Spr2.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Spr2.Last = function() {
    /// <signature>
    /// <summary>Returns the last spr2 in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last spr2 in</param>
    /// <returns type="Spr2"/>
    /// </signature>
}

Spr2.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next spr2 in the model.</summary>
    /// <returns type="Spr2"/>
    /// </signature>
}

Spr2.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a spr2.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only spr2s from that model can be picked. If the argument is a Flag then only spr2s that are flagged with limit can be selected. If omitted, or null, any spr2s from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Spr2"/>
    /// </signature>
}

Spr2.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous spr2 in the model.</summary>
    /// <returns type="Spr2"/>
    /// </signature>
}

Spr2.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select spr2s using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting spr2s</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only spr2s from that model can be selected. If the argument is a Flag then only spr2s that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any spr2s can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spr2.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the spr2.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the spr2</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the spr2. The spr2 will be sketched until you either call Spr2.Unsketch(), Spr2.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spr2 is sketched. If omitted redraw is true. If you want to sketch several spr2s and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged spr2s in the model. The spr2s will be sketched until you either call Spr2.Unsketch(), Spr2.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged spr2s will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spr2s that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spr2s are sketched. If omitted redraw is true. If you want to sketch flagged spr2s several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of spr2s in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing spr2s should be counted. If false or omitted referenced but undefined spr2s will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Spr2.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the spr2</summary>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the spr2s in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spr2s will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged spr2s in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged spr2s will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spr2s that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the spr2s in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all spr2s will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the spr2s</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the spr2.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spr2 is unsketched. If omitted redraw is true. If you want to unsketch several spr2s and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all spr2s.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spr2s will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spr2s are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged spr2s in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all spr2s will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the spr2s that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the spr2s are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Spr2"/>
    /// </signature>
}

Spr2.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for spr2. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Spr2.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this spr2.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Spr2.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the spr2 data in keyword format. Note that this contains the keyword header and the keyword cards. See also Spr2.Keyword() and Spr2.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var StagedConstructionPart = function() {
    /// <signature>
    /// <summary>Create a new StagedConstructionPart object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that Define staged construction parts will be created in</param>
    /// <param name="option" type="Number" optional="false">Specify the type of Define staged construction parts. Can be StagedConstructionPart.PART or StagedConstructionPart.SET)</param>
    /// <param name="id" type="Number" optional="false">Part ID or part set ID</param>
    /// <param name="stga" type="Number" optional="false">Construction stage at which part is added.</param>
    /// <param name="stgr" type="Number" optional="false">Construction stage at which part is removed.</param>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if Define staged construction parts exists, false if referred to but not defined (read only)</field>
    /// <field name='id' static='false' type='Number'>Part ID or part set ID (not internal label)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the Define staged construction parts is in.</field>
    /// <field name='label' static='false' type='Number'>The label the Define staged construction parts has in PRIMER (read only)</field>
    /// <field name='model' static='false' type='Number'>The Model number that the Define staged construction part is in.</field>
    /// <field name='option' static='false' type='Number'>The Define staged construction parts option. Can be StagedConstructionPart.PART or StagedConstructionPart.SET.</field>
    /// <field name='stga' static='false' type='Number'>Construction stage at which part is added.</field>
    /// <field name='stgr' static='false' type='Number'>Construction stage at which part is removed.</field>
    /// <field name='PART' static='true' type='Number'>DEFN is *DEFINE_STAGED_CONSTRUCTION_PART.</field>
    /// <field name='SET' static='true' type='Number'>DEFN is *DEFINE_STAGED_CONSTRUCTION_PART_SET.</field>
}

StagedConstructionPart.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the Define staged construction part</summary>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the Define staged construction parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all Define staged construction parts will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged Define staged construction parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged Define staged construction parts will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the Define staged construction parts that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the Define staged construction part is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

StagedConstructionPart.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the Define staged construction part.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the Define staged construction part</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the Define staged construction part.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a Define staged construction parts card.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the Define staged construction parts card will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for Define staged construction part. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.First = function() {
    /// <signature>
    /// <summary>Returns the first Define staged construction part in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first Define staged construction part in</param>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the Define staged construction parts in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all Define staged construction parts will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the Define staged construction parts</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the Define staged construction part is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the Define staged construction part</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

StagedConstructionPart.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each Define staged construction part in the model. Note that ForEach has been designed to make looping over Define staged construction parts as fast as possible and so has some limitations. Firstly, a single temporary StagedConstructionPart object is created and on each function call it is updated with the current Define staged construction part data. This means that you should not try to store the StagedConstructionPart object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new Define staged construction parts inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all Define staged construction parts are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each Define staged construction part</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of StagedConstructionPart objects for all of the Define staged construction parts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get Define staged construction parts from</param>
    /// <returns type="Array" elementType="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of StagedConstructionPart objects for all of the flagged Define staged construction parts in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get Define staged construction parts from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the Define staged construction parts that you want to retrieve</param>
    /// <returns type="Array" elementType="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the StagedConstructionPart object for a Define staged construction part ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the Define staged construction part in</param>
    /// <param name="number" type="Number" optional="false">number of the Define staged construction part you want the StagedConstructionPart object for</param>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a StagedConstructionPart property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the StagedConstructionPart.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">Define staged construction part property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

StagedConstructionPart.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this Define staged construction parts (*Define_staged_construction_part). Note that a carriage return is not added. See also StagedConstructionPart.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

StagedConstructionPart.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the Define staged construction parts. Note that a carriage return is not added. See also StagedConstructionPart.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

StagedConstructionPart.Last = function() {
    /// <signature>
    /// <summary>Returns the last Define staged construction part in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last Define staged construction part in</param>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next Define staged construction part in the model.</summary>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a Define staged construction part.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only Define staged construction parts from that model can be picked. If the argument is a Flag then only Define staged construction parts that are flagged with limit can be selected. If omitted, or null, any Define staged construction parts from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous Define staged construction part in the model.</summary>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select Define staged construction parts using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting Define staged construction parts</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only Define staged construction parts from that model can be selected. If the argument is a Flag then only Define staged construction parts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any Define staged construction parts can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

StagedConstructionPart.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the Define staged construction part.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the Define staged construction part</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the Define staged construction part. The Define staged construction part will be sketched until you either call StagedConstructionPart.Unsketch(), StagedConstructionPart.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the Define staged construction part is sketched. If omitted redraw is true. If you want to sketch several Define staged construction parts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged Define staged construction parts in the model. The Define staged construction parts will be sketched until you either call StagedConstructionPart.Unsketch(), StagedConstructionPart.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged Define staged construction parts will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the Define staged construction parts that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the Define staged construction parts are sketched. If omitted redraw is true. If you want to sketch flagged Define staged construction parts several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of Define staged construction parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing Define staged construction parts should be counted. If false or omitted referenced but undefined Define staged construction parts will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

StagedConstructionPart.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the Define staged construction part</summary>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the Define staged construction parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all Define staged construction parts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged Define staged construction parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged Define staged construction parts will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the Define staged construction parts that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the Define staged construction parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all Define staged construction parts will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the Define staged construction parts</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the Define staged construction part.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the Define staged construction part is unsketched. If omitted redraw is true. If you want to unsketch several Define staged construction parts and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all Define staged construction parts.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all Define staged construction parts will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the Define staged construction parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged Define staged construction parts in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all Define staged construction parts will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the Define staged construction parts that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the Define staged construction parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="StagedConstructionPart"/>
    /// </signature>
}

StagedConstructionPart.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for Define staged construction part. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

StagedConstructionPart.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this Define staged construction part.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

StagedConstructionPart.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the Define staged construction parts data in keyword format. Note that this contains the keyword header and the keyword cards. See also StagedConstructionPart.Keyword() and StagedConstructionPart.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var StressSection = function() {
    /// <signature>
    /// <summary>Create a new StressSection object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that stress section will be created in</param>
    /// <param name="issid" type="Number" optional="false">StressSection number.</param>
    /// <param name="csid" type="Number" optional="false">Cross section ID.</param>
    /// <param name="lcid" type="Number" optional="false">Load curve ID defining preload stress versus time.</param>
    /// <param name="psid" type="Number" optional="false">Part set ID.</param>
    /// <param name="vid" type="Number" optional="false">Vector ID.</param>
    /// <param name="izshear" type="Number" optional="false">Shear stress flag.</param>
    /// <param name="istiff" type="Number" optional="true">Load curve ID defining artificial stress fraction versus time.</param>
    /// <returns type="StressSection"/>
    /// </signature>
    /// <field name='csid' static='false' type='Number'>Cross section ID.</field>
    /// <field name='exists' static='false' type='Boolean'>true if stress section exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the stress section is in.</field>
    /// <field name='issid' static='false' type='Number'>StressSection number. Also see the label property which is an alternative name for this.</field>
    /// <field name='istiff' static='false' type='Number'>Load curve ID defining the artificial stress fraction versus time.</field>
    /// <field name='izshear' static='false' type='Number'>Shear stress flag.</field>
    /// <field name='label' static='false' type='Number'>StressSection number. Also see the issid property which is an alternative name for this.</field>
    /// <field name='lcid' static='false' type='Number'>Load curve ID defining preload stress versus time.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the stress section is in.</field>
    /// <field name='psid' static='false' type='Number'>Part set ID.</field>
    /// <field name='vid' static='false' type='Number'>Vector ID defining the direction normal to the cross section.</field>
}

StressSection.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the stress section</summary>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the stress sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all stress sections will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged stress sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged stress sections will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the stress sections that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the stress section is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

StressSection.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the stress section.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the stress section</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the stress section.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="StressSection"/>
    /// </signature>
}

StressSection.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a initial stress section definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the stress section will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="StressSection"/>
    /// </signature>
}

StressSection.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for stress section. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.First = function() {
    /// <signature>
    /// <summary>Returns the first stress section in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first stress section in</param>
    /// <returns type="StressSection"/>
    /// </signature>
}

StressSection.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free stress section label in the model. Also see StressSection.LastFreeLabel(), StressSection.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free stress section label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

StressSection.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the stress sections in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all stress sections will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the stress sections</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the stress section is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the stress section</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

StressSection.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each stress section in the model. Note that ForEach has been designed to make looping over stress sections as fast as possible and so has some limitations. Firstly, a single temporary StressSection object is created and on each function call it is updated with the current stress section data. This means that you should not try to store the StressSection object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new stress sections inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all stress sections are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each stress section</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of StressSection objects for all of the stress sections in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get stress sections from</param>
    /// <returns type="Array" elementType="StressSection"/>
    /// </signature>
}

StressSection.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of StressSection objects for all of the flagged stress sections in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get stress sections from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the stress sections that you want to retrieve</param>
    /// <returns type="Array" elementType="StressSection"/>
    /// </signature>
}

StressSection.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the StressSection object for a stress section ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the stress section in</param>
    /// <param name="number" type="Number" optional="false">number of the stress section you want the StressSection object for</param>
    /// <returns type="StressSection"/>
    /// </signature>
}

StressSection.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a StressSection property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the StressSection.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">stress section property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

StressSection.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this stress section. Note that a carriage return is not added. See also StressSection.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

StressSection.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the stress section. Note that a carriage return is not added. See also StressSection.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

StressSection.Last = function() {
    /// <signature>
    /// <summary>Returns the last stress section in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last stress section in</param>
    /// <returns type="StressSection"/>
    /// </signature>
}

StressSection.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free stress section label in the model. Also see StressSection.FirstFreeLabel(), StressSection.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free stress section label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

StressSection.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next stress section in the model.</summary>
    /// <returns type="StressSection"/>
    /// </signature>
}

StressSection.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) stress section label in the model. Also see StressSection.FirstFreeLabel(), StressSection.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free stress section label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

StressSection.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous stress section in the model.</summary>
    /// <returns type="StressSection"/>
    /// </signature>
}

StressSection.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the stress sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all stress sections will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged stress sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged stress sections will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the stress sections that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select stress sections using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting stress sections</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only stress sections from that model can be selected. If the argument is a Flag then only stress sections that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any stress sections can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

StressSection.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the stress section.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the stress section</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the stress section. The stress section will be sketched until you either call StressSection.Unsketch(), StressSection.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the stress section is sketched. If omitted redraw is true. If you want to sketch several stress sections and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged stress sections in the model. The stress sections will be sketched until you either call StressSection.Unsketch(), StressSection.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged stress sections will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the stress sections that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the stress sections are sketched. If omitted redraw is true. If you want to sketch flagged stress sections several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of stress sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing stress sections should be counted. If false or omitted referenced but undefined stress sections will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

StressSection.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the stress section</summary>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the stress sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all stress sections will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged stress sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged stress sections will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the stress sections that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the stress sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all stress sections will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the stress sections</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the stress section.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the stress section is unsketched. If omitted redraw is true. If you want to unsketch several stress sections and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all stress sections.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all stress sections will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the stress sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged stress sections in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all stress sections will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the stress sections that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the stress sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="StressSection"/>
    /// </signature>
}

StressSection.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for stress section. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

StressSection.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this stress section.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

StressSection.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the stress section data in keyword format. Note that this contains the keyword header and the keyword cards. See also StressSection.Keyword() and StressSection.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var StressShell = function() {
    /// <signature>
    /// <summary>Create a new StressShell object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that stress_shell will be created in</param>
    /// <param name="type" type="Number" optional="false">Specify the type of initial stress shell (Can be StressShell.SHELL or StressShell.SET)</param>
    /// <param name="eid" type="Number" optional="false">Node Element ID or shell set ID</param>
    /// <param name="nplane" type="Number" optional="false">Number of in plane integration points being output</param>
    /// <param name="nthick" type="Number" optional="false">Number of integration points through the thickness</param>
    /// <param name="nhisv" type="Number" optional="false">Number of additional history variables</param>
    /// <param name="ntensr" type="Number" optional="false">Number of components of tensor data taken from the element history variables stored</param>
    /// <returns type="StressShell"/>
    /// </signature>
    /// <field name='eid' static='false' type='Number'>Node Element ID or shell set ID</field>
    /// <field name='exists' static='false' type='Boolean'>true if stress_shell exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the initial stress shell is in.</field>
    /// <field name='large' static='false' type='Boolean'>true if large format, false otherwise</field>
    /// <field name='model' static='false' type='Number'>The Model number that the initial stress shell is in.</field>
    /// <field name='nhisv' static='false' type='Number'>Number of additional history variables</field>
    /// <field name='nplane' static='false' type='Number'>Number of in plane integration points being output</field>
    /// <field name='ntensr' static='false' type='Number'>Number of components of tensor data taken from the element history variables stored</field>
    /// <field name='nthhsv' static='false' type='Number'>Number of thermal history variables per thermal integration point</field>
    /// <field name='nthick' static='false' type='Number'>Number of integration points through the thickness</field>
    /// <field name='nthint' static='false' type='Number'>Number of thermal integration points</field>
    /// <field name='type' static='false' type='Number'>The Intial stress shell type. Can be StressShell.SHELL or StressShell.SET.</field>
    /// <field name='SET' static='true' type='Number'>Initial is *INITIAL_STRESS_SHELL_SET.</field>
    /// <field name='SHELL' static='true' type='Number'>Initial is *INITIAL_STRESS_SHELL.</field>
}

StressShell.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the initial stress shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the initial stress shell</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the initial stress shell.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="StressShell"/>
    /// </signature>
}

StressShell.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for initial stress shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.First = function() {
    /// <signature>
    /// <summary>Returns the first initial stress shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first initial stress shell in</param>
    /// <returns type="StressShell"/>
    /// </signature>
}

StressShell.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the initial stress shells in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial stress shells will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the initial stress shells</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the initial stress shell is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the initial stress shell</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

StressShell.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each initial stress shell in the model. Note that ForEach has been designed to make looping over initial stress shells as fast as possible and so has some limitations. Firstly, a single temporary StressShell object is created and on each function call it is updated with the current initial stress shell data. This means that you should not try to store the StressShell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new initial stress shells inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial stress shells are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each initial stress shell</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of StressShell objects for all of the initial stress shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get initial stress shells from</param>
    /// <returns type="Array" elementType="StressShell"/>
    /// </signature>
}

StressShell.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of StressShell objects for all of the flagged initial stress shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get initial stress shells from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial stress shells that you want to retrieve</param>
    /// <returns type="Array" elementType="StressShell"/>
    /// </signature>
}

StressShell.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the StressShell object for a initial stress shell ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the initial stress shell in</param>
    /// <param name="number" type="Number" optional="false">number of the initial stress shell you want the StressShell object for</param>
    /// <returns type="StressShell"/>
    /// </signature>
}

StressShell.prototype.GetHisvData_#deprecated = function() {
    /// <signature>
    /// <summary>Please use StressShell.GetIntegrationPoint() instead.</summary>
    /// </signature>
}

StressShell.prototype.GetIntegrationPoint = function() {
    /// <signature>
    /// <summary>Returns the data for a specific integration point as an array. For each integration point there will be 8 + nhisv + (6 x ntensr) values. There are nplane x nthick integration points.</summary>
    /// <param name="index" type="Number" optional="false">Index you want the integration point data for. Note that indices start at 0.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

StressShell.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a StressShell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the StressShell.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">initial stress shell property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

StressShell.prototype.GetStressData_#deprecated = function() {
    /// <signature>
    /// <summary>Please use StressShell.GetIntegrationPoint() instead.</summary>
    /// </signature>
}

StressShell.prototype.GetTensrData_#deprecated = function() {
    /// <signature>
    /// <summary>Please use StressShell.GetIntegrationPoint() instead.</summary>
    /// </signature>
}

StressShell.prototype.GetThermalIntegrationPoint = function() {
    /// <signature>
    /// <summary>Returns the thermal data for a specific integration point as an array. For each integration point there will be nthhsv values. There are nthint integration points.</summary>
    /// <param name="index" type="Number" optional="false">Index you want the integration point data for. Note that indices start at 0.</param>
    /// <returns type="Array" elementType="Array"/>
    /// </signature>
}

StressShell.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this initial stress shell (*INITIAL_STRESS_SHELL). Note that a carriage return is not added. See also StressShell.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

StressShell.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the initial stress shell. Note that a carriage return is not added. See also StressShell.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

StressShell.Last = function() {
    /// <signature>
    /// <summary>Returns the last initial stress shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last initial stress shell in</param>
    /// <returns type="StressShell"/>
    /// </signature>
}

StressShell.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next initial stress shell in the model.</summary>
    /// <returns type="StressShell"/>
    /// </signature>
}

StressShell.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a initial stress shell.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only initial stress shells from that model can be picked. If the argument is a Flag then only initial stress shells that are flagged with limit can be selected. If omitted, or null, any initial stress shells from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="StressShell"/>
    /// </signature>
}

StressShell.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous initial stress shell in the model.</summary>
    /// <returns type="StressShell"/>
    /// </signature>
}

StressShell.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select initial stress shells using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting initial stress shells</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only initial stress shells from that model can be selected. If the argument is a Flag then only initial stress shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any initial stress shells can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

StressShell.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the initial stress shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the initial stress shell</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.prototype.SetHisvData_#deprecated = function() {
    /// <signature>
    /// <summary>Please use StressShell.SetIntegrationPoint() instead.</summary>
    /// </signature>
}

StressShell.prototype.SetIntegrationPoint = function() {
    /// <signature>
    /// <summary>Set the data for a specific integration point. For each integration point there will be 8 + nhisv + (6 x ntensr) values. There are nplane x nthick integration points.</summary>
    /// <param name="index" type="Number" optional="false">Index you want the integration point data for. Note that indices start at 0.</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">Array containing the integration point data. The array length should be 8 + nhisv + (6 x ntensr).</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.prototype.SetStressData_#deprecated = function() {
    /// <signature>
    /// <summary>Please use StressShell.SetIntegrationPoint() instead.</summary>
    /// </signature>
}

StressShell.prototype.SetTensrData_#deprecated = function() {
    /// <signature>
    /// <summary>Please use StressShell.SetIntegrationPoint() instead.</summary>
    /// </signature>
}

StressShell.prototype.SetThermalIntegrationPoint = function() {
    /// <signature>
    /// <summary>Set the thermal data for a specific integration point. For each integration point there will be nthhsv values. There are nthint thermal integration points.</summary>
    /// <param name="index" type="Number" optional="false">Index you want the thermal integration point data for. Note that indices start at 0.</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">Array containing the thermal integration point data. The array length should be nthint.</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the initial stress shell. The initial stress shell will be sketched until you either call StressShell.Unsketch(), StressShell.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial stress shell is sketched. If omitted redraw is true. If you want to sketch several initial stress shells and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged initial stress shells in the model. The initial stress shells will be sketched until you either call StressShell.Unsketch(), StressShell.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged initial stress shells will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial stress shells that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial stress shells are sketched. If omitted redraw is true. If you want to sketch flagged initial stress shells several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of initial stress shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing initial stress shells should be counted. If false or omitted referenced but undefined initial stress shells will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

StressShell.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the initial stress shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all initial stress shells will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the initial stress shells</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the initial stress shell.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial stress shell is unsketched. If omitted redraw is true. If you want to unsketch several initial stress shells and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all initial stress shells.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial stress shells will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial stress shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged initial stress shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial stress shells will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial stress shells that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial stress shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="StressShell"/>
    /// </signature>
}

StressShell.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for initial stress shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

StressShell.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this initial stress shell.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

StressShell.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the initial stress shell data in keyword format. Note that this contains the keyword header and the keyword cards. See also StressShell.Keyword() and StressShell.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Termination = function() {
    /// <signature>
    /// <summary>Create a new Termination object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that termination will be created in</param>
    /// <param name="Type" type="Number" optional="false">Specify the type of Termination (Can be Termination.BODY or Termination.CONTACT or Termination.CURVE or Termination.DELETED_SHELLS or Termination.DELETED_SOLIDS or Termination.NODE or Termination.SENSOR).</param>
    /// <param name="id" type="Number" optional="false">Can be Part ID for Termination.BODY or Termination.DELETED_SHELLS or Termination.DELETED_SOLIDS, OR Contact ID for Termination.CONTACT, OR Node ID for Termination.NODE, OR Curve ID for Termination.CURVE, OR Part Set ID for Termination.DELETED_SHELLS_SET or Termination.DELETED_SOLIDS_SET, OR Sensor Switch ID for Termination.SENSOR.</param>
    /// <returns type="Termination"/>
    /// </signature>
    /// <field name='actTime' static='false' type='Number'>Activation time value. Used for Termination.CONTACT or Termination.CURVE.</field>
    /// <field name='dof' static='false' type='Number'>Directions to consider for Force Magnitude. Valid values are: Termination.DOF_X or Termination.DOF_Y or Termination.DOF_Z. Used for Termination.CONTACT.</field>
    /// <field name='duration' static='false' type='Number'>Time duration of null resultant force prior to termination. Used for Termination.CONTACT.</field>
    /// <field name='exists' static='false' type='Boolean'>true if termination exists, false if referred to but not defined. (read only)</field>
    /// <field name='id' static='false' type='Number'>Can be Part or NRBC ID based on ptype value for Termination.BODY, OR Contact ID for Termination.CONTACT, OR Node ID for Termination.NODE, OR Curve ID for Termination.CURVE, OR Part for Termination.DELETED_SHELLS or Termination.DELETED_SOLIDS, OR Part Set ID for Termination.DELETED_SHELLS_SET or Termination.DELETED_SOLIDS_SET, OR Sensor Switch ID for Termination.SENSOR.</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the termination is in.</field>
    /// <field name='maxc' static='false' type='Number'>Maximum (most positive) displacement. If value is 0.0, it is set to 1.0e21. Value should be more than minc. Used for Termination.BODY or Termination.NODE.</field>
    /// <field name='minc' static='false' type='Number'>Minimum (most negative) displacement. If value is 0.0, it is set to -1.0e21. Value should be less than maxc. Used for Termination.BODY or Termination.NODE.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the termination is in.</field>
    /// <field name='numDeletedElems' static='false' type='Number'>Number of elements that must be deleted for the specified Part ID's, before an error termination occurs. Used for Termination.DELETED_SHELLS_SET or Termination.DELETED_SOLIDS_SET.</field>
    /// <field name='ptype' static='false' type='Number'>Gives the type of Part for Termination.BODY. Values can be 0 for Part or 1 for NRBC (read only)</field>
    /// <field name='stop' static='false' type='Number'>Stop Criterion. Valid values are: Termination.STOP_X or Termination.STOP_Y or Termination.STOP_Z or Termination.STOP_MAG. Used for Termination.BODY or Termination.NODE.</field>
    /// <field name='threshold' static='false' type='Number'>Any measured force magnitude below or equal to this specified threshold is taken as a null force. Used for Termination.CONTACT.</field>
    /// <field name='type' static='false' type='Number'>Gives the type of *TERMINATION keyword (read only).</field>
    /// <field name='BODY' static='true' type='Number'>TERMINATION is *TERMINATION_BODY.</field>
    /// <field name='CONTACT' static='true' type='Number'>TERMINATION is *TERMINATION_CONTACT.</field>
    /// <field name='CURVE' static='true' type='Number'>TERMINATION is *TERMINATION_CURVE.</field>
    /// <field name='DELETED_SHELLS' static='true' type='Number'>TERMINATION is *TERMINATION_DELETED_SHELLS.</field>
    /// <field name='DELETED_SHELLS_SET' static='true' type='Number'>TERMINATION is *TERMINATION_DELETED_SHELLS_SET.</field>
    /// <field name='DELETED_SOLIDS' static='true' type='Number'>TERMINATION is *TERMINATION_DELETED_SOLIDS.</field>
    /// <field name='DELETED_SOLIDS_SET' static='true' type='Number'>TERMINATION is *TERMINATION_DELETED_SOLIDS_SET.</field>
    /// <field name='DOF_X' static='true' type='Number'>Degree of freedom in X direction for Force magnitude. Used for Termination.CONTACT.</field>
    /// <field name='DOF_Y' static='true' type='Number'>Degree of freedom in Y direction for Force magnitude. Used for Termination.CONTACT.</field>
    /// <field name='DOF_Z' static='true' type='Number'>Degree of freedom in Z direction for Force magnitude. Used for Termination.CONTACT.</field>
    /// <field name='NODE' static='true' type='Number'>TERMINATION is *TERMINATION_NODE.</field>
    /// <field name='SENSOR' static='true' type='Number'>TERMINATION is *TERMINATION_SENSOR.</field>
    /// <field name='STOP_MAG' static='true' type='Number'>Stop if displacement magnitude is exceeded. Used for Termination.BODY or Termination.NODE.</field>
    /// <field name='STOP_X' static='true' type='Number'>Stop criterion is in Global X direction. Used for Termination.BODY or Termination.NODE.</field>
    /// <field name='STOP_Y' static='true' type='Number'>Stop criterion is in Global Y direction. Used for Termination.BODY or Termination.NODE.</field>
    /// <field name='STOP_Z' static='true' type='Number'>Stop criterion is in Global X direction. Used for Termination.BODY or Termination.NODE.</field>
}

Termination.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Termination.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the termination.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the termination</param>
    /// <returns type="null"/>
    /// </signature>
}

Termination.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the termination.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Termination"/>
    /// </signature>
}

Termination.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an Termination definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the Termination will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Termination"/>
    /// </signature>
}

Termination.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Termination.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for termination. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Termination.First = function() {
    /// <signature>
    /// <summary>Returns the first termination in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first termination in</param>
    /// <returns type="Termination"/>
    /// </signature>
}

Termination.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the terminations in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all terminations will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the terminations</param>
    /// <returns type="null"/>
    /// </signature>
}

Termination.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the termination is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the termination</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Termination.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each termination in the model. Note that ForEach has been designed to make looping over terminations as fast as possible and so has some limitations. Firstly, a single temporary Termination object is created and on each function call it is updated with the current termination data. This means that you should not try to store the Termination object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new terminations inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all terminations are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each termination</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Termination.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Termination objects for all of the terminations in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get terminations from</param>
    /// <returns type="Array" elementType="Termination"/>
    /// </signature>
}

Termination.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Termination objects for all of the flagged terminations in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get terminations from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the terminations that you want to retrieve</param>
    /// <returns type="Array" elementType="Termination"/>
    /// </signature>
}

Termination.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Termination object for a termination ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the termination in</param>
    /// <param name="number" type="Number" optional="false">number of the termination you want the Termination object for</param>
    /// <returns type="Termination"/>
    /// </signature>
}

Termination.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Termination property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Termination.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">termination property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Termination.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this Termination (*TERMINATION_xxxx) Note that a carriage return is not added. See also Termination.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Termination.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the Termination. Note that a carriage return is not added. See also Termination.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Termination.Last = function() {
    /// <signature>
    /// <summary>Returns the last termination in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last termination in</param>
    /// <returns type="Termination"/>
    /// </signature>
}

Termination.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next termination in the model.</summary>
    /// <returns type="Termination"/>
    /// </signature>
}

Termination.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous termination in the model.</summary>
    /// <returns type="Termination"/>
    /// </signature>
}

Termination.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select terminations using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting terminations</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only terminations from that model can be selected. If the argument is a Flag then only terminations that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any terminations can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Termination.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the termination.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the termination</param>
    /// <returns type="null"/>
    /// </signature>
}

Termination.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of terminations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing terminations should be counted. If false or omitted referenced but undefined terminations will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Termination.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the terminations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all terminations will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the terminations</param>
    /// <returns type="null"/>
    /// </signature>
}

Termination.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Termination"/>
    /// </signature>
}

Termination.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for termination. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Termination.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this termination.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Termination.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the Termination data in keyword format. Note that this contains the keyword header and the keyword cards. See also Termination.Keyword() and Termination.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var TieBreak = function() {
    /// <signature>
    /// <summary>Create a new TieBreak object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that constrained tie-break will be created in</param>
    /// <param name="snsid" type="Number" optional="false">Slave Node Set ID.</param>
    /// <param name="mnsid" type="Number" optional="false">Master Node Set ID.</param>
    /// <param name="eppf" type="Number" optional="true">Plastic strain at failure.</param>
    /// <returns type="TieBreak"/>
    /// </signature>
    /// <field name='eppf' static='false' type='Number'>Plastic strain at failure.</field>
    /// <field name='exists' static='false' type='Boolean'>true if constrained tie-break exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the constrained tie-break is in.</field>
    /// <field name='mnsid' static='false' type='Number'>Master Node Set ID.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the tie-break is in.</field>
    /// <field name='snsid' static='false' type='Number'>Slave Node Set ID.</field>
}

TieBreak.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the tie-break</summary>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the tie-breaks in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all tie-breaks will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged tie-breaks in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged tie-breaks will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the tie-breaks that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the tie-break is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

TieBreak.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the tie-break.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the tie-break</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the tie-break.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="TieBreak"/>
    /// </signature>
}

TieBreak.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for tie-break. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.First = function() {
    /// <signature>
    /// <summary>Returns the first tie-break in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first tie-break in</param>
    /// <returns type="TieBreak"/>
    /// </signature>
}

TieBreak.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the tie-breaks in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all tie-breaks will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the tie-breaks</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the tie-break is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the tie-break</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

TieBreak.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each tie-break in the model. Note that ForEach has been designed to make looping over tie-breaks as fast as possible and so has some limitations. Firstly, a single temporary TieBreak object is created and on each function call it is updated with the current tie-break data. This means that you should not try to store the TieBreak object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new tie-breaks inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all tie-breaks are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each tie-break</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of TieBreak objects for all of the tie-breaks in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get tie-breaks from</param>
    /// <returns type="Array" elementType="TieBreak"/>
    /// </signature>
}

TieBreak.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of TieBreak objects for all of the flagged tie-breaks in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get tie-breaks from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the tie-breaks that you want to retrieve</param>
    /// <returns type="Array" elementType="TieBreak"/>
    /// </signature>
}

TieBreak.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the TieBreak object for a tie-break ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the tie-break in</param>
    /// <param name="number" type="Number" optional="false">number of the tie-break you want the TieBreak object for</param>
    /// <returns type="TieBreak"/>
    /// </signature>
}

TieBreak.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a TieBreak property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the TieBreak.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">tie-break property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

TieBreak.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this tie-break (**CONSTRAINED_TIE_BREAK). Note that a carriage return is not added. See also TieBreak.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

TieBreak.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the tie-break. Note that a carriage return is not added. See also TieBreak.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

TieBreak.Last = function() {
    /// <signature>
    /// <summary>Returns the last tie-break in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last tie-break in</param>
    /// <returns type="TieBreak"/>
    /// </signature>
}

TieBreak.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next tie-break in the model.</summary>
    /// <returns type="TieBreak"/>
    /// </signature>
}

TieBreak.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a tie-break.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only tie-breaks from that model can be picked. If the argument is a Flag then only tie-breaks that are flagged with limit can be selected. If omitted, or null, any tie-breaks from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="TieBreak"/>
    /// </signature>
}

TieBreak.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous tie-break in the model.</summary>
    /// <returns type="TieBreak"/>
    /// </signature>
}

TieBreak.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select tie-breaks using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting tie-breaks</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only tie-breaks from that model can be selected. If the argument is a Flag then only tie-breaks that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any tie-breaks can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

TieBreak.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the tie-break.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the tie-break</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the tie-break. The tie-break will be sketched until you either call TieBreak.Unsketch(), TieBreak.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the tie-break is sketched. If omitted redraw is true. If you want to sketch several tie-breaks and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged tie-breaks in the model. The tie-breaks will be sketched until you either call TieBreak.Unsketch(), TieBreak.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged tie-breaks will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the tie-breaks that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the tie-breaks are sketched. If omitted redraw is true. If you want to sketch flagged tie-breaks several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of tie-breaks in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing tie-breaks should be counted. If false or omitted referenced but undefined tie-breaks will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

TieBreak.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the tie-break</summary>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the tie-breaks in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all tie-breaks will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged tie-breaks in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged tie-breaks will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the tie-breaks that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the tie-breaks in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all tie-breaks will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the tie-breaks</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the tie-break.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the tie-break is unsketched. If omitted redraw is true. If you want to unsketch several tie-breaks and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all tie-breaks.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all tie-breaks will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the tie-breaks are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged tie-breaks in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all tie-breaks will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the tie-breaks that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the tie-breaks are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="TieBreak"/>
    /// </signature>
}

TieBreak.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for tie-break. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

TieBreak.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this tie-break.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

TieBreak.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the tie-break data in keyword format. Note that this contains the keyword header and the keyword cards. See also TieBreak.Keyword() and TieBreak.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Transformation = function() {
    /// <signature>
    /// <summary>Create a new Transformation object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that transformation will be created in</param>
    /// <param name="tranid" type="Number" optional="false">Transformation label</param>
    /// <param name="title" type="String" optional="true">Transformation title</param>
    /// <returns type="Transformation"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if transformation exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the transformation is in.</field>
    /// <field name='label' static='false' type='Number'>Transformation number. Also see the tranid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the transformation is in.</field>
    /// <field name='nrow' static='false' type='Number'>Number of rows of transformations</field>
    /// <field name='title' static='false' type='String'>The title for the transformation.</field>
    /// <field name='tranid' static='false' type='Number'>Transformation number. Also see the label property which is an alternative name for this.</field>
}

Transformation.prototype.AddRow = function() {
    /// <signature>
    /// <summary>Adds a row of data for a *DEFINE_TRANSFORMATION.</summary>
    /// <param name="data" type="Array" elementType="Number" optional="false">The data you want to add</param>
    /// <param name="row" type="Number" optional="true">The row you want to add the data at. Existing transforms will be shifted. If omitted the data will be added to the end of the existing transforms. Note that row indices start at 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the transformation.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the transformation</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the transformation.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Transformation"/>
    /// </signature>
}

Transformation.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a define transformation definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the transformation will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Transformation"/>
    /// </signature>
}

Transformation.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for transformation. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.First = function() {
    /// <signature>
    /// <summary>Returns the first transformation in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first transformation in</param>
    /// <returns type="Transformation"/>
    /// </signature>
}

Transformation.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free transformation label in the model. Also see Transformation.LastFreeLabel(), Transformation.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free transformation label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Transformation.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the transformations in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all transformations will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the transformations</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the transformation is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the transformation</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Transformation.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each transformation in the model. Note that ForEach has been designed to make looping over transformations as fast as possible and so has some limitations. Firstly, a single temporary Transformation object is created and on each function call it is updated with the current transformation data. This means that you should not try to store the Transformation object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new transformations inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all transformations are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each transformation</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Transformation objects for all of the transformations in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get transformations from</param>
    /// <returns type="Array" elementType="Transformation"/>
    /// </signature>
}

Transformation.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Transformation objects for all of the flagged transformations in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get transformations from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the transformations that you want to retrieve</param>
    /// <returns type="Array" elementType="Transformation"/>
    /// </signature>
}

Transformation.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Transformation object for a transformation ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the transformation in</param>
    /// <param name="number" type="Number" optional="false">number of the transformation you want the Transformation object for</param>
    /// <returns type="Transformation"/>
    /// </signature>
}

Transformation.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Transformation property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Transformation.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">transformation property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Transformation.prototype.GetRow = function() {
    /// <signature>
    /// <summary>Returns the data for a row in the transformation.</summary>
    /// <param name="row" type="Number" optional="false">The row you want the data for. Note row indices start at 0.</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Transformation.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this transformation. Note that a carriage return is not added. See also Transformation.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Transformation.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the transformation. Note that a carriage return is not added. See also Transformation.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Transformation.Last = function() {
    /// <signature>
    /// <summary>Returns the last transformation in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last transformation in</param>
    /// <returns type="Transformation"/>
    /// </signature>
}

Transformation.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free transformation label in the model. Also see Transformation.FirstFreeLabel(), Transformation.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free transformation label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Transformation.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next transformation in the model.</summary>
    /// <returns type="Transformation"/>
    /// </signature>
}

Transformation.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) transformation label in the model. Also see Transformation.FirstFreeLabel(), Transformation.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free transformation label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Transformation.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous transformation in the model.</summary>
    /// <returns type="Transformation"/>
    /// </signature>
}

Transformation.prototype.RemoveRow = function() {
    /// <signature>
    /// <summary>Removes the data for a row in *DEFINE_TRANSFORMATION.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to remove the data for. Note that row indices start at 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select transformations using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting transformations</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only transformations from that model can be selected. If the argument is a Flag then only transformations that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any transformations can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Transformation.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the transformation.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the transformation</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.prototype.SetRow = function() {
    /// <signature>
    /// <summary>Sets the data for a row in *DEFINE_TRANSFORMATION.</summary>
    /// <param name="row" type="Number" optional="false">The row you want to set the data for. Note that row indices start at 0.</param>
    /// <param name="data" type="Array" elementType="Number" optional="false">The data you want to set the row to</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of transformations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing transformations should be counted. If false or omitted referenced but undefined transformations will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Transformation.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the transformations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all transformations will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the transformations</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Transformation"/>
    /// </signature>
}

Transformation.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for transformation. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Transformation.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this transformation.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Transformation.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the transformation data in keyword format. Note that this contains the keyword header and the keyword cards. See also Transformation.Keyword() and Transformation.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Tshell = function() {
    /// <signature>
    /// <summary>Create a new Tshell object. Use either 6 or 8 nodes when creating a new thick shell.</summary>
    /// <param name="Model" type="Model" optional="false">Model that thick shell will be created in</param>
    /// <param name="eid" type="Number" optional="false">Tshell number</param>
    /// <param name="pid" type="Number" optional="false">Part number</param>
    /// <param name="n1" type="Number" optional="false">Node number 1</param>
    /// <param name="n2" type="Number" optional="false">Node number 2</param>
    /// <param name="n3" type="Number" optional="false">Node number 3</param>
    /// <param name="n4" type="Number" optional="false">Node number 4</param>
    /// <param name="n5" type="Number" optional="false">Node number 5</param>
    /// <param name="n6" type="Number" optional="false">Node number 6</param>
    /// <param name="n7" type="Number" optional="true">Node number 7</param>
    /// <param name="n8" type="Number" optional="true">Node number 8</param>
    /// <returns type="Tshell"/>
    /// </signature>
    /// <field name='beta' static='false' type='Boolean'>If BETA option is set.</field>
    /// <field name='beta_angle' static='false' type='Number'>Angle for BETA option.</field>
    /// <field name='colour' static='false' type='Colour'>The colour of the thick shell</field>
    /// <field name='composite' static='false' type='Boolean'>If COMPOSITE option is set. Can be true or false</field>
    /// <field name='eid' static='false' type='Number'>Tshell number. Also see the label property which is an alternative name for this.</field>
    /// <field name='exists' static='false' type='Boolean'>true if thick shell exists, false if referred to but not defined. (read only)</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the thick shell is in.</field>
    /// <field name='label' static='false' type='Number'>Tshell number. Also see the eid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the thick shell is in.</field>
    /// <field name='n1' static='false' type='Number'>Node number 1</field>
    /// <field name='n2' static='false' type='Number'>Node number 2</field>
    /// <field name='n3' static='false' type='Number'>Node number 3</field>
    /// <field name='n4' static='false' type='Number'>Node number 4</field>
    /// <field name='n5' static='false' type='Number'>Node number 5</field>
    /// <field name='n6' static='false' type='Number'>Node number 6</field>
    /// <field name='n7' static='false' type='Number'>Node number 7</field>
    /// <field name='n8' static='false' type='Number'>Node number 8</field>
    /// <field name='nip' static='false' type='Boolean'>Number of integration points for composite thick shell</field>
    /// <field name='nodes' static='false' type='Number'>Number of nodes thick shell has (read only)</field>
    /// <field name='pid' static='false' type='Number'>Part number</field>
    /// <field name='transparency' static='false' type='Number'>The transparency of the thick shell (0-100) 0% is opaque, 100% is transparent.</field>
}

Tshell.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the thick shell</summary>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the thick shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all thick shells will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged thick shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged thick shells will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the thick shells that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the thick shell is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Tshell.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the thick shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the thick shell</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the thick shell.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Tshell"/>
    /// </signature>
}

Tshell.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a thick shell.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the thick shell will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Tshell"/>
    /// </signature>
}

Tshell.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.ElemCut = function() {
    /// <signature>
    /// <summary>Returns coordinates of the intersections between a thick shell and a database cross section.</summary>
    /// <param name="Database cross section label" type="Number" optional="false">The label of the database cross section.</param>
    /// <returns type="Object"/>
    /// </signature>
}

Tshell.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for thick shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.ExtractColour = function() {
    /// <signature>
    /// <summary>Extracts the actual colour used for thick shell. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the thick shell colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the thick shell.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Tshell.FindTshellInBox = function() {
    /// <signature>
    /// <summary>Returns an array of Tshell objects for the thick shells within a box. This requires a previous (outside loop) call to function m.FindElemInit() where the process is initialized for flagged thick shells in the model and m.FindElemEnd() to close the process. Please note this function provides a list of all thick shells that could potentially be in the box (using computationally cheap bounding box comparison) it is not a rigorous test of whether the thick shellis actually in the box. See also Model.FindElemInit() See also Model.FindElemEnd()</summary>
    /// <param name="Model" type="Model" optional="false">Model designated model</param>
    /// <param name="xmin" type="Number" optional="false">Minimum bound in global x</param>
    /// <param name="xmax" type="Number" optional="false">Maximum bound in global x</param>
    /// <param name="ymin" type="Number" optional="false">Minimum bound in global y</param>
    /// <param name="ymax" type="Number" optional="false">Maximum bound in global y</param>
    /// <param name="zmin" type="Number" optional="false">Minimum bound in global z</param>
    /// <param name="zmax" type="Number" optional="false">Maximum bound in global z</param>
    /// <param name="hflag" type="Number" optional="true">Optional flag to restrict thick shells considered</param>
    /// <returns type="Array" elementType="Tshell"/>
    /// </signature>
}

Tshell.First = function() {
    /// <signature>
    /// <summary>Returns the first thick shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first thick shell in</param>
    /// <returns type="Tshell"/>
    /// </signature>
}

Tshell.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free thick shell label in the model. Also see Tshell.LastFreeLabel(), Tshell.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free thick shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Tshell.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the thick shells in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all thick shells will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the thick shells</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the thick shell is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the thick shell</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Tshell.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each thick shell in the model. Note that ForEach has been designed to make looping over thick shells as fast as possible and so has some limitations. Firstly, a single temporary Tshell object is created and on each function call it is updated with the current thick shell data. This means that you should not try to store the Tshell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new thick shells inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all thick shells are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each thick shell</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Tshell objects for all of the thick shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get thick shells from</param>
    /// <returns type="Array" elementType="Tshell"/>
    /// </signature>
}

Tshell.prototype.GetCompositeData = function() {
    /// <signature>
    /// <summary>Returns the composite data for an integration point in *ELEMENT_TSHELL_COMPOSITE.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want the data for. Note that integration points start at 0, not 1.</param>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Tshell.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Tshell objects for all of the flagged thick shells in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get thick shells from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the thick shells that you want to retrieve</param>
    /// <returns type="Array" elementType="Tshell"/>
    /// </signature>
}

Tshell.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Tshell object for a thick shell ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the thick shell in</param>
    /// <param name="number" type="Number" optional="false">number of the thick shell you want the Tshell object for</param>
    /// <returns type="Tshell"/>
    /// </signature>
}

Tshell.prototype.GetNodeIDs = function() {
    /// <signature>
    /// <summary>Returns the labels of the nodes on the thick shell as an array. See also Tshell.GetNodes()</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Tshell.prototype.GetNodes = function() {
    /// <signature>
    /// <summary>Returns the nodes on the thick shell as an array of Node objects. See also Tshell.GetNodeIDs()</summary>
    /// <returns type="Array" elementType="Node"/>
    /// </signature>
}

Tshell.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Tshell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Tshell.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">thick shell property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Tshell.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this thick shell (*ELEMENT_TSHELL or *ELEMENT_TSHELL_COMPOSITE). Note that a carriage return is not added. See also Tshell.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Tshell.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the thick shell. Note that a carriage return is not added. See also Tshell.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Tshell.Last = function() {
    /// <signature>
    /// <summary>Returns the last thick shell in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last thick shell in</param>
    /// <returns type="Tshell"/>
    /// </signature>
}

Tshell.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free thick shell label in the model. Also see Tshell.FirstFreeLabel(), Tshell.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free thick shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Tshell.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next thick shell in the model.</summary>
    /// <returns type="Tshell"/>
    /// </signature>
}

Tshell.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) thick shell label in the model. Also see Tshell.FirstFreeLabel(), Tshell.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free thick shell label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Tshell.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a thick shell.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only thick shells from that model can be picked. If the argument is a Flag then only thick shells that are flagged with limit can be selected. If omitted, or null, any thick shells from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Tshell"/>
    /// </signature>
}

Tshell.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous thick shell in the model.</summary>
    /// <returns type="Tshell"/>
    /// </signature>
}

Tshell.prototype.RemoveCompositeData = function() {
    /// <signature>
    /// <summary>Removes the composite data for an integration point in *ELEMENT_TSHELL_COMPOSITE.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want to remove. Note that integration points start at 0, not 1.</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the thick shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all thick shells will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged thick shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged thick shells will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the thick shells that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select thick shells using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting thick shells</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only thick shells from that model can be selected. If the argument is a Flag then only thick shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any thick shells can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Tshell.prototype.SetCompositeData = function() {
    /// <signature>
    /// <summary>Sets the composite data for an integration point in *ELEMENT_TSHELL_COMPOSITE.</summary>
    /// <param name="ipt" type="Number" optional="false">The integration point you want to set the data for. Note that integration points start at 0, not 1.</param>
    /// <param name="mid" type="Number" optional="false">Material ID for the integration point.</param>
    /// <param name="thick" type="Number" optional="false">Thickness of the integration point.</param>
    /// <param name="beta" type="Number" optional="false">Material angle of the integration point.</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the thick shell.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the thick shell</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the thick shell. The thick shell will be sketched until you either call Tshell.Unsketch(), Tshell.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the thick shell is sketched. If omitted redraw is true. If you want to sketch several thick shells and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged thick shells in the model. The thick shells will be sketched until you either call Tshell.Unsketch(), Tshell.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged thick shells will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the thick shells that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the thick shells are sketched. If omitted redraw is true. If you want to sketch flagged thick shells several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.Timestep = function() {
    /// <signature>
    /// <summary>Calculates the timestep for the thick shell</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Tshell.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of thick shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing thick shells should be counted. If false or omitted referenced but undefined thick shells will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Tshell.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the thick shell</summary>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the thick shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all thick shells will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged thick shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged thick shells will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the thick shells that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the thick shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all thick shells will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the thick shells</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the thick shell.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the thick shell is unsketched. If omitted redraw is true. If you want to unsketch several thick shells and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all thick shells.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all thick shells will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the thick shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged thick shells in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all thick shells will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the thick shells that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the thick shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Tshell"/>
    /// </signature>
}

Tshell.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for thick shell. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Tshell.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this thick shell.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Tshell.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the thick shell data in keyword format. Note that this contains the keyword header and the keyword cards. See also Tshell.Keyword() and Tshell.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Utils = function() {
}

Utils.Ascii85Decode = function() {
    /// <signature>
    /// <summary>Decodes an ASCII85 encoded string. See Utils.Ascii85Encode() for details on the method.</summary>
    /// <param name="encoded" type="String" optional="false">An ASCII85 encoded string</param>
    /// <returns type="ArrayBuffer"/>
    /// </signature>
}

Utils.Ascii85Encode = function() {
    /// <signature>
    /// <summary>Encodes an ASCII85 encoded string. This enables binary data to be represented by ASCII characters using five ASCII characters to represent four bytes of binary data (making the encoded size 1/4 larger than the original). By doing this binary data can be stored in JavaScript strings. Note that the method used by PRIMER to encode and decode strings differs from the standard ASCII85 encoding as that uses the ASCII characters ", ' and \ which cannot be used in JavaScript strings as they have special meanings. The method in PRIMER uses 0-84 are !-u (ASCII codes 33-117) (i.e. 33 is added to it) with the following exceptions v is used instead of " (ASCII code 118 instead of 34) w is used instead of ' (ASCII code 119 instead of 39) x is used instead of \ (ASCII code 120 instead of 92) If all five digits are 0 they are represented by a single character z instead of !!!!!</summary>
    /// <param name="data" type="ArrayBuffer" optional="false">ArrayBuffer containing the data</param>
    /// <param name="length" type="Number" optional="true">Length of data in array buffer to encode. If omitted the whole array buffer will be encoded</param>
    /// <returns type="String"/>
    /// </signature>
}

Utils.Build = function() {
    /// <signature>
    /// <summary>Returns the build number</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Utils.CheckoutLicense = function() {
    /// <signature>
    /// <summary>Checks out a license for a feature</summary>
    /// <param name="feature" type="String" optional="false">feature to check license for</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Utils.GarbageCollect = function() {
    /// <signature>
    /// <summary>Forces garbage collection to be done. This should not normally need to be called but in exceptional circumstances it can be called to ensure that garbage collection is done to return memory.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Utils.HTMLBrowser = function() {
    /// <signature>
    /// <summary>Returns the path to the default HTML browser</summary>
    /// <returns type="String"/>
    /// </signature>
}

Utils.PdfReader = function() {
    /// <signature>
    /// <summary>Returns the path to the executable of the default pdf reader</summary>
    /// <returns type="String"/>
    /// </signature>
}

Utils.Version = function() {
    /// <signature>
    /// <summary>Returns the version number</summary>
    /// <returns type="Number"/>
    /// </signature>
}

var Vector = function() {
    /// <signature>
    /// <summary>Create a new Vector object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that vector will be created in</param>
    /// <param name="vid" type="Number" optional="false">Vector number</param>
    /// <param name="xt" type="Number" optional="false">X coordinate of tail of vector</param>
    /// <param name="yt" type="Number" optional="false">Y coordinate of tail of vector</param>
    /// <param name="zt" type="Number" optional="false">Z coordinate of tail vector</param>
    /// <param name="xh" type="Number" optional="false">X coordinate of head of vector</param>
    /// <param name="yh" type="Number" optional="false">Y coordinate of head of vector</param>
    /// <param name="zh" type="Number" optional="false">Z coordinate of head of vector</param>
    /// <param name="cid" type="int" optional="true">Coordinate system ID</param>
    /// <param name="heading" type="String" optional="true">Title for the vector</param>
    /// <returns type="Vector"/>
    /// </signature>
    /// <signature>
    /// <summary>Create a new Vector object with _NODES option.</summary>
    /// <param name="Model" type="Model" optional="false">Model that vector will be created in</param>
    /// <param name="vid" type="Number" optional="false">Vector number</param>
    /// <param name="nodet" type="Number" optional="false">Node ID for tail of vector</param>
    /// <param name="nodeh" type="Number" optional="false">Node ID for head of vector</param>
    /// <param name="heading" type="String" optional="true">Title for the vector</param>
    /// <returns type="Vector"/>
    /// </signature>
    /// <field name='cid' static='false' type='int'>Coordinate system ID</field>
    /// <field name='exists' static='false' type='Boolean'>true if vector exists, false if referred to but not defined. (read only)</field>
    /// <field name='heading' static='false' type='String'>Vector heading</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the vector is in.</field>
    /// <field name='label' static='false' type='Number'>Vector number. Also see the vid property which is an alternative name for this.</field>
    /// <field name='model' static='false' type='Number'>The Model number that the vector is in.</field>
    /// <field name='nodeh' static='false' type='int'>Node ID for head of vector (for _NODES option)</field>
    /// <field name='nodes' static='false' type='Boolean'>_NODES option</field>
    /// <field name='nodet' static='false' type='int'>Node ID for tail of vector (for _NODES option)</field>
    /// <field name='vid' static='false' type='Number'>Vector number. Also see the label property which is an alternative name for this.</field>
    /// <field name='xh' static='false' type='Number'>X coordinate of head of vector</field>
    /// <field name='xt' static='false' type='Number'>X coordinate of tail of vector</field>
    /// <field name='yh' static='false' type='Number'>Y coordinate of head of vector</field>
    /// <field name='yt' static='false' type='Number'>Y coordinate of tail of vector</field>
    /// <field name='zh' static='false' type='Number'>Z coordinate of head of vector</field>
    /// <field name='zt' static='false' type='Number'>Z coordinate of tail vector</field>
}

Vector.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the vector</summary>
    /// <returns type="null"/>
    /// </signature>
}

Vector.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the vectors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all vectors will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged vectors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged vectors will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the vectors that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the vector is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Vector.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the vector.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the vector</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the vector.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Vector"/>
    /// </signature>
}

Vector.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create a vector.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the vector will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="Vector"/>
    /// </signature>
}

Vector.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for vector. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.First = function() {
    /// <signature>
    /// <summary>Returns the first vector in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first vector in</param>
    /// <returns type="Vector"/>
    /// </signature>
}

Vector.FirstFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the first free vector label in the model. Also see Vector.LastFreeLabel(), Vector.NextFreeLabel() and Model.FirstFreeItemLabel().</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first free vector label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Vector.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the vectors in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all vectors will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the vectors</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the vector is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the vector</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Vector.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each vector in the model. Note that ForEach has been designed to make looping over vectors as fast as possible and so has some limitations. Firstly, a single temporary Vector object is created and on each function call it is updated with the current vector data. This means that you should not try to store the Vector object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new vectors inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all vectors are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each vector</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Vector objects for all of the vectors in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get vectors from</param>
    /// <returns type="Array" elementType="Vector"/>
    /// </signature>
}

Vector.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Vector objects for all of the flagged vectors in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get vectors from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the vectors that you want to retrieve</param>
    /// <returns type="Array" elementType="Vector"/>
    /// </signature>
}

Vector.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Vector object for a vector ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the vector in</param>
    /// <param name="number" type="Number" optional="false">number of the vector you want the Vector object for</param>
    /// <returns type="Vector"/>
    /// </signature>
}

Vector.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Vector property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Vector.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">vector property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Vector.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this vector (*DEFINE_VECTOR). Note that a carriage return is not added. See also Vector.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Vector.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the vector. Note that a carriage return is not added. See also Vector.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Vector.Last = function() {
    /// <signature>
    /// <summary>Returns the last vector in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last vector in</param>
    /// <returns type="Vector"/>
    /// </signature>
}

Vector.LastFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the last free vector label in the model. Also see Vector.FirstFreeLabel(), Vector.NextFreeLabel() and see Model.LastFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last free vector label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Vector.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next vector in the model.</summary>
    /// <returns type="Vector"/>
    /// </signature>
}

Vector.NextFreeLabel = function() {
    /// <signature>
    /// <summary>Returns the next free (highest+1) vector label in the model. Also see Vector.FirstFreeLabel(), Vector.LastFreeLabel() and Model.NextFreeItemLabel()</summary>
    /// <param name="Model" type="Model" optional="false">Model to get next free vector label in</param>
    /// <param name="layer" type="Number" optional="true">Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Vector.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a vector.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only vectors from that model can be picked. If the argument is a Flag then only vectors that are flagged with limit can be selected. If omitted, or null, any vectors from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Vector"/>
    /// </signature>
}

Vector.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous vector in the model.</summary>
    /// <returns type="Vector"/>
    /// </signature>
}

Vector.RenumberAll = function() {
    /// <signature>
    /// <summary>Renumbers all of the vectors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all vectors will be renumbered in</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.RenumberFlagged = function() {
    /// <signature>
    /// <summary>Renumbers all of the flagged vectors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged vectors will be renumbered in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the vectors that you want to renumber</param>
    /// <param name="start" type="Number" optional="false">Start point for renumbering</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select vectors using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting vectors</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only vectors from that model can be selected. If the argument is a Flag then only vectors that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any vectors can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Vector.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the vector.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the vector</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the vector. The vector will be sketched until you either call Vector.Unsketch(), Vector.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the vector is sketched. If omitted redraw is true. If you want to sketch several vectors and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged vectors in the model. The vectors will be sketched until you either call Vector.Unsketch(), Vector.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged vectors will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the vectors that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the vectors are sketched. If omitted redraw is true. If you want to sketch flagged vectors several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of vectors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing vectors should be counted. If false or omitted referenced but undefined vectors will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Vector.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the vector</summary>
    /// <returns type="null"/>
    /// </signature>
}

Vector.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the vectors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all vectors will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged vectors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged vectors will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the vectors that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the vectors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all vectors will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the vectors</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the vector.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the vector is unsketched. If omitted redraw is true. If you want to unsketch several vectors and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all vectors.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all vectors will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the vectors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged vectors in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all vectors will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the vectors that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the vectors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Vector"/>
    /// </signature>
}

Vector.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for vector. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Vector.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this vector.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Vector.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the vector data in keyword format. Note that this contains the keyword header and the keyword cards. See also Vector.Keyword() and Vector.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var Velocity = function() {
    /// <signature>
    /// <summary>Create a new Velocity object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that velocity will be created in</param>
    /// <param name="nsid" type="Number" optional="false">Set Node set ID</param>
    /// <param name="vx" type="Number" optional="false">Initial velocity in X direction</param>
    /// <param name="vy" type="Number" optional="false">Initial velocity in Y direction</param>
    /// <param name="vz" type="Number" optional="false">Initial velocity in Z direction</param>
    /// <param name="vxr" type="Number" optional="false">Initial rotational velocity about X axis</param>
    /// <param name="vyr" type="Number" optional="false">Initial rotational velocity about Y axis</param>
    /// <param name="vzr" type="Number" optional="false">Initial rotational velocity about Z axis</param>
    /// <param name="boxid" type="Number" optional="true">Define box containing nodes</param>
    /// <param name="irigid" type="Number" optional="true">IRIGID flag</param>
    /// <param name="nsidex" type="Number" optional="true">Set Exempted Node set ID</param>
    /// <param name="vxe" type="Number" optional="true">Initial velocity in X direction of exempted nodes</param>
    /// <param name="vye" type="Number" optional="true">Initial velocity in Y direction of exempted nodes</param>
    /// <param name="vze" type="Number" optional="true">Initial velocity in Z direction of exempted nodes</param>
    /// <param name="vxre" type="Number" optional="true">Initial rotational velocity about X axis of exempted nodes</param>
    /// <param name="vyre" type="Number" optional="true">Initial rotational velocity about Y axis of exempted nodes</param>
    /// <param name="vzre" type="Number" optional="true">Initial rotational velocity about Z axis of exempted nodes</param>
    /// <param name="icid" type="Number" optional="true">Local coordinate system nodes</param>
    /// <returns type="Velocity"/>
    /// </signature>
    /// <field name='boxid' static='false' type='Number'>Define box containing nodes</field>
    /// <field name='exists' static='false' type='Boolean'>true if velocity exists, false if referred to but not defined. (read only)</field>
    /// <field name='icid' static='false' type='Number'>Local coordinate system</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the initial velocity is in.</field>
    /// <field name='irigid' static='false' type='Number'>IRIGID flag</field>
    /// <field name='model' static='false' type='Number'>The Model number that the initial velocity is in.</field>
    /// <field name='nsid' static='false' type='Number'>Set Node set ID</field>
    /// <field name='nsidex' static='false' type='Number'>Set Exempted Node set ID</field>
    /// <field name='vx' static='false' type='Number'>Initial velocity in X direction</field>
    /// <field name='vxe' static='false' type='Number'>Initial velocity in X direction of exempted nodes</field>
    /// <field name='vxr' static='false' type='Number'>Initial rotational velocity about X axis</field>
    /// <field name='vxre' static='false' type='Number'>Initial rotational velocity about X axis of exempted nodes</field>
    /// <field name='vy' static='false' type='Number'>Initial velocity in Y direction</field>
    /// <field name='vye' static='false' type='Number'>Initial velocity in Y direction of exempted nodes</field>
    /// <field name='vyr' static='false' type='Number'>Initial rotational velocity about Y axis</field>
    /// <field name='vyre' static='false' type='Number'>Initial rotational velocity about Y axis of exempted nodes</field>
    /// <field name='vz' static='false' type='Number'>Initial velocity in Z direction</field>
    /// <field name='vze' static='false' type='Number'>Initial velocity in Z direction of exempted nodes</field>
    /// <field name='vzr' static='false' type='Number'>Initial rotational velocity about Z axis</field>
    /// <field name='vzre' static='false' type='Number'>Initial rotational velocity about Z axis of exempted nodes</field>
}

Velocity.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the initial velocity</summary>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the initial velocitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocitys will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged initial velocitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged initial velocitys will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocitys that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the initial velocity is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Velocity.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the initial velocity.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the initial velocity</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the initial velocity.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="Velocity"/>
    /// </signature>
}

Velocity.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for initial velocity. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.First = function() {
    /// <signature>
    /// <summary>Returns the first initial velocity in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first initial velocity in</param>
    /// <returns type="Velocity"/>
    /// </signature>
}

Velocity.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the initial velocitys in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocitys will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the initial velocitys</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the initial velocity is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the initial velocity</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Velocity.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each initial velocity in the model. Note that ForEach has been designed to make looping over initial velocitys as fast as possible and so has some limitations. Firstly, a single temporary Velocity object is created and on each function call it is updated with the current initial velocity data. This means that you should not try to store the Velocity object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new initial velocitys inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocitys are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each initial velocity</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of Velocity objects for all of the initial velocitys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get initial velocitys from</param>
    /// <returns type="Array" elementType="Velocity"/>
    /// </signature>
}

Velocity.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of Velocity objects for all of the flagged initial velocitys in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get initial velocitys from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocitys that you want to retrieve</param>
    /// <returns type="Array" elementType="Velocity"/>
    /// </signature>
}

Velocity.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the Velocity object for a initial velocity ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the initial velocity in</param>
    /// <param name="number" type="Number" optional="false">number of the initial velocity you want the Velocity object for</param>
    /// <returns type="Velocity"/>
    /// </signature>
}

Velocity.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a Velocity property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Velocity.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">initial velocity property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

Velocity.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this initial velocity (*INITIAL_VELOCITY). Note that a carriage return is not added. See also Velocity.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Velocity.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the initial velocity. Note that a carriage return is not added. See also Velocity.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

Velocity.Last = function() {
    /// <signature>
    /// <summary>Returns the last initial velocity in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last initial velocity in</param>
    /// <returns type="Velocity"/>
    /// </signature>
}

Velocity.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next initial velocity in the model.</summary>
    /// <returns type="Velocity"/>
    /// </signature>
}

Velocity.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a initial velocity.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only initial velocitys from that model can be picked. If the argument is a Flag then only initial velocitys that are flagged with limit can be selected. If omitted, or null, any initial velocitys from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="Velocity"/>
    /// </signature>
}

Velocity.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous initial velocity in the model.</summary>
    /// <returns type="Velocity"/>
    /// </signature>
}

Velocity.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select initial velocitys using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting initial velocitys</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only initial velocitys from that model can be selected. If the argument is a Flag then only initial velocitys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any initial velocitys can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Velocity.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the initial velocity.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the initial velocity</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the initial velocity. The initial velocity will be sketched until you either call Velocity.Unsketch(), Velocity.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocity is sketched. If omitted redraw is true. If you want to sketch several initial velocitys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged initial velocitys in the model. The initial velocitys will be sketched until you either call Velocity.Unsketch(), Velocity.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged initial velocitys will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocitys that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocitys are sketched. If omitted redraw is true. If you want to sketch flagged initial velocitys several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of initial velocitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing initial velocitys should be counted. If false or omitted referenced but undefined initial velocitys will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Velocity.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the initial velocity</summary>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the initial velocitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocitys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged initial velocitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged initial velocitys will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocitys that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the initial velocitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all initial velocitys will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the initial velocitys</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the initial velocity.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocity is unsketched. If omitted redraw is true. If you want to unsketch several initial velocitys and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all initial velocitys.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocitys will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocitys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged initial velocitys in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocitys will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocitys that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocitys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="Velocity"/>
    /// </signature>
}

Velocity.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for initial velocity. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

Velocity.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this initial velocity.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

Velocity.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the initial velocity data in keyword format. Note that this contains the keyword header and the keyword cards. See also Velocity.Keyword() and Velocity.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var VelocityGeneration = function() {
    /// <signature>
    /// <summary>Create a new VelocityGeneration object.</summary>
    /// <param name="Model" type="Model" optional="false">Model that velocity will be created in</param>
    /// <param name="type" type="Number" optional="false">Specify the type of Velocity generation (Can be VelocityGeneration.PART_SET or VelocityGeneration.PART or VelocityGeneration.NODE_SET)</param>
    /// <param name="id" type="Number" optional="false">Set Part ID, Part set ID or Node set ID</param>
    /// <param name="omega" type="Number" optional="false">Angular velocity about the rotational axis</param>
    /// <param name="vx" type="Number" optional="false">Initial translational velocity in X direction</param>
    /// <param name="vy" type="Number" optional="false">Initial translational velocity in Y direction</param>
    /// <param name="vz" type="Number" optional="false">Initial translational velocity in Z direction</param>
    /// <param name="ivatn" type="Number" optional="false">Slave parts flag</param>
    /// <param name="xc" type="Number" optional="false">x-coordinate on rotational axis</param>
    /// <param name="yc" type="Number" optional="false">y-coordinate on rotational axis</param>
    /// <param name="zc" type="Number" optional="false">z-coordinate on rotational axis</param>
    /// <param name="nx" type="Number" optional="false">x-direction cosine</param>
    /// <param name="ny" type="Number" optional="false">y-direction cosine</param>
    /// <param name="nz" type="Number" optional="false">z-direction cosine</param>
    /// <param name="phase" type="Number" optional="false">Dynamic relaxation flag</param>
    /// <param name="irigid" type="Number" optional="false">Overide part inertia flag</param>
    /// <param name="icid" type="Number" optional="false">Local coordinate system</param>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
    /// <field name='exists' static='false' type='Boolean'>true if velocity exists, false if referred to but not defined. (read only)</field>
    /// <field name='icid' static='false' type='Number'>Local coordinate system</field>
    /// <field name='id' static='false' type='Number'>Set Part ID, Part set ID or Node set ID</field>
    /// <field name='include' static='false' type='Number'>The Include file number that the initial velocity is in.</field>
    /// <field name='irigid' static='false' type='Number'>Overide part inertia flag</field>
    /// <field name='ivatn' static='false' type='Number'>Slave parts flag</field>
    /// <field name='model' static='false' type='Number'>The Model number that the initial velocity generation is in.</field>
    /// <field name='nx' static='false' type='Number'>x-direction cosine</field>
    /// <field name='ny' static='false' type='Number'>y-direction cosine</field>
    /// <field name='nz' static='false' type='Number'>z-direction cosine</field>
    /// <field name='omega' static='false' type='Number'>Angular velocity about the rotational axis</field>
    /// <field name='phase' static='false' type='Number'>Dynamic relaxation flag</field>
    /// <field name='type' static='false' type='Number'>Specify the type of Velocity generation (Can be VelocityGeneration.PART_SET or VelocityGeneration.PART or VelocityGeneration.NODE_SET)</field>
    /// <field name='vx' static='false' type='Number'>Initial translational velocity in X direction</field>
    /// <field name='vy' static='false' type='Number'>Initial translational velocity in Y direction</field>
    /// <field name='vz' static='false' type='Number'>Initial translational velocity in Z direction</field>
    /// <field name='xc' static='false' type='Number'>x-coordinate on rotational axis</field>
    /// <field name='yc' static='false' type='Number'>y-coordinate on rotational axis</field>
    /// <field name='zc' static='false' type='Number'>z-coordinate on rotational axis</field>
    /// <field name='NODE_SET' static='true' type='Number'>ID is a NODE_SET</field>
    /// <field name='PART' static='true' type='Number'>ID is a PART</field>
    /// <field name='PART_SET' static='true' type='Number'>ID is a PART_SET</field>
}

VelocityGeneration.prototype.Blank = function() {
    /// <signature>
    /// <summary>Blanks the initial velocity generation</summary>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.BlankAll = function() {
    /// <signature>
    /// <summary>Blanks all of the initial velocity generations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocity generations will be blanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.BlankFlagged = function() {
    /// <signature>
    /// <summary>Blanks all of the flagged initial velocity generations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged initial velocity generations will be blanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocity generations that you want to blank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.prototype.Blanked = function() {
    /// <signature>
    /// <summary>Checks if the initial velocity generation is blanked or not.</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

VelocityGeneration.prototype.Browse = function() {
    /// <signature>
    /// <summary>Starts an edit panel in Browse mode.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.prototype.ClearFlag = function() {
    /// <signature>
    /// <summary>Clears a flag on the initial velocity generation.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to clear on the initial velocity generation</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.prototype.Copy = function() {
    /// <signature>
    /// <summary>Copies the initial velocity generation.</summary>
    /// <param name="range" type="Boolean" optional="true">If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().</param>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.Create = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel to create an initial velocity generation definition.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the initial velocity generation definition will be created in</param>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.prototype.Edit = function() {
    /// <signature>
    /// <summary>Starts an interactive editing panel.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.prototype.Error = function() {
    /// <signature>
    /// <summary>Adds an error for initial velocity generation. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The error message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed error message</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.First = function() {
    /// <signature>
    /// <summary>Returns the first initial velocity generation in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get first initial velocity generation in</param>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.FlagAll = function() {
    /// <signature>
    /// <summary>Flags all of the initial velocity generations in the model with a defined flag.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocity generations will be flagged in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the initial velocity generations</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.prototype.Flagged = function() {
    /// <signature>
    /// <summary>Checks if the initial velocity generation is flagged or not.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to test on the initial velocity generation</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

VelocityGeneration.ForEach = function() {
    /// <signature>
    /// <summary>Calls a function for each initial velocity generation in the model. Note that ForEach has been designed to make looping over initial velocity generations as fast as possible and so has some limitations. Firstly, a single temporary VelocityGeneration object is created and on each function call it is updated with the current initial velocity generation data. This means that you should not try to store the VelocityGeneration object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new initial velocity generations inside a ForEach loop. </summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocity generations are in</param>
    /// <param name="func" type="function" optional="false">Function to call for each initial velocity generation</param>
    /// <param name="extra" type="any" optional="true">An optional extra object/array/string etc that will appended to arguments when calling the function</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.GetAll = function() {
    /// <signature>
    /// <summary>Returns an array of VelocityGeneration objects for all of the initial velocity generations in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get initial velocity generations from</param>
    /// <returns type="Array" elementType="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.GetFlagged = function() {
    /// <signature>
    /// <summary>Returns an array of VelocityGeneration objects for all of the flagged initial velocity generations in a model in Primer</summary>
    /// <param name="Model" type="Model" optional="false">Model to get initial velocity generations from</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocity generations that you want to retrieve</param>
    /// <returns type="Array" elementType="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.GetFromID = function() {
    /// <signature>
    /// <summary>Returns the VelocityGeneration object for a initial velocity generation ID.</summary>
    /// <param name="Model" type="Model" optional="false">Model to find the initial velocity generation in</param>
    /// <param name="number" type="Number" optional="false">number of the initial velocity generation you want the VelocityGeneration object for</param>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.prototype.GetParameter = function() {
    /// <signature>
    /// <summary>Checks if a VelocityGeneration property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the VelocityGeneration.ViewParameters() method and 'method chaining' (see the examples below).</summary>
    /// <param name="prop" type="String" optional="false">initial velocity generation property to get parameter for</param>
    /// <returns type="Parameter"/>
    /// </signature>
}

VelocityGeneration.prototype.Keyword = function() {
    /// <signature>
    /// <summary>Returns the keyword for this initial velocity (*INITIAL_VELOCITY_GENERATION). Note that a carriage return is not added. See also VelocityGeneration.KeywordCards()</summary>
    /// <returns type="String"/>
    /// </signature>
}

VelocityGeneration.prototype.KeywordCards = function() {
    /// <signature>
    /// <summary>Returns the keyword cards for the initial velocity_generation. Note that a carriage return is not added. See also VelocityGeneration.Keyword()</summary>
    /// <returns type="String"/>
    /// </signature>
}

VelocityGeneration.Last = function() {
    /// <signature>
    /// <summary>Returns the last initial velocity generation in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get last initial velocity generation in</param>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.prototype.Next = function() {
    /// <signature>
    /// <summary>Returns the next initial velocity generation in the model.</summary>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.Pick = function() {
    /// <signature>
    /// <summary>Allows the user to pick a initial velocity generation.</summary>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only initial velocity generations from that model can be picked. If the argument is a Flag then only initial velocity generations that are flagged with limit can be selected. If omitted, or null, any initial velocity generations from any model can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.</param>
    /// <param name="button text" type="String" optional="true">By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.</param>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.prototype.Previous = function() {
    /// <signature>
    /// <summary>Returns the previous initial velocity generation in the model.</summary>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.Select = function() {
    /// <signature>
    /// <summary>Allows the user to select initial velocity generations using standard PRIMER object menus.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to use when selecting initial velocity generations</param>
    /// <param name="prompt" type="String" optional="false">Text to display as a prompt to the user</param>
    /// <param name="limit" type="Model|Number" optional="true">If the argument is a Model then only initial velocity generations from that model can be selected. If the argument is a Flag then only initial velocity generations that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any initial velocity generations can be selected. from any model.</param>
    /// <param name="modal" type="Boolean" optional="true">If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.</param>
    /// <returns type="Number"/>
    /// </signature>
}

VelocityGeneration.prototype.SetFlag = function() {
    /// <signature>
    /// <summary>Sets a flag on the initial velocity generation.</summary>
    /// <param name="flag" type="Flag" optional="false">Flag to set on the initial velocity generation</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.prototype.Sketch = function() {
    /// <signature>
    /// <summary>Sketches the initial velocity generation. The initial velocity generation will be sketched until you either call VelocityGeneration.Unsketch(), VelocityGeneration.UnsketchAll(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocity generation is sketched. If omitted redraw is true. If you want to sketch several initial velocity generations and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.SketchFlagged = function() {
    /// <signature>
    /// <summary>Sketches all of the flagged initial velocity generations in the model. The initial velocity generations will be sketched until you either call VelocityGeneration.Unsketch(), VelocityGeneration.UnsketchFlagged(), Model.UnsketchAll(), or delete the model</summary>
    /// <param name="Model" type="Model" optional="false">Model that all the flagged initial velocity generations will be sketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocity generations that you want to sketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocity generations are sketched. If omitted redraw is true. If you want to sketch flagged initial velocity generations several times and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.Total = function() {
    /// <signature>
    /// <summary>Returns the total number of initial velocity generations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model to get total for</param>
    /// <param name="exists" type="Boolean" optional="true">true if only existing initial velocity generations should be counted. If false or omitted referenced but undefined initial velocity generations will also be included in the total.</param>
    /// <returns type="Number"/>
    /// </signature>
}

VelocityGeneration.prototype.Unblank = function() {
    /// <signature>
    /// <summary>Unblanks the initial velocity generation</summary>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.UnblankAll = function() {
    /// <signature>
    /// <summary>Unblanks all of the initial velocity generations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocity generations will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.UnblankFlagged = function() {
    /// <signature>
    /// <summary>Unblanks all of the flagged initial velocity generations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the flagged initial velocity generations will be unblanked in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocity generations that you want to unblank</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.UnflagAll = function() {
    /// <signature>
    /// <summary>Unsets a defined flag on all of the initial velocity generations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that the defined flag for all initial velocity generations will be unset in</param>
    /// <param name="flag" type="Flag" optional="false">Flag to unset on the initial velocity generations</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.prototype.Unsketch = function() {
    /// <signature>
    /// <summary>Unsketches the initial velocity generation.</summary>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocity generation is unsketched. If omitted redraw is true. If you want to unsketch several initial velocity generations and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.UnsketchAll = function() {
    /// <signature>
    /// <summary>Unsketches all initial velocity generations.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocity generations will be unblanked in</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocity generations are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.UnsketchFlagged = function() {
    /// <signature>
    /// <summary>Unsketches all flagged initial velocity generations in the model.</summary>
    /// <param name="Model" type="Model" optional="false">Model that all initial velocity generations will be unsketched in</param>
    /// <param name="flag" type="Flag" optional="false">Flag set on the initial velocity generations that you want to unsketch</param>
    /// <param name="redraw" type="Boolean" optional="true">If model should be redrawn or not after the initial velocity generations are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.prototype.ViewParameters = function() {
    /// <signature>
    /// <summary>Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.</summary>
    /// <returns type="VelocityGeneration"/>
    /// </signature>
}

VelocityGeneration.prototype.Warning = function() {
    /// <signature>
    /// <summary>Adds a warning for initial velocity generation. For more details on checking see the Check class.</summary>
    /// <param name="message" type="String" optional="false">The warning message to give</param>
    /// <param name="details" type="String" optional="true">An optional detailed warning message</param>
    /// <returns type="null"/>
    /// </signature>
}

VelocityGeneration.prototype.Xrefs = function() {
    /// <signature>
    /// <summary>Returns the cross references for this initial velocity generation.</summary>
    /// <returns type="Xrefs"/>
    /// </signature>
}

VelocityGeneration.prototype.toString = function() {
    /// <signature>
    /// <summary>Creates a string containing the initial velocity data in keyword format. Note that this contains the keyword header and the keyword cards. See also VelocityGeneration.Keyword() and VelocityGeneration.KeywordCards().</summary>
    /// <returns type="String"/>
    /// </signature>
}

var View = function() {
    /// <field name='ABSOLUTE' static='true' type='Number'>Subtype Absolute (of type Shell Thickness)</field>
    /// <field name='ADDEDMASS' static='true' type='Number'>Subtype Added Mass (of type Mass Scale)</field>
    /// <field name='ADDEDMASSPART' static='true' type='Number'>Subtype Added Mass #Part (of type Mass Scale)</field>
    /// <field name='ASPECTRATIO' static='true' type='Number'>Subtype Aspect Ratio (of type Element Quality)</field>
    /// <field name='CONTOUR' static='true' type='Number'>Subtype Contour (of type Shell Normals)</field>
    /// <field name='DENSITY' static='true' type='Number'>Subtype Density (of type Material Property)</field>
    /// <field name='ELEMPROPS' static='true' type='Number'>Type Element Properties</field>
    /// <field name='ELEMQUAL' static='true' type='Number'>Type Element Quality</field>
    /// <field name='EMPFINALMASS' static='true' type='Number'>Subtype (*)Final Mass (of type (*)EMP Parts Only)</field>
    /// <field name='EMPNSMASS' static='true' type='Number'>Subtype (*)NS Mass (of type (*)EMP Parts Only)</field>
    /// <field name='EMPSTRUCTMASS' static='true' type='Number'>Subtype (*)Struct Mass (of type (*)EMP Parts Only)</field>
    /// <field name='FAILEDCRITERIA' static='true' type='Number'>Subtype Failed Criteria (of type Element Quality)</field>
    /// <field name='FINALMASS' static='true' type='Number'>Subtype Final Mass (of type (*)EMP Parts Only)</field>
    /// <field name='FORM' static='true' type='Number'>Subtype Form (native) (of type Element Property)</field>
    /// <field name='FORMULATION' static='true' type='Number'>Subtype Formulation (of type Element Property)</field>
    /// <field name='INITVELRES' static='true' type='Number'>Subtype Init Vel-Res (of type Init Vel Component)</field>
    /// <field name='INITVELS' static='true' type='Number'>Type Initial Velocities</field>
    /// <field name='INITVELX' static='true' type='Number'>Subtype Init Vel-X (of type Init Vel Component)</field>
    /// <field name='INITVELY' static='true' type='Number'>Subtype Init Vel-Y (of type Init Vel Component)</field>
    /// <field name='INITVELZ' static='true' type='Number'>Subtype Init Vel-Z (of type Init Vel Component)</field>
    /// <field name='INTPOINTS' static='true' type='Number'>Subtype Integration Points (of type Element Property)</field>
    /// <field name='ISO' static='true' type='Number'>Isometric projection</field>
    /// <field name='JACOBIAN' static='true' type='Number'>Subtype Jacobian (of type Element Quality)</field>
    /// <field name='LOADSHELLDIRECTION' static='true' type='Number'>Type Load Shell Direction</field>
    /// <field name='MASSSCALE' static='true' type='Number'>Type Mass Scale</field>
    /// <field name='MATERIALNUMBER' static='true' type='Number'>Subtype Material Number (of type Material Property)</field>
    /// <field name='MATLPROPS' static='true' type='Number'>Type Material Properties</field>
    /// <field name='MAXINTANGLE' static='true' type='Number'>Subtype Max Internal Angle (of type Element Quality)</field>
    /// <field name='MININTANGLE' static='true' type='Number'>Subtype Min Internal Angle (of type Element Quality)</field>
    /// <field name='MINLENGTH' static='true' type='Number'>Subtype Min Length (of type Element Quality)</field>
    /// <field name='PARTMASS' static='true' type='Number'>Type Part Mass</field>
    /// <field name='PERCENTADDEDMASS' static='true' type='Number'>Subtype % Added Mass (of type Mass Scale)</field>
    /// <field name='PERCENTADDEDMASSPART' static='true' type='Number'>Subtype % Added Mass #Part (of type Mass Scale)</field>
    /// <field name='PLASTICSTRAIN' static='true' type='Number'>Subtype Plastic Strain (of type Element Property)</field>
    /// <field name='POISSONRATIO' static='true' type='Number'>Subtype Poisson's Ratio (of type Material Property)</field>
    /// <field name='QUALIMPERF' static='true' type='Number'>Subtype Tet Collapse (of type Element Quality)</field>
    /// <field name='REMAINING' static='true' type='Number'>Subtype % remaining (of type Shell Thickness)</field>
    /// <field name='SHELLNORMALS' static='true' type='Number'>Type Shell Normals</field>
    /// <field name='SHELLTHICKNESS' static='true' type='Number'>Type Shell Thickness</field>
    /// <field name='SKEW' static='true' type='Number'>Subtype Skew (native) (of type Element Quality)</field>
    /// <field name='STRUCTMASS' static='true' type='Number'>Subtype Struct Mass (of type (*)EMP Parts Only)</field>
    /// <field name='TAPER' static='true' type='Number'>Subtype Taper (of type Element Quality)</field>
    /// <field name='TETCOLLAPSE' static='true' type='Number'>Subtype Formulation (of type Element Quality)</field>
    /// <field name='THINNING' static='true' type='Number'>Subtype % thinning (of type Shell Thickness)</field>
    /// <field name='TIMESTEP' static='true' type='Number'>Type TimeStep</field>
    /// <field name='VECTOR' static='true' type='Number'>Subtype Vector (of type Shell Normals)</field>
    /// <field name='WARPAGE' static='true' type='Number'>Subtype Warpage (of type Element Quality)</field>
    /// <field name='XY' static='true' type='Number'>XY axis projection</field>
    /// <field name='XZ' static='true' type='Number'>XZ axis projection</field>
    /// <field name='YIELDSTRESS' static='true' type='Number'>Subtype Yield Stress (of type Material Property)</field>
    /// <field name='YOUNGMODULUS' static='true' type='Number'>Subtype Young's Modulus (of type Material Property)</field>
    /// <field name='YZ' static='true' type='Number'>YZ axis projection</field>
}

View.Ac = function() {
    /// <signature>
    /// <summary>Autoscales the view</summary>
    /// <returns type="null"/>
    /// </signature>
}

View.Ct = function() {
    /// <signature>
    /// <summary>Does a contour plot</summary>
    /// <returns type="null"/>
    /// </signature>
}

View.Hi = function() {
    /// <signature>
    /// <summary>Does a Hidden line plot</summary>
    /// <returns type="null"/>
    /// </signature>
}

View.Li = function() {
    /// <signature>
    /// <summary>Does a line (wireframe) plot</summary>
    /// <returns type="null"/>
    /// </signature>
}

View.Redraw = function() {
    /// <signature>
    /// <summary>Redraws the plot using the current plot mode.</summary>
    /// <returns type="null"/>
    /// </signature>
}

View.SetContourType = function() {
    /// <signature>
    /// <summary>Sets a contour type (and subtype)</summary>
    /// <param name="View type" type="Number" optional="false">The type of contour to plot. Can be:  View.TIMESTEP  View.SHELLTHICKNESS  View.SHELLNORMALS  View.LOADSHELLDIRECTION  View.ELEMPROPS  View.ELEMQUAL  View.MASSSCALE  View.MATLPROPS  View.INITVELS  View.PARTMASS</param>
    /// <param name="View subtype" type="Number" optional="false">The subtype of contour to plot. Note: This second argument is NOT required for types TIMESTEP and LOADSHELLDIRECTION.  Subtypes for Type TIMESTEP:  No subtypes  Subtypes for Type SHELLTHICKNESS:  View.ABSOLUTE  View.THINNING  View.REMAINING  Subtypes for SHELLNORMALS:  View.CONTOUR  View.VECTOR  Subtypes for Type LOADSHELLDIRECTION:  No subtypes  Subtypes for Type ELEMPROPS:  View.FORMULATION  View.INTPOINTS  View.PLASTICSTRAIN  View.FORM  Subtypes for Type ELEMQUAL:  View.MINLENGTH  View.ASPECTRATIO  View.WARPAGE  View.SKEW  View.MININTANGLE  View.MAXINTANGLE  View.JACOBIAN  View.TAPER  View.TETCOLLAPSE  View.QUALIMPERF  View.FAILEDCRITERIA  Subtypes for Type MASSSCALE:  View.PERCENTADDEDMASS  View.ADDEDMASS  View.PERCENTADDEDMASSPART  View.ADDEDMASSPART  Subtypes for Type MATLPROPS:  View.DENSITY  View.YIELDSTRESS  View.POISSONRATIO  View.YOUNGMODULUS  View.MATERIALNUMBER  Subtypes for Type INITVELS:  View.INITVELX  View.INITVELY  View.INITVELZ  View.INITVELRES  Subtypes for Type PARTMASS:  View.STRUCTMASS  View.EMPSTRUCTMASS  View.EMPNSMASS  View.FINALMASS  View.EMPFINALMASS </param>
    /// <returns type="null"/>
    /// </signature>
}

View.Sh = function() {
    /// <signature>
    /// <summary>Does a shaded plot</summary>
    /// <returns type="null"/>
    /// </signature>
}

View.Show = function() {
    /// <signature>
    /// <summary>Redraws using one of the standard views</summary>
    /// <param name="View type" type="Number" optional="false">The view to show. Can be +/-View.XY, +/-View.YZ, +/-View.XZ or +/-View.ISO</param>
    /// <returns type="null"/>
    /// </signature>
}

View.Si = function() {
    /// <signature>
    /// <summary>Does a shaded image contour plot</summary>
    /// <returns type="null"/>
    /// </signature>
}

View.Vec = function() {
    /// <signature>
    /// <summary>Does a vector plot</summary>
    /// <returns type="null"/>
    /// </signature>
}

var Widget = function() {
    /// <signature>
    /// <summary>Create a new Widget object.</summary>
    /// <param name="window" type="Window|PopupWindow" optional="false">Window or PopupWindow that widget will be created in</param>
    /// <param name="type" type="Number" optional="false">Widget type. Can be Widget.LABEL, Widget.BUTTON, Widget.CHECKBOX, Widget.COMBOBOX, Widget.LISTBOX, Widget.TEXTBOX or Widget.SLIDER.</param>
    /// <param name="left" type="Number" optional="false">left coordinate of widget</param>
    /// <param name="right" type="Number" optional="false">right coordinate of widget</param>
    /// <param name="top" type="Number" optional="false">top coordinate of widget</param>
    /// <param name="bottom" type="Number" optional="false">bottom coordinate of widget</param>
    /// <param name="text" type="String" optional="true">Text to show on widget (optional for LABEL, BUTTON and TEXTBOX, not required for CHECKBOX, COMBOBOX, LISTBOX and SLIDER)</param>
    /// <returns type="Widget"/>
    /// </signature>
    /// <field name='active' static='false' type='Boolean'>If widget is active (true) or disabled (false)</field>
    /// <field name='arrows' static='false' type='Boolean'>Whether arrows will be shown for a slider (default is true). Slider Widgets only.</field>
    /// <field name='background' static='false' type='Number'>Widget background colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY, Widget.ORANGE, Widget.DEFAULT, Widget.COLOUR_NEUTRAL, Widget.COLOUR_CONTRAST, Widget.COLOUR_CONTRAST_2, Widget.COLOUR_WARNING, Widget.COLOUR_SAFE, Widget.COLOUR_TITLE, Widget.COLOUR_INVERSE, Widget.DARKGREY_NEUTRAL, Widget.LIGHTGREY_NEUTRAL ,or a colour returned by Colour.RGB(). Note, background colours in the Window.THEME_DARK, Window.THEME_LIGHT, and Window.THEME_CLASSIC themes will be determined by the category of the widget not the background colour. To override this behaviour and use this background colour first set the widget category to Widget.NO_CATEGORY.</field>
    /// <field name='bottom' static='false' type='Number'>Widget bottom coordinate</field>
    /// <field name='category' static='false' type='Number'>The button category which determines the button's appearance when using the new user interface, see Window.Theme()</field>
    /// <field name='fontSize' static='false' type='Number'>Widget font size in points. Currently only supports the following sizes: 6, 7, 8, 10, 12, 14, 18, 24. Can be used only with Widget.LABEL and Widget.BUTTON. Both LATIN1 and UTF-8 encoding is supported on Windows but Linux only supports LATIN1 encoding at the moment.</field>
    /// <field name='foreground' static='false' type='Number'>Widget foreground colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY, Widget.ORANGE, Widget.DEFAULT, Widget.COLOUR_NEUTRAL, Widget.COLOUR_CONTRAST, Widget.COLOUR_CONTRAST_2, Widget.COLOUR_WARNING, Widget.COLOUR_SAFE, Widget.COLOUR_TITLE, Widget.COLOUR_LABEL, Widget.COLOUR_INVERSE, Widget.DARKGREY_NEUTRAL, Widget.LIGHTGREY_NEUTRAL ,or a colour returned by Colour.RGB().</field>
    /// <field name='hover' static='false' type='String'>Widget hover text</field>
    /// <field name='imageHeight' static='false' type='Number'>Height of widget image (pixels)</field>
    /// <field name='imageWidth' static='false' type='Number'>Width of widget image (pixels)</field>
    /// <field name='justify' static='false' type='Number'>Widget justification. Can be: Widget.LEFT, Widget.RIGHT or Widget.CENTRE (default).</field>
    /// <field name='left' static='false' type='Number'>Widget left coordinate</field>
    /// <field name='lineWidth' static='false' type='Number'>Width of lines when drawing graphics (initially 1; values 1-255 allowed).</field>
    /// <field name='macroTag' static='false' type='String'>Tag to use for this widget when recording a macro. If empty then the text property value will be used.</field>
    /// <field name='maximum' static='false' type='Number'>The maximum value allowed for a slider (default is 100). Slider Widgets only.</field>
    /// <field name='minimum' static='false' type='Number'>The minimum value allowed for a slider (default is 0). Slider Widgets only.</field>
    /// <field name='monospace' static='false' type='Boolean'>true if the widget uses a monospace font instead of a proportional width font (default). Label and button Widgets only.</field>
    /// <field name='onChange' static='false' type='function'>Function to call when the text in a TEXTBOX widget, the selection in a COMBOBOX widget or the value of a SLIDER is changed. The Widget object is accessible in the function using the 'this' keyword (see the example below for more details of how to define the function and how to use the 'this' keyword). To unset the function set the property to null. Note that this function is called when the user actually types something into the textbox, selects an item in the combobox or moves the slider, NOT when the Widget.text or Widget.value property changes.</field>
    /// <field name='onClick' static='false' type='function'>Function to call when a BUTTON, LABEL, CHECKBOX or COMBOBOX widget is clicked. The Widget object is accessible in the function using the 'this' keyword (see the example below for more details of how to define the function and how to use the 'this' keyword). To unset the function set the property to null. Note that this function is called when the user actually clicks on the button, NOT when the Widget.pushed property changes. For the COMBOBOX widget the function is called before the list of items is mapped.</field>
    /// <field name='onPopup' static='false' type='function'>Function to call when a BUTTON, LABEL or TEXTBOX widget is right clicked to map a popup. The Widget object is accessible in the function using the 'this' keyword. The PopupWindow can then be found by using the popupWindow property of the Widget. The function is called before the popup is mapped so you can change the widgets in the popup as required.</field>
    /// <field name='onTimer' static='false' type='function'>Function to call for a widget when timerDelay ms have elapsed after setting this. Additionally if timerRepeat is set this function will be called repetitively, every timerDelay ms. The Widget object is accessible in the function using the 'this' keyword. To unset the function set the property to null. Note that as soon as this property is set the timer starts!</field>
    /// <field name='orientation' static='false' type='Number'>The orientation of a slider. Can be: Widget.VERTICAL or Widget.HORIZONTAL (default). Slider Widgets only.</field>
    /// <field name='popupDirection' static='false' type='Number'>How PopupWindow will be mapped relative to this widget. Can be Widget.LEFT, Widget.RIGHT, Widget.TOP or Widget.BOTTOM (default).</field>
    /// <field name='popupSymbol' static='false' type='Boolean'>TRUE (default) if a symbol will be shown for a PopupWindow.</field>
    /// <field name='popupWindow' static='false' type='PopupWindow'>PopupWindow for this Widget. Only available for Button, Label and Textbox Widgets. To remove a PopupWindow from a Widget set to null.</field>
    /// <field name='pushed' static='false' type='Boolean'>If widget is pushed (true) or not (false). This only affects Widget.BUTTON with the Widget.toggle property set, and Widget.CHECKBOX widgets.</field>
    /// <field name='right' static='false' type='Number'>Widget right coordinate</field>
    /// <field name='select' static='false' type='Number'>Selection method for ListBox Widgets. Can be: Widget.SELECT_NONE, Widget.SELECT_SINGLE or Widget.SELECT_MULTIPLE or Widget.SELECT_ENHANCED (default).</field>
    /// <field name='selectedItem' static='false' type='WidgetItem'>WidgetItem that is currently selected for a ComboBox Widget. If null no WidgetItem is selected. For a ListBox Widget this property contains the last WidgetItem that was (de)selected. To get a list of all of the selected WidgetItems use WidgetItems() to return all of the WidgetItems and inspect the WidgetItem selected property.</field>
    /// <field name='shown' static='false' type='Boolean'>true if the widget is visible. To alter the visibility of a widget use the Show() and Hide() methods.</field>
    /// <field name='step' static='false' type='Number'>The step value of a slider (default is 1). Slider Widgets only.</field>
    /// <field name='text' static='false' type='String'>Widget text. For a ComboBox Widget this will be the text for the currently selected WidgetItem</field>
    /// <field name='textHidden' static='false' type='Boolean'>true if the widget text is hidden and replaced by asterisks. This may be used to create textboxes to type passwords in. TextBox Widgets only.</field>
    /// <field name='timerDelay' static='false' type='Number'>Delay in ms before the function set for onTimer will be called. The initial value is 1000 (ms). Also see timerRepeat.</field>
    /// <field name='timerRepeat' static='false' type='Boolean'>If the function set for onTimer will be called once (false) or repeatedly (true). The initial value is false. Also see timerDelay.</field>
    /// <field name='toggle' static='false' type='Boolean'>If widget can be toggled (true) or not (false). This only affects Widget.BUTTON widgets.</field>
    /// <field name='top' static='false' type='Number'>Widget top coordinate</field>
    /// <field name='type' static='false' type='Number'>Type of the widget</field>
    /// <field name='value' static='false' type='Number'>The current value of a slider (initially will be the minimum value). Slider Widgets only.</field>
    /// <field name='window' static='false' type='Window'>The Window that this widget is defined in</field>
    /// <field name='xResolution' static='false' type='Number'>X resolution of button when drawing lines, circles, polygons and rectangles (initially 100). X coordinates on the Widget can be from 0 (on the left of the widget) to xResolution (on the right of the widget). Available for Widget.LABEL and Widget.BUTTON Widgets.</field>
    /// <field name='yResolution' static='false' type='Number'>Y resolution of button when drawing lines, circles, polygons and rectangles (initially 100). Y coordinates on the Widget can be from 0 (on the top of the widget) to yResolution (on the bottom of the widget). Available for Widget.LABEL and Widget.BUTTON Widgets.</field>
    /// <field name='BLACK' static='true' type='Number'>Colour black</field>
    /// <field name='BLUE' static='true' type='Number'>Colour blue</field>
    /// <field name='BOTTOM' static='true' type='Number'>Bottom justification</field>
    /// <field name='BUTTON' static='true' type='Number'>Button widget</field>
    /// <field name='CATEGORY_APPLY' static='true' type='Number'>Apply buttons</field>
    /// <field name='CATEGORY_BUTTON_BOX' static='true' type='Number'>A button box panel that contains other widgets</field>
    /// <field name='CATEGORY_CANCEL' static='true' type='Number'>Buttons which cancel the current operation</field>
    /// <field name='CATEGORY_DATA_ENTRY_HEADER' static='true' type='Number'>Header for data entry cells, e.g. PRIMER create panels</field>
    /// <field name='CATEGORY_DISMISS' static='true' type='Number'>Buttons to close or dismiss panels</field>
    /// <field name='CATEGORY_ENTITY' static='true' type='Number'>Entity types in T/HIS</field>
    /// <field name='CATEGORY_GENERIC' static='true' type='Number'>A generic button that isn't a special category</field>
    /// <field name='CATEGORY_GENERIC_2' static='true' type='Number'>An alternative to the generic category that has a complementary colour</field>
    /// <field name='CATEGORY_HELP' static='true' type='Number'>Help buttons</field>
    /// <field name='CATEGORY_KEYWORD' static='true' type='Number'>A PRIMER keyword button</field>
    /// <field name='CATEGORY_LABEL' static='true' type='Number'>A text label</field>
    /// <field name='CATEGORY_LABEL_BOX' static='true' type='Number'>Text label with a border</field>
    /// <field name='CATEGORY_LABEL_POPUP' static='true' type='Number'>Text label with a popup that blends into the background</field>
    /// <field name='CATEGORY_MENU_BOX' static='true' type='Number'>A menu box</field>
    /// <field name='CATEGORY_MESSAGE' static='true' type='Number'>For displaying a temporary warning message</field>
    /// <field name='CATEGORY_OPERATE' static='true' type='Number'>Operate buttons in T/HIS</field>
    /// <field name='CATEGORY_POPUP_BOX' static='true' type='Number'>A popup box that can contain buttons and plain text</field>
    /// <field name='CATEGORY_SAFE_ACTION' static='true' type='Number'>Buttons (usually green) to indicate a safe action</field>
    /// <field name='CATEGORY_SEL_ALL' static='true' type='Number'>Select all</field>
    /// <field name='CATEGORY_TAB' static='true' type='Number'>Tab</field>
    /// <field name='CATEGORY_TABLE_HEADER' static='true' type='Number'>Table (column) header</field>
    /// <field name='CATEGORY_TABLE_ROW' static='true' type='Number'>Table row</field>
    /// <field name='CATEGORY_TEXT_BOX' static='true' type='Number'>A text box</field>
    /// <field name='CATEGORY_TICKBOX' static='true' type='Number'>A tick box</field>
    /// <field name='CATEGORY_TITLE' static='true' type='Number'>Title text</field>
    /// <field name='CATEGORY_TOGGLE' static='true' type='Number'>Buttons that can be toggled, e.g. On/Off</field>
    /// <field name='CATEGORY_TOOL' static='true' type='Number'>Buttons within the tools area</field>
    /// <field name='CATEGORY_UNDO' static='true' type='Number'>Buttons which undo the last operation</field>
    /// <field name='CATEGORY_UNSEL_ALL' static='true' type='Number'>Unselect/deslect all</field>
    /// <field name='CATEGORY_UPDATE' static='true' type='Number'>Update buttons which update the screen but leave the panel open</field>
    /// <field name='CATEGORY_WARNING_ACTION' static='true' type='Number'>Buttons (usually red) to indicate a dangerous action</field>
    /// <field name='CENTRE' static='true' type='Number'>Centre (horizontal) justification</field>
    /// <field name='CHECKBOX' static='true' type='Number'>Checkbox widget</field>
    /// <field name='COLOUR_CONTRAST' static='true' type='Number'>A contrasting colour in the 3 user interface themes (Green, Purple, and Blue in the Dark, Light, and Classic themes respectively). Blue in the legacy theme.</field>
    /// <field name='COLOUR_CONTRAST_2' static='true' type='Number'>Another contrasting colour in the 3 user interface themes (Yellow, Red, and Red in the Dark, Light, and Classic themes respectively). Red in the legacy theme.</field>
    /// <field name='COLOUR_INVERSE' static='true' type='Number'>Inverse colour in the 3 user interface themes (Black or white depending on theme). Black in the legacy theme.</field>
    /// <field name='COLOUR_LABEL' static='true' type='Number'>Label text colour in the 3 user interface themes (Black or white depending on theme). Black in the legacy theme.</field>
    /// <field name='COLOUR_NEUTRAL' static='true' type='Number'>Neutral colour in the 3 user interface themes (Different shade of grey in every theme). Light grey in the legacy theme.</field>
    /// <field name='COLOUR_SAFE' static='true' type='Number'>Safe colour in the 3 user interface themes (Different shade of green in every theme). Dark green in the legacy theme.</field>
    /// <field name='COLOUR_TITLE' static='true' type='Number'>Title colour in the 3 user interface themes (Different shade of grey in every theme). Dark blue in the legacy theme.</field>
    /// <field name='COLOUR_WARNING' static='true' type='Number'>Warning colour in the 3 user interface themes (Different shade of red in every theme). Dark red in the legacy theme.</field>
    /// <field name='COMBOBOX' static='true' type='Number'>Combobox widget</field>
    /// <field name='CYAN' static='true' type='Number'>Colour cyan</field>
    /// <field name='DARKBLUE' static='true' type='Number'>Colour dark blue</field>
    /// <field name='DARKGREEN' static='true' type='Number'>Colour dark green</field>
    /// <field name='DARKGREY' static='true' type='Number'>Colour dark grey</field>
    /// <field name='DARKGREY_NEUTRAL' static='true' type='Number'>Only valid in the function 'Line'. Used to keep the 3D effect in the legacy theme and not in the other themes. Neutral colour in the 3 user interface themes (Different shade of grey in every theme). Dark grey in the legacy theme</field>
    /// <field name='DARKRED' static='true' type='Number'>Colour dark red</field>
    /// <field name='DEFAULT' static='true' type='Number'>Default colour for widgets</field>
    /// <field name='GREEN' static='true' type='Number'>Colour green</field>
    /// <field name='GREY' static='true' type='Number'>Colour grey</field>
    /// <field name='HORIZONTAL' static='true' type='Number'>Horizontal orientation (for sliders)</field>
    /// <field name='LABEL' static='true' type='Number'>Label widget</field>
    /// <field name='LEFT' static='true' type='Number'>Left justification</field>
    /// <field name='LIGHTGREY' static='true' type='Number'>Colour light grey</field>
    /// <field name='LIGHTGREY_NEUTRAL' static='true' type='Number'>Only valid in the function 'Line'. Used to keep the 3D effect in the legacy theme and not in the other themes. Neutral colour in the 3 user interface themes (Different shade of grey in every theme). Light grey in the legacy theme</field>
    /// <field name='LISTBOX' static='true' type='Number'>Listbox widget</field>
    /// <field name='MAGENTA' static='true' type='Number'>Colour magenta</field>
    /// <field name='MIDDLE' static='true' type='Number'>Middle (vertical) justification</field>
    /// <field name='NO_CATEGORY' static='true' type='Number'>No styling is applied. Widget colour controlled by foreground/background properties and is the same in all themes</field>
    /// <field name='ORANGE' static='true' type='Number'>Colour orange</field>
    /// <field name='RED' static='true' type='Number'>Colour red</field>
    /// <field name='RGB24' static='true' type='Number'>24 bits for RGB data in widget images</field>
    /// <field name='RGB8' static='true' type='Number'>8 bits for RGB data in widget images</field>
    /// <field name='RIGHT' static='true' type='Number'>Right justification</field>
    /// <field name='SCALE' static='true' type='Number'>Image will be scaled to fit widget</field>
    /// <field name='SELECT_ENHANCED' static='true' type='Number'>Multiple WidgetItems in a ListBox Widget can be selected. When the user selects a WidgetItem the selection is cleared and the new WidgetItem selected. However, if the user presses the Ctrl key when clicking on a WidgetItem, the clicked WidgetItem gets toggled and all other WidgetItems are left untouched. If the user presses the Shift key while clicking on a WidgetItem, all WidgetItems between the last selected WidgetItem and the clicked WidgetItem are selected or unselected, depending on the state of the clicked WidgetItem.</field>
    /// <field name='SELECT_MULTIPLE' static='true' type='Number'>Multiple WidgetItems in a ListBox Widget can be selected. When the user selects a WidgetItem, the selection status of that WidgetItem is toggled and the other WidgetItems are left alone.</field>
    /// <field name='SELECT_NONE' static='true' type='Number'>No WidgetItem in a ListBox Widget can be selected</field>
    /// <field name='SELECT_SINGLE' static='true' type='Number'>A single WidgetItem in a ListBox Widget can be selected. When the user selects a WidgetItem, any already-selected WidgetItem becomes unselected, and the user cannot unselect the selected WidgetItem by clicking on it.</field>
    /// <field name='SLIDER' static='true' type='Number'>Slider widget</field>
    /// <field name='TEXTBOX' static='true' type='Number'>Text input widget</field>
    /// <field name='TOP' static='true' type='Number'>Top justification</field>
    /// <field name='VERTICAL' static='true' type='Number'>Vertical orientation (for sliders)</field>
    /// <field name='WHITE' static='true' type='Number'>Colour white</field>
    /// <field name='YELLOW' static='true' type='Number'>Colour yellow</field>
}

Widget.prototype.AddWidgetItem = function() {
    /// <signature>
    /// <summary>Adds a WidgetItem to the Widget. Also see Widget.RemoveAllWidgetItems and Widget.RemoveWidgetItem.</summary>
    /// <param name="item" type="WidgetItem" optional="false">WidgetItem to add</param>
    /// <param name="position" type="Number" optional="true">Position on Widget to add the WidgetItem. Any existing WidgetItems will be shifted down as required. If omitted the WidgetItem will be added to the end of the existing ones. Note that positions start at 0.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.Circle = function() {
    /// <signature>
    /// <summary>Draws a circle on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The coordinates are local to the Widget, not the Window. See properties xResolution and yResolution for more details. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().</summary>
    /// <param name="colour" type="Number" optional="false">Colour of circle. See foreground for colours.</param>
    /// <param name="fill" type="Boolean" optional="false">If circle should be filled or not.</param>
    /// <param name="xc" type="Number" optional="false">x coordinate of centre of circle.</param>
    /// <param name="yc" type="Number" optional="false">y coordinate of centre of circle.</param>
    /// <param name="radius" type="Number" optional="false">radius of circle.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.Clear = function() {
    /// <signature>
    /// <summary>Clears any graphics on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().</summary>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.ClearSelection = function() {
    /// <signature>
    /// <summary>Clears selection of any WidgetItems on the widget. Only possible for Widget.COMBOBOX and Widget.LISTBOX widgets.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.Cross = function() {
    /// <signature>
    /// <summary>Draws a cross symbol on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets.</summary>
    /// <param name="colour" type="Number" optional="true">Colour of cross symbol. See foreground for colours. If omitted, current foreground colour is used.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.CtrlPressed = function() {
    /// <signature>
    /// <summary>Check to see if the Ctrl key is pressed</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Widget.prototype.Delete = function() {
    /// <signature>
    /// <summary>Deletes the widget from PRIMER (removing it from the window it is defined in) and returns any memory/resources used for the widget. This function should not normally need to be called. However, sometimes a script may want to recreate widgets in a window many times and unless the old widgets are deleted PRIMER will reach the maximum number of widgets for a window (Options.max_widgets). To avoid this problem this method can be used to force PRIMER to delete and return the resources for a widget. Do not use the Widget object after calling this method.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.DirectoryIcon = function() {
    /// <signature>
    /// <summary>Draws a directory icon on the widget. Only possible for Widget.BUTTON widgets.</summary>
    /// <param name="line_colour" type="Number" optional="false">Colour of lines of folder (only used in the old UI - in the new UI it will be ignored, a standard icon is always used). See foreground for colours.</param>
    /// <param name="fill_colour" type="Number" optional="false">Colour of fill of folder (only used in the old UI - in the new UI it will be ignored, a standard icon is always used). See foreground for colours.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.DumpImageString = function() {
    /// <signature>
    /// <summary>Dumps a string representation of an image for a widget to a file in a form that can be used by Widget.ReadImageString(). Only possible for Widget.LABEL and Widget.BUTTON widgets.</summary>
    /// <param name="filename" type="String" optional="false">Filename to dump string representation to</param>
    /// <param name="format" type="Number" optional="true">Can be Widget.RGB8 or Widget.RGB24. Before version 15 PRIMER only used 8 bits to store RGB (red, green and blue) colour information for widget images. In version 15 widget images have been changed to use 24 bits to store RGB information (8 bits for red, 8 bits for green and 8 bits for blue). Both formats are supported. If omitted the new Widget.RGB24 format will be used. See Widget.ReadImageString() for more details.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.Hide = function() {
    /// <signature>
    /// <summary>Hides the widget on the screen</summary>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.ItemAt = function() {
    /// <signature>
    /// <summary>Returns the WidgetItem object used at index in this Widget. See also Widget.TotalItems() and Widget.WidgetItems().</summary>
    /// <param name="index" type="Number" optional="false">index to return WidgetItem for. Note that indices start at 0.</param>
    /// <returns type="WidgetItem"/>
    /// </signature>
}

Widget.prototype.Line = function() {
    /// <signature>
    /// <summary>Draws a line on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The coordinates are local to the Widget, not the Window. See properties xResolution and yResolution for more details. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().</summary>
    /// <param name="colour" type="Number" optional="false">Colour of line. See foreground for colours.</param>
    /// <param name="x1" type="Number" optional="false">x coordinate of start of line.</param>
    /// <param name="y1" type="Number" optional="false">y coordinate of start of line.</param>
    /// <param name="x2" type="Number" optional="false">x coordinate of end of line.</param>
    /// <param name="y2" type="Number" optional="false">y coordinate of end of line.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.PixelsPerUnit = function() {
    /// <signature>
    /// <summary>Returns the number of pixels per unit coordinate. This will vary depending on the monitor PRIMER is running on.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Widget.prototype.Polygon = function() {
    /// <signature>
    /// <summary>Draws a polygon on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The coordinates are local to the Widget, not the Window. See properties xResolution and yResolution for more details. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().</summary>
    /// <param name="colour" type="Number" optional="false">Colour of polygon. See foreground for colours.</param>
    /// <param name="fill" type="Boolean" optional="false">If polygon should be filled or not.</param>
    /// <param name="x1" type="Number" optional="false">x coordinate of point 1.</param>
    /// <param name="y1" type="Number" optional="false">y coordinate of point 1.</param>
    /// <param name="x2" type="Number" optional="false">x coordinate of point 2.</param>
    /// <param name="y2" type="Number" optional="false">y coordinate of point 2.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.ReadImageFile = function() {
    /// <signature>
    /// <summary>Reads an image from a file to show on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The image will be shown on the widget underneath any text. Note that due to the way that colours are used for menus in PRIMER only a small number of colours are available for Widget images. Black and white images will display without any issues but colour images will be displayed with a reduced set of colours.</summary>
    /// <param name="filename" type="String" optional="false">Image file (BMP, GIF, JPEG or PNG) to read. To remove an image use null.</param>
    /// <param name="justify" type="Number" optional="true">Widget justification. Can be a bitwise or of Widget.LEFT, Widget.RIGHT or Widget.CENTRE and Widget.TOP, Widget.MIDDLE or Widget.BOTTOM. Additionally Widget.SCALE can be used to scale the image (either reducing or enlarging it) so that it fills the widget. If omitted the default is Widget.CENTRE|Widget.MIDDLE without scaling.</param>
    /// <param name="transparent" type="Number" optional="true">Transparent colour. Must be a colour returned by Colour.RGB() in PRIMER. If given then this colour will be replaced by a transparent colour. i.e. the widget background colour will be shown. If omitted or null no transparency will be used.</param>
    /// <param name="tolerance" type="Number" optional="true">Tolerance for transparent colour (0-255). Any pixels in the image that have a red, green and blue colour value within tolerance of the transparent colour will be transparent. For example if the transparent colour was given as Colour.RGB(255, 0, 0) and tolerance is 0 only pixels which have red value 255 and green value 0 and blue value 0 will be made transparent. If tolerance is 4, pixels which have red values between 251 and 255 and green values between 0 and 4 and blue values between 0 and 4 will be made transparent. If omitted a value of 8 will be used.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.ReadImageString = function() {
    /// <signature>
    /// <summary>Reads an image from a JavaScript string previously created by Widget.DumpImageString() to show on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The image will be shown on the widget underneath any text. Note, prior to version 15 of PRIMER only a small number of colours were available for Widget images. In version 14 and earlier the RGB (red, green and blue) information for each pixel in the image was packed into a single byte (8 bits) with 3 bits for red, 3 for green and 2 for blue. Widget.DumpImageString() always returned the string beginning with "RRRGGGBB_RLE" which is this 8 bit format with run length encoding. This is format Widget.RGB8. In version 15 support for Widget images was enhanced to give 24bit support for colours. The RGB information for each pixel has 8 bits for red, 8 bits for green and 8 bits for blue. This is format Widget.RGB24. From version 15 Widget.DumpImageString() can either return the the old 8 bit format Widget.RGB8 (string beginning with "RRRGGGBB_RLE") or return the the new 24bit format Widget.RGB24 (string beginning with "RGB24_Z"). ReadImageString supports both formats.</summary>
    /// <param name="string" type="String" optional="false">String containing the image data previously created by Widget.DumpImageString(). To remove an image use null.</param>
    /// <param name="justify" type="Number" optional="true">Widget justification. Can be a bitwise or of Widget.LEFT, Widget.RIGHT or Widget.CENTRE and Widget.TOP, Widget.MIDDLE or Widget.BOTTOM. Additionally Widget.SCALE can be used to scale the image (either reducing or enlarging it) so that it fills the widget. If omitted the default is Widget.CENTRE|Widget.MIDDLE without scaling.</param>
    /// <param name="transparent" type="Number" optional="true">Transparent colour. Must be a colour returned by Colour.RGB() in PRIMER. If given then this colour will be replaced by a transparent colour. i.e. the widget background colour will be shown. If omitted or null no transparency will be used.</param>
    /// <param name="tolerance" type="Number" optional="true">Tolerance for transparent colour (0-255). Only used for the new 24bit format Widget.RGB24 (strings beginning with "RGB24_Z"). Ignored for the old 8 bit format Widget.RGB8 (strings beginning with "RRRGGGBB_RLE"). Any pixels in the image that have a red, green and blue colour value within tolerance of the transparent colour will be transparent. For example if the transparent colour was given as Colour.RGB(255, 0, 0) and tolerance is 0 only pixels which have red value 255 and green value 0 and blue value 0 will be made transparent. If tolerance is 4, pixels which have red values between 251 and 255 and green values between 0 and 4 and blue values between 0 and 4 will be made transparent. If omitted a value of 8 will be used.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.Rectangle = function() {
    /// <signature>
    /// <summary>Draws a rectangle on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The coordinates are local to the Widget, not the Window. See properties xResolution and yResolution for more details. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().</summary>
    /// <param name="colour" type="Number" optional="false">Colour of rectangle. See foreground for colours.</param>
    /// <param name="fill" type="Boolean" optional="false">If rectangle should be filled or not.</param>
    /// <param name="x1" type="Number" optional="false">x coordinate of first corner of rectangle.</param>
    /// <param name="y1" type="Number" optional="false">y coordinate of first corner of rectangle.</param>
    /// <param name="x2" type="Number" optional="false">x coordinate of second (opposite) corner of rectangle.</param>
    /// <param name="y2" type="Number" optional="false">y coordinate of second (opposite) corner of rectangle.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.RemoveAllWidgetItems = function() {
    /// <signature>
    /// <summary>Removes any WidgetItems from the Widget. Also see Widget.AddWidgetItem and Widget.RemoveWidgetItem.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.RemoveWidgetItem = function() {
    /// <signature>
    /// <summary>Removes a WidgetItem from the Widget. Also see Widget.AddWidgetItem and Widget.RemoveAllWidgetItems.</summary>
    /// <param name="item" type="WidgetItem" optional="false">WidgetItem to remove</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.ShiftPressed = function() {
    /// <signature>
    /// <summary>Check to see if the Shift key is pressed</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Widget.prototype.Show = function() {
    /// <signature>
    /// <summary>Shows the widget on the screen</summary>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.Static = function() {
    /// <signature>
    /// <summary>Windows have two different regions for Widgets. A 'normal' region which can be scrolled if required (if the window is made smaller scrollbars will be shown which can be used to scroll the contents) and a 'static' region at the top of the Window which is fixed and does not scroll. For an example of a static region in a Window see any of the keyword editing panels. The 'Dismiss', 'Create', 'Reset' etc buttons are in the static region. By default Widgets are put into the normal region of the Window. This method puts the Widget to the static region of the Window.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Widget.StringLength = function() {
    /// <signature>
    /// <summary>Returns the length of a string in Widget units. This can be used to find what size a Widget must be to be able to display the string.</summary>
    /// <param name="text" type="String" optional="false">Text to find the width of</param>
    /// <param name="monospace" type="Boolean" optional="true">If true then width will be calculated using a monospace font. If false (default) then the normal proportional width font will be used</param>
    /// <param name="fontSize" type="Number" optional="true">Calculation can be based on a defined font size, at the moment support is added only for font sizes of 6, 7, 8, 10, 12, 14, 18 and 24.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Widget.prototype.Tick = function() {
    /// <signature>
    /// <summary>Draws a tick symbol on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets.</summary>
    /// <param name="colour" type="Number" optional="true">Colour of tick symbol. See foreground for colours. If omitted, current foreground colour is used.</param>
    /// <returns type="null"/>
    /// </signature>
}

Widget.prototype.TotalItems = function() {
    /// <signature>
    /// <summary>Returns the number of the WidgetItem objects used in this Widget (or 0 if none used). See also Widget.ItemAt() and Widget.WidgetItems().</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Widget.prototype.WidgetItems = function() {
    /// <signature>
    /// <summary>Returns an array of the WidgetItem objects used in this Widget (or null if none used). See also Widget.ItemAt() and Widget.TotalItems().</summary>
    /// <returns type="Array" elementType="WidgetItem"/>
    /// </signature>
}

var WidgetItem = function() {
    /// <signature>
    /// <summary>Create a new WidgetItem object.</summary>
    /// <param name="widget" type="Widget" optional="false">Widget that widget item will be created in. This can be null in which case the WidgetItem will be created but not assigned to a Widget. It can be assigned later by using Widget.AddWidgetItem().</param>
    /// <param name="text" type="String" optional="false">Text to show on widget item</param>
    /// <param name="selectable" type="Boolean" optional="true">If the widget item can be selected. If omitted the widget item will be selectable.</param>
    /// <returns type="WidgetItem"/>
    /// </signature>
    /// <field name='background' static='false' type='Number'>Widget background colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY or Widget.DEFAULT</field>
    /// <field name='foreground' static='false' type='Number'>Widget foreground colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY or Widget.DEFAULT</field>
    /// <field name='hover' static='false' type='String'>WidgetItem's hover text</field>
    /// <field name='index' static='false' type='Number'>The index of this widgetitem in the parent widget (undefined if widgetitem is not assigned to a widget).</field>
    /// <field name='monospace' static='false' type='Boolean'>true if the widgetitem uses a monospace font instead of a proportional width font (default).</field>
    /// <field name='onClick' static='false' type='function'>Function to call when a widget item in a COMBOBOX or LISTBOX widget is clicked. The Widgetitem object is accessible in the function using the 'this' keyword.</field>
    /// <field name='onMouseOver' static='false' type='function'>Function to call when the mouse moves over a widget item in a COMBOBOX or LISTBOX widget. The Widgetitem object is accessible in the function using the 'this' keyword.</field>
    /// <field name='selectable' static='false' type='Boolean'>If the widget item can be selected (true) or not (false).</field>
    /// <field name='selected' static='false' type='Boolean'>If the widget item is selected (true) or not (false).</field>
    /// <field name='text' static='false' type='String'>Widget text</field>
    /// <field name='widget' static='false' type='Object'>The widget that this item is defined for (null if not set)</field>
}

var Window = function() {
    /// <signature>
    /// <summary>Create a new Window object.</summary>
    /// <param name="title" type="String" optional="false">Window title to show in title bar</param>
    /// <param name="left" type="Number" optional="false">left coordinate of window in range 0.0 (left) to 1.0 (right)</param>
    /// <param name="right" type="Number" optional="false">right coordinate of window in range 0.0 (left) to 1.0 (right)</param>
    /// <param name="bottom" type="Number" optional="false">bottom coordinate of window in range 0.0 (bottom) to 1.0 (top)</param>
    /// <param name="top" type="Number" optional="false">top coordinate of window in range 0.0 (bottom) to 1.0 (top)</param>
    /// <returns type="Window"/>
    /// </signature>
    /// <field name='active' static='false' type='Boolean'>If true (default) then the window then the window is active and widgets in the window can be used. If false then the window is inactive and the widgets cannot be used.</field>
    /// <field name='background' static='false' type='Number'>Window background colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY or Widget.DEFAULT ,or a colour returned by Colour.RGB().</field>
    /// <field name='bottom' static='false' type='Number'>bottom coordinate of window in range 0.0 (bottom) to 1.0 (top)</field>
    /// <field name='height' static='false' type='Number'>height of window</field>
    /// <field name='keepOnTop' static='false' type='Boolean'>If true then the window will be kept "on top" of other windows. If false (default) then the window stacking order can be changed.</field>
    /// <field name='left' static='false' type='Number'>left coordinate of window in range 0.0 (left) to 1.0 (right)</field>
    /// <field name='maxWidgets' static='false' type='Number'>The maximum number of widgets that can be made in this window. This can be changed before the window is created by using Options.max_widgets. Also see totalWidgets</field>
    /// <field name='onAfterShow' static='false' type='function'>Function to call after a Window is shown. The Window object is accessible in the function using the 'this' keyword. This may be useful to ensure that certain actions are done after the window is shown. It can also be used to show another window so this enables multiple windows to be shown. To unset the function set the property to null.</field>
    /// <field name='onBeforeShow' static='false' type='function'>Function to call before a Window is shown. The Window object is accessible in the function using the 'this' keyword. This may be useful to ensure that buttons are shown/hidden etc before the window is shown. Note that it cannot be used to show another window. Use onAfterShow for that. To unset the function set the property to null.</field>
    /// <field name='onClose' static='false' type='function'>Function to call when a Window is closed by pressing the X on the top right of the window. The Window object is accessible in the function using the 'this' keyword. To unset the function set the property to null.</field>
    /// <field name='resize' static='false' type='Number'>Window resizing. By default when a Window is shown it is allowed to resize on all sides (left, right, top and bottom) to try to make enough room to show the Widgets. The behaviour can be changed by using this property. It can be any combination (bitwise OR) of Window.LEFT, Window.RIGHT, Window.TOP or Window.BOTTOM or 0. In addition Window.REDUCE can also be added to allow the window to reduce in size when resizing. Note that when Window.Show is called this property is set to 0 (i.e. not to resize on any side).</field>
    /// <field name='right' static='false' type='Number'>right coordinate of window in range 0.0 (left) to 1.0 (right)</field>
    /// <field name='showClose' static='false' type='Boolean'>If true (default) then a close (X) button will automatically be added on the top right of the window. If false then no close button will be shown.</field>
    /// <field name='shown' static='false' type='Boolean'>true if window is currently shown, false if not</field>
    /// <field name='title' static='false' type='String'>Window title</field>
    /// <field name='top' static='false' type='Number'>top coordinate of window in range 0.0 (bottom) to 1.0 (top)</field>
    /// <field name='totalWidgets' static='false' type='Number'>The total number of widgets that have been made in this window. This can be changed before the window is created by using Options.max_widgets. Also see maxWidgets</field>
    /// <field name='width' static='false' type='Number'>width of window</field>
    /// <field name='BOTTOM' static='true' type='Number'>Bottom resizing/positioning of window</field>
    /// <field name='CANCEL' static='true' type='Number'>Show CANCEL button</field>
    /// <field name='CENTRE' static='true' type='Number'>Centre (horizontal) positioning of window</field>
    /// <field name='LEFT' static='true' type='Number'>Left resizing/positioning of window</field>
    /// <field name='MIDDLE' static='true' type='Number'>Middle (vertical) positioning of window</field>
    /// <field name='NO' static='true' type='Number'>Show NO button</field>
    /// <field name='NONMODAL' static='true' type='Number'>Allow Window.Error, Window.Question, Window.Warning etc windows to be non modal</field>
    /// <field name='OK' static='true' type='Number'>Show OK button</field>
    /// <field name='REDUCE' static='true' type='Number'>Window is allowed to reduce in size when resizing</field>
    /// <field name='RIGHT' static='true' type='Number'>Right resizing/positioning of window</field>
    /// <field name='THEME_CLASSIC' static='true' type='Number'>Use the Classic theme (Note: Not only the script will use this theme, the whole interface of the program will switch to classic)</field>
    /// <field name='THEME_CURRENT' static='true' type='Number'>Use the current theme</field>
    /// <field name='THEME_DARK' static='true' type='Number'>Use the Dark theme (Note: Not only the script will use this theme, the whole interface of the program will switch to dark)</field>
    /// <field name='THEME_LIGHT' static='true' type='Number'>Use the Light theme (Note: Not only the script will use this theme, the whole interface of the program will switch to light)</field>
    /// <field name='TOP' static='true' type='Number'>Top resizing/positioning of window</field>
    /// <field name='USE_OLD_UI_JS' static='true' type='Number'>Use the original, pre v17, theme (default). (Note:The interface of the program will NOT switch to old)</field>
    /// <field name='YES' static='true' type='Number'>Show YES button</field>
}

Window.BottomBorder = function() {
    /// <signature>
    /// <summary>Returns the vertical position of the bottom border (in range 0-1). This can be used to help position windows on the screen.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Window.prototype.Delete = function() {
    /// <signature>
    /// <summary>Deletes the window from PRIMER and returns any memory/resources used for the window. This function should not normally need to be called. However, in exceptional circumstances if a script recreates windows many times PRIMER may run out of USER objects on Microsoft Windows because of the way PRIMER creates and shows windows. To avoid this problem this method can be used to force PRIMER to return the resources for a window. Do not use the Window object after calling this method.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Window.Error = function() {
    /// <signature>
    /// <summary>Show an error message in a window.</summary>
    /// <param name="title" type="String" optional="false">Title for window.</param>
    /// <param name="error" type="String" optional="false">Error message to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.</param>
    /// <param name="buttons" type="Number" optional="true">The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted an OK button will be used. By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Window.GetDirectory = function() {
    /// <signature>
    /// <summary>Map the directory selector box native to your machine, allowing you to choose a directory. On Unix this will be a Motif selector. Windows will use the standard windows directory selector.</summary>
    /// <param name="initial" type="String" optional="true">Initial directory to start from.</param>
    /// <returns type="String"/>
    /// </signature>
}

Window.GetFile = function() {
    /// <signature>
    /// <summary>Map a file selector box allowing you to choose a file. See also Window.GetFiles() and Window.GetFilename().</summary>
    /// <param name="extension" type="String" optional="true">Extension to filter by.</param>
    /// <param name="save" type="Boolean" optional="true">If true the file selector is to be used for saving a file. If false (default) the file selector is for opening a file. Due to native operating system file selector differences, on linux new filenames can only be given when saving a file. On windows it is possible to give new filenames when opening or saving a file.</param>
    /// <param name="initial" type="String" optional="true">Initial directory to start from.</param>
    /// <returns type="String"/>
    /// </signature>
}

Window.GetFilename = function() {
    /// <signature>
    /// <summary>Map a window allowing you to input a filename (or select it using a file selector). OK and Cancel buttons are shown. See also Window.GetFile().</summary>
    /// <param name="title" type="String" optional="false">Title for window.</param>
    /// <param name="message" type="String" optional="false">Message to show in window.</param>
    /// <param name="extension" type="String" optional="true">Extension to filter by.</param>
    /// <param name="initial" type="String" optional="true">Initial value.</param>
    /// <param name="save" type="Boolean" optional="true">If true the file selector is to be used for saving a file. If false (default) the file selector is for opening a file. Due to native operating system file selector differences, on linux new filenames can only be given when saving a file. On windows it is possible to give new filenames when opening or saving a file.</param>
    /// <returns type="String"/>
    /// </signature>
}

Window.GetFiles = function() {
    /// <signature>
    /// <summary>Map a file selector box allowing you to choose multiple files. See also Window.GetFile() and Window.GetFilename().</summary>
    /// <param name="extension" type="String" optional="true">Extension to filter by.</param>
    /// <returns type="String"/>
    /// </signature>
}

Window.GetGraphicsWindowPosition = function() {
    /// <signature>
    /// <summary>This function returns the current position of the graphics window.</summary>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Window.GetInteger = function() {
    /// <signature>
    /// <summary>Map a window allowing you to input an integer. OK and Cancel buttons are shown.</summary>
    /// <param name="title" type="String" optional="false">Title for window.</param>
    /// <param name="message" type="String" optional="false">Message to show in window.</param>
    /// <param name="initial" type="Number" optional="true">Initial value.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Window.GetNumber = function() {
    /// <signature>
    /// <summary>Map a window allowing you to input a number. OK and Cancel buttons are shown.</summary>
    /// <param name="title" type="String" optional="false">Title for window.</param>
    /// <param name="message" type="String" optional="false">Message to show in window.</param>
    /// <param name="initial" type="Number" optional="true">Initial value.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Window.GetString = function() {
    /// <signature>
    /// <summary>Map a window allowing you to input a string. OK and Cancel buttons are shown.</summary>
    /// <param name="title" type="String" optional="false">Title for window.</param>
    /// <param name="message" type="String" optional="false">Message to show in window.</param>
    /// <param name="initial" type="String" optional="true">Initial value.</param>
    /// <returns type="String"/>
    /// </signature>
}

Window.prototype.Hide = function() {
    /// <signature>
    /// <summary>Hides (unmaps) the window.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Window.Information = function() {
    /// <signature>
    /// <summary>Show information in a window.</summary>
    /// <param name="title" type="String" optional="false">Title for window.</param>
    /// <param name="info" type="String" optional="false">Information to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.</param>
    /// <param name="buttons" type="Number" optional="true">The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted an OK button will be used. By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Window.MasterResolution = function() {
    /// <signature>
    /// <summary>Returns the resolution of the master programme window in pixels</summary>
    /// <returns type="Array" elementType="Number"/>
    /// </signature>
}

Window.Message = function() {
    /// <signature>
    /// <summary>Show a message in a window.</summary>
    /// <param name="title" type="String" optional="false">Title for window.</param>
    /// <param name="message" type="String" optional="false">Message to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.</param>
    /// <param name="buttons" type="Number" optional="true">The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted an OK button will be used By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Window.MiddleBorder = function() {
    /// <signature>
    /// <summary>Returns the vertical position of the middle border (in range 0-1). The middle border is the border between the tools/keywords window and the docked windows. This can be used to help position windows on the screen.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Window.Question = function() {
    /// <signature>
    /// <summary>Show a question in a window.</summary>
    /// <param name="title" type="String" optional="false">Title for window.</param>
    /// <param name="question" type="String" optional="false">Question to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.</param>
    /// <param name="buttons" type="Number" optional="true">The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted Yes and No button will be used. By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Window.prototype.Recompute = function() {
    /// <signature>
    /// <summary>Recomputes the positions of widgets in the window. If you have static widgets and 'normal' widgets in a window and you show and/or hide widgets the window needs to be recomputed to refresh the graphics, scroll bars etc. Calling this method will recompute and redraw the window.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Window.prototype.Redraw = function() {
    /// <signature>
    /// <summary>Redraws the window. Sometimes if you show, hide or draw graphics on widgets the window needs to be redrawn to refresh the graphics. Calling this method will redraw the window refreshing the graphics.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Window.RightBorder = function() {
    /// <signature>
    /// <summary>Returns the horizontal position of the right border (in range 0-1). This can be used to help position windows on the screen.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Window.SetGraphicsWindowPosition = function() {
    /// <signature>
    /// <summary>This function allows you to move or resize the graphics window.</summary>
    /// <param name="left" type="Number" optional="false">left coordinate of graphics window in range 0.0 (left) to 1.0 (right)</param>
    /// <param name="right" type="Number" optional="false">right coordinate of graphics window in range 0.0 (left) to 1.0 (right)</param>
    /// <param name="bottom" type="Number" optional="false">bottom coordinate of graphics window in range 0.0 (bottom) to 1.0 (top)</param>
    /// <param name="top" type="Number" optional="false">top coordinate of graphics window in range 0.0 (bottom) to 1.0 (top)</param>
    /// <returns type="null"/>
    /// </signature>
}

Window.SetGraphicsWindowSize = function() {
    /// <signature>
    /// <summary>This function allows you to resize the graphics window.</summary>
    /// <param name="width" type="Number" optional="false">Width of the graphics window in pixels</param>
    /// <param name="height" type="Number" optional="false">Height of the graphics window in pixels</param>
    /// <returns type="null"/>
    /// </signature>
}

Window.prototype.Show = function() {
    /// <signature>
    /// <summary>Shows (maps) the window and waits for user input.</summary>
    /// <param name="modal" type="Boolean" optional="true">If this window is modal (true) then the user is blocked from doing anything else in PRIMER until this window is dismissed). If non-modal (false) then the user can still use other functions in PRIMER. If omitted the window will be modal. Note that making a window modal will stop interaction in all other windows and may prevent operations such as picking from working in any macros that are run from scripts.</param>
    /// <returns type="null"/>
    /// </signature>
}

Window.Theme = function() {
    /// <signature>
    /// <summary>Set or get a user interface theme.</summary>
    /// <param name="theme" type="Number" optional="true">If it is provided it is used to set the current theme. Can be either Window.USE_OLD_UI_JS, Window.THEME_CURRENT, Window.THEME_DARK, Window.THEME_LIGHT, Window.THEME_CLASSIC.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Window.TopBorder = function() {
    /// <signature>
    /// <summary>Returns the vertical position of the top border (in range 0-1). This can be used to help position windows on the screen. This is no longer used in PRIMER and will always be 1 but is left for backwards compatibility.</summary>
    /// <returns type="Number"/>
    /// </signature>
}

Window.UpdateGUI = function() {
    /// <signature>
    /// <summary>Force GUI to be updated. This function is not normally needed but if you are doing a computationally expensive operation and want to update the GUI it may be necessary as the GUI update requests are cached until there is spare time to update them. Calling this function forces any outstanding requests to be flushed.</summary>
    /// <returns type="null"/>
    /// </signature>
}

Window.Warning = function() {
    /// <signature>
    /// <summary>Show a warning message in a window.</summary>
    /// <param name="title" type="String" optional="false">Title for window.</param>
    /// <param name="warning" type="String" optional="false">Warning message to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.</param>
    /// <param name="buttons" type="Number" optional="true">The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted an OK button will be used. By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.</param>
    /// <returns type="Number"/>
    /// </signature>
}

var XMLParser = function() {
    /// <signature>
    /// <summary>Create a new XMLParser object for reading XML files.</summary>
    /// <returns type="XMLParser"/>
    /// </signature>
    /// <field name='characterDataHandler' static='false' type='function'>Function to call when character data is found. The function will be called with 1 argument which is a string containing the character data</field>
    /// <field name='commentHandler' static='false' type='function'>Function to call when a comment is found. The function will be called with 1 argument which is a string containing the text inside the comment</field>
    /// <field name='endCDATAHandler' static='false' type='function'>Function to call at the end of a CDATA section. The function does not have any arguments.</field>
    /// <field name='endElementHandler' static='false' type='function'>Function to call when an element end tag is found. The function will be called with 1 argument which is a string containing the name of the element</field>
    /// <field name='startCDATAHandler' static='false' type='function'>Function to call at the start of a CDATA section. The function does not have any arguments.</field>
    /// <field name='startElementHandler' static='false' type='function'>Function to call when an element start tag is found. The function will be called with 2 arguments. Argument 1 is a string containing the name of the element. Argument 2 is an object containing the element attributes</field>
}

XMLParser.prototype.Parse = function() {
    /// <signature>
    /// <summary>starts parsing an XML file</summary>
    /// <param name="filename" type="String" optional="false">XML file to parse</param>
    /// <returns type="null"/>
    /// </signature>
}

var XlsxWorkbook = function() {
    /// <signature>
    /// <summary>Create a new XlsxWorkbook object for writing xlsx files.</summary>
    /// <param name="filename" type="String" optional="false">Filename of the xlsx file you want to write. The file will be overwritten (if it exists).</param>
    /// <returns type="XlsxWorkbook"/>
    /// </signature>
    /// <field name='filename' static='false' type='String'>Name of the xlsx file</field>
}

XlsxWorkbook.prototype.Close = function() {
    /// <signature>
    /// <summary>Close a Xlsx file</summary>
    /// <returns type="null"/>
    /// </signature>
}

var XlsxWorksheet = function() {
    /// <signature>
    /// <summary>Create a new XlsxWorksheet object for writing xlsx files.</summary>
    /// <param name="workbook" type="XlsxWorkbook" optional="false">The workbook to create the worksheet in.</param>
    /// <param name="name" type="String" optional="true">The name of the worksheet. If omitted the default names 'Sheet1', 'Sheet2' etc will be used.</param>
    /// <returns type="XlsxWorksheet"/>
    /// </signature>
}

XlsxWorksheet.prototype.AddImage = function() {
    /// <signature>
    /// <summary>Add an image to the Xlsx file. Note that the image will not actually be read/inserted until the workbook is written by calling XlsxWorkbook.Close so you must make sure the image file exists until then.</summary>
    /// <param name="row" type="Number" optional="false">The row in the xlsx file (rows start at zero)</param>
    /// <param name="column" type="Number" optional="false">The column in the xlsx file (columns start at zero)</param>
    /// <param name="filename" type="String" optional="false">Name of the image file you want to add to the xlsx file. The image can be in png or jpeg format.</param>
    /// <returns type="null"/>
    /// </signature>
}

XlsxWorksheet.prototype.AddNumber = function() {
    /// <signature>
    /// <summary>Add number to the Xlsx file</summary>
    /// <param name="row" type="Number" optional="false">The row in the xlsx file (rows start at zero)</param>
    /// <param name="column" type="Number" optional="false">The column in the xlsx file (columns start at zero)</param>
    /// <param name="value" type="number" optional="false">Number you want to add to the xlsx file</param>
    /// <returns type="null"/>
    /// </signature>
}

XlsxWorksheet.prototype.AddText = function() {
    /// <signature>
    /// <summary>Add text to the Xlsx file</summary>
    /// <param name="row" type="Number" optional="false">The row in the xlsx file (rows start at zero)</param>
    /// <param name="column" type="Number" optional="false">The column in the xlsx file (columns start at zero)</param>
    /// <param name="text" type="String" optional="false">Text you want to add to the xlsx file</param>
    /// <returns type="null"/>
    /// </signature>
}

XlsxWorksheet.prototype.SetColumnProperties = function() {
    /// <signature>
    /// <summary>Set the column properties in the worksheet</summary>
    /// <param name="column" type="Number" optional="false">The column in the xlsx file (columns start at zero)</param>
    /// <param name="width" type="number" optional="false">Width of the column to set</param>
    /// <returns type="null"/>
    /// </signature>
}

XlsxWorksheet.prototype.SetRowProperties = function() {
    /// <signature>
    /// <summary>Set the row properties in the worksheet</summary>
    /// <param name="row" type="Number" optional="false">The row in the xlsx file (rows start at zero)</param>
    /// <param name="height" type="number" optional="false">Height of the row to set</param>
    /// <returns type="null"/>
    /// </signature>
}

var Xrefs = function() {
    /// <field name='numtypes' static='false' type='Number'>The number of different types that this item is referenced by. (read only)</field>
    /// <field name='total' static='false' type='Number'>The total number of cross references of all types to this item. (read only)</field>
}

Xrefs.prototype.GetID_#deprecated = function() {
    /// <signature>
    /// <summary>Use Xrefs.GetItemID() instead.</summary>
    /// <param name="type" type="String" optional="false">Use Xrefs.GetItemID() instead.</param>
    /// <param name="pos" type="Number" optional="false">Use Xrefs.GetItemID() instead.</param>
    /// </signature>
}

Xrefs.prototype.GetItemID = function() {
    /// <signature>
    /// <summary>Returns the ID of the item in the reference list.</summary>
    /// <param name="type" type="String" optional="false">The type of the item in the reference list (for a list of types see Appendix I of the PRIMER manual).</param>
    /// <param name="pos" type="Number" optional="false">The position in the list for this item. Note that positions start at 0, not 1</param>
    /// <returns type="Number"/>
    /// </signature>
}

Xrefs.prototype.GetItemType = function() {
    /// <signature>
    /// <summary>Returns the type of the item in the reference list. This function is only required when trying to look at cross references to *DEFINE_CURVE items. These items are used in a slightly different way in PRIMER (each time a curve is used a 'LOADCURVE REFERENCE' structure is created to store things like the units and descriptions of each axis for the curve). If you try to get the cross references for a curve all the references will be of type 'LOADCURVE REFERENCE' and numtypes will be 1. GetItemID() will correctly return the ID of the item from the 'LOADCURVE REFERENCE' structure but to get the type of the item this function is required.</summary>
    /// <param name="type" type="String" optional="false">The type of the item in the reference list (for a list of types see Appendix I of the PRIMER manual).</param>
    /// <param name="pos" type="Number" optional="false">The position in the list for this item. Note that positions start at 0, not 1</param>
    /// <returns type="String"/>
    /// </signature>
}

Xrefs.prototype.GetTotal = function() {
    /// <signature>
    /// <summary>Returns the total number of references of a type.</summary>
    /// <param name="type" type="String" optional="false">The type of the item in the reference list (for a list of types see Appendix I of the PRIMER manual).</param>
    /// <returns type="Number"/>
    /// </signature>
}

Xrefs.prototype.GetType = function() {
    /// <signature>
    /// <summary>Returns the type for</summary>
    /// <param name="n" type="Number" optional="false">The entry in the reference types that you want the type for. Note that entries start at 0, not 1</param>
    /// <returns type="String"/>
    /// </signature>
}

var Zip = function() {
    /// <signature>
    /// <summary>Create a new Zip object for reading/writing zip files.</summary>
    /// <param name="filename" type="String" optional="false">Filename of the zip file you want to read/write. If reading (Zip.READ) or appending (Zip.APPEND), the file must exist. If writing (Zip.WRITE) the file will be overwritten (if it exists).</param>
    /// <param name="mode" type="Number" optional="false">The mode to open the file with. Can be Zip.READ, Zip.WRITE or Zip.APPEND.</param>
    /// <returns type="Zip"/>
    /// </signature>
    /// <field name='filename' static='false' type='String'>Name of the zip file</field>
    /// <field name='mode' static='false' type='Number'>Mode the zip file was opened with (Zip.READ, Zip.WRITE or Zip.APPEND)</field>
    /// <field name='APPEND' static='true' type='Number'>Flag to open zip file for appending</field>
    /// <field name='READ' static='true' type='Number'>Flag to open zip file for reading</field>
    /// <field name='WRITE' static='true' type='Number'>Flag to open zip file for writing</field>
}

Zip.prototype.AddFile = function() {
    /// <signature>
    /// <summary>Add a file to the Zip file</summary>
    /// <param name="filename" type="String" optional="false">Name of the file you want to add to the zip file</param>
    /// <param name="zipname" type="String" optional="false">Name to give the file in the zip file</param>
    /// <returns type="null"/>
    /// </signature>
}

Zip.prototype.Close = function() {
    /// <signature>
    /// <summary>Close a Zip file</summary>
    /// <returns type="null"/>
    /// </signature>
}

Zip.prototype.Information = function() {
    /// <signature>
    /// <summary>Gets information for the current entry in the Zip file such as name, size etc</summary>
    /// <returns type="Object"/>
    /// </signature>
}

Zip.prototype.Next = function() {
    /// <signature>
    /// <summary>Go to the next entry in the Zip file</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Zip.prototype.ReadFile = function() {
    /// <signature>
    /// <summary>Reads the current entry to a file from the Zip file</summary>
    /// <param name="filename" type="String" optional="false">Name of the file you want to create</param>
    /// <returns type="null"/>
    /// </signature>
}

var global = function() {
}

AllocateFlag = function() {
    /// <signature>
    /// <summary>Allocate a flag for use in the script. See also ReturnFlag() and Model.PropagateFlag(). Once allocated the flag is automatically cleared for all the models currently in PRIMER.</summary>
    /// <returns type="Flag"/>
    /// </signature>
}

BatchMode = function() {
    /// <signature>
    /// <summary>Check if PRIMER is running in batch mode (i.e. menus are not active)</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

DialogueFunction = function() {
    /// <signature>
    /// <summary>Set the function for dialogue callback. This function can be used to make PRIMER return any dialogue messages that are printed. This may be useful for you to know if a particular dialogue message has been printed or a particular event has taken place. The function will be called with 1 argument which is a string containing the dialogue message. To remove the dialogue function use DialogueFunction(null).</summary>
    /// <param name="name" type="function" optional="false">The name of the function (or null to remove the function)</param>
    /// <returns type="null"/>
    /// </signature>
}

DialogueInput = function() {
    /// <signature>
    /// <summary>Execute one or more lines of command line dialogue input.</summary>
    /// <param name="string_1, (string_2 ... string_n)" type="String" optional="false">The command(s) that are to be executed as if they had been typed into the dialogue box</param>
    /// <returns type="Number"/>
    /// </signature>
}

DialogueInputNoEcho = function() {
    /// <signature>
    /// <summary>Execute one or more lines of command line dialogue input with no echo of commands to dialogue box.</summary>
    /// <param name="string_1, (string_2 ... string_n)" type="String" optional="false">The command(s) that are to be executed as if they had been typed into the dialogue box</param>
    /// <returns type="Number"/>
    /// </signature>
}

ErrorMessage = function() {
    /// <signature>
    /// <summary>Print an error message to the dialogue box adding a carriage return.</summary>
    /// <param name="string" type="String" optional="false">The string/item that you want to print</param>
    /// <returns type="null"/>
    /// </signature>
}

Execute = function() {
    /// <signature>
    /// <summary>Execute a program or script outside PRIMER and get the standard output and error streams.</summary>
    /// <param name="data" type="Object" optional="false">Execute data</param>
    /// <returns type="Object"/>
    /// </signature>
}

Exit = function() {
    /// <signature>
    /// <summary>Exit script</summary>
    /// <returns type="null"/>
    /// </signature>
}

FlagsAvailable = function() {
    /// <signature>
    /// <summary>Number of flags available to be used for AllocateFlag()</summary>
    /// <returns type="Number"/>
    /// </signature>
}

GetCurrentDirectory = function() {
    /// <signature>
    /// <summary>Get the current working directory</summary>
    /// <returns type="String"/>
    /// </signature>
}

GetInstallDirectory = function() {
    /// <signature>
    /// <summary>Get the directory in which executables are installed. This is the OA_INSTALL environment variable, or if that is not set the directory in which the current executable is installed. Returns NULL if not found</summary>
    /// <returns type="String"/>
    /// </signature>
}

GetPreferenceValue = function() {
    /// <signature>
    /// <summary>Get the Preference value with the given string in the any of admin ("OA_ADMIN") or install ("OA_INSTALL") or home ("OA_HOME") directory oa_pref</summary>
    /// <param name="program" type="String" optional="false">The program name string : Valid values are 'All', 'D3Plot', 'Primer', 'Reporter', 'Shell','T/His'</param>
    /// <param name="name" type="String" optional="false">The preference name string</param>
    /// <returns type="String"/>
    /// </signature>
}

GetStartInDirectory = function() {
    /// <signature>
    /// <summary>Get the directory passed to PRIMER by the -start_in command line argument</summary>
    /// <returns type="String"/>
    /// </signature>
}

Getenv = function() {
    /// <signature>
    /// <summary>Get the value of an environment variable</summary>
    /// <param name="name" type="String" optional="false">The environment variable name</param>
    /// <returns type="String"/>
    /// </signature>
}

Labels = function() {
    /// <signature>
    /// <summary>Set or get labelling of items in PRIMER</summary>
    /// <param name="type" type="String" optional="false">The type of the item (for a list of types see Appendix I of the PRIMER manual). Additionally, to change the visibility of attached or unattached nodes you can use the types "ATTACHED_NODE" and "UNATTACHED_NODE".</param>
    /// <param name="state" type="Boolean" optional="true">If it is provided it is used to set the labelling status of entity. "true" to make items labelled and "false" to make them not labelled.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

MacroFunction = function() {
    /// <signature>
    /// <summary>Set the function for macro callback. This function can be used to make PRIMER return the macro command that would be recorded if macro recording was active for every button press etc. This may be useful for you to know if a particular action has been done by the user. The function will be called with 1 argument which is a string containing the macro command. To remove the macro function use MacroFunction(null).</summary>
    /// <param name="name" type="function" optional="false">The name of the function (or null to remove a function)</param>
    /// <returns type="null"/>
    /// </signature>
}

Message = function() {
    /// <signature>
    /// <summary>Print a message to the dialogue box adding a carriage return.</summary>
    /// <param name="string" type="String" optional="false">The string/item that you want to print. If '\r' is added to the end of the string then instead of automatically adding a carriage return in the dialogue box, the next message will overwrite the current one. This may be useful for giving feedback to the dialogue box when doing an operation.</param>
    /// <returns type="null"/>
    /// </signature>
}

MilliSleep = function() {
    /// <signature>
    /// <summary>Pause execution of the script for time milliseconds. See also Sleep()</summary>
    /// <param name="time" type="Number" optional="false">Number of milliseconds to pause for</param>
    /// <returns type="null"/>
    /// </signature>
}

NumberToString = function() {
    /// <signature>
    /// <summary>Formats a number to a string with the specified width.</summary>
    /// <param name="number" type="Number" optional="false">The number you want to format.</param>
    /// <param name="width" type="Number" optional="false">The width of the string you want to format it to (must be less than 80).</param>
    /// <param name="pref_int" type="Boolean" optional="true">By default only integer values inside the single precision 32 bit signed integer limit of approximately +/-2e9 are formatted as integers, all other numeric values are formatted as floats. With this argument set to TRUE then integer values up to the mantissa precision of a 64 bit float, approximately +/-9e15, will also be formatted as integers.</param>
    /// <returns type="String"/>
    /// </signature>
}

PlayMacro = function() {
    /// <signature>
    /// <summary>Play a macro in PRIMER</summary>
    /// <param name="filename" type="String" optional="false">The name of the macro file to play</param>
    /// <param name="options" type="Object" optional="true">Options specifying how the macro file should be replayed. If omitted the default values below will be used. The properties available are: pick [logical] If picks/drags from the macro file should be replayed. If omitted the current value from macro window will be used. view [logical] If views encoded in the macro file for picks/drags should be replayed. If omitted the current value from macro window will be used. delay [integer] Delay in ms between commands when replaying. If omitted the current value from macro window will be used. variables [object] Object containing names and values for variables in the macro. If null or omitted no variables are used. terminate [logical] If the script should be terminated if an error occurs when playing the macro. If omitted the script will be terminated. utf8 [logical] If the script is UTF-8 encoded. If omitted or false the script is assumed to be ASCII text.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

PlayMacro_#deprecated = function() {
    /// <signature>
    /// <summary>Play a macro in PRIMER</summary>
    /// <param name="filename" type="String" optional="false">The name of the macro file to play</param>
    /// <param name="pick" type="Boolean" optional="true">If picks/drags from the macro file should be replayed. If omitted the current value from macro window will be used.</param>
    /// <param name="view" type="Boolean" optional="true">If views encoded in the macro file for picks/drags should be replayed. If omitted the current value from macro window will be used.</param>
    /// <param name="delay" type="Number" optional="true">Delay in ms between commands when replaying. If omitted the current value from macro window will be used.</param>
    /// <param name="variables" type="Object" optional="true">Object containing names and values for variables in the macro. If null or omitted no variables are used.</param>
    /// <param name="terminate" type="Boolean" optional="true">If the script should be terminated if an error occurs when playing the macro. If omitted the script will be terminated.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

Print = function() {
    /// <signature>
    /// <summary>Print a string to stdout. Note that a carriage return is not added.</summary>
    /// <param name="string" type="String" optional="false">The string/item that you want to print</param>
    /// <returns type="null"/>
    /// </signature>
}

Println = function() {
    /// <signature>
    /// <summary>Print a string to stdout adding a carriage return.</summary>
    /// <param name="string" type="String" optional="false">The string/item that you want to print</param>
    /// <returns type="null"/>
    /// </signature>
}

Requires = function() {
    /// <signature>
    /// <summary>Checks to see if the build number of PRIMER is high enough to run this script. If your script requires features that are only present in builds of PRIMER greater than a certain value Require can test this and only run the script if the build is high enough.</summary>
    /// <param name="build" type="Number" optional="false">The minimum build number that is required.</param>
    /// <returns type="null"/>
    /// </signature>
}

ReturnFlag = function() {
    /// <signature>
    /// <summary>Return a flag used in the script. See also AllocateFlag() and Model.PropagateFlag().</summary>
    /// <param name="flag" type="Flag" optional="false">The flag to return.</param>
    /// <returns type="null"/>
    /// </signature>
}

RunScript = function() {
    /// <signature>
    /// <summary>Run a script</summary>
    /// <param name="filename" type="String" optional="false">The name of the script file to run. If the filename is relative then the file will be searched for relative to this script. If not found then the script_directory preference will be used.</param>
    /// <param name="separate" type="Boolean" optional="true">If the script will use separate memory from the current script. If it uses separate memory (true) then the 'child' script is completely separated from this script and knows nothing about variables in this script. If it does not use separate memory (false) then the 'child' script will have access to all of the variables in the current script and hence variables must not clash. It is strongly recommended that you use namespaces to stop variable names from clashing. If omitted the script will use separate memory.</param>
    /// <returns type="null"/>
    /// </signature>
}

SetCurrentDirectory = function() {
    /// <signature>
    /// <summary>Sets the current working directory.</summary>
    /// <param name="directory path" type="String" optional="false">Path to the directory you would like to change into.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

SetPreferenceValue = function() {
    /// <signature>
    /// <summary>Save the preference string and its value into oa_pref of home directory. If the preference is locked in admin ("OA_ADMIN") or install ("OA_INSTALL") oa_pref, then API is unsuccessful. Home directory is defined by environment variable OA_HOME. If OA_HOME is not defined then API is unsuccessful.</summary>
    /// <param name="program" type="String" optional="false">The program name string : Valid values are 'All', 'D3Plot', 'Primer', 'Reporter', 'Shell','T/His'</param>
    /// <param name="name" type="String" optional="false">The preference name string</param>
    /// <param name="value" type="String" optional="false">The preference value string. If "value" is of zero length, then the option is simply removed from the file if present, and no new entry is made.This argument cannot be null.</param>
    /// <param name="refresh" type="Boolean" optional="true">If the saved preference should be refreshed. If omitted, the preference will NOT be refreshed. This argument is currently only available in Primer JS API and ignored in D3PLOT and T/HIS.</param>
    /// <returns type="Number"/>
    /// </signature>
}

Sleep = function() {
    /// <signature>
    /// <summary>Pause execution of the script for time seconds. See also MilliSleep()</summary>
    /// <param name="time" type="Number" optional="false">Number of seconds to pause for</param>
    /// <returns type="null"/>
    /// </signature>
}

System = function() {
    /// <signature>
    /// <summary>Do a system command outside PRIMER. To run an external command and get the output then please use Execute() instead.</summary>
    /// <param name="string" type="String" optional="false">The system command that you want to do</param>
    /// <returns type="Number"/>
    /// </signature>
}

Unix = function() {
    /// <signature>
    /// <summary>Test whether script is running on a Unix/Linux operating system. See also Windows()</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

Use = function() {
    /// <signature>
    /// <summary>Use script from a separate file</summary>
    /// <param name="filename" type="String" optional="false">Use allows you to include a script from a separate file. This may be useful if your script is very large and you want to split it up to help with maintenance. Alternatively you may have a 'library' of common functions which you always want to include in your scripts. Including the 'library' with Use means that any changes only have to be done in one place. Primer will look for the file in the same directory as the main script. If that fails then it will look in $OA_INSTALL/primer_library/scripts directory and the script directory specified by the primer*script_directory preference. Note that the file is included when the script is compiled, NOT at runtime.</param>
    /// <returns type="null"/>
    /// </signature>
}

UuidCreate = function() {
    /// <signature>
    /// <summary>Create a UUID (Universally unique ID)</summary>
    /// <returns type="String"/>
    /// </signature>
}

Visibility = function() {
    /// <signature>
    /// <summary>Set or get visibility of items in PRIMER</summary>
    /// <param name="type" type="String" optional="false">The type of the item (for a list of types see Appendix I of the PRIMER manual). Additionally, to change the visibility of attached or unattached nodes you can use the types "ATTACHED_NODE" and "UNATTACHED_NODE".</param>
    /// <param name="state" type="Boolean" optional="true">If it is provided it is used to set the visibility. "true" to make items visible and "false" to make them not visible.</param>
    /// <returns type="Boolean"/>
    /// </signature>
}

WarningMessage = function() {
    /// <signature>
    /// <summary>Print a warning message to the dialogue box adding a carriage return.</summary>
    /// <param name="string" type="String" optional="false">The string/item that you want to print</param>
    /// <returns type="null"/>
    /// </signature>
}

Windows = function() {
    /// <signature>
    /// <summary>Test whether script is running on a Windows operating system. See also Unix()</summary>
    /// <returns type="Boolean"/>
    /// </signature>
}

