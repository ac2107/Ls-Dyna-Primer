declare class Accelerometer {
/**
 * Blanks the accelerometer
 */
    Blank(): void;

/**
 * Blanks all of the accelerometers in the model.
 * @param Model Model that all accelerometers will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged accelerometers in the model.
 * @param Model Model that all the flagged accelerometers will be blanked in
 * @param flag Flag set on the accelerometers that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the accelerometer is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the accelerometer.
 * @param flag Flag to clear on the accelerometer
 */
    ClearFlag(flag: number): void;

/**
 * Copies the accelerometer.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Accelerometer;

/**
 * Starts an interactive editing panel to create a accelerometer.
 * @param Model Model that the accelerometer will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Accelerometer;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for accelerometer. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for accelerometer. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the accelerometer colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the accelerometer.
 */
    ExtractColour(): number;

/**
 * Returns the first accelerometer in the model.
 * @param Model Model to get first accelerometer in
 */
    static First(Model: Model): Accelerometer;

/**
 * Returns the first free accelerometer label in the model. Also see Accelerometer.LastFreeLabel(), Accelerometer.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free accelerometer label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the accelerometers in the model with a defined flag.
 * @param Model Model that all accelerometers will be flagged in
 * @param flag Flag to set on the accelerometers
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the accelerometer is flagged or not.
 * @param flag Flag to test on the accelerometer
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each accelerometer in the model. Note that ForEach has been designed to make looping over accelerometers as fast as possible and so has some limitations. Firstly, a single temporary Accelerometer object is created and on each function call it is updated with the current accelerometer data. This means that you should not try to store the Accelerometer object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new accelerometers inside a ForEach loop. 
 * @param Model Model that all accelerometers are in
 * @param func Function to call for each accelerometer
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Accelerometer objects for all of the accelerometers in a model in Primer
 * @param Model Model to get accelerometers from
 */
    static GetAll(Model: Model): Accelerometer[];

/**
 * Returns an array of Accelerometer objects for all of the flagged accelerometers in a model in Primer
 * @param Model Model to get accelerometers from
 * @param flag Flag set on the accelerometers that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Accelerometer[];

/**
 * Returns the Accelerometer object for a accelerometer ID.
 * @param Model Model to find the accelerometer in
 * @param number number of the accelerometer you want the Accelerometer object for
 */
    static GetFromID(Model: Model, number: number): Accelerometer;

/**
 * Checks if a Accelerometer property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Accelerometer.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop accelerometer property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this accelerometer (*ELEMENT_SEATBELT_ACCELEROMETER) Note that a carriage return is not added. See also Accelerometer.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the accelerometer. Note that a carriage return is not added. See also Accelerometer.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last accelerometer in the model.
 * @param Model Model to get last accelerometer in
 */
    static Last(Model: Model): Accelerometer;

/**
 * Returns the last free accelerometer label in the model. Also see Accelerometer.FirstFreeLabel(), Accelerometer.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free accelerometer label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next accelerometer in the model.
 */
    Next(): Accelerometer;

/**
 * Returns the next free (highest+1) accelerometer label in the model. Also see Accelerometer.FirstFreeLabel(), Accelerometer.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free accelerometer label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a accelerometer.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only accelerometers from that model can be picked. If the argument is a Flag then only accelerometers that are flagged with limit can be selected. If omitted, or null, any accelerometers from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Accelerometer;

/**
 * Returns the previous accelerometer in the model.
 */
    Previous(): Accelerometer;

/**
 * Renumbers all of the accelerometers in the model.
 * @param Model Model that all accelerometers will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged accelerometers in the model.
 * @param Model Model that all the flagged accelerometers will be renumbered in
 * @param flag Flag set on the accelerometers that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select accelerometers using standard PRIMER object menus.
 * @param flag Flag to use when selecting accelerometers
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only accelerometers from that model can be selected. If the argument is a Flag then only accelerometers that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any accelerometers can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the accelerometer.
 * @param flag Flag to set on the accelerometer
 */
    SetFlag(flag: number): void;

/**
 * Sketches the accelerometer. The accelerometer will be sketched until you either call Accelerometer.Unsketch(), Accelerometer.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the accelerometer is sketched. If omitted redraw is true. If you want to sketch several accelerometers and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged accelerometers in the model. The accelerometers will be sketched until you either call Accelerometer.Unsketch(), Accelerometer.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged accelerometers will be sketched in
 * @param flag Flag set on the accelerometers that you want to sketch
 * @param redraw If model should be redrawn or not after the accelerometers are sketched. If omitted redraw is true. If you want to sketch flagged accelerometers several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of accelerometers in the model.
 * @param Model Model to get total for
 * @param exists true if only existing accelerometers should be counted. If false or omitted referenced but undefined accelerometers will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the accelerometer
 */
    Unblank(): void;

/**
 * Unblanks all of the accelerometers in the model.
 * @param Model Model that all accelerometers will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged accelerometers in the model.
 * @param Model Model that the flagged accelerometers will be unblanked in
 * @param flag Flag set on the accelerometers that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the accelerometers in the model.
 * @param Model Model that the defined flag for all accelerometers will be unset in
 * @param flag Flag to unset on the accelerometers
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the accelerometer.
 * @param redraw If model should be redrawn or not after the accelerometer is unsketched. If omitted redraw is true. If you want to unsketch several accelerometers and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all accelerometers.
 * @param Model Model that all accelerometers will be unblanked in
 * @param redraw If model should be redrawn or not after the accelerometers are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged accelerometers in the model.
 * @param Model Model that all accelerometers will be unsketched in
 * @param flag Flag set on the accelerometers that you want to unsketch
 * @param redraw If model should be redrawn or not after the accelerometers are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Accelerometer;

/**
 * Adds a warning for accelerometer. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this accelerometer.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Seatbelt Accelerometer object.
 * @param Model Model that accelerometer will be created in
 * @param sbacid Accelerometer number. Also see the label property which is an alternative name for this.
 * @param nid1 Node number 1
 * @param nid2 Node number 2
 * @param nid3 Node number 3
 * @param igrav Gravitational acceleration due to body force loads is included in acceleration output if igrav is 0, removed if igrav is 1.
 * @param intopt Integration option; velocities are integrated from global accelerations and transformed into local system if intopt is 0, they are integrated directly from local accelerations if intopt is 1.
 * @param mass Optional added mass for accelerometer
 */
    constructor(Model: Model, sbacid: number, nid1: number, nid2: number, nid3: number, igrav?: number, intopt?: number, mass?: number);

/**
 * Creates a string containing the accelerometer data in keyword format. Note that this contains the keyword header and the keyword cards. See also Accelerometer.Keyword() and Accelerometer.KeywordCards().
 */
    toString(): string;

/** The colour of the accelerometer */
    colour: Colour;
/** true if accelerometer exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Gravitational acceleration due to body force loads is included in acceleration output if igrav is 0, removed if igrav is 1. */
    igrav: number;
/** The Include file number that the accelerometer is in. */
    include: number;
/** Integration option; velocities are integrated from global accelerations and transformed into local system if intopt is 0, they are integrated directly from local accelerations if intopt is 1. */
    intopt: number;
/** Accelerometer number. Also see the sbacid property which is an alternative name for this. */
    label: number;
/** Optional added mass for accelerometer */
    mass: number;
/** The Model number that the accelerometer is in. */
    model: number;
/** Node number 1 */
    nid1: number;
/** Node number 2 */
    nid2: number;
/** Node number 3 */
    nid3: number;
/** Accelerometer number. Also see the label property which is an alternative name for this. */
    sbacid: number;
/** The transparency of the accelerometer (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
}

declare class Airbag {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the airbag.
 * @param flag Flag to clear on the airbag
 */
    ClearFlag(flag: number): void;

/**
 * Copies the airbag.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Airbag;

/**
 * Starts an interactive editing panel to create an airbag.
 * @param Model Model that the airbag will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Airbag;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for airbag. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first airbag in the model.
 * @param Model Model to get first airbag in
 */
    static First(Model: Model): Airbag;

/**
 * Returns the first free airbag label in the model. Also see Airbag.LastFreeLabel(), Airbag.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free airbag label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the airbags in the model with a defined flag.
 * @param Model Model that all airbags will be flagged in
 * @param flag Flag to set on the airbags
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the airbag is flagged or not.
 * @param flag Flag to test on the airbag
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each airbag in the model. Note that ForEach has been designed to make looping over airbags as fast as possible and so has some limitations. Firstly, a single temporary Airbag object is created and on each function call it is updated with the current airbag data. This means that you should not try to store the Airbag object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new airbags inside a ForEach loop. 
 * @param Model Model that all airbags are in
 * @param func Function to call for each airbag
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Airbag objects for all of the airbags in a model in Primer
 * @param Model Model to get airbags from
 */
    static GetAll(Model: Model): Airbag[];

/**
 * Returns an array of Airbag objects for all of the flagged airbags in a model in Primer
 * @param Model Model to get airbags from
 * @param flag Flag set on the airbags that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Airbag[];

/**
 * Returns the Airbag object for a airbag ID.
 * @param Model Model to find the airbag in
 * @param number number of the airbag you want the Airbag object for
 */
    static GetFromID(Model: Model, number: number): Airbag;

/**
 * Checks if a Airbag property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Airbag.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop airbag property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the value of property at index index for this Airbag object or null if no property exists.
 * @param index The index of the property value to retrieve. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for an airbag may not have adjacent indices.
 */
    GetPropertyByIndex(index: number): number;

/**
 * Returns the value of property string acronym for this Airbag object or null if no property exists.
 * @param acronym The acronym of the property value to retrieve
 */
    GetPropertyByName(acronym: string): number;

/**
 * Returns the value of the property for row and col for this Airbag object or null if no property exists. Note that columns start at 0. Rows start at 1 if the _ID option is set, at 0 otherwise.
 * @param row The row of the property value to retrieve
 * @param col The column of the property value to retrieve
 */
    GetPropertyByRowCol(row: number, col: number): number;

/**
 * Returns the name of the property at index index for this Airbag object or null if there is no property.
 * @param index The index of the property name to retrieve. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for an airbag may not have adjacent indices.
 */
    GetPropertyNameForIndex(index: number): string;

/**
 * Returns the name of the property at row and col for this Airbag object or null if there is no property. Note that columns start at 0. Rows start at 1 if the _ID option is set, at 0 otherwise.
 * @param row The row of the property name to retrieve
 * @param col The column of the property name to retrieve
 */
    GetPropertyNameForRowCol(row: number, col: number): string;

/**
 * Returns the keyword for this airbag (e.g. *AIRBAG_SIMPLE_PRESSURE_VOLUME, *AIRBAG_SIMPLE_AIRBAG_MODEL etc). Note that a carriage return is not added. See also Airbag.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the airbag. Note that a carriage return is not added. See also Airbag.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last airbag in the model.
 * @param Model Model to get last airbag in
 */
    static Last(Model: Model): Airbag;

/**
 * Returns the last free airbag label in the model. Also see Airbag.FirstFreeLabel(), Airbag.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free airbag label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next airbag in the model.
 */
    Next(): Airbag;

/**
 * Returns the next free (highest+1) airbag label in the model. Also see Airbag.FirstFreeLabel(), Airbag.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free airbag label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous airbag in the model.
 */
    Previous(): Airbag;

/**
 * Renumbers all of the airbags in the model.
 * @param Model Model that all airbags will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged airbags in the model.
 * @param Model Model that all the flagged airbags will be renumbered in
 * @param flag Flag set on the airbags that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select airbags using standard PRIMER object menus.
 * @param flag Flag to use when selecting airbags
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only airbags from that model can be selected. If the argument is a Flag then only airbags that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any airbags can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the airbag.
 * @param flag Flag to set on the airbag
 */
    SetFlag(flag: number): void;

/**
 * Sets the value of property at index index for this Airbag object
 * @param index The index of the property value to set. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for an airbag may not have adjacent indices.
 * @param value The value of the property to set.
 */
    SetPropertyByIndex(index: number, value: number): void;

/**
 * Sets the value of property string acronym for this Airbag object
 * @param acronym The acronym of the property value to set
 * @param value The value of the property to set.
 */
    SetPropertyByName(acronym: string, value: number): void;

/**
 * Sets the value of the property for row and col for this Airbag object. Note that columns start at 0. Rows start at 1 if the _ID option is set, at 0 otherwise.
 * @param row The row of the property value to set
 * @param col The column of the property value to set
 * @param value The value of the property to set.
 */
    SetPropertyByRowCol(row: number, col: number, value: number): void;

/**
 * Sketches the airbag. The airbag will be sketched until you either call Airbag.Unsketch(), Airbag.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the airbag is sketched. If omitted redraw is true. If you want to sketch several airbags and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged airbags in the model. The airbags will be sketched until you either call Airbag.Unsketch(), Airbag.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged airbags will be sketched in
 * @param flag Flag set on the airbags that you want to sketch
 * @param redraw If model should be redrawn or not after the airbags are sketched. If omitted redraw is true. If you want to sketch flagged airbags several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of airbags in the model.
 * @param Model Model to get total for
 * @param exists true if only existing airbags should be counted. If false or omitted referenced but undefined airbags will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the airbags in the model.
 * @param Model Model that the defined flag for all airbags will be unset in
 * @param flag Flag to unset on the airbags
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the airbag.
 * @param redraw If model should be redrawn or not after the airbag is unsketched. If omitted redraw is true. If you want to unsketch several airbags and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all airbags.
 * @param Model Model that all airbags will be unblanked in
 * @param redraw If model should be redrawn or not after the airbags are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged airbags in the model.
 * @param Model Model that all airbags will be unsketched in
 * @param flag Flag set on the airbags that you want to unsketch
 * @param redraw If model should be redrawn or not after the airbags are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Airbag;

/**
 * Adds a warning for airbag. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this airbag.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Airbag object.
 * @param Model Model that airbag will be created in
 * @param type Airbag type. Can be Airbag.SIMPLE_PRESSURE_VOLUME, Airbag.SIMPLE_AIRBAG_MODEL, Airbag.ADIABATIC_GAS_MODEL, Airbag.WANG_NEFSKE, Airbag.WANG_NEFSKE_JETTING, Airbag.WANG_NEFSKE_MULTIPLE_JETTING, Airbag.LOAD_CURVE, Airbag.LINEAR_FLUID, Airbag.HYBRID, Airbag.HYBRID_JETTING, Airbag.HYBRID_CHEMKIN, Airbag.ALE, Airbag.ADVANCED_ALE or Airbag.PARTICLE
 * @param sid Set ID
 * @param sidtyp Set type: segment/part set ID
 * @param abid Airbag number
 * @param heading Airbag title
 */
    constructor(Model: Model, type: string, sid: number, sidtyp?: number, abid?: number, heading?: string);

/**
 * Creates a string containing the airbag data in keyword format. Note that this contains the keyword header and the keyword cards. See also Airbag.Keyword() and Airbag.KeywordCards().
 */
    toString(): string;

/** Airbag number. Also see the label property which is an alternative name for this. */
    abid: number;
/** The number of columns of data the airbag has (read only) */
    readonly cols: number;
/** true if airbag exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Turns _ID on or OFF */
    id: boolean;
/** The Include file number that the airbag is in. */
    include: number;
/** Airbag number. Also see the abid property which is an alternative name for this. */
    label: number;
/** The Model number that the airbag is in. */
    model: number;
/** The total number of properties that the airbag has */
    properties: number;
/** The number of rows of data the airbag has (read only). This includes the _ID card if it is set. */
    readonly rows: number;
/** Airbag title */
    title: string;
/** Airbag type. Can be Airbag.SIMPLE_PRESSURE_VOLUME, Airbag.SIMPLE_AIRBAG_MODEL, Airbag.ADIABATIC_GAS_MODEL, Airbag.WANG_NEFSKE, Airbag.WANG_NEFSKE_JETTING, Airbag.WANG_NEFSKE_MULTIPLE_JETTING, Airbag.LOAD_CURVE, Airbag.LINEAR_FLUID, Airbag.HYBRID, Airbag.HYBRID_JETTING, Airbag.HYBRID_CHEMKIN, Airbag.ALE, Airbag.ADVANCED_ALE or Airbag.PARTICLE */
    type: number;
/** Airbag adiabatic gas model type */
    static ADIABATIC_GAS_MODEL: number;
/** Airbag advanced ALE type */
    static ADVANCED_ALE: number;
/** Airbag ALE type */
    static ALE: number;
/** Airbag hybrid type */
    static HYBRID: number;
/** Airbag hybrid chemkin type */
    static HYBRID_CHEMKIN: number;
/** Airbag hybrid jetting type */
    static HYBRID_JETTING: number;
/** Airbag linear fluid type */
    static LINEAR_FLUID: number;
/** Airbag load curve type */
    static LOAD_CURVE: number;
/** Airbag particle type */
    static PARTICLE: number;
/** Airbag simple airbag model type */
    static SIMPLE_AIRBAG_MODEL: number;
/** Airbag simple pressure volume type */
    static SIMPLE_PRESSURE_VOLUME: number;
/** Airbag Wang Nefske type */
    static WANG_NEFSKE: number;
/** Airbag Wang Nefske jetting type */
    static WANG_NEFSKE_JETTING: number;
/** Airbag Wang Nefske multiple jetting type */
    static WANG_NEFSKE_MULTIPLE_JETTING: number;
}

declare class Attached {
/**
 * Sets the find attached option for beam 3rd nodes on or off
 * @param Setting If true beam 3rd nodes are considered for find attached, if false, they are not.
 */
    static Beam3rdNodes(Setting: boolean): void;

/**
 * Sets the find attached option for beam pid on or off
 * @param Setting If true beam pid's are considered for find attached, if false, they are not.
 */
    static BeamPid(Setting: boolean): void;

/**
 * Sets the deformable option for find attached
 * @param Setting Option. Can be Attached.WHOLE, Attached.SINGLE
 */
    static Deformable(Setting: number): void;

/**
 * Sets an option to flag parts after a find attached if any elements within that part are flagged
 * @param Setting If true, parts are flagged after a find attached if any elements within that part are flagged, if false, they are not.
 */
    static FlagPart(Setting: boolean): void;

/**
 * Sets the find attached option for recursive on or off
 * @param Setting If true recursive is on, if false, it is off.
 * @param Number Option to set the number of find attached iterations used when the recursive option is set.
 */
    static Recursive(Setting: boolean, Number?: number): void;

/**
 * Sets the rigid option for find attached
 * @param Setting Option. Can be Attached.WHOLE, Attached.SINGLE
 */
    static Rigid(Setting: number): void;

/**
 * Sets entity to be on or off to find attached through.
 * @param Type The type of the item to switch on or off (for a list of types see Appendix I of the PRIMER manual).
 * @param Setting If true you turn the entity switch on, if false you turn it off.
 */
    static SetEntity(Type: string, Setting: boolean): void;

/**
 * Sets the find attached option for tied contacts on or off
 * @param Setting If true tied contacts are considered for find attached, if false, they are not.
 */
    static TiedContacts(Setting: boolean): void;

/** Find attached option - find attached through single elements only */
    static SINGLE: number;
/** Find attached option - find through whole attached part */
    static WHOLE: number;
}

declare class AxialForceBeam {
/**
 * Clears a flag on the axial force beam.
 * @param flag Flag to clear on the axial force beam
 */
    ClearFlag(flag: number): void;

/**
 * Copies the axial force beam.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): AxialForceBeam;

/**
 * Adds an error for axial force beam. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first axial force beam in the model.
 * @param Model Model to get first axial force beam in
 */
    static First(Model: Model): AxialForceBeam;

/**
 * Flags all of the axial force beams in the model with a defined flag.
 * @param Model Model that all axial force beams will be flagged in
 * @param flag Flag to set on the axial force beams
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the axial force beam is flagged or not.
 * @param flag Flag to test on the axial force beam
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each axial force beam in the model. Note that ForEach has been designed to make looping over axial force beams as fast as possible and so has some limitations. Firstly, a single temporary AxialForceBeam object is created and on each function call it is updated with the current axial force beam data. This means that you should not try to store the AxialForceBeam object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new axial force beams inside a ForEach loop. 
 * @param Model Model that all axial force beams are in
 * @param func Function to call for each axial force beam
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of AxialForceBeam objects for all of the axial force beams in a model in Primer
 * @param Model Model to get axial force beams from
 */
    static GetAll(Model: Model): AxialForceBeam[];

/**
 * Returns an array of AxialForceBeam objects for all of the flagged axial force beams in a model in Primer
 * @param Model Model to get axial force beams from
 * @param flag Flag set on the axial force beams that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): AxialForceBeam[];

/**
 * Returns the AxialForceBeam object for a axial force beam ID.
 * @param Model Model to find the axial force beam in
 * @param number number of the axial force beam you want the AxialForceBeam object for
 */
    static GetFromID(Model: Model, number: number): AxialForceBeam;

/**
 * Checks if a AxialForceBeam property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the AxialForceBeam.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop axial force beam property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this axial force beam (*INITIAL_AXIAL_FORCE_BEAM). Note that a carriage return is not added. See also AxialForceBeam.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the axial force beam. Note that a carriage return is not added. See also AxialForceBeam.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last axial force beam in the model.
 * @param Model Model to get last axial force beam in
 */
    static Last(Model: Model): AxialForceBeam;

/**
 * Returns the next axial force beam in the model.
 */
    Next(): AxialForceBeam;

/**
 * Returns the previous axial force beam in the model.
 */
    Previous(): AxialForceBeam;

/**
 * Allows the user to select axial force beams using standard PRIMER object menus.
 * @param flag Flag to use when selecting axial force beams
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only axial force beams from that model can be selected. If the argument is a Flag then only axial force beams that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any axial force beams can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the axial force beam.
 * @param flag Flag to set on the axial force beam
 */
    SetFlag(flag: number): void;

/**
 * Sketches the axial force beam. The axial force beam will be sketched until you either call AxialForceBeam.Unsketch(), AxialForceBeam.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the axial force beam is sketched. If omitted redraw is true. If you want to sketch several axial force beams and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged axial force beams in the model. The axial force beams will be sketched until you either call AxialForceBeam.Unsketch(), AxialForceBeam.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged axial force beams will be sketched in
 * @param flag Flag set on the axial force beams that you want to sketch
 * @param redraw If model should be redrawn or not after the axial force beams are sketched. If omitted redraw is true. If you want to sketch flagged axial force beams several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of axial force beams in the model.
 * @param Model Model to get total for
 * @param exists true if only existing axial force beams should be counted. If false or omitted referenced but undefined axial force beams will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the axial force beams in the model.
 * @param Model Model that the defined flag for all axial force beams will be unset in
 * @param flag Flag to unset on the axial force beams
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the axial force beam.
 * @param redraw If model should be redrawn or not after the axial force beam is unsketched. If omitted redraw is true. If you want to unsketch several axial force beams and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all axial force beams.
 * @param Model Model that all axial force beams will be unblanked in
 * @param redraw If model should be redrawn or not after the axial force beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged axial force beams in the model.
 * @param Model Model that all axial force beams will be unsketched in
 * @param flag Flag set on the axial force beams that you want to unsketch
 * @param redraw If model should be redrawn or not after the axial force beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): AxialForceBeam;

/**
 * Adds a warning for axial force beam. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this axial force beam.
 */
    Xrefs(): Xrefs;

/**
 * Create a new AxialForceBeam object.
 * @param Model Model that axial force beam will be created in
 * @param bsid BeamSet ID.
 * @param lcid Loadcurve ID defining preload versus time.
 * @param scale Scale factor on curve
 */
    constructor(Model: Model, bsid: number, lcid: number, scale?: number);

/**
 * Creates a string containing the axial force data in keyword format. Note that this contains the keyword header and the keyword cards. See also AxialForceBeam.Keyword() and AxialForceBeam.KeywordCards().
 */
    toString(): string;

/** Beam set ID. */
    bsid: number;
/** true if axial force beam exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** ID of the axial force beam. Only used in Primer. */
    readonly id: number;
/** The Include file number that the axial force beam is in. */
    include: number;
/** Bending stiffness flag. */
    kbend: number;
/** Loadcurve ID. */
    lcid: number;
/** The Model number that the axial force beam is in. */
    model: number;
/** Scale factor on loadcurve. */
    scale: number;
}

declare class Beam {
/**
 * Blanks the beam
 */
    Blank(): void;

/**
 * Blanks all of the beams in the model.
 * @param Model Model that all beams will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged beams in the model.
 * @param Model Model that all the flagged beams will be blanked in
 * @param flag Flag set on the beams that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the beam is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the beam.
 * @param flag Flag to clear on the beam
 */
    ClearFlag(flag: number): void;

/**
 * Copies the beam.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Beam;

/**
 * Starts an interactive editing panel to create a beam.
 * @param Model Model that the beam will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Beam;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Returns coordinates of the intersections between a beam and a database cross section.
 * @param Database_cross_section_label The label of the database cross section.
 */
    ElemCut(Database_cross_section_label: number): number[];

/**
 * Adds an error for beam. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for beam. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the beam colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the beam.
 */
    ExtractColour(): number;

/**
 * Returns an array of Beam objects for the beams within a box. This requires a previous (outside loop) call to function FindBeamInit() or m.FindElemInit() where the process is initialized for flagged beams in the model (typically all beams) and m.FindElemEnd() to close the process. Please note this function provides a list of all beams that could potentially be in the box (using computationally cheap bounding box comparison) it is not a rigorous test of whether the beam is actually in the box. See also Beam.FindBeamInit() See also Model.FindElemInit() See also Model.FindElemEnd()
 * @param Model Model designated model
 * @param xmin Minimum bound in global x
 * @param xmax Maximum bound in global x
 * @param ymin Minimum bound in global y
 * @param ymax Maximum bound in global y
 * @param zmin Minimum bound in global z
 * @param zmax Maximum bound in global z
 * @param bflag Optional flag to restrict beams considered
 * @param bthick Optional flag to consider thickness for beams
 */
    static FindBeamInBox(Model: Model, xmin: number, xmax: number, ymin: number, ymax: number, zmin: number, zmax: number, bflag?: number, bthick?: number): Beam[];

/**
 * Initialize setup so that all flagged beams in model can be tested to see if they are within box. See also Beam.FindBeamInBox() See also Model.FindElemInit() See also Model.FindElemEnd()
 * @param Model Model in which beams have been flagged
 * @param flag Optional flag that has been set on the beams, if unsupplied all beams considered
 */
    static FindBeamInit(Model: Model, flag?: number): void;

/**
 * Returns the first beam in the model.
 * @param Model Model to get first beam in
 */
    static First(Model: Model): Beam;

/**
 * Returns the first free beam label in the model. Also see Beam.LastFreeLabel(), Beam.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free beam label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the beams in the model with a defined flag.
 * @param Model Model that all beams will be flagged in
 * @param flag Flag to set on the beams
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the beam is flagged or not.
 * @param flag Flag to test on the beam
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each beam in the model. Note that ForEach has been designed to make looping over beams as fast as possible and so has some limitations. Firstly, a single temporary Beam object is created and on each function call it is updated with the current beam data. This means that you should not try to store the Beam object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new beams inside a ForEach loop. 
 * @param Model Model that all beams are in
 * @param func Function to call for each beam
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Beam objects for all of the beams in a model in Primer
 * @param Model Model to get beams from
 */
    static GetAll(Model: Model): Beam[];

/**
 * Returns an array of Beam objects for all of the flagged beams in a model in Primer
 * @param Model Model to get beams from
 * @param flag Flag set on the beams that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Beam[];

/**
 * Returns the Beam object for a beam ID.
 * @param Model Model to find the beam in
 * @param number number of the beam you want the Beam object for
 */
    static GetFromID(Model: Model, number: number): Beam;

/**
 * Checks if a Beam property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Beam.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop beam property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this beam (*BEAM, *BEAM_SCALAR or *BEAM_SCALAR_VALUE). Note that a carriage return is not added. See also Beam.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the beam. Note that a carriage return is not added. See also Beam.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last beam in the model.
 * @param Model Model to get last beam in
 */
    static Last(Model: Model): Beam;

/**
 * Returns the last free beam label in the model. Also see Beam.FirstFreeLabel(), Beam.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free beam label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next beam in the model.
 */
    Next(): Beam;

/**
 * Returns the next free (highest+1) beam label in the model. Also see Beam.FirstFreeLabel(), Beam.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free beam label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a beam.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only beams from that model can be picked. If the argument is a Flag then only beams that are flagged with limit can be selected. If omitted, or null, any beams from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Beam;

/**
 * Returns the previous beam in the model.
 */
    Previous(): Beam;

/**
 * Renumbers all of the beams in the model.
 * @param Model Model that all beams will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged beams in the model.
 * @param Model Model that all the flagged beams will be renumbered in
 * @param flag Flag set on the beams that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Returns the indices of the points for a faces to plot the true section of the beam. Note face numbers start at 0. Beam.SectionPoints must be called before this method.
 * @param face Face to get indices for
 */
    SectionFacePoints(face: number): number[];

/**
 * Returns the number of faces to plot the true section of the beam. Beam.SectionPoints must be called before this method.
 */
    SectionFaces(): number;

/**
 * Returns the point coordinates to plot the true section of the beam. They are returned in a single array of numbers.
 */
    SectionPoints(): number[];

/**
 * Allows the user to select beams using standard PRIMER object menus.
 * @param flag Flag to use when selecting beams
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only beams from that model can be selected. If the argument is a Flag then only beams that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any beams can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the beam.
 * @param flag Flag to set on the beam
 */
    SetFlag(flag: number): void;

/**
 * Sketches the beam. The beam will be sketched until you either call Beam.Unsketch(), Beam.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the beam is sketched. If omitted redraw is true. If you want to sketch several beams and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged beams in the model. The beams will be sketched until you either call Beam.Unsketch(), Beam.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged beams will be sketched in
 * @param flag Flag set on the beams that you want to sketch
 * @param redraw If model should be redrawn or not after the beams are sketched. If omitted redraw is true. If you want to sketch flagged beams several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if nodes of beam are tied by contact or directly attached (non-zero option1)
 * @param Contact_label The label of the tied contact. If zero the tied contact is found for the beam by reverse lookup.
 * @param Flag flag bit
 * @param Option1 Directly tied node (logical OR) 0:NONE 1:NRB/C_EXNO 2:BEAM 4:SHELL 8:SOLID 16:TSHELL
 * @param Option2 0:No action 1:report error if directly attached node (acc. option1) also captured by contact
 */
    TiedNodeCheck(Contact_label: number, Flag: number, Option1: number, Option2: number): string;

/**
 * Calculates the timestep for the beam
 */
    Timestep(): number;

/**
 * Returns the total number of beams in the model.
 * @param Model Model to get total for
 * @param exists true if only existing beams should be counted. If false or omitted referenced but undefined beams will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the beam
 */
    Unblank(): void;

/**
 * Unblanks all of the beams in the model.
 * @param Model Model that all beams will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged beams in the model.
 * @param Model Model that the flagged beams will be unblanked in
 * @param flag Flag set on the beams that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the beams in the model.
 * @param Model Model that the defined flag for all beams will be unset in
 * @param flag Flag to unset on the beams
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the beam.
 * @param redraw If model should be redrawn or not after the beam is unsketched. If omitted redraw is true. If you want to unsketch several beams and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all beams.
 * @param Model Model that all beams will be unblanked in
 * @param redraw If model should be redrawn or not after the beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged beams in the model.
 * @param Model Model that all beams will be unsketched in
 * @param flag Flag set on the beams that you want to unsketch
 * @param redraw If model should be redrawn or not after the beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Beam;

/**
 * Adds a warning for beam. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this beam.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Beam object. Use either 1, 2 or 3 nodes when creating a new beam.
 * @param Model Model that beam will be created in
 * @param eid Beam number
 * @param pid Part number
 * @param n1 Node number 1
 * @param n2 Node number 2 (optional)
 * @param n3 Node number 3 (optional)
 */
    constructor(Model: Model, eid: number, pid: number, n1: number, n2: number, n3: number);

/**
 * Creates a string containing the beam data in keyword format. Note that this contains the keyword header and the keyword cards. See also Beam.Keyword() and Beam.KeywordCards().
 */
    toString(): string;

/** Coordinate system ID (_SCALAR) */
    cid: number;
/** Coordinate system ID at node 1 (_SCALR) */
    cid_1: number;
/** The colour of the beam */
    colour: Colour;
/** Section parameter 1 */
    d1: number;
/** Section parameter 2 */
    d2: number;
/** Section parameter 3 */
    d3: number;
/** Section parameter 4 */
    d4: number;
/** Section parameter 5 */
    d5: number;
/** Section parameter 6 */
    d6: number;
/** Active degree of freedom at node 1 (_SCALAR) */
    dofn1: number;
/** Active degree of freedom at node 2 (_SCALAR) */
    dofn2: number;
/** Active degrees of freedom at nodes 1 and 2 (_SCALR) */
    dofns: number;
/** Beam number. Also see the label property which is an alternative name for this. */
    eid: number;
/** If ELBOW option is set. Can be true or false */
    elbow: boolean;
/** true if beam exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the beam is in. */
    include: number;
/** Mass moment of inertia for beam */
    iner: number;
/** Beam number. Also see the eid property which is an alternative name for this. */
    label: number;
/** Coordinate system option */
    local: number;
/** Middle Node for elbow beam */
    mn: number;
/** The Model number that the beam is in. */
    model: number;
/** Node number 1 */
    n1: number;
/** Node number 2 */
    n2: number;
/** Node number 3 */
    n3: number;
/** Number of nodes beam has (read only) */
    readonly nodes: number;
/** If _OFFSET option is set. Can be true or false */
    offset: number;
/** If _ORIENTATION option is set. Can be true or false */
    orientation: number;
/** Thickness parameter 1 */
    parm1: number;
/** Thickness parameter 2 */
    parm2: number;
/** Thickness parameter 3 */
    parm3: number;
/** Thickness parameter 4 */
    parm4: number;
/** Thickness parameter 5 */
    parm5: number;
/** Part number */
    pid: number;
/** Part number 1 for spotweld beam */
    pid1: number;
/** Part number 2 for spotweld beam */
    pid2: number;
/** If _PID option is set. Can be true or false */
    pid_opt: boolean;
/** Rotational release code at node 1 */
    rr1: number;
/** Rotational release code at node 2 */
    rr2: number;
/** Translational release code at node 1 */
    rt1: number;
/** Translational release code at node 2 */
    rt2: number;
/** If _SCALAR option is set. Can be true or false */
    scalar: boolean;
/** If _SCALR option is set. Can be true or false */
    scalr: boolean;
/** If _SECTION option is set. Can be true or false */
    section: boolean;
/** Scalar Node number 1 */
    sn1: number;
/** Scalar Node number 2 */
    sn2: number;
/** Section type */
    stype: string;
/** If _THICKNESS option is set. Can be true or false */
    thickness: boolean;
/** The transparency of the beam (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Volume of beam */
    vol: number;
/** Orientation vector X at node 1 */
    vx: number;
/** Orientation vector Y at node 1 */
    vy: number;
/** Orientation vector Z at node 1 */
    vz: number;
/** If WARPAGE option is set. Can be true or false */
    warpage: boolean;
/** Offset vector X at node 1 */
    wx1: number;
/** Offset vector X at node 2 */
    wx2: number;
/** Offset vector Y at node 1 */
    wy1: number;
/** Offset vector Y at node 2 */
    wy2: number;
/** Offset vector Z at node 1 */
    wz1: number;
/** Offset vector Z at node 2 */
    wz2: number;
}


/** Object function argument in InsertPoint */
interface InsertPointArgument_data {
    /** Point fixity type. Bitwise 'or' of the Path point fixity constants: Belt.B_POST_SLIPRING, Belt.FREE_SLIPRING, Belt.KNOWN, Belt.RETRACTOR, Belt.TWIST, Belt.XSEC */
    fixity: number;
    /** Node label (not required if using x, y and z) */
    node?: number;
    /** Twist node 1 label */
    tnode1?: number;
    /** Twist node 2 label */
    tnode2?: number;
    /** X component of normal vector 1 */
    tnx1?: number;
    /** X component of normal vector 2 */
    tnx2?: number;
    /** Y component of normal vector 1 */
    tny1?: number;
    /** Y component of normal vector 2 */
    tny2?: number;
    /** Z component of normal vector 1 */
    tnz1?: number;
    /** Z component of normal vector 2 */
    tnz2?: number;
    /** X component of twist radial vector 1 */
    trx1?: number;
    /** X component of twist radial vector 2 */
    trx2?: number;
    /** Y component of twist radial vector 1 */
    try1?: number;
    /** Y component of twist radial vector 2 */
    try2?: number;
    /** Z component of twist radial vector 1 */
    trz1?: number;
    /** Z component of twist radial vector 2 */
    trz2?: number;
    /** X coordinate (not required if using node) */
    x?: number;
    /** Y coordinate (not required if using node) */
    y?: number;
    /** Z coordinate (not required if using node) */
    z?: number;
}


/** Object function argument in SetMesh */
interface SetMeshArgument_data {
    /** 1st base point number */
    base_pt1: number;
    /** 2nd base point number */
    base_pt2: number;
    /** Number of belt elements at the 1st end for mixed modes */
    lb1: number;
    /** Number of belt elements at the 2nd end for mixed modes */
    lb2: number;
    /** Meshing modes can be of old style or new style. The following old style constants are available: Belt.MSEG_B1_ONLY, Belt.MSEG_B2_ONLY, Belt.MSEG_SH_ONLY, Belt.MSEG_MIX_SB1, Belt.MSEG_MIX_SB2 The following constant must be invoked in order to use the new style: Belt.MSEG_BD_NEW The following new style constants are available: Belt.MSEG_E1_1D, Belt.MSEG_E1_2D, Belt.MSEG_E1_SH, Belt.MSEG_E2_1D, Belt.MSEG_E2_2D, Belt.MSEG_E2_SH, Belt.MSEG_CE_1D, Belt.MSEG_CE_2D, Belt.MSEG_CE_SH */
    mode: number;
    /** 1st path point number */
    path_pt1: number;
    /** 2nd path point number */
    path_pt2: number;
}


/** Object function argument in SetPoint */
interface SetPointArgument_data {
    /** Point fixity type. Bitwise 'or' of the Path point fixity constants: Belt.B_POST_SLIPRING, Belt.FREE_SLIPRING, Belt.KNOWN, Belt.RETRACTOR, Belt.TWIST, Belt.XSEC */
    fixity: number;
    /** Node label (not required if using x, y and z) */
    node?: number;
    /** Twist node 1 label */
    tnode1?: number;
    /** Twist node 2 label */
    tnode2?: number;
    /** X component of normal vector 1 */
    tnx1?: number;
    /** X component of normal vector 2 */
    tnx2?: number;
    /** Y component of normal vector 1 */
    tny1?: number;
    /** Y component of normal vector 2 */
    tny2?: number;
    /** Z component of normal vector 1 */
    tnz1?: number;
    /** Z component of normal vector 2 */
    tnz2?: number;
    /** X component of twist radial vector 1 */
    trx1?: number;
    /** X component of twist radial vector 2 */
    trx2?: number;
    /** Y component of twist radial vector 1 */
    try1?: number;
    /** Y component of twist radial vector 2 */
    try2?: number;
    /** Z component of twist radial vector 1 */
    trz1?: number;
    /** Z component of twist radial vector 2 */
    trz2?: number;
    /** X coordinate (not required if using node) */
    x?: number;
    /** Y coordinate (not required if using node) */
    y?: number;
    /** Z coordinate (not required if using node) */
    z?: number;
}

declare class Belt {
/**
 * Blanks the belt
 */
    Blank(): void;

/**
 * Blanks all of the belts in the model.
 * @param Model Model that all belts will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged belts in the model.
 * @param Model Model that all the flagged belts will be blanked in
 * @param flag Flag set on the belts that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the belt is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the belt.
 * @param flag Flag to clear on the belt
 */
    ClearFlag(flag: number): void;

/**
 * Copies the belt.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Belt;

/**
 * Adds an error for belt. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first belt in the model.
 * @param Model Model to get first belt in
 */
    static First(Model: Model): Belt;

/**
 * Returns the first free belt label in the model. Also see Belt.LastFreeLabel(), Belt.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free belt label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * (Re)fits belt
 */
    Fit(): void;

/**
 * Flags all of the belts in the model with a defined flag.
 * @param Model Model that all belts will be flagged in
 * @param flag Flag to set on the belts
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the belt is flagged or not.
 * @param flag Flag to test on the belt
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each belt in the model. Note that ForEach has been designed to make looping over belts as fast as possible and so has some limitations. Firstly, a single temporary Belt object is created and on each function call it is updated with the current belt data. This means that you should not try to store the Belt object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new belts inside a ForEach loop. 
 * @param Model Model that all belts are in
 * @param func Function to call for each belt
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Generates belt mesh. Extracts and uses existing mesh properties when a mesh is present; inserts a default mesh otherwise.
 */
    Generate(): void;

/**
 * Returns an array of Belt objects for all of the belts in a model in Primer
 * @param Model Model to get belts from
 */
    static GetAll(Model: Model): Belt[];

/**
 * Returns an array of Belt objects for all of the flagged belts in a model in Primer
 * @param Model Model to get belts from
 * @param flag Flag set on the belts that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Belt[];

/**
 * Returns the Belt object for a belt ID.
 * @param Model Model to find the belt in
 * @param number number of the belt you want the Belt object for
 */
    static GetFromID(Model: Model, number: number): Belt;

/**
 * Returns the information for a belt mesh section (properties base_pt1, base_pt2, path_pt1, path_pt2, mode, lb1, lb2). See Belt.SetMesh() for more information on supported properties. Must be preceded by a call to Belt.Generate().
 * @param index The index of the mesh section you want the information for. Note that mesh segments start at 0, not 1. 0 &lt;= index &lt; meshSegs
 */
    GetMesh(index: number): object;

/**
 * Checks if a Belt property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Belt.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop belt property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the information for a path point (properties fixity, x, y, z, node, trx1, try1, trz1, tnx1, tny1, tnz1, tnode1, trx2, try2, trz2, tnx2, tny2, tnz2, tnode2). Properties fixity, x, y, z and node will always be returned. Twist properties trx1, try1, trz1, tnx1, tny1, tnz1, tnode1, trx2, try2, trz2, tnx2, tny2, tnz2 and tnode2 will only be returned if defined for the point.
 * @param index The index of the path point you want the information for. Note that path points start at 0, not 1. 0 &lt;= index &lt; points
 */
    GetPoint(index: number): number;

/**
 * Inserts a path point before/after an existing one. Subsequent path points will be moved 'up' as required.
 * @param index The index of an existing path point. Note that path points start at 0, not 1. 0 &lt;= index &lt; points
 * @param position Do we want to insert before or after the path point denoted by index? The position can be Belt.INSERT_AFTER or Belt.INSERT_BEFORE
 * @param data Object containing the path point data.
 */
    InsertPoint(index: number, position: number, data: InsertPointArgument_data): void;

/**
 * Returns the last belt in the model.
 * @param Model Model to get last belt in
 */
    static Last(Model: Model): Belt;

/**
 * Returns the last free belt label in the model. Also see Belt.FirstFreeLabel(), Belt.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free belt label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next belt in the model.
 */
    Next(): Belt;

/**
 * Returns the next free (highest+1) belt label in the model. Also see Belt.FirstFreeLabel(), Belt.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free belt label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a belt.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only belts from that model can be picked. If the argument is a Flag then only belts that are flagged with limit can be selected. If omitted, or null, any belts from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Belt;

/**
 * Returns the previous belt in the model.
 */
    Previous(): Belt;

/**
 * Removes a path point from a belt
 * @param index The index of the path point you want to remove. Note that path points start at 0, not 1. 0 &lt;= index &lt; points
 */
    RemovePoint(index: number): void;

/**
 * Renumbers all of the belts in the model.
 * @param Model Model that all belts will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged belts in the model.
 * @param Model Model that all the flagged belts will be renumbered in
 * @param flag Flag set on the belts that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select belts using standard PRIMER object menus.
 * @param flag Flag to use when selecting belts
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only belts from that model can be selected. If the argument is a Flag then only belts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any belts can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the belt.
 * @param flag Flag to set on the belt
 */
    SetFlag(flag: number): void;

/**
 * Sets the data for various properties for a mesh section in a belt. Values for properties not invoked will be retained as is. Must be preceded by a call to Belt.Generate()
 * @param index The index of the mesh section
 * @param data Object containing the mesh section data.
 */
    SetMesh(index: number, data: SetMeshArgument_data): void;

/**
 * Set the start labels for the entities created for a Seat Belt.
 * @param entity_type The Meshing label can be Belt.MESH_NODE,  Belt.MESH_SHELL, Belt.MESH_SET_NODE, Belt.MESH_SET_NODE, Belt.MESH_SEATBELT, Belt.MESH_NRBC, BELT.MESH_RETRACTOR, Belt.MESH_XSEC, Belt.MESH_SLIPRING, Belt.MESH_SET_PART, Belt.MESH_2D_SLIPRING_SET_NODE, Belt.MESH_ALL.
 * @param label_value The intial label value to be assigned for the entity type.
 */
    static SetMeshingLabels(entity_type: number, label_value: number): void;

/**
 * Sets the data for a path point in a belt
 * @param index The index of the path point you want to set. Note that path points start at 0, not 1. To add a new point use index points
 * @param data Object containing the path point data.
 */
    SetPoint(index: number, data: SetPointArgument_data): void;

/**
 * Sketches the belt. The belt will be sketched until you either call Belt.Unsketch(), Belt.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the belt is sketched. If omitted redraw is true. If you want to sketch several belts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged belts in the model. The belts will be sketched until you either call Belt.Unsketch(), Belt.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged belts will be sketched in
 * @param flag Flag set on the belts that you want to sketch
 * @param redraw If model should be redrawn or not after the belts are sketched. If omitted redraw is true. If you want to sketch flagged belts several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of belts in the model.
 * @param Model Model to get total for
 * @param exists true if only existing belts should be counted. If false or omitted referenced but undefined belts will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the belt
 */
    Unblank(): void;

/**
 * Unblanks all of the belts in the model.
 * @param Model Model that all belts will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged belts in the model.
 * @param Model Model that the flagged belts will be unblanked in
 * @param flag Flag set on the belts that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the belts in the model.
 * @param Model Model that the defined flag for all belts will be unset in
 * @param flag Flag to unset on the belts
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the belt.
 * @param redraw If model should be redrawn or not after the belt is unsketched. If omitted redraw is true. If you want to unsketch several belts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all belts.
 * @param Model Model that all belts will be unblanked in
 * @param redraw If model should be redrawn or not after the belts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged belts in the model.
 * @param Model Model that all belts will be unsketched in
 * @param flag Flag set on the belts that you want to unsketch
 * @param redraw If model should be redrawn or not after the belts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Belt;

/**
 * Adds a warning for belt. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this belt.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Belt object.
 * @param model Model that the belt definition will be created in
 * @param id Belt number
 * @param title Title for the belt
 * @param structural_type Seatbelt will be fitted around this entity type. This will trigger creation of sets as required. Type can be one of MODEL, DUMMY, PART, any ELEMENT subtype such as SHELL, or any SET subtype such as SET_PART. See Appendix I of the PRIMER manual for more information on PRIMER types
 * @param flag Flag used to identify entities that the belt should fit around. This argument is ignored if structural_type is MODEL. Instead, the current model is used
 */
    constructor(model: Model, id: number, title?: string, structural_type?: string, flag?: number);

/** Limiting angle to be considered "acute" (0 means 90) */
    acuteAngle: number;
/** Maximum permitted transverse belt curvature in degrees */
    curvature: number;
/** Set of shell or 2D seatbelt elements. Only created if the option to generate a contact for the belt is used (read only) */
    readonly elemSet: number;
/** true if belt exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Transverse friction coefficient */
    friction: number;
/** Belt number. Also see the label property which is an alternative name for this. */
    id: number;
/** The Include file number that the belt is in. */
    include: number;
/** The number of fitting iterations between contact bucket resorts */
    iterations: number;
/** Belt number. Also see the id property which is an alternative name for this. */
    label: number;
/** The characteristic length of each belt element */
    length: number;
/** Number of mesh segments defined (read only) */
    readonly meshSegs: number;
/** The Model number that the belt is in. */
    model: number;
/** Nodes to Surface contact used between nodes on 1D belt elements and dummy structure. Only used if the option to create a contact between belt and dummy "structure" has been used (read only) */
    readonly n2sContact: number;
/** Set of all nodes in seatbelt. Only created if the option to generate a contact for the belt is used (read only) */
    readonly nodeSet: number;
/** First nodal rigid body ID (read only) */
    readonly nrbFirst: number;
/** Last nodal rigid body ID (read only) */
    readonly nrbLast: number;
/** Set of nodes on 1D seatbelt elements only. Only created if the option to generate a contact for the belt is used (read only) */
    readonly nsboSet: number;
/** Fraction by which facets are extended during contact checking to stop nodes "falling into gaps" */
    overlap: number;
/** Part set ID defining structure. Note that if you are creating the seatbelt definition from scratch in JavaScript you must define a shell, solid or thick shell set. */
    parts: number;
/** Maximum penetration distance considered for contact into solid and thick shell elements */
    penetration: number;
/** The part ID for any 2D seatbelt elements */
    pidShell: number;
/** The part ID for any 1D seatbelt elements */
    pid_1d: number;
/** The part ID for any 2D seatbelt elements */
    pid_2d: number;
/** Number of path points defined (read only) */
    readonly points: number;
/** Initial projection distance by which belt path is "thrown outwards" at start of fitting */
    projection: number;
/** Optional orthotropic angle for any shell elements */
    psiShell: number;
/** Optional orthotropic angle for any 2D seatbelt elements */
    psi_2d: number;
/** First retractor ID (read only) */
    readonly retractorFirst: number;
/** Last retractor ID (read only) */
    readonly retractorLast: number;
/** The number of rows of 2D elements across the belt */
    rows: number;
/** Surface to Surface contact used between shell/2D belt elements and dummy structure. Only used if the option to create a contact between belt and dummy "structure" has been used (read only) */
    readonly s2sContact: number;
/** First 1D seatbelt ID (read only) */
    readonly seatbeltFirst: number;
/** Last 1D seatbelt ID (read only) */
    readonly seatbeltLast: number;
/** Segment set created for contact (read only) */
    readonly segments: number;
/** Shell set ID defining structure. Note that if you are creating the seatbelt definition from scratch in JavaScript you must define a shell, solid or thick shell set. */
    shells: number;
/** The initial slack length for any 1D seatbelt elements */
    slen_1d: number;
/** First slipring ID (read only) */
    readonly slipringFirst: number;
/** Last slipring ID (read only) */
    readonly slipringLast: number;
/** Solid set ID defining structure. Note that if you are creating the seatbelt definition from scratch in JavaScript you must define a shell, solid or thick shell set. */
    solids: number;
/** Optional thickness at n1 for any shell elements */
    t1Shell: number;
/** Optional thickness at n1 for any 2D seatbelt elements */
    t1_2d: number;
/** Optional thickness at n2 for any shell elements */
    t2Shell: number;
/** Optional thickness at n2 for any 2D seatbelt elements */
    t2_2d: number;
/** Optional thickness at n3 for any shell elements */
    t3Shell: number;
/** Optional thickness at n3 for any 2D seatbelt elements */
    t3_2d: number;
/** Optional thickness at n4 for any shell elements */
    t4Shell: number;
/** Optional thickness at n4 for any 2D seatbelt elements */
    t4_2d: number;
/** Factor used when thickFlag is 1 */
    thickFactor: number;
/** Thickness used during fitting: 0 (default)=use true thickness; 1=use true thickness x factor; 2=use neutral axis (no thickness) */
    thickFlag: number;
/** The thickness of 2D belt elements */
    thickness: number;
/** Belt title. */
    title: string;
/** The convergence tolerance at which fitting halts */
    tolerance: number;
/** Thick shell set ID defining structure. Note that if you are creating the seatbelt definition from scratch in JavaScript you must define a shell, solid or thick shell set. */
    tshells: number;
/** The overall belt width */
    width: number;
/** First cross section ID (read only) */
    readonly xsectionFirst: number;
/** Last cross section ID (read only) */
    readonly xsectionLast: number;
/** There is a B-Post slipring at this point. */
    static B_POST_SLIPRING: number;
/** Point is fixed */
    static FIXED: number;
/** There is a free (eg pelvis) slipring at this point. */
    static FREE_SLIPRING: number;
/** Insert after given path point. */
    static INSERT_AFTER: number;
/** Insert before given path point. */
    static INSERT_BEFORE: number;
/** The belt path is known to pass through this point */
    static KNOWN: number;
/** Set meshing start Labels for 2D slipring node sets */
    static MESH_2D_SLIPRING_SET_NODE: number;
/** Set meshing start Labels for everything used in the seatbelt definition */
    static MESH_ALL: number;
/** Set meshing start Labels for nodes */
    static MESH_NODE: number;
/** Set meshing start Labels for nodal rigid bodies */
    static MESH_NRBC: number;
/** Set meshing start Labels for retractors */
    static MESH_RETRACTOR: number;
/** Set meshing start Labels for seatbelt elements */
    static MESH_SEATBELT: number;
/** Set meshing start Labels for node sets */
    static MESH_SET_NODE: number;
/** Set meshing start Labels for part sets */
    static MESH_SET_PART: number;
/** Set meshing start Labels for shell sets */
    static MESH_SET_SHELL: number;
/** Set meshing start Labels for shells */
    static MESH_SHELL: number;
/** Set meshing start Labels for slipring elements */
    static MESH_SLIPRING: number;
/** Set meshing start Labels for Database cross sections */
    static MESH_XSEC: number;
/** Old style all 1D belt */
    static MSEG_B1_ONLY: number;
/** Old style all 2D belt */
    static MSEG_B2_ONLY: number;
/** Indicates new mode. This must be set before any of the new style constants can be used */
    static MSEG_BD_NEW: number;
/** New style 1D at centre */
    static MSEG_CE_1D: number;
/** New style 1D at end 1 */
    static MSEG_E1_1D: number;
/** New style 2D at end 1 */
    static MSEG_E1_2D: number;
/** New style shells at end 1 */
    static MSEG_E1_SH: number;
/** New style 1D at end 2 */
    static MSEG_E2_1D: number;
/** New style 2D at end 2 */
    static MSEG_E2_2D: number;
/** New style shells at end 2 */
    static MSEG_E2_SH: number;
/** Old style 1D at ends, shells in middle */
    static MSEG_MIX_SB1: number;
/** Old style 2D at ends, shells in middle */
    static MSEG_MIX_SB2: number;
/** Old style all shell belt */
    static MSEG_SH_ONLY: number;
/** There is a retractor at this point */
    static RETRACTOR: number;
/** There is a slipring at this point. (Deprecated from V12 onwards, use FREE_SLIPRING or B_POST_SLIPRING instead) */
    static SLIPRING: number;
/** Point has twist vectors or twist nodes defined */
    static TWIST: number;
/** There is a database cross section at this point */
    static XSEC: number;
}

declare class Box {
/**
 * Blanks the box
 */
    Blank(): void;

/**
 * Blanks all of the boxs in the model.
 * @param Model Model that all boxs will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged boxs in the model.
 * @param Model Model that all the flagged boxs will be blanked in
 * @param flag Flag set on the boxs that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the box is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the box.
 * @param flag Flag to clear on the box
 */
    ClearFlag(flag: number): void;

/**
 * Copies the box.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Box;

/**
 * Starts an interactive editing panel to create a box.
 * @param Model Model that the box will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Box;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for box. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first box in the model.
 * @param Model Model to get first box in
 */
    static First(Model: Model): Box;

/**
 * Returns the first free box label in the model. Also see Box.LastFreeLabel(), Box.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free box label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the boxs in the model with a defined flag.
 * @param Model Model that all boxs will be flagged in
 * @param flag Flag to set on the boxs
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the box is flagged or not.
 * @param flag Flag to test on the box
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each box in the model. Note that ForEach has been designed to make looping over boxs as fast as possible and so has some limitations. Firstly, a single temporary Box object is created and on each function call it is updated with the current box data. This means that you should not try to store the Box object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boxs inside a ForEach loop. 
 * @param Model Model that all boxs are in
 * @param func Function to call for each box
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Box objects for all of the boxs in a model in Primer
 * @param Model Model to get boxs from
 */
    static GetAll(Model: Model): Box[];

/**
 * Returns an array of Box objects for all of the flagged boxs in a model in Primer
 * @param Model Model to get boxs from
 * @param flag Flag set on the boxs that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Box[];

/**
 * Returns the Box object for a box ID.
 * @param Model Model to find the box in
 * @param number number of the box you want the Box object for
 */
    static GetFromID(Model: Model, number: number): Box;

/**
 * Checks if a Box property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Box.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop box property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this box (*DEFINE_BOX). Note that a carriage return is not added. See also Box.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the box. Note that a carriage return is not added. See also Box.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last box in the model.
 * @param Model Model to get last box in
 */
    static Last(Model: Model): Box;

/**
 * Returns the last free box label in the model. Also see Box.FirstFreeLabel(), Box.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free box label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next box in the model.
 */
    Next(): Box;

/**
 * Returns the next free (highest+1) box label in the model. Also see Box.FirstFreeLabel(), Box.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free box label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a box.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boxs from that model can be picked. If the argument is a Flag then only boxs that are flagged with limit can be selected. If omitted, or null, any boxs from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Box;

/**
 * Returns the previous box in the model.
 */
    Previous(): Box;

/**
 * Renumbers all of the boxs in the model.
 * @param Model Model that all boxs will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged boxs in the model.
 * @param Model Model that all the flagged boxs will be renumbered in
 * @param flag Flag set on the boxs that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select boxs using standard PRIMER object menus.
 * @param flag Flag to use when selecting boxs
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boxs from that model can be selected. If the argument is a Flag then only boxs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boxs can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the box.
 * @param flag Flag to set on the box
 */
    SetFlag(flag: number): void;

/**
 * Sketches the box. The box will be sketched until you either call Box.Unsketch(), Box.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the box is sketched. If omitted redraw is true. If you want to sketch several boxs and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged boxs in the model. The boxs will be sketched until you either call Box.Unsketch(), Box.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged boxs will be sketched in
 * @param flag Flag set on the boxs that you want to sketch
 * @param redraw If model should be redrawn or not after the boxs are sketched. If omitted redraw is true. If you want to sketch flagged boxs several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of boxs in the model.
 * @param Model Model to get total for
 * @param exists true if only existing boxs should be counted. If false or omitted referenced but undefined boxs will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the box
 */
    Unblank(): void;

/**
 * Unblanks all of the boxs in the model.
 * @param Model Model that all boxs will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged boxs in the model.
 * @param Model Model that the flagged boxs will be unblanked in
 * @param flag Flag set on the boxs that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the boxs in the model.
 * @param Model Model that the defined flag for all boxs will be unset in
 * @param flag Flag to unset on the boxs
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the box.
 * @param redraw If model should be redrawn or not after the box is unsketched. If omitted redraw is true. If you want to unsketch several boxs and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all boxs.
 * @param Model Model that all boxs will be unblanked in
 * @param redraw If model should be redrawn or not after the boxs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged boxs in the model.
 * @param Model Model that all boxs will be unsketched in
 * @param flag Flag set on the boxs that you want to unsketch
 * @param redraw If model should be redrawn or not after the boxs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Box;

/**
 * Adds a warning for box. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this box.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Box object.
 * @param Model Model that box will be created in
 * @param bid Box number
 * @param xmn Minimum X coordinate
 * @param xmx Maximum X coordinate
 * @param ymn Minimum Y coordinate
 * @param ymx Maximum Y coordinate
 * @param zmn Minimum Z coordinate
 * @param zmx Maximum Z coordinate
 * @param heading Title for the box
 */
    constructor(Model: Model, bid: number, xmn: number, xmx: number, ymn: number, ymx: number, zmn: number, zmx: number, heading?: string);

/**
 * Creates a string containing the box data in keyword format. Note that this contains the keyword header and the keyword cards. See also Box.Keyword() and Box.KeywordCards().
 */
    toString(): string;

/** Box number. Also see the label property which is an alternative name for this. */
    bid: number;
/** Maximum mesh size in 3D tetrahedron adaptivity */
    brmax: number;
/** Minimum mesh size in 3D tetrahedron adaptivity */
    brmin: number;
/** Optional coordinate system ID for tubular drawbead */
    cid: number;
/** X coordinate of offset vector to local origin */
    cx: number;
/** Y coordinate of offset vector to local origin */
    cy: number;
/** Z coordinate of offset vector to local origin */
    cz: number;
/** true if box exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Box heading */
    heading: string;
/** Direction of tooling movement. 1: x-direction, 2: y-direction, 3: z-direction */
    idir: number;
/** Element protection flag. 0: elements inside, 1: elements outside box cannot be coarsened. */
    iflag: number;
/** The Include file number that the box is in. */
    include: number;
/** Box number. Also see the bid property which is an alternative name for this. */
    label: number;
/** Load curve ID to describe motion value versus time */
    lcid: number;
/** Maximum number of refinement levels for elements contained in box */
    level: number;
/** Box movement in global X axis or by node. The ndid property is an alternative name for this. */
    lidx: number;
/** Box movement in global Y axis */
    lidy: number;
/** Box movement in global Z axis */
    lidz: number;
/** Turns _LOCAL on or off */
    local: boolean;
/** The Model number that the box is in. */
    model: number;
/** Box movement in global X axis or by node. The lidx property is an alternative name for this. */
    ndid: number;
/** Referential nodal ID for vd = 2 */
    nid: number;
/** The box option. Can be Box.BOX, Box.BOX_ADAPTIVE, Box.BOX_COARSEN, Box.BOX_DRAWBEAD or Box.BOX_SPH. */
    option: number;
/** Part ID for Box.BOX_ADAPTIVE option */
    pid_adaptive: number;
/** Part ID of blank for Box.BOX_DRAWBEAD option */
    pid_drawbead: number;
/** Radius of tube centered around draw bead */
    radius: number;
/** Part set, part or node set defining the nodal points along draw bead */
    sid: number;
/** Set type for stype. 2: part set ID, 3: part ID, 4: node set ID */
    stype: number;
/** Velocity/Displacement flag. 0: velocity, 1: displacement, 2: referential node */
    vd: number;
/** Vector ID of DOF */
    vid: number;
/** Minimum X coordinate */
    xmn: number;
/** Maximum X coordinate */
    xmx: number;
/** Local V vector X coordinate */
    xv: number;
/** Local X vector X coordinate */
    xx: number;
/** Minimum Y coordinate */
    ymn: number;
/** Maximum Y coordinate */
    ymx: number;
/** Local V vector Y coordinate */
    yv: number;
/** Local X vector Y coordinate */
    yx: number;
/** Minimum Z coordinate */
    zmn: number;
/** Maximum Z coordinate */
    zmx: number;
/** Local V vector Z coordinate */
    zv: number;
/** Local X vector Z coordinate */
    zx: number;
/** Box is *DEFINE_BOX. */
    static BOX: number;
/** Box is *DEFINE_BOX_ADAPTIVE. */
    static BOX_ADAPTIVE: number;
/** Box is *DEFINE_BOX_COARSEN. */
    static BOX_COARSEN: number;
/** Box is *DEFINE_BOX_DRAWBEAD. */
    static BOX_DRAWBEAD: number;
/** Box is *DEFINE_BOX_SPH. */
    static BOX_SPH: number;
}

declare class Check {
/**
 * Adds a comment for a user dashboard check. Multiple comments can be added. Call this function as many times as required.  This function should only be called from a user JavaScript dashboard script.
 * @param comment The comment to add.
 */
    static AddDashboardComment(comment: string): void;

/**
 * Allows the user to add the value of model health based on the other dashboard results  This function should only be called from model_health.config.js which should be placed with the other user defined dashboard scripts.
 * @param model_health Text which will be displayed on the dashboard panel and the summary files.
 * @param Health_text_colour Colour of the model health text. The default colour is Black.
 * @param Health_button_colour Colour of the model health button. The default colour is dark grey.
 */
    static AddDashboardHealth(model_health: string, Health_text_colour?: number, Health_button_colour?: number): void;

/**
 * Adds a custom error. This function should only be called from a custom JavaScript check script. See the details in the Check class for how to do this.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    static Error(message: string, details?: string): void;

/**
 * Returns data from all the dashboards that are defined.  This function should only be called from model_health.config.js which should be placed with the other user defined dashboard scripts.  The dashboard properties are:  result (Overall result of the dashboard) title (dashboard title) message1 (First message of the dashboard) message2 (Second message of the dashboard) comments (Array of comments on the dashboard) 
 */
    static GetAllDashboards(): dashboard[];

/**
 * Used to proceed with or abort the keyout operation (LS-DYNA output) from the keyout_hook.js script. The current hooks are launched just before the keyout operation from the model write tab, writing from the dialogue box and during keyout from the include tree. Please look at the example_keyout_script.js for an example of its usage.
 * @param interrupt_flag If this flag is set to true then keyout is aborted else keyout proceeds as usual.
 */
    static KeyoutHook(interrupt_flag: boolean): void;

/**
 * Adds a message for a user dashboard check. Each dashboard can currently show two messages. This function should only be called from a user JavaScript dashboard script.
 * @param first The first message to add.
 * @param second The second message to add.
 */
    static SetDashboardMessage(first: string, second?: string): void;

/**
 * Sets the status of a user dashboard check. This function should only be called from a user JavaScript dashboard script.
 * @param status The status. Can be Check.OK, Check.WARNING, Check.ERROR or Check.UNKNOWN.
 */
    static SetDashboardStatus(status: number): void;

/**
 * Adds a custom warning. This function should only be called from a custom JavaScript check script. See the details in the Check class for how to do this.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    static Warning(message: string, details?: string): void;

/** Colour black */
    static BLACK: number;
/** Colour blue */
    static BLUE: number;
/** Colour cyan */
    static CYAN: number;
/** Colour dark blue */
    static DARKBLUE: number;
/** Colour dark green */
    static DARKGREEN: number;
/** Colour dark grey */
    static DARKGREY: number;
/** Colour dark red */
    static DARKRED: number;
/** Dashboard check gave error(s) */
    static ERROR: number;
/** Colour green */
    static GREEN: number;
/** Colour grey */
    static GREY: number;
/** Colour light grey */
    static LIGHTGREY: number;
/** Colour magenta */
    static MAGENTA: number;
/** Dashboard check status OK */
    static OK: number;
/** Colour orange */
    static ORANGE: number;
/** Colour red */
    static RED: number;
/** Dashboard check status unknown (not run) */
    static UNKNOWN: number;
/** Dashboard check gave warning(s) */
    static WARNING: number;
/** Colour white */
    static WHITE: number;
/** Colour yellow */
    static YELLOW: number;
}

declare class Colour {
/**
 * Creates a colour from red, green and blue components
 * @param red red component of colour (0-255).
 * @param green green component of colour (0-255).
 * @param blue blue component of colour (0-255).
 */
    static RGB(red: number, green: number, blue: number): number;

/** Base colour on assembly */
    static ASSEMBLY: number;
/** Background colour */
    static BACKGROUND: number;
/** Colour black */
    static BLACK: number;
/** Colour blue */
    static BLUE: number;
/** Colour cyan */
    static CYAN: number;
/** Colour dark orange */
    static DARK_ORANGE: number;
/** Default colour for objects */
    static DEFAULT: number;
/** Colour green */
    static GREEN: number;
/** Colour green/cyan */
    static GREEN_CYAN: number;
/** Colour grey */
    static GREY: number;
/** Base colour on include file */
    static INCLUDE: number;
/** Colour light blue */
    static LIGHT_BLUE: number;
/** Colour magenta */
    static MAGENTA: number;
/** For elements with part IDs base colour on material ID */
    static MATERIAL: number;
/** Colour medium blue */
    static MEDIUM_BLUE: number;
/** Base colour on model */
    static MODEL: number;
/** Not the background colour */
    static NOT_BACKGROUND: number;
/** Colour orange */
    static ORANGE: number;
/** For elements with part IDs base colour on part ID */
    static PART: number;
/** Colour red */
    static RED: number;
/** Colour red/magenta */
    static RED_MAGENTA: number;
/** For elements with part IDs base colour on section ID */
    static SECTION: number;
/** Sketch colour */
    static SKETCH: number;
/** Text colour */
    static TEXT: number;
/** Colour white */
    static WHITE: number;
/** Colour yellow */
    static YELLOW: number;
/** Colour yellow/green */
    static YELLOW_GREEN: number;
}

declare class ConnectionProperties {
/**
 * Allows user to add material data line in *DEFINE_CONNECTION_PROPERTIES.
 */
    AddMaterialDataLine(): void;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the *DEFINE_CONNECTION_PROPERTIES.
 * @param flag Flag to clear on the *DEFINE_CONNECTION_PROPERTIES
 */
    ClearFlag(flag: number): void;

/**
 * Copies the *DEFINE_CONNECTION_PROPERTIES.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): ConnectionProperties;

/**
 * Starts an interactive editing panel to create a *DEFINE_CONNECTION_PROPERTIES.
 * @param Model Model that the *DEFINE_CONNECTION_PROPERTIES will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): ConnectionProperties;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for *DEFINE_CONNECTION_PROPERTIES. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first *DEFINE_CONNECTION_PROPERTIES in the model.
 * @param Model Model to get first *DEFINE_CONNECTION_PROPERTIES in
 */
    static First(Model: Model): ConnectionProperties;

/**
 * Returns the first free *DEFINE_CONNECTION_PROPERTIES label in the model. Also see ConnectionProperties.LastFreeLabel(), ConnectionProperties.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free *DEFINE_CONNECTION_PROPERTIES label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the *DEFINE_CONNECTION_PROPERTIESs in the model with a defined flag.
 * @param Model Model that all *DEFINE_CONNECTION_PROPERTIESs will be flagged in
 * @param flag Flag to set on the *DEFINE_CONNECTION_PROPERTIESs
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the *DEFINE_CONNECTION_PROPERTIES is flagged or not.
 * @param flag Flag to test on the *DEFINE_CONNECTION_PROPERTIES
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each *DEFINE_CONNECTION_PROPERTIES in the model. Note that ForEach has been designed to make looping over *DEFINE_CONNECTION_PROPERTIESs as fast as possible and so has some limitations. Firstly, a single temporary ConnectionProperties object is created and on each function call it is updated with the current *DEFINE_CONNECTION_PROPERTIES data. This means that you should not try to store the ConnectionProperties object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new *DEFINE_CONNECTION_PROPERTIESs inside a ForEach loop. 
 * @param Model Model that all *DEFINE_CONNECTION_PROPERTIESs are in
 * @param func Function to call for each *DEFINE_CONNECTION_PROPERTIES
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of ConnectionProperties objects for all of the *DEFINE_CONNECTION_PROPERTIESs in a model in Primer
 * @param Model Model to get *DEFINE_CONNECTION_PROPERTIESs from
 */
    static GetAll(Model: Model): ConnectionProperties[];

/**
 * Returns an array of ConnectionProperties objects for all of the flagged *DEFINE_CONNECTION_PROPERTIESs in a model in Primer
 * @param Model Model to get *DEFINE_CONNECTION_PROPERTIESs from
 * @param flag Flag set on the *DEFINE_CONNECTION_PROPERTIESs that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): ConnectionProperties[];

/**
 * Returns the ConnectionProperties object for a *DEFINE_CONNECTION_PROPERTIES ID.
 * @param Model Model to find the *DEFINE_CONNECTION_PROPERTIES in
 * @param number number of the *DEFINE_CONNECTION_PROPERTIES you want the ConnectionProperties object for
 */
    static GetFromID(Model: Model, number: number): ConnectionProperties;

/**
 * Returns the material data at given row in *DEFINE_CONNECTION_PROPERTIES.
 * @param row Material data row number, eg. for first material data, row = 0
 */
    GetMaterialDataLine(row: number): number[];

/**
 * Checks if a ConnectionProperties property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ConnectionProperties.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop *DEFINE_CONNECTION_PROPERTIES property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this *DEFINE_CONNECTION_PROPERTIES Note that a carriage return is not added. See also ConnectionProperties.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the *DEFINE_CONNECTION_PROPERTIES. Note that a carriage return is not added. See also ConnectionProperties.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last *DEFINE_CONNECTION_PROPERTIES in the model.
 * @param Model Model to get last *DEFINE_CONNECTION_PROPERTIES in
 */
    static Last(Model: Model): ConnectionProperties;

/**
 * Returns the last free *DEFINE_CONNECTION_PROPERTIES label in the model. Also see ConnectionProperties.FirstFreeLabel(), ConnectionProperties.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free *DEFINE_CONNECTION_PROPERTIES label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next *DEFINE_CONNECTION_PROPERTIES in the model.
 */
    Next(): ConnectionProperties;

/**
 * Returns the next free (highest+1) *DEFINE_CONNECTION_PROPERTIES label in the model. Also see ConnectionProperties.FirstFreeLabel(), ConnectionProperties.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free *DEFINE_CONNECTION_PROPERTIES label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous *DEFINE_CONNECTION_PROPERTIES in the model.
 */
    Previous(): ConnectionProperties;

/**
 * Allows user to remove material data line in *DEFINE_CONNECTION_PROPERTIES.
 * @param row Material data row number, eg. for first material data, row = 0
 */
    RemoveMaterialDataLine(row: number): void;

/**
 * Renumbers all of the *DEFINE_CONNECTION_PROPERTIESs in the model.
 * @param Model Model that all *DEFINE_CONNECTION_PROPERTIESs will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged *DEFINE_CONNECTION_PROPERTIESs in the model.
 * @param Model Model that all the flagged *DEFINE_CONNECTION_PROPERTIESs will be renumbered in
 * @param flag Flag set on the *DEFINE_CONNECTION_PROPERTIESs that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select *DEFINE_CONNECTION_PROPERTIESs using standard PRIMER object menus.
 * @param flag Flag to use when selecting *DEFINE_CONNECTION_PROPERTIESs
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only *DEFINE_CONNECTION_PROPERTIESs from that model can be selected. If the argument is a Flag then only *DEFINE_CONNECTION_PROPERTIESs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any *DEFINE_CONNECTION_PROPERTIESs can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the *DEFINE_CONNECTION_PROPERTIES.
 * @param flag Flag to set on the *DEFINE_CONNECTION_PROPERTIES
 */
    SetFlag(flag: number): void;

/**
 * Allows user to set fields for material data line at given row in *DEFINE_CONNECTION_PROPERTIES.
 * @param row Material data row number, eg. for first material data, row = 0
 * @param mid Material ID
 * @param sigy Default yield stress
 * @param etan Default tangent modulus
 * @param dg_pr Default damage parameter
 * @param rank Default rank value
 * @param sn Default normal strength
 * @param sb Default bending strength
 * @param ss Default shear strength
 * @param exsn Default normal stress exponent
 * @param exsb Default bending stress exponent
 * @param exss Default shear stress exponent
 * @param lcsn Default LC of normal stress scale factor wrt strain rate
 * @param lcsb Default LC of bending stress scale factor wrt strain rate
 * @param lcss Default LC of shear stress scale factor wrt strain rate
 * @param gfad Default fading energy
 * @param sclmrr Default scaling factor for torsional moment in failure function
 */
    SetMaterialDataLine(row: number, mid: number, sigy?: number, etan?: number, dg_pr?: number, rank?: number, sn?: number, sb?: number, ss?: number, exsn?: number, exsb?: number, exss?: number, lcsn?: number, lcsb?: number, lcss?: number, gfad?: number, sclmrr?: number): void;

/**
 * Returns the total number of *DEFINE_CONNECTION_PROPERTIESs in the model.
 * @param Model Model to get total for
 * @param exists true if only existing *DEFINE_CONNECTION_PROPERTIESs should be counted. If false or omitted referenced but undefined *DEFINE_CONNECTION_PROPERTIESs will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the *DEFINE_CONNECTION_PROPERTIESs in the model.
 * @param Model Model that the defined flag for all *DEFINE_CONNECTION_PROPERTIESs will be unset in
 * @param flag Flag to unset on the *DEFINE_CONNECTION_PROPERTIESs
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): ConnectionProperties;

/**
 * Adds a warning for *DEFINE_CONNECTION_PROPERTIES. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this *DEFINE_CONNECTION_PROPERTIES.
 */
    Xrefs(): Xrefs;

/**
 * Create a new  *DEFINE_CONNECTION_PROPERTIES object.
 * @param Model Model that *DEFINE_CONNECTION_PROPERTIES will be created in
 * @param con_id *DEFINE_CONNECTION_PROPERTIES id.
 * @param heading Title for the *DEFINE_CONNECTION_PROPERTIES
 */
    constructor(Model: Model, con_id: number, heading?: string);

/**
 * Creates a string containing the connection_properties data in keyword format. Note that this contains the keyword header and the keyword cards. See also ConnectionProperties.Keyword() and ConnectionProperties.KeywordCards().
 */
    toString(): string;

/** To _ADD case's parent definition */
    add: number;
/** Area equation number. */
    areaeq: number;
/** *DEFINE_CONNECTION_PROPERTIES id. */
    con_id: number;
/** Default damage parameter. */
    d_dg_pr: number;
/** Default damage parameter(function if proprul == 2). */
    d_dg_prf: number;
/** Default tangent modulus. */
    d_etan: number;
/** Default tangent modulus(function if proprul == 2). */
    d_etanf: number;
/** Default bending stress exponent. */
    d_exsb: number;
/** Default bending stress exponent(function if proprul == 2). */
    d_exsbf: number;
/** Default normal stress exponent. */
    d_exsn: number;
/** Default normal stress exponent(function if proprul == 2). */
    d_exsnf: number;
/** Default shear stress exponent. */
    d_exss: number;
/** Default shear stress exponent(function if proprul == 2). */
    d_exssf: number;
/** Default fading energy. */
    d_gfad: number;
/** Default fading energy(function if proprul == 2). */
    d_gfadf: number;
/** Default LC of bending stress scale factor wrt strain rate. */
    d_lcsb: number;
/** Default LC of normal stress scale factor wrt strain rate. */
    d_lcsn: number;
/** Default LC of shear stress scale factor wrt strain rate. */
    d_lcss: number;
/** Default rank value. */
    d_rank: number;
/** Default bending strength. */
    d_sb: number;
/** Default bending strength(function if proprul == 2). */
    d_sbf: number;
/** Default scaling factor for torsional moment in failure function. */
    d_sclmrr: number;
/** Default yield stress. */
    d_sigy: number;
/** Default yield stress(function if proprul == 2). */
    d_sigyf: number;
/** Default normal strength. */
    d_sn: number;
/** Default normal strength(function if proprul == 2). */
    d_snf: number;
/** Default shear strength. */
    d_ss: number;
/** Default shear strength(function if proprul == 2). */
    d_ssf: number;
/** Damage type. */
    dg_typ: number;
/** true if *DEFINE_CONNECTION_PROPERTIES exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The title of the *DEFINE_CONNECTION_PROPERTIES or the empty string if _TITLE is not set */
    heading: string;
/** The Include file number that the *DEFINE_CONNECTION_PROPERTIES is in. */
    include: number;
/** Modelled area flag. */
    moarfl: number;
/** The Model number that the *DEFINE_CONNECTION_PROPERTIES is in. */
    model: number;
/** Property rule number. */
    proprul: number;
}

declare class ConstructionStages {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the *DEFINE_CONSTRUCTION_STAGES.
 * @param flag Flag to clear on the *DEFINE_CONSTRUCTION_STAGES
 */
    ClearFlag(flag: number): void;

/**
 * Copies the *DEFINE_CONSTRUCTION_STAGES.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): ConstructionStages;

/**
 * Starts an interactive editing panel to create a *DEFINE_CONSTRUCTION_STAGES.
 * @param Model Model that the *DEFINE_CONSTRUCTION_STAGES will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): ConstructionStages;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for *DEFINE_CONSTRUCTION_STAGES. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first *DEFINE_CONSTRUCTION_STAGES in the model.
 * @param Model Model to get first *DEFINE_CONSTRUCTION_STAGES in
 */
    static First(Model: Model): ConstructionStages;

/**
 * Returns the first free *DEFINE_CONSTRUCTION_STAGES label in the model. Also see ConstructionStages.LastFreeLabel(), ConstructionStages.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free *DEFINE_CONSTRUCTION_STAGES label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the *DEFINE_CONSTRUCTION_STAGESs in the model with a defined flag.
 * @param Model Model that all *DEFINE_CONSTRUCTION_STAGESs will be flagged in
 * @param flag Flag to set on the *DEFINE_CONSTRUCTION_STAGESs
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the *DEFINE_CONSTRUCTION_STAGES is flagged or not.
 * @param flag Flag to test on the *DEFINE_CONSTRUCTION_STAGES
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each *DEFINE_CONSTRUCTION_STAGES in the model. Note that ForEach has been designed to make looping over *DEFINE_CONSTRUCTION_STAGESs as fast as possible and so has some limitations. Firstly, a single temporary ConstructionStages object is created and on each function call it is updated with the current *DEFINE_CONSTRUCTION_STAGES data. This means that you should not try to store the ConstructionStages object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new *DEFINE_CONSTRUCTION_STAGESs inside a ForEach loop. 
 * @param Model Model that all *DEFINE_CONSTRUCTION_STAGESs are in
 * @param func Function to call for each *DEFINE_CONSTRUCTION_STAGES
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of ConstructionStages objects for all of the *DEFINE_CONSTRUCTION_STAGESs in a model in Primer
 * @param Model Model to get *DEFINE_CONSTRUCTION_STAGESs from
 */
    static GetAll(Model: Model): ConstructionStages[];

/**
 * Returns an array of ConstructionStages objects for all of the flagged *DEFINE_CONSTRUCTION_STAGESs in a model in Primer
 * @param Model Model to get *DEFINE_CONSTRUCTION_STAGESs from
 * @param flag Flag set on the *DEFINE_CONSTRUCTION_STAGESs that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): ConstructionStages[];

/**
 * Returns the ConstructionStages object for a *DEFINE_CONSTRUCTION_STAGES ID.
 * @param Model Model to find the *DEFINE_CONSTRUCTION_STAGES in
 * @param number number of the *DEFINE_CONSTRUCTION_STAGES you want the ConstructionStages object for
 */
    static GetFromID(Model: Model, number: number): ConstructionStages;

/**
 * Checks if a ConstructionStages property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ConstructionStages.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop *DEFINE_CONSTRUCTION_STAGES property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this *DEFINE_CONSTRUCTION_STAGES. Note that a carriage return is not added. See also ConstructionStages.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the *DEFINE_CONSTRUCTION_STAGES. Note that a carriage return is not added. See also ConstructionStages.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last *DEFINE_CONSTRUCTION_STAGES in the model.
 * @param Model Model to get last *DEFINE_CONSTRUCTION_STAGES in
 */
    static Last(Model: Model): ConstructionStages;

/**
 * Returns the last free *DEFINE_CONSTRUCTION_STAGES label in the model. Also see ConstructionStages.FirstFreeLabel(), ConstructionStages.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free *DEFINE_CONSTRUCTION_STAGES label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next *DEFINE_CONSTRUCTION_STAGES in the model.
 */
    Next(): ConstructionStages;

/**
 * Returns the next free (highest+1) *DEFINE_CONSTRUCTION_STAGES label in the model. Also see ConstructionStages.FirstFreeLabel(), ConstructionStages.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free *DEFINE_CONSTRUCTION_STAGES label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous *DEFINE_CONSTRUCTION_STAGES in the model.
 */
    Previous(): ConstructionStages;

/**
 * Renumbers all of the *DEFINE_CONSTRUCTION_STAGESs in the model.
 * @param Model Model that all *DEFINE_CONSTRUCTION_STAGESs will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged *DEFINE_CONSTRUCTION_STAGESs in the model.
 * @param Model Model that all the flagged *DEFINE_CONSTRUCTION_STAGESs will be renumbered in
 * @param flag Flag set on the *DEFINE_CONSTRUCTION_STAGESs that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select *DEFINE_CONSTRUCTION_STAGESs using standard PRIMER object menus.
 * @param flag Flag to use when selecting *DEFINE_CONSTRUCTION_STAGESs
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only *DEFINE_CONSTRUCTION_STAGESs from that model can be selected. If the argument is a Flag then only *DEFINE_CONSTRUCTION_STAGESs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any *DEFINE_CONSTRUCTION_STAGESs can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the *DEFINE_CONSTRUCTION_STAGES.
 * @param flag Flag to set on the *DEFINE_CONSTRUCTION_STAGES
 */
    SetFlag(flag: number): void;

/**
 * Returns the total number of *DEFINE_CONSTRUCTION_STAGESs in the model.
 * @param Model Model to get total for
 * @param exists true if only existing *DEFINE_CONSTRUCTION_STAGESs should be counted. If false or omitted referenced but undefined *DEFINE_CONSTRUCTION_STAGESs will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the *DEFINE_CONSTRUCTION_STAGESs in the model.
 * @param Model Model that the defined flag for all *DEFINE_CONSTRUCTION_STAGESs will be unset in
 * @param flag Flag to unset on the *DEFINE_CONSTRUCTION_STAGESs
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): ConstructionStages;

/**
 * Adds a warning for *DEFINE_CONSTRUCTION_STAGES. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this *DEFINE_CONSTRUCTION_STAGES.
 */
    Xrefs(): Xrefs;

/**
 * Create a new ConstructionStages object.
 * @param Model Model that *DEFINE_CONSTRUCTION_STAGES will be created in
 * @param Stage_ID ConstructionStages id.
 * @param heading Title for the *DEFINE_CONSTRUCTION_STAGES
 */
    constructor(Model: Model, Stage_ID: number, heading?: string);

/**
 * Creates a string containing the construction stages data in keyword format. Note that this contains the keyword header and the keyword cards. See also ConstructionStages.Keyword() and ConstructionStages.KeywordCards().
 */
    toString(): string;

/** Analysis time at end of stage. */
    ate: number;
/** Analysis time duration of stage. */
    atr: number;
/** Analysis time at start of stage. */
    ats: number;
/** true if *DEFINE_CONSTRUCTION_STAGES exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The title of the *DEFINE_CONSTRUCTION_STAGES or the empty string if _TITLE is not set */
    heading: string;
/** The Include file number that the *DEFINE_CONSTRUCTION_STAGES is in. */
    include: number;
/** ConstructionStages number. The label is an alternative name for this. */
    istage: number;
/** Flag to set velocities to zero at start of stage. */
    ivel0: number;
/** ConstructionStages number. The istage is an alternative name for this. */
    label: number;
/** The Model number that the *DEFINE_CONSTRUCTION_STAGES is in. */
    model: number;
/** Real time at end of stage. */
    rte: number;
/** Real time at start of stage. */
    rts: number;
}


/** Object returned by Interactions */
interface InteractionsReturn {
    /** End coordinate of intersection line (for Contact.CROSSED_EDGES) */
    end: number[];
    /** Node 1 of master segment (for Contact.PENETRATIONS) */
    n1: Node;
    /** Node 2 of master segment (for Contact.PENETRATIONS) */
    n2: Node;
    /** Node 3 of master segment (for Contact.PENETRATIONS) */
    n3: Node;
    /** Node 4 of master segment (for Contact.PENETRATIONS) */
    n4: Node;
    /** Penetrating node (for Contact.PENETRATIONS) */
    node: Node;
    /** Depth of penetration (for Contact.PENETRATIONS) */
    pen: number;
    /** Remaining thickness ratio (for Contact.PENETRATIONS) */
    qthick: number;
    /** Remaining unpenetrated thickness (for Contact.PENETRATIONS) */
    rthick: number;
    /** s parametric coordinate of the slave node projected onto the shell (for Contact.PENETRATIONS) */
    s: number;
    /** Penetrated shell (for Contact.PENETRATIONS) */
    shell: Shell;
    /** First segment if shell (for Contact.CROSSED_EDGES) */
    shell1: Shell;
    /** Second segment if shell (for Contact.CROSSED_EDGES) */
    shell2: Shell;
    /** Penetrated solid (for Contact.PENETRATIONS) */
    solid: Solid;
    /** First segment if solid (for Contact.CROSSED_EDGES) */
    solid1: Solid;
    /** Second segment if solid (for Contact.CROSSED_EDGES) */
    solid2: Solid;
    /** Start coordinate of intersection line (for Contact.CROSSED_EDGES) */
    start: number[];
    /** t parametric coordinate of the slave node projected onto the shell (for Contact.PENETRATIONS) */
    t: number;
    /** Thickness of contact segment, i.e. 0.5*(t1+t2) (for Contact.PENETRATIONS) */
    thick: number;
    /** Penetrated thick shell (for Contact.PENETRATIONS) */
    thickshell: Tshell;
    /** First segment if thick shell (for Contact.CROSSED_EDGES) */
    thickshell1: Tshell;
    /** Second segment if thick shell (for Contact.CROSSED_EDGES) */
    thickshell2: Tshell;
    /** The interaction type. Either Contact.PENETRATIONS or Contact.CROSSED_EDGES. */
    type: number;
}

declare class Contact {
/**
 * Blanks the contact
 */
    Blank(): void;

/**
 * Blanks all of the contacts in the model.
 * @param Model Model that all contacts will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged contacts in the model.
 * @param Model Model that all the flagged contacts will be blanked in
 * @param flag Flag set on the contacts that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the contact is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the contact.
 * @param flag Flag to clear on the contact
 */
    ClearFlag(flag: number): void;

/**
 * see if tied/spotweld contact uses constrained formulation
 * @param connection if true will only consider conntacts used for primer connections
 */
    Constrained(connection: boolean): boolean;

/**
 * Copies the contact.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Contact;

/**
 * Starts an interactive editing panel to create a contact.
 * @param Model Model that the contact will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Contact;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for contact. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first contact in the model.
 * @param Model Model to get first contact in
 */
    static First(Model: Model): Contact;

/**
 * Returns the first free contact label in the model. Also see Contact.LastFreeLabel(), Contact.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free contact label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the contacts in the model with a defined flag.
 * @param Model Model that all contacts will be flagged in
 * @param flag Flag to set on the contacts
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the contact is flagged or not.
 * @param flag Flag to test on the contact
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each contact in the model. Note that ForEach has been designed to make looping over contacts as fast as possible and so has some limitations. Firstly, a single temporary Contact object is created and on each function call it is updated with the current contact data. This means that you should not try to store the Contact object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new contacts inside a ForEach loop. 
 * @param Model Model that all contacts are in
 * @param func Function to call for each contact
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Contact objects for all of the contacts in a model in Primer
 * @param Model Model to get contacts from
 */
    static GetAll(Model: Model): Contact[];

/**
 * Returns an array of Contact objects for all of the flagged contacts in a model in Primer
 * @param Model Model to get contacts from
 * @param flag Flag set on the contacts that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Contact[];

/**
 * Returns the Contact object for a contact ID.
 * @param Model Model to find the contact in
 * @param number number of the contact you want the Contact object for
 */
    static GetFromID(Model: Model, number: number): Contact;

/**
 * Checks if a Contact property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Contact.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop contact property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns an array of objects describing the interactions which can either be penetrations (slave nodes that are tied to or penetrate elements in the contact) or crossed edges (contact segments that cross).
 * @param type What type of interactions to return. Can be bitwise code of Contact.PENETRATIONS to return penetrations and Contact.CROSSED_EDGES to return crossed edges. If omitted penetrations will be returned.
 */
    Interactions(type?: number): InteractionsReturn[];

/**
 * Returns the keyword for this Contact (*BOUNDARY_PRESCRIBED_MOTION_xxxx). Note that a carriage return is not added. See also Contact.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the Contact. Note that a carriage return is not added. See also Contact.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last contact in the model.
 * @param Model Model to get last contact in
 */
    static Last(Model: Model): Contact;

/**
 * Returns the last free contact label in the model. Also see Contact.FirstFreeLabel(), Contact.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free contact label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next contact in the model.
 */
    Next(): Contact;

/**
 * Returns the next free (highest+1) contact label in the model. Also see Contact.FirstFreeLabel(), Contact.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free contact label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags nodes that penetrate (or tie) in contact
 * @param flag Flag to be set on penetrating (or tied) node.
 * @param eflag Optional flag for elements. If supplied, node will be flagged only if it penetrates (or ties to) an element that is flagged. Node and element flag may be the same.
 */
    PenCheck(flag: number, eflag: number): number;

/**
 * launches the interactive edit panel for penetration check on the con
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 * @param check_mode Check mode. Can be Model.MPP_MODE or Model.SMP_MODE. Default is set to the oa pref contact_check_mode
 * @param mpp_threshold Can set the MPP threshold, by default this is set to the oa pref contact_mpp_penetration_threshold
 * @param report_crossed_3d_elems Can set the value of reporting crossed elements to TRUE or FALSE, by default this is set to the oa pref report_crossed_3d_elems
 * @param contact_penchk_dup_shells Duplicate shell treatment Can be Model.SHELL_AUTO, Model.SHELL_THICK or Model.SHELL_THIN. Default is set to the oa pref contact_penchk_dup_shells
 */
    PenCheckEdit(modal?: boolean, check_mode?: number, mpp_threshold?: number, report_crossed_3d_elems?: boolean, contact_penchk_dup_shells?: number): void;

/**
 * Allows the user to pick a contact.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only contacts from that model can be picked. If the argument is a Flag then only contacts that are flagged with limit can be selected. If omitted, or null, any contacts from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Contact;

/**
 * Returns the previous contact in the model.
 */
    Previous(): Contact;

/**
 * Renumbers all of the contacts in the model.
 * @param Model Model that all contacts will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged contacts in the model.
 * @param Model Model that all the flagged contacts will be renumbered in
 * @param flag Flag set on the contacts that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select contacts using standard PRIMER object menus.
 * @param flag Flag to use when selecting contacts
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only contacts from that model can be selected. If the argument is a Flag then only contacts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any contacts can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the contact.
 * @param flag Flag to set on the contact
 */
    SetFlag(flag: number): void;

/**
 * Sketches the contact. The contact will be sketched until you either call Contact.Unsketch(), Contact.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the contact is sketched. If omitted redraw is true. If you want to sketch several contacts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged contacts in the model. The contacts will be sketched until you either call Contact.Unsketch(), Contact.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged contacts will be sketched in
 * @param flag Flag set on the contacts that you want to sketch
 * @param redraw If model should be redrawn or not after the contacts are sketched. If omitted redraw is true. If you want to sketch flagged contacts several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks sliding contact for crossed edges and penetrations
 */
    StatusCheck(): number[];

/**
 * Returns the total number of contacts in the model.
 * @param Model Model to get total for
 * @param exists true if only existing contacts should be counted. If false or omitted referenced but undefined contacts will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the contact
 */
    Unblank(): void;

/**
 * Unblanks all of the contacts in the model.
 * @param Model Model that all contacts will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged contacts in the model.
 * @param Model Model that the flagged contacts will be unblanked in
 * @param flag Flag set on the contacts that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the contacts in the model.
 * @param Model Model that the defined flag for all contacts will be unset in
 * @param flag Flag to unset on the contacts
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the contact.
 * @param redraw If model should be redrawn or not after the contact is unsketched. If omitted redraw is true. If you want to unsketch several contacts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all contacts.
 * @param Model Model that all contacts will be unblanked in
 * @param redraw If model should be redrawn or not after the contacts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged contacts in the model.
 * @param Model Model that all contacts will be unsketched in
 * @param flag Flag set on the contacts that you want to unsketch
 * @param redraw If model should be redrawn or not after the contacts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Contact;

/**
 * Adds a warning for contact. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this contact.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Contact object.
 * @param Model Model that Contact will be created in
 * @param type Type of contact
 * @param id Contact number
 * @param heading Title for the Contact
 */
    constructor(Model: Model, type: string, id?: number, heading?: string);

/**
 * Creates a string containing the Contact data in keyword format. Note that this contains the keyword header and the keyword cards. See also Contact.Keyword() and Contact.KeywordCards().
 */
    toString(): string;

/** Loadcurve ID for a */
    a: number;
/** contact algorithm */
    algo: number;
/** Key amplitude parameter A */
    alpha: number;
/** Loadcurve ID for b */
    b: number;
/** boundary condition flag */
    bc_flg: number;
/** Key amplitude parameter B */
    beta: number;
/** Loadcurve for #cycles between bucket sorts */
    bsort: number;
/** Contact birth time */
    bt: number;
/** Bucket sorting frequency */
    bucket: number;
/** Loadcurve ID for c */
    c: number;
/** Checking mode on the pen check edit panel. (Can be Contact.MPP_METHOD, Contact.MPP_METHOD or Contact.SMP_METHOD) */
    check_mode: number;
/** Special check for inverted elements */
    chksegs: number;
/** Contact number (identical to label. */
    cid: number;
/** Coordinate system ID to output rcforc force resultants and ncforc data in a local system */
    cid_rcf: number;
/** Curve ID for the viscosity */
    cideta: number;
/** Curve ID for the coefficient of friction */
    cidmu: number;
/** Surface closeness parameter */
    close: number;
/** Normal stiffness */
    cn: number;
/** Normal stiffness */
    cn_1: number;
/** Shell treatment on the pen check edit panel. (Can be Contact.SHELL_AUTO, Contact.SHELL_AUTO or Contact.SHELL_THIN or Contact.SHELL_THICK) */
    contact_penchk_dup_shells: number;
/** Exclude beam to beam contact flag */
    cparm8: number;
/** Spotweld beam flag for SMP */
    cparm8smp: number;
/** Ratio of tangential stiffness to normal stiffness */
    ct2cn: number;
/** Ratio of tangential to normal stiff */
    ct2cn_1: number;
/** Loadcurve ID for d */
    d: number;
/** Composite film thickness */
    d_comp: number;
/** Draw bead depth */
    dbdth: number;
/** 2dbinr - Flag to include 2d belt elements in contact (note properties cannot start with a number, so 2 has been removed). */
    dbinr: number;
/** optional Part ID */
    dbpid: number;
/** Exponential decay coeff */
    dc: number;
/** Loadcurve for search depth in automatic contact */
    depth: number;
/** Scale factor on lcidrf */
    dfscl: number;
/** Distance for nonlinear force scaling */
    dnlscl: number;
/** Depth of penetration reduction factor */
    dprfac: number;
/** Contact death time */
    dt: number;
/** Time interval between penetration reports */
    dtpchk: number;
/** Timestep used in stiffness calc */
    dtstif: number;
/** optional element id offset */
    eloff: number;
/** Normal energy release rate used in damage calculation */
    eraten: number;
/** Shear energy release rate used in damage calculation */
    erates: number;
/** Erosion/interior node option */
    erosop: number;
/** true if contact exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Force calculation method */
    fcm: number;
/** Dynamic coeff of friction */
    fd: number;
/** Angle tolerance in radians for feature lines option in smooth contact */
    flangl: number;
/** Scale factor for nonlinear force scaling */
    fnlscl: number;
/** formula id */
    formula: number;
/** Radiation conductance across gap */
    frad: number;
/** #cycles between penalty force updates */
    frcfrq: number;
/** Scale factor for frictional stiffness */
    fricsf: number;
/** Static coeff of friction */
    fs: number;
/** Coulomb friction scale factor */
    fsf: number;
/** Tolerance for determining flat segments. */
    fstol: number;
/** Beam torsional force computation flag */
    ftorq: number;
/** Fraction of sliding friction energy partitioned to slave surface */
    ftoslv: number;
/** Experimental contact algorithm */
    grpable: number;
/** Heat transfer coefficient */
    h0: number;
/** Thermal contact conductivity */
    hclose: number;
/** Contact heading */
    heading: string;
/** Segment searching option */
    i2d3d: number;
/** Adjacent matl treatment for solids */
    iadj: number;
/** coefficient of restitution expressed as a percentage */
    icor: number;
/** true if _ID option is set, false if not */
    id: boolean;
/** Implicit convergence flag */
    igap: number;
/** Ignore initial pens in automatic types */
    ignore: number;
/** Flag to ignore the thickness offset for shells in the calculation of the shell contact penetration depth. */
    ignroff: number;
/** The Include file number that the contact is in. */
    include: number;
/** Number of iterations for initial penetration checking */
    inititer: number;
/** Create backup penalty tied contact */
    ipback: number;
/** Symmetry plane option */
    isym: number;
/** Symmetry plane option */
    isym_1: number;
/** Conductivity of gap fluid */
    k: number;
/** Kinematic partition factor */
    kpf: number;
/** Contact number. */
    label: number;
/** Bucket sorting frequency loadcurve ID */
    lcbucket: number;
/** Loadcurve ID for plastic strain vs. parametric coord */
    lceps: number;
/** Loadcurve ID for plastic strain vs. parametric coord (elements moved &gt; offset) */
    lceps2: number;
/** Loadcurve ID for dynamic friction vs. temp */
    lcfdt: number;
/** Loadcurve ID for static friction vs. temp */
    lcfst: number;
/** Loadcurve ID for lch */
    lch: number;
/** Loadcurve ID for Force vs penetration curve */
    lcid: number;
/** Loadcurve ID for Dyn rel stiffness */
    lcid1: number;
/** Loadcurve ID for Transient stiffness */
    lcid2: number;
/** Loadcurve ID for airbag thickness vs time */
    lcidab: number;
/** Loadcurve ID for Normal force per unit length */
    lcidnf: number;
/** Loadcurve ID for Force due to bending per unit length */
    lcidrf: number;
/** Max size for thermal contact */
    lmax: number;
/** Critical gap size */
    lmin: number;
/** Max parametric coord overlap */
    maxpar: number;
/** Master box id */
    mboxid: number;
/** Shear force exponent */
    mes: number;
/** The Model number that the contact is in. */
    model: number;
/** true if _MPP option is set, false if not */
    mpp: boolean;
/** Master side printout flag */
    mpr: number;
/** Master set id */
    msid: number;
/** Optional master side shell thickness */
    mst: number;
/** Master set type */
    mstyp: number;
/** The method option for the gap function */
    mtcj: number;
/** Normal force exponent */
    nen: number;
/** Normal failure stress */
    nfls: number;
/** Number of history variables */
    nhv: number;
/** Number of material history variables */
    nmhis: number;
/** Number of segments to track per slave node */
    ns2track: number;
/** Number of user tied weld parameters */
    ntprm: number;
/** #int points along drawbead */
    numint: number;
/** Flag for offset treatment. This is only valid for *CONTACT_AUTOMATIC(_ONE_WAY)_SURFACE_TO_SURFACE_TIEBREAK_USER and should not be confused with the 'offset' property for other contact types. */
    offset: number;
/** distance offset */
    offset_1: number;
/** _OFFSET option. (Can be Contact.NO_OFFSET, Contact.SIMPLE_OFFSET, Contact.CONSTR_OFFSET or Contact.BEAM_OFFSET) */
    offset_flag: number;
/** Response option */
    option: number;
/** User tiebreak type */
    option_1: number;
/** Critical distance */
    param: number;
/** The parametric extension distance for contact segments */
    parmax: number;
/** Penetration search flag */
    penchk: number;
/** Max pen distance for "old" types 3, 5, 10 */
    penmax: number;
/** Ignore penetration scale factor */
    pensf: number;
/** Flag to choose the method for calculating the penalty stiffness */
    pstiff: number;
/** Split quads into 2 trias */
    q2tri: number;
/** Region to limit contact volume */
    region: number;
/** segment based contact option */
    sbopt: number;
/** Slave box id */
    sboxid: number;
/** Shear failure stress */
    sfls: number;
/** Scale factor on master penalty stiffness */
    sfm: number;
/** Scale factor on true master shell thickness */
    sfmt: number;
/** Scale factor for neighbour segment contact */
    sfnbr: number;
/** Scale factor on slave penalty stiffness */
    sfs: number;
/** Scale factor on true slave shell thickness */
    sfst: number;
/** Shared constraint flag */
    sharec: number;
/** Edge shape for shells when measuring penetration */
    shledg: number;
/** Thickness consideration flag */
    shlthk: number;
/** Optional solid stiffness */
    sldstf: number;
/** Optional solid thickness */
    sldthk: number;
/** Shooting node logic flag */
    snlog: number;
/** Soft constraint scale factor */
    sofscl: number;
/** Soft constraint flag */
    soft: number;
/** Slave side printout flag */
    spr: number;
/** Flag for non-extended exterior shell edges */
    srnde: number;
/** Slave set id */
    ssid: number;
/** Optional slave side shell thickness */
    sst: number;
/** Slave set type */
    sstyp: number;
/** Loadcurve ID for stress vs gap post failure */
    tblcid: number;
/** Segment treatment only flag */
    tcso: number;
/** Minimum temperature required. */
    temp: number;
/** Tensile traction for failure */
    tfail: number;
/** If _THERMAL option is set. Can be true or false */
    thermal: boolean;
/** flag for thickness offset */
    thkoff: number;
/** Thickness option for "old" types 3, 5, 10 */
    thkopt: number;
/** Incremental displacement update for tied contacts */
    tiedid: number;
/**  */
    tscale: number;
/** X component of the free sliding direction T */
    tsvx: number;
/** Y component of the free sliding direction T */
    tsvy: number;
/** Z component of the free sliding direction T */
    tsvz: number;
/** Contact type ("AUTOMATIC_GENERAL", "SINGLE_SURFACE" etc). */
    type: string;
/** User parameter */
    up1: number;
/** User parameter */
    up10: number;
/** User parameter */
    up11: number;
/** User parameter */
    up12: number;
/** User parameter */
    up13: number;
/** User parameter */
    up14: number;
/** User parameter */
    up15: number;
/** User parameter */
    up16: number;
/** User parameter */
    up2: number;
/** User parameter */
    up3: number;
/** User parameter */
    up4: number;
/** User parameter */
    up5: number;
/** User parameter */
    up6: number;
/** User parameter */
    up7: number;
/** User parameter */
    up8: number;
/** User parameter */
    up9: number;
/** Optional unloading stiffness */
    us: number;
/** Coeff for viscous friction */
    vc: number;
/** Visous damping coefficient */
    vdc: number;
/** Viscous friction scale factor */
    vsf: number;
/** Adds _BEAM_OFFSET option */
    static BEAM_OFFSET: number;
/** Adds _CONSTRAINED_OFFSET option */
    static CONSTR_OFFSET: number;
/** Return crossed edges in Contact.Interactions() */
    static CROSSED_EDGES: number;
/** Launches the penetration edit panel with the MPP methodology turned on */
    static MPP_METHOD: number;
/** MPP penetration check mode */
    static MPP_MODE: number;
/** No offset option added. */
    static NO_OFFSET: number;
/** Return penetrations in Contact.Interactions() */
    static PENETRATIONS: number;
/** Launches the penetration edit panel with Automatic shell treatment of duplicate shells. */
    static SHELL_AUTO: number;
/** Launches the penetration edit panel with the thickest always option for duplicate shells. */
    static SHELL_THICK: number;
/** Launches the penetration edit panel with the thinnest always option for duplicate shells. */
    static SHELL_THIN: number;
/** Adds _OFFSET option */
    static SIMPLE_OFFSET: number;
/** Launches the penetration edit panel with the SMP methodology turned on */
    static SMP_METHOD: number;
/** SMP penetration check mode */
    static SMP_MODE: number;
}

declare class ContactGuidedCable {
/**
 * Blanks the contact guided_cable
 */
    Blank(): void;

/**
 * Blanks all of the contact guided_cables in the model.
 * @param Model Model that all contact guided_cables will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged contact guided_cables in the model.
 * @param Model Model that all the flagged contact guided_cables will be blanked in
 * @param flag Flag set on the contact guided_cables that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the contact guided_cable is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the contact guided_cable.
 * @param flag Flag to clear on the contact guided_cable
 */
    ClearFlag(flag: number): void;

/**
 * Copies the contact guided_cable.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): ContactGuidedCable;

/**
 * Adds an error for contact guided_cable. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first contact guided_cable in the model.
 * @param Model Model to get first contact guided_cable in
 */
    static First(Model: Model): ContactGuidedCable;

/**
 * Returns the first free contact guided_cable label in the model. Also see ContactGuidedCable.LastFreeLabel(), ContactGuidedCable.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free contact guided_cable label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the contact guided_cables in the model with a defined flag.
 * @param Model Model that all contact guided_cables will be flagged in
 * @param flag Flag to set on the contact guided_cables
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the contact guided_cable is flagged or not.
 * @param flag Flag to test on the contact guided_cable
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each contact guided_cable in the model. Note that ForEach has been designed to make looping over contact guided_cables as fast as possible and so has some limitations. Firstly, a single temporary ContactGuidedCable object is created and on each function call it is updated with the current contact guided_cable data. This means that you should not try to store the ContactGuidedCable object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new contact guided_cables inside a ForEach loop. 
 * @param Model Model that all contact guided_cables are in
 * @param func Function to call for each contact guided_cable
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of ContactGuidedCable objects for all of the contact guided_cables in a model in Primer
 * @param Model Model to get contact guided_cables from
 */
    static GetAll(Model: Model): ContactGuidedCable[];

/**
 * Returns an array of ContactGuidedCable objects for all of the flagged contact guided_cables in a model in Primer
 * @param Model Model to get contact guided_cables from
 * @param flag Flag set on the contact guided_cables that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): ContactGuidedCable[];

/**
 * Returns the ContactGuidedCable object for a contact guided_cable ID.
 * @param Model Model to find the contact guided_cable in
 * @param number number of the contact guided_cable you want the ContactGuidedCable object for
 */
    static GetFromID(Model: Model, number: number): ContactGuidedCable;

/**
 * Checks if a ContactGuidedCable property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ContactGuidedCable.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop contact guided_cable property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this ContactGuidedCable (*contact_guided_cable). Note that a carriage return is not added. See also ContactGuidedCable.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the ContactGuidedCable. Note that a carriage return is not added. See also ContactGuidedCable.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last contact guided_cable in the model.
 * @param Model Model to get last contact guided_cable in
 */
    static Last(Model: Model): ContactGuidedCable;

/**
 * Returns the last free contact guided_cable label in the model. Also see ContactGuidedCable.FirstFreeLabel(), ContactGuidedCable.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free contact guided_cable label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next contact guided_cable in the model.
 */
    Next(): ContactGuidedCable;

/**
 * Returns the next free (highest+1) contact guided_cable label in the model. Also see ContactGuidedCable.FirstFreeLabel(), ContactGuidedCable.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free contact guided_cable label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a contact guided_cable.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only contact guided_cables from that model can be picked. If the argument is a Flag then only contact guided_cables that are flagged with limit can be selected. If omitted, or null, any contact guided_cables from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): ContactGuidedCable;

/**
 * Returns the previous contact guided_cable in the model.
 */
    Previous(): ContactGuidedCable;

/**
 * Renumbers all of the contact guided_cables in the model.
 * @param Model Model that all contact guided_cables will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged contact guided_cables in the model.
 * @param Model Model that all the flagged contact guided_cables will be renumbered in
 * @param flag Flag set on the contact guided_cables that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select contact guided_cables using standard PRIMER object menus.
 * @param flag Flag to use when selecting contact guided_cables
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only contact guided_cables from that model can be selected. If the argument is a Flag then only contact guided_cables that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any contact guided_cables can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the contact guided_cable.
 * @param flag Flag to set on the contact guided_cable
 */
    SetFlag(flag: number): void;

/**
 * Sketches the contact guided_cable. The contact guided_cable will be sketched until you either call ContactGuidedCable.Unsketch(), ContactGuidedCable.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the contact guided_cable is sketched. If omitted redraw is true. If you want to sketch several contact guided_cables and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged contact guided_cables in the model. The contact guided_cables will be sketched until you either call ContactGuidedCable.Unsketch(), ContactGuidedCable.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged contact guided_cables will be sketched in
 * @param flag Flag set on the contact guided_cables that you want to sketch
 * @param redraw If model should be redrawn or not after the contact guided_cables are sketched. If omitted redraw is true. If you want to sketch flagged contact guided_cables several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of contact guided_cables in the model.
 * @param Model Model to get total for
 * @param exists true if only existing contact guided_cables should be counted. If false or omitted referenced but undefined contact guided_cables will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the contact guided_cable
 */
    Unblank(): void;

/**
 * Unblanks all of the contact guided_cables in the model.
 * @param Model Model that all contact guided_cables will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged contact guided_cables in the model.
 * @param Model Model that the flagged contact guided_cables will be unblanked in
 * @param flag Flag set on the contact guided_cables that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the contact guided_cables in the model.
 * @param Model Model that the defined flag for all contact guided_cables will be unset in
 * @param flag Flag to unset on the contact guided_cables
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the contact guided_cable.
 * @param redraw If model should be redrawn or not after the contact guided_cable is unsketched. If omitted redraw is true. If you want to unsketch several contact guided_cables and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all contact guided_cables.
 * @param Model Model that all contact guided_cables will be unblanked in
 * @param redraw If model should be redrawn or not after the contact guided_cables are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged contact guided_cables in the model.
 * @param Model Model that all contact guided_cables will be unsketched in
 * @param flag Flag set on the contact guided_cables that you want to unsketch
 * @param redraw If model should be redrawn or not after the contact guided_cables are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): ContactGuidedCable;

/**
 * Adds a warning for contact guided_cable. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this contact guided_cable.
 */
    Xrefs(): Xrefs;

/**
 * Create a new ContactGuidedCable object.
 * @param Model Model that ContactGuidedCable will be created in
 * @param ptype Specify the type of ContactGuidedCable (Can be ContactGuidedCable.PART or ContactGuidedCable.SET_PART
 * @param nsid Node Set ID that guides the 1D elements.
 * @param pid Part ID or Part Set ID
 * @param soft Flag for soft constraint option. Set to 1 for soft constraint.
 * @param ssfac Stiffness scale factor for penalty stiffness value. The default value is unity. This applies to SOFT set to 0 and 1.
 * @param fric Contact friction.
 * @param cid ContactGuidedCable number (Same as label).
 * @param heading ContactGuidedCable heading (Same as title).
 */
    constructor(Model: Model, ptype: number, nsid: number, pid: number, soft?: number, ssfac?: number, fric?: number, cid?: number, heading?: string);

/**
 * Creates a string containing the ContactGuidedCable data in keyword format. Note that this contains the keyword header and the keyword cards. See also ContactGuidedCable.Keyword() and ContactGuidedCable.KeywordCards().
 */
    toString(): string;

/** ContactGuidedCable number. */
    cid: number;
/** true if ContactGuidedCable exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Contact friction. */
    fric: number;
/** ContactGuidedCable heading */
    heading: string;
/** TRUE if _ID option is set, FALSE if not */
    id: boolean;
/** The Include file number that the ContactGuidedCable is in. */
    include: number;
/** The Model number that the contact guided_cable is in. */
    model: number;
/** Node Set ID that guides the 1D elements. */
    nsid: number;
/** Part ID or Part Set ID */
    pid: number;
/** The Contact Part type. Can be ContactGuidedCable.PART or ContactGuidedCable.SET_PART. */
    ptype: number;
/** Flag for soft constraint option. Set to 1 for soft constraint. */
    soft: number;
/** Stiffness scale factor for penalty stiffness value. The default value is unity. This applies to SOFT set to 0 and 1. */
    ssfac: number;
/** CONTACT is *CONTACT_GUIDED_CABLE. */
    static PART: number;
/** CONTACT is *CONTACT_GUIDED_CABLE_SET. */
    static SET_PART: number;
}

declare class Control {
/**
 * Returns the damping coefficient data for an index in *CONTROL_IMPLICIT_MODAL_DYNAMIC_DAMPING.
 * @param index The index you want the data for. Note that indices start at 0, not 1.
 */
    GetCoefficient(index: number): number[];

/**
 * Removes the damping coefficient data for an index in *CONTROL_IMPLICIT_MODAL_DYNAMIC_DAMPING.
 * @param index The index you want to delete damping data for. Note that indices start at 0, not 1.
 */
    RemoveCoefficient(index: number): void;

/**
 * Sets the damping coefficient data for an index in *CONTROL_IMPLICIT_MODAL_DYNAMIC_DAMPING.
 * @param index The index you want to set the data for. Note that indices start at 0, not 1.
 * @param mode_frequency The mode ID (_SPECIFIC) or frequency (_FREQUENCY_RANGE).
 * @param zeta Damping coefficient
 */
    SetCoefficient(index: number, mode_frequency: number, zeta: number): void;

/** Load curve ID for the a coefficient used in the formula */
    a: number;
/** ALE advection factor */
    aafac: number;
/** Terminate based on absolute total displacement in the Euclidean norm. */
    absol: number;
/** absolute convergence tol */
    abstol: number;
/** Absolute convergence tolerance */
    abstol_1: number;
/** gravity */
    accel: number;
/** *CONTROL_ACCURACY card */
    accuracy: object;
/** *CONTROL_ACOUSTIC card */
    acoustic: object;
/** *CONTROL_ADAPSTEP card */
    adapstep: object;
/** *CONTROL_ADAPTIVE card */
    adaptive: object;
/** *CONTROL_ADAPTIVE_CURVE card */
    adaptive_curve: object;
/** Total number of adaptive steps during the forming simulation */
    adatims: number;
/** 1 or 2 pass adaptivity flag */
    adpass: number;
/** Adaptivity error tolerance in degrees for activating fusion */
    adpctl: number;
/** Nodal penetration at which to refine elem */
    adpene: number;
/** Options for recovery techniques and error estimators */
    adperr: number;
/** Time interval between refinements */
    adpfreq: number;
/** Adaptive options */
    adpopt: number;
/** Min element edge size for adaptivity */
    adpsize: number;
/** Absolute shell thickness below which remeshing should begin */
    adpth: number;
/** Adaptive error tolerance (degrees) */
    adptol: number;
/** Smoothing weight factor: simple average */
    afac: number;
/** Pressure of atmospheric air */
    air_p: number;
/** Density of atmospheric air */
    air_ro: number;
/** *CONTROL_AIRBAG card */
    airbag: object;
/** A=Aluminium blank, F=steel */
    al_fe: string;
/** A=Aluminium blank, F=steel */
    al_fe_1: string;
/** *CONTROL_ALE card */
    ale: object;
/** Contact algorithm type */
    algo: number;
/** Composite time integration constant */
    alpha: number;
/** Maximum allowable acceleration */
    amax: number;
/** Maximum allowable acceleration */
    amax_1: number;
/** Flag to turn off printing of pore air analysis status message */
    anamsg: number;
/** contact angle */
    ang: number;
/** Permitted angle between neighbours */
    angle: number;
/** relative influence predictor step */
    arcalf: number;
/** Arc length controlling node ID */
    arcctl: number;
/** Arc length controlling node direction */
    arcdir: number;
/** Arc length damping option */
    arcdmp: number;
/** Arc length size */
    arclen: number;
/** Arc length method */
    arcmth: number;
/** relative influence load/time parameter */
    arcpsi: number;
/** initiation time */
    arctim: number;
/** Analysis type */
    atype: number;
/** Thermal analysis type */
    atype_1: number;
/** AUTOSPC switch */
    autospc: number;
/** AUTOSPC tolerance */
    autotol: number;
/** weight factor */
    awgt: number;
/** Load curve ID for the b coefficient used in the formula */
    b: number;
/** Thermal boundary condition flag */
    bc_flg: number;
/** Method to extract buckling modes */
    bckmth: number;
/** Flag for aligning beam dynamics */
    beamin: number;
/** start time */
    begtim: number;
/** Newmark time integration constant */
    beta: number;
/** Smoothing weight factor: volume weighting */
    bfac: number;
/** flag to set _BINARY option */
    binary: number;
/** birth time */
    birth: number;
/** Part (stype=0) or part set (stype=1) ID for blank */
    blank: number;
/** Part (stype=0) or part set (stype=1) ID that defines the blank */
    blkid: number;
/** beam set for convert to hex assembly */
    bmsid: number;
/** Multi-Material ALE group set if positive or -1 */
    bndflx: number;
/** Part that defines the lower binder */
    bndl: number;
/** Part that defines the upper binder */
    bndu: number;
/** Box limiting application */
    boxid: number;
/** Birth time */
    bt: number;
/** beam bulk viscosity type */
    btype: number;
/** *CONTROL_BULK_VISCOSITY card */
    bulk_viscosity: object;
/** Warping stiffness flag for Belytschko-Tsay shells */
    bwc: number;
/** Load curve ID for the c coefficient used in the formula */
    c: number;
/** dry/wet particle flag */
    cap: number;
/** Birth time for adaptive fusion */
    cbirth: number;
/** Death time for adaptive fusion */
    cdeath: number;
/** Tolerance for output of *DEFINE_CURVE discretization warnings */
    cdetol: number;
/** Centre frequency */
    center: number;
/** Smoothing weight factor: isoparametric */
    cfac: number;
/** Convergence tolerance for iterative solver */
    cgtol: number;
/** Max flange height */
    charlen: number;
/** *CONTROL_CHECK card */
    check: object;
/** Parameter for ALE pressure locking */
    checkr: number;
/** ID of coordinate system (only for the LOCAL option) */
    cid: number;
/** coordinate system id */
    cid_1: number;
/** Limit angle for corner nodes */
    cnla: number;
/** Consistent tangent stiffness flag */
    cnstn: number;
/** include shell ref surface offset */
    cntco: number;
/** *CONTROL_COARSEN card */
    coarsen: object;
/** Number of coefficients for SPECIFIC and FREQUENCY_RANGE options */
    coefficients: number;
/** damping factor */
    conmax: number;
/** Consistency (Accuracy) flag */
    consty: number;
/** Particle approx method */
    cont: number;
/** *CONTROL_CONTACT card */
    contact: object;
/** conduction factor */
    conv: number;
/** *CONTROL_COUPLING card */
    coupling: object;
/** Heat Capacity. Constant float value if CPTYP = 0,  Curve ID if CPTYP = 1. */
    cp: number;
/** Contact penetration check flag */
    cpchk: number;
/** *CONTROL_CPM card */
    cpm: object;
/** Disable/enable error checking */
    cpmerr: number;
/** Flag to consider airbag system velocity */
    cpmmf: number;
/** Type of CP. Valid values: 0-Constant, 1-Temperature vs Heat Capacity Curve. */
    cptyp: number;
/** *CONTROL_CPU card */
    cpu: object;
/** Max permitted cpu time */
    cputim: number;
/** Coord sys for type 6 element */
    cstyp6: number;
/** Element cost scale factor for element in contact */
    cweight: number;
/** X component of centre of most-bent location */
    cx: number;
/** Y component of centre of most-bent location */
    cy: number;
/** Z component of centre of most-bent location */
    cz: number;
/** Explicit accuracy parameter */
    d: number;
/** D3ITER database control */
    d3itctl: number;
/** Number of output states in the D3PLOT database */
    d3plot: number;
/** Number of output states in the D3PLOT database */
    d3plt: number;
/** Flag for writing out d3plot state */
    d3trace: number;
/** Modal damping coefficient */
    dampf: number;
/** Z elevation of datum */
    datum: number;
/** Exponential decay coefficient */
    dc: number;
/** Divergence control parameter */
    dcp: number;
/** Default continuum treatment */
    dct: number;
/** Displacement convergence tolerance */
    dctol: number;
/** death time */
    death: number;
/** *CONTROL_DEBUG card */
    debug: object;
/** Geometry for decomposition */
    defgeo: number;
/** delete shells where neighbours fail */
    delfr: number;
/** Terminate based on rel total displacement in max norm */
    delta1: number;
/** Terminate based on rel total displacement in Euclidean norm */
    deltau: number;
/** Output DEM density data to d3plot database */
    demden: number;
/** Density */
    density: number;
/** Density */
    density_1: number;
/** Time integration type */
    deriv: number;
/** Smoothing weight factor: equipotential */
    dfac: number;
/** Incremental increase in factin */
    dfactr: number;
/** Default dynamic coefficient of friction */
    dfric: number;
/** Part that defines the die */
    dieid: number;
/** Number of automatically determined directions */
    direct: number;
/** *CONTROL_DISCRETE_ELEMENT card */
    discrete_element: object;
/** Distance tolerance for auto-SPC along flange roots */
    dist: number;
/** Divergence flag */
    diverg: number;
/** Mass proportional damping constant in Rayleigh damping */
    dmpmas: number;
/** Stiffness proportional damping constant in Rayleigh damping */
    dmpstf: number;
/** Maximum displacement convergence tolerance */
    dmtol: number;
/** Displacement norm for convergence test */
    dnorm: number;
/** Applicable degrees-of-freedom for excitation input */
    dof1: number;
/** Applicable degrees-of-freedom for response output */
    dof2: number;
/** Dormant part treatment in d3plot file */
    dordel: number;
/** Max rate of change of pwp water head (m/s) */
    dpwmax: number;
/** Drilling rotation constraint method */
    drcm: number;
/** drilling rotation constraint method. */
    drcmth: number;
/** Drilling rotation constraint parameter */
    drcprm: number;
/** part set for drilling rotation constraint method. */
    drcpsid: number;
/** drilling rotation constraint parameter. */
    drcpsrm: number;
/** Dyn relaxation factor */
    drfctr: number;
/** Part set used to check for convergence */
    drpset: number;
/** Optional DR termination time */
    drterm: number;
/** Convergence tolerance */
    drtol: number;
/** Death time */
    dt: number;
/** initial time step size */
    dt0: number;
/** Initial timestep for implicit analysis */
    dt0_1: number;
/** Timestep for mass scaling */
    dt2ms: number;
/** Scale factor for initial timestep size to determine min permitted time step size */
    dt2msf: number;
/** Loadcurve: DT2MS vs time */
    dt2mslc: number;
/** Death time */
    dt_1: number;
/** Flag for output option (time interval or cycle number) */
    dt_cycle: number;
/** Flag for output option (time interval or cycle number) */
    dt_cycle_1: number;
/** Max delta temp permitted before timestep decrease, of LC of dt vs time if -ve */
    dtemp: number;
/** time in explicit before switch */
    dtexp: number;
/** Time step factor. */
    dtfac: number;
/** Initial timestep size */
    dtinit: number;
/** Maximum allowable timestep. Loadcurve if negative */
    dtmax: number;
/** Minimum allowable timestep */
    dtmin: number;
/** timestep size for remesh */
    dtmin_1: number;
/** Scale factor on initial dt size for termination */
    dtmin_2: number;
/** Scale time step called DTMU */
    dtmufac: number;
/** Time interval between outputs. Constant float value if DTOUTYP = 0,  Curve ID if DTOUTYP = 1. */
    dtout: number;
/** Modal dynamics output interval */
    dtout_1: number;
/** Type of DTOUT. Valid values: 0-Constant, 1-Time vs DTOUT Curve. */
    dtoutyp: number;
/** Time interval between view factor updates */
    dtvf: number;
/** Not used */
    dvid: number;
/** *CONTROL_DYNAMIC_RELAXATION card */
    dynamic_relaxation: object;
/** Youngs modulus */
    e: number;
/** Youngs modulus */
    e_1: number;
/** Automatic Euler boundary condition */
    ebc: number;
/** Timestep override for eroding contacts */
    ecdt: number;
/** Energy convergence tolerance */
    ectol: number;
/** Default exponential decay coefficient */
    edc: number;
/** Convergence tolerance on auto control */
    edttl: number;
/** Smoothing weight factor: equipotential */
    efac: number;
/** *CONTROL_EFG card */
    efg: object;
/** efg keyword option */
    efg_1: number;
/** Eigenvalue extraction method */
    eigmth: number;
/** Maximum energy convergence tolerance */
    emtol: number;
/** Flag for dumping elemental stiffness and mass matrices */
    emxdmp: number;
/** End time for smoothing */
    end: number;
/** Termination cycle # */
    endcyc: number;
/** %age change in energy for termination */
    endeng: number;
/** %age change in mass for termination */
    endmas: number;
/** Termination time */
    endtim: number;
/** *CONTROL_ENERGY card */
    energy: object;
/** Flag to output contact sliding energy densities for mortar contact */
    engout: number;
/** Treatment of mass of eroded nodes */
    enmass: number;
/** Elout coordinate system option */
    eocs: number;
/** Max effective plastic strain, beyond which elements are deleted */
    epsmx: number;
/** Mechanical equivelent of heat (J/Nm etc). Loadcurve if negative */
    eqheat: number;
/** Erosion flag for solids &amp; shells @ DTMIN */
    erode: number;
/** Degenerate shell sorting flag (was ITRIST) */
    esort: number;
/** Automatic sort of tetra &amp; penta flag */
    esort_1: number;
/** Event termination time */
    eterm: number;
/** event time termination */
    eterm_1: number;
/** Flag for interpretation of time */
    etflag: number;
/** Error tolerance in the IMLM */
    etol: number;
/** Flag for writing eigenvalues and eigenvectors */
    evdump: number;
/** Explicit accuracy parameter */
    exacc: number;
/** .eq.1 if excl above */
    excl: number;
/** true if control card exists */
    exists: boolean;
/** true if control card exists */
    exists_1: boolean;
/** true if control card exists */
    exists_10: boolean;
/** true if control card exists */
    exists_100: boolean;
/** true if control card exists */
    exists_101: boolean;
/** true if control card exists */
    exists_102: boolean;
/** true if control card exists */
    exists_103: boolean;
/** true if control card exists */
    exists_104: boolean;
/** true if control card exists */
    exists_105: boolean;
/** true if control card exists */
    exists_106: boolean;
/** true if control card exists */
    exists_107: boolean;
/** true if control card exists */
    exists_108: boolean;
/** true if control card exists */
    exists_109: boolean;
/** true if control card exists */
    exists_11: boolean;
/** true if control card exists */
    exists_110: boolean;
/** true if control card exists */
    exists_111: boolean;
/** true if control card exists */
    exists_112: boolean;
/** true if control card exists */
    exists_113: boolean;
/** true if control card exists */
    exists_114: boolean;
/** true if control card exists */
    exists_115: boolean;
/** true if control card exists */
    exists_116: boolean;
/** true if control card exists */
    exists_117: boolean;
/** true if control card exists */
    exists_118: boolean;
/** true if control card exists */
    exists_119: boolean;
/** true if control card exists */
    exists_12: boolean;
/** true if control card exists */
    exists_120: boolean;
/** true if control card exists */
    exists_13: boolean;
/** true if control card exists */
    exists_14: boolean;
/** true if control card exists */
    exists_15: boolean;
/** true if control card exists */
    exists_16: boolean;
/** true if control card exists */
    exists_17: boolean;
/** true if control card exists */
    exists_18: boolean;
/** true if control card exists */
    exists_19: boolean;
/** true if control card exists */
    exists_2: boolean;
/** true if control card exists */
    exists_20: boolean;
/** true if control card exists */
    exists_21: boolean;
/** true if control card exists */
    exists_22: boolean;
/** true if control card exists */
    exists_23: boolean;
/** true if control card exists */
    exists_24: boolean;
/** true if control card exists */
    exists_25: boolean;
/** true if control card exists */
    exists_26: boolean;
/** true if control card exists */
    exists_27: boolean;
/** true if control card exists */
    exists_28: boolean;
/** true if control card exists */
    exists_29: boolean;
/** true if control card exists */
    exists_3: boolean;
/** true if control card exists */
    exists_30: boolean;
/** true if control card exists */
    exists_31: boolean;
/** true if control card exists */
    exists_32: boolean;
/** true if control card exists */
    exists_33: boolean;
/** true if control card exists */
    exists_34: boolean;
/** true if control card exists */
    exists_35: boolean;
/** true if control card exists */
    exists_36: boolean;
/** true if control card exists */
    exists_37: boolean;
/** true if control card exists */
    exists_38: boolean;
/** true if control card exists */
    exists_39: boolean;
/** true if control card exists */
    exists_4: boolean;
/** true if control card exists */
    exists_40: boolean;
/** true if control card exists */
    exists_41: boolean;
/** true if control card exists */
    exists_42: boolean;
/** true if control card exists */
    exists_43: boolean;
/** true if control card exists */
    exists_44: boolean;
/** true if control card exists */
    exists_45: boolean;
/** true if control card exists */
    exists_46: boolean;
/** true if control card exists */
    exists_47: boolean;
/** true if control card exists */
    exists_48: boolean;
/** true if control card exists */
    exists_49: boolean;
/** true if control card exists */
    exists_5: boolean;
/** true if control card exists */
    exists_50: boolean;
/** true if control card exists */
    exists_51: boolean;
/** true if control card exists */
    exists_52: boolean;
/** true if control card exists */
    exists_53: boolean;
/** true if control card exists */
    exists_54: boolean;
/** true if control card exists */
    exists_55: boolean;
/** true if control card exists */
    exists_56: boolean;
/** true if control card exists */
    exists_57: boolean;
/** true if control card exists */
    exists_58: boolean;
/** true if control card exists */
    exists_59: boolean;
/** true if control card exists */
    exists_6: boolean;
/** true if control card exists */
    exists_60: boolean;
/** true if control card exists */
    exists_61: boolean;
/** true if control card exists */
    exists_62: boolean;
/** true if control card exists */
    exists_63: boolean;
/** true if control card exists */
    exists_64: boolean;
/** true if control card exists */
    exists_65: boolean;
/** true if control card exists */
    exists_66: boolean;
/** true if control card exists */
    exists_67: boolean;
/** true if control card exists */
    exists_68: boolean;
/** true if control card exists */
    exists_69: boolean;
/** true if control card exists */
    exists_7: boolean;
/** true if control card exists */
    exists_70: boolean;
/** true if control card exists */
    exists_71: boolean;
/** true if control card exists */
    exists_72: boolean;
/** true if control card exists */
    exists_73: boolean;
/** true if control card exists */
    exists_74: boolean;
/** true if control card exists */
    exists_75: boolean;
/** true if control card exists */
    exists_76: boolean;
/** true if control card exists */
    exists_77: boolean;
/** true if control card exists */
    exists_78: boolean;
/** true if control card exists */
    exists_79: boolean;
/** true if control card exists */
    exists_8: boolean;
/** true if control card exists */
    exists_80: boolean;
/** true if control card exists */
    exists_81: boolean;
/** true if control card exists */
    exists_82: boolean;
/** true if control card exists */
    exists_83: boolean;
/** true if control card exists */
    exists_84: boolean;
/** true if control card exists */
    exists_85: boolean;
/** true if control card exists */
    exists_86: boolean;
/** true if control card exists */
    exists_87: boolean;
/** true if control card exists */
    exists_88: boolean;
/** true if control card exists */
    exists_89: boolean;
/** true if control card exists */
    exists_9: boolean;
/** true if control card exists */
    exists_90: boolean;
/** true if control card exists */
    exists_91: boolean;
/** true if control card exists */
    exists_92: boolean;
/** true if control card exists */
    exists_93: boolean;
/** true if control card exists */
    exists_94: boolean;
/** true if control card exists */
    exists_95: boolean;
/** true if control card exists */
    exists_96: boolean;
/** true if control card exists */
    exists_97: boolean;
/** true if control card exists */
    exists_98: boolean;
/** true if control card exists */
    exists_99: boolean;
/** *CONTROL_EXPLICIT_THERMAL_PROPERTIES card */
    explicit_thermal: object;
/** *CONTROL_EXPLICIT_THERMAL_ALE_COUPLING card */
    explicit_thermal_ale_coupling: object;
/** *CONTROL_EXPLICIT_THERMAL_BOUNDARY card */
    explicit_thermal_boundary: object;
/** *CONTROL_EXPLICIT_THERMAL_CONTACT card */
    explicit_thermal_contact: object;
/** *CONTROL_EXPLICIT_THERMAL_INITIAL card */
    explicit_thermal_initial: object;
/** *CONTROL_EXPLICIT_THERMAL_OUTPUT card */
    explicit_thermal_output: object;
/** *CONTROL_EXPLICIT_THERMAL_SOLVER card */
    explicit_thermal_solver: object;
/** *CONTROL_EXPLOSIVE_SHADOW card */
    explosive_shadow: object;
/** Internal flag to set 936 compatibility */
    f_936: number;
/** default stiffness/gravity factor */
    fact: number;
/** Initial relaxation factor for contact force */
    factin: number;
/** Target mesh file in keyword format */
    filename: string;
/** Constraint modes file name */
    filename2: string;
/** Eigen modes file name */
    filename_1: string;
/** Flag to flip X coords */
    flipx: number;
/** Flag to flip Y coords */
    flipy: number;
/** Flag to flip Z coords */
    flipz: number;
/** calculation method for deformation gradient */
    fmatrix: number;
/** Maximum frequency for FRF output */
    fmax: number;
/** max seepage factor */
    fmax_1: number;
/** Maximum factor on seepage calc */
    fmax_2: number;
/** Minimum frequency for FRF output */
    fmin: number;
/** min seepage factor */
    fmin_1: number;
/** Minimum factor on seepage calc */
    fmin_2: number;
/** Optional maximum natural frequency */
    fnmax: number;
/** Part for tool to follow */
    follow: number;
/** Element formulation to use. */
    form: number;
/** particle theory */
    form_1: number;
/** *CONTROL_FORMING_CONTROL_FORMING_BESTFIT card */
    forming_bestfit: object;
/** *CONTROL_FORMING_INITIAL_THICKNESS card */
    forming_initial_thickness: object;
/** *CONTROL_FORMING_MAXID card */
    forming_maxid: object;
/** *CONTROL_FORMING_POSITION card */
    forming_position: object;
/** *CONTROL_FORMING_PRE_BENDING card */
    forming_pre_bending: object;
/** *CONTROL_FORMING_PROJECTION card */
    forming_projection: object;
/** *CONTROL_FORMING_REMOVE_ADAPTIVE_CONSTRAINTS card */
    forming_remove_adaptive_constraints: object;
/** *CONTROL_FORMING_SHELL_TO_TSHELL card */
    forming_shell_to_tshell: object;
/** *CONTROL_FORMING_STONING card */
    forming_stoning: object;
/** *CONTROL_FORMING_STRAIN_RATIO_SMOOTH card */
    forming_strain_ratio_smooth: object;
/** *CONTROL_FORMING_TEMPLATE card */
    forming_template: object;
/** *CONTROL_FORMING_TOLERANC card */
    forming_toleranc: object;
/** *CONTROL_FORMING_TRAVEL card */
    forming_travel: object;
/** *CONTROL_FORMING_TRIM_MERGE card */
    forming_trim_merge: object;
/** *CONTROL_FORMING_TRIMMING_SOLID_REFINEMENT card */
    forming_trimming_solid_refinement: object;
/** *CONTROL_FORMING_UNFLANGING card */
    forming_unflanging: object;
/** *CONTROL_FORMING_USER card */
    forming_user: object;
/** Formula that defines the contact heat conductance as a function of temperature and pressure */
    formula: number;
/** Radiation factor between the contact surfaces */
    frad: number;
/** Flag to calculate internal friction energy */
    frceng: number;
/** Time interval between redecomposition */
    freq: number;
/** *CONTROL_FREQUENCY_DOMAIN card */
    frequency_domain: object;
/** If FREQUENCY_RANGE option is used */
    frequency_range: boolean;
/** *CONTROL_FREQUENCY_RESPONSE_FUNCTION card */
    frequency_response_function: object;
/** Output frequency for failed element report */
    frfreq: number;
/** Dynamic coefficient of friction */
    fricd: number;
/** rolling friction coefficient */
    fricr: number;
/** friction coefficient */
    frics: number;
/** Friction coefficient */
    fs: number;
/** Friction coefficient */
    fs_1: number;
/** output contact forces to rcforc */
    ftall: number;
/** Analysis type */
    ftied: number;
/** Fraction of sliding friction energy partitioned to the slave surface */
    ftoslv: number;
/** Fraction of mechanical heat converted into heat */
    fwork: number;
/** Fraction of mechanical work converted into heat */
    fwork_1: number;
/** liquid surface tension */
    gamma: number;
/** Newmark time integration constant */
    gamma_1: number;
/** parameter affecting spatial limit of liquid bridge */
    gap: number;
/** Minimum gap */
    gap_1: number;
/** Home gap between rigid tools */
    gap_2: number;
/** Min distance between tool and target in the home position */
    gap_3: number;
/** Minimum gap between tools */
    gap_4: number;
/** Gap distance between two open ends of a trim loop curve in the model */
    gapm: number;
/** Separation distance calculation flag */
    gaponly: number;
/** Joint rotational stiffness */
    gjadstf: number;
/** Joint rotational damping */
    gjadvsc: number;
/** output interval for *INTERFACE_SSI_AUX */
    gmdt: number;
/** #gauss points in solids */
    gpt: number;
/** Gravitational acceleration for Ro.g.h */
    grav: number;
/** GROUPABLE algorithm options */
    grp: number;
/** Heat transfer conductance for closed gaps */
    h0: number;
/** Mid-point relative Euclidian residual norm max tolerance */
    hcmax: number;
/** Mid-point relative Euclidian residual norm min tolerance */
    hcmin: number;
/** Hourglass energy calc flag */
    hgen: number;
/** Flag to invoke output of extra history variable names */
    hisnout: number;
/** Mid-point relative maximum residual norm max tolerance */
    hmmax: number;
/** Mid-point relative maximum residual norm min tolerance */
    hmmin: number;
/** Mid-point absolute Nodal Rotational norm tolerance */
    hnrmax: number;
/** Mid-point absolute Nodal Translational norm tolerance */
    hntmax: number;
/** *CONTROL_HOURGLASS card */
    hourglass: object;
/** Mid-point absolute Rigid body Rotational norm tolerance */
    hrrmax: number;
/** Mid-point absolute Rigid body Translational norm tolerance */
    hrtmax: number;
/** Not used */
    hsort: number;
/** interactive adaptivity adjustable tolerance */
    iaat: number;
/** Implicit accuracy flag */
    iacc: number;
/** Flag for accels in d3thdt to be averaged */
    iaccop: number;
/** Fission level that fusion will start at */
    iadpcl: number;
/** Maximum no. of elements covering 90degree of radii */
    iadpe90: number;
/** Fiffion flag for neighbour splitting */
    iadpgh: number;
/** Include ALE computations in the dynamic relaxation analysis */
    ialedr: number;
/** Artificial stabilization flag */
    ias: number;
/** interactive adaptivity */
    iat: number;
/** tolerance of shear distortion indicator for interactive adaptivity */
    iat1: number;
/** tolerance of unbalanced nodal distribution indicator for interactive adaptivity */
    iat2: number;
/** tolerance of volumetric change indicator for interactive adaptivity */
    iat3: number;
/** Automatic timestep control flag. Loadcurve if negative */
    iauto: number;
/** artificial viscosity formulation */
    iavis: number;
/** Offset for numbering */
    ibase: number;
/** Beam element formulation for implicit */
    ibeam: number;
/** Default bulk viscosity type (m#PR035) */
    ibq: number;
/** Flag to invoke output of *SET_BEAM data */
    ibsf: number;
/** On/Off flag */
    icoarse: number;
/** global flag for cohesive element deletion */
    icoh: number;
/** contact option */
    icont: number;
/** Invokes the covariant formulation of Konyukhov and Schweizerhof */
    icov: number;
/** Output node and element sets used in computing secforc data */
    icrfile: number;
/** number of elements along radius */
    icurv: number;
/** Treatment of cylindrical joints */
    icylin: number;
/** If less than 0 then Element ID if greater than 0 then  Set ID. Can be SOLID, SHELL, BEAM or THICK SHELL based on value of idtyp. */
    id: number;
/** Contact ID 1 to distrubute */
    id1: number;
/** Contact ID 10 to distrubute */
    id10: number;
/** Contact ID 11 to distrubute */
    id11: number;
/** Contact ID 12 to distrubute */
    id12: number;
/** Contact ID 13 to distrubute */
    id13: number;
/** Contact ID 14 to distrubute */
    id14: number;
/** Contact ID 15 to distrubute */
    id15: number;
/** Contact ID 1 to distrubute */
    id1_1: number;
/** Contact ID 2 to distrubute */
    id2: number;
/** Contact ID 2 to distrubute */
    id2_1: number;
/** Contact ID 3 to distrubute */
    id3: number;
/** Contact ID 3 to distrubute */
    id3_1: number;
/** Contact ID 4 to distrubute */
    id4: number;
/** Contact ID 4 to distrubute */
    id4_1: number;
/** Contact ID 5 to distrubute */
    id5: number;
/** Contact ID 5 to distrubute */
    id5_1: number;
/** Contact ID 6 to distrubute */
    id6: number;
/** Contact ID 7 to distrubute */
    id7: number;
/** Contact ID 8 to distrubute */
    id8: number;
/** Contact ID 9 to distrubute */
    id9: number;
/** part id offset */
    id_off: number;
/** Output internal debug message */
    ideb: number;
/** dilation param */
    idila: number;
/** Space system flag */
    idim: number;
/** Part id for tool */
    idpm: number;
/** Part id for blank */
    idps: number;
/** Stress initialisation flag */
    idrflg: number;
/** Set id of the segments to be generated at the bottom layer */
    idsegb: number;
/** Set id of the segments to be generated at the top layer */
    idsegt: number;
/** Shell/Part set id */
    idset: number;
/** Type of forming process */
    idtemp: number;
/** Type of ID. Valid values: 1-Solid, 2-Shell, 3-Beam, 4-Thick shell . */
    idtyp: number;
/** remeshing with element erosion */
    ier: number;
/** erosion option */
    ierod: number;
/** output eroded energy */
    ierode: number;
/** Terminate based on internal energy */
    ietol: number;
/** Computing performance optimisation flag */
    ifast: number;
/** Best fit flag */
    ifit: number;
/** Consistent mass matrix flag */
    iflag: number;
/** Iteration limit for first phase of unfolding */
    iflimit: number;
/** i/o buffer flushing interval (t-steps) */
    iflush: number;
/** Format for processing eigenmodes */
    iformat: number;
/** Flag for forming of sandwiched parts with adaptive blank mesh */
    ifsand: number;
/** Optional flag to define a node set to be included or excluded */
    ifset: number;
/** option to use isogeometric shells for contact detection */
    igactc: number;
/** glstat data flag */
    iglst: number;
/** Ignore initial penetrations flag */
    ignore: number;
/** Ignore penetration flag */
    ignore_1: number;
/** Geometric (initial stress) stiffness flag */
    igs: number;
/** Method for calculating solid element time steps */
    ihdo: number;
/** Hourglass viscosity type */
    ihq: number;
/** Status report interval to d3hsp */
    ikedit: number;
/** Adaptive refinement level */
    ilevel: number;
/** Iteration limit between automatic stiffness reformations */
    ilimit: number;
/** Unfolding algorithm selection flag */
    ilinear: number;
/** Flag for mass scaling for ALE parts */
    imascl: number;
/** Implicit analysis type */
    imass: number;
/** Inertia switching flag */
    imass_1: number;
/** Activation flag */
    imerge: number;
/** Implicit/explicit switching flag; loadcurve if negative */
    imflag: number;
/** Element formulation switching flag */
    imform: number;
/** Choice for matrix operation, linear solving and memory usage */
    imlm: number;
/** *CONTROL_IMPLICIT_AUTO card */
    implicit_auto: object;
/** *CONTROL_IMPLICIT_BUCKLE card */
    implicit_buckle: object;
/** *CONTROL_IMPLICIT_CONSISTENT_MASS card */
    implicit_consistent_mass: object;
/** *CONTROL_IMPLICIT_DYNAMICS card */
    implicit_dynamics: object;
/** *CONTROL_IMPLICIT_EIGENVALUE card */
    implicit_eigenvalue: object;
/** *CONTROL_IMPLICIT_EXPLICT_HYBRID card */
    implicit_explicit_hybrid: object;
/** *CONTROL_IMPLICIT_FORMING card */
    implicit_forming: object;
/** *CONTROL_IMPLICIT_GENERAL card */
    implicit_general: object;
/** *CONTROL_IMPLICIT_INERTIA_RELIEF card */
    implicit_inertia_relief: object;
/** *CONTROL_IMPLICIT_JOINTS card */
    implicit_joints: object;
/** *CONTROL_IMPLICIT_MODAL_DYNAMIC card */
    implicit_modal_dynamic: object;
/** *CONTROL_IMPLICIT_MODAL_DYNAMIC_DAMPING card */
    implicit_modal_dynamic_damping: object;
/** *CONTROL_IMPLICIT_MODES card */
    implicit_modes: object;
/** *CONTROL_IMPLICIT_ORDERING card */
    implicit_ordering: object;
/** *CONTROL_IMPLICIT_RESIDUAL_VECTOR card */
    implicit_residual_vector: object;
/** *CONTROL_IMPLICIT_SOLUTION card */
    implicit_solution: object;
/** *CONTROL_IMPLICIT_SOLVER card */
    implicit_solver: object;
/** *CONTROL_IMPLICIT_STABILIZATION card */
    implicit_stabilization: object;
/** *CONTROL_IMPLICIT_STATIC_CONDENSATION card */
    implicit_static_condensation: object;
/** *CONTROL_IMPLICIT_TERMINATION card */
    implicit_termination: object;
/** Selective mass scaling. Part set if negative */
    imscl: number;
/** The Include file number that the control card is in. */
    include: number;
/** The Include file number that the control card is in. */
    include_1: number;
/** The Include file number that the control card is in. */
    include_10: number;
/** The Include file number that the control card is in. */
    include_100: number;
/** The Include file number that the control card is in. */
    include_101: number;
/** The Include file number that the control card is in. */
    include_102: number;
/** The Include file number that the control card is in. */
    include_103: number;
/** The Include file number that the control card is in. */
    include_104: number;
/** The Include file number that the control card is in. */
    include_105: number;
/** The Include file number that the control card is in. */
    include_106: number;
/** The Include file number that the control card is in. */
    include_107: number;
/** The Include file number that the control card is in. */
    include_108: number;
/** The Include file number that the control card is in. */
    include_109: number;
/** The Include file number that the control card is in. */
    include_11: number;
/** The Include file number that the control card is in. */
    include_110: number;
/** The Include file number that the control card is in. */
    include_111: number;
/** The Include file number that the control card is in. */
    include_112: number;
/** The Include file number that the control card is in. */
    include_113: number;
/** The Include file number that the control card is in. */
    include_114: number;
/** The Include file number that the control card is in. */
    include_115: number;
/** The Include file number that the control card is in. */
    include_116: number;
/** The Include file number that the control card is in. */
    include_117: number;
/** The Include file number that the control card is in. */
    include_118: number;
/** The Include file number that the control card is in. */
    include_119: number;
/** The Include file number that the control card is in. */
    include_12: number;
/** The Include file number that the control card is in. */
    include_120: number;
/** The Include file number that the control card is in. */
    include_13: number;
/** The Include file number that the control card is in. */
    include_14: number;
/** The Include file number that the control card is in. */
    include_15: number;
/** The Include file number that the control card is in. */
    include_16: number;
/** The Include file number that the control card is in. */
    include_17: number;
/** The Include file number that the control card is in. */
    include_18: number;
/** The Include file number that the control card is in. */
    include_19: number;
/** The Include file number that the control card is in. */
    include_2: number;
/** The Include file number that the control card is in. */
    include_20: number;
/** The Include file number that the control card is in. */
    include_21: number;
/** The Include file number that the control card is in. */
    include_22: number;
/** The Include file number that the control card is in. */
    include_23: number;
/** The Include file number that the control card is in. */
    include_24: number;
/** The Include file number that the control card is in. */
    include_25: number;
/** The Include file number that the control card is in. */
    include_26: number;
/** The Include file number that the control card is in. */
    include_27: number;
/** The Include file number that the control card is in. */
    include_28: number;
/** The Include file number that the control card is in. */
    include_29: number;
/** The Include file number that the control card is in. */
    include_3: number;
/** The Include file number that the control card is in. */
    include_30: number;
/** The Include file number that the control card is in. */
    include_31: number;
/** The Include file number that the control card is in. */
    include_32: number;
/** The Include file number that the control card is in. */
    include_33: number;
/** The Include file number that the control card is in. */
    include_34: number;
/** The Include file number that the control card is in. */
    include_35: number;
/** The Include file number that the control card is in. */
    include_36: number;
/** The Include file number that the control card is in. */
    include_37: number;
/** The Include file number that the control card is in. */
    include_38: number;
/** The Include file number that the control card is in. */
    include_39: number;
/** The Include file number that the control card is in. */
    include_4: number;
/** The Include file number that the control card is in. */
    include_40: number;
/** The Include file number that the control card is in. */
    include_41: number;
/** The Include file number that the control card is in. */
    include_42: number;
/** The Include file number that the control card is in. */
    include_43: number;
/** The Include file number that the control card is in. */
    include_44: number;
/** The Include file number that the control card is in. */
    include_45: number;
/** The Include file number that the control card is in. */
    include_46: number;
/** The Include file number that the control card is in. */
    include_47: number;
/** The Include file number that the control card is in. */
    include_48: number;
/** The Include file number that the control card is in. */
    include_49: number;
/** The Include file number that the control card is in. */
    include_5: number;
/** The Include file number that the control card is in. */
    include_50: number;
/** The Include file number that the control card is in. */
    include_51: number;
/** The Include file number that the control card is in. */
    include_52: number;
/** The Include file number that the control card is in. */
    include_53: number;
/** The Include file number that the control card is in. */
    include_54: number;
/** The Include file number that the control card is in. */
    include_55: number;
/** The Include file number that the control card is in. */
    include_56: number;
/** The Include file number that the control card is in. */
    include_57: number;
/** The Include file number that the control card is in. */
    include_58: number;
/** The Include file number that the control card is in. */
    include_59: number;
/** The Include file number that the control card is in. */
    include_6: number;
/** The Include file number that the control card is in. */
    include_60: number;
/** The Include file number that the control card is in. */
    include_61: number;
/** The Include file number that the control card is in. */
    include_62: number;
/** The Include file number that the control card is in. */
    include_63: number;
/** The Include file number that the control card is in. */
    include_64: number;
/** The Include file number that the control card is in. */
    include_65: number;
/** The Include file number that the control card is in. */
    include_66: number;
/** The Include file number that the control card is in. */
    include_67: number;
/** The Include file number that the control card is in. */
    include_68: number;
/** The Include file number that the control card is in. */
    include_69: number;
/** The Include file number that the control card is in. */
    include_7: number;
/** The Include file number that the control card is in. */
    include_70: number;
/** The Include file number that the control card is in. */
    include_71: number;
/** The Include file number that the control card is in. */
    include_72: number;
/** The Include file number that the control card is in. */
    include_73: number;
/** The Include file number that the control card is in. */
    include_74: number;
/** The Include file number that the control card is in. */
    include_75: number;
/** The Include file number that the control card is in. */
    include_76: number;
/** The Include file number that the control card is in. */
    include_77: number;
/** The Include file number that the control card is in. */
    include_78: number;
/** The Include file number that the control card is in. */
    include_79: number;
/** The Include file number that the control card is in. */
    include_8: number;
/** The Include file number that the control card is in. */
    include_80: number;
/** The Include file number that the control card is in. */
    include_81: number;
/** The Include file number that the control card is in. */
    include_82: number;
/** The Include file number that the control card is in. */
    include_83: number;
/** The Include file number that the control card is in. */
    include_84: number;
/** The Include file number that the control card is in. */
    include_85: number;
/** The Include file number that the control card is in. */
    include_86: number;
/** The Include file number that the control card is in. */
    include_87: number;
/** The Include file number that the control card is in. */
    include_88: number;
/** The Include file number that the control card is in. */
    include_89: number;
/** The Include file number that the control card is in. */
    include_9: number;
/** The Include file number that the control card is in. */
    include_90: number;
/** The Include file number that the control card is in. */
    include_91: number;
/** The Include file number that the control card is in. */
    include_92: number;
/** The Include file number that the control card is in. */
    include_93: number;
/** The Include file number that the control card is in. */
    include_94: number;
/** The Include file number that the control card is in. */
    include_95: number;
/** The Include file number that the control card is in. */
    include_96: number;
/** The Include file number that the control card is in. */
    include_97: number;
/** The Include file number that the control card is in. */
    include_98: number;
/** The Include file number that the control card is in. */
    include_99: number;
/** bucket or global smoothing */
    ini: number;
/** Factor needed for the estimation of maximum workspace used during initialization */
    inint: number;
/** Invariant node numbering for shell element */
    inn: number;
/** Flag to invoke output of *SET_NODE data */
    insf: number;
/** Integration method */
    integ: number;
/** Intermittent searching flag for old contacts */
    interm: number;
/** Gauss/Lobatto intg rule switch */
    intgrd: number;
/** Flag for behavior in case of unwanted interp. or extrap. of initial stresses */
    intperr: number;
/** Flag to generate adaptive mesh */
    ioflag: number;
/** 1:gravity 2:binder */
    ioption: number;
/** output of 1D seatbelt created for 2D seatbelt to sbtout */
    ip1dblt: number;
/** Number of strips in U direction */
    ipanelu: number;
/** Number of strips in V direction */
    ipanelv: number;
/** Minimum block size for the Cholesky factorization (for eigmth=101) or Maximum number of iterations (for eigmth=102) */
    iparm1: number;
/** Maximum number of iterations */
    iparm1_1: number;
/** Maximum block size for the Cholesky factorization (for eigmth=101) or Block size (for eigmth=102) */
    iparm2: number;
/** Node set ID */
    iparm3: number;
/** MCMS minimum group/substructure size */
    iparm4: number;
/** output curve data flag */
    ipcurv: number;
/** Flag to print initial timesteps at cycle #1 */
    ipnint: number;
/** Print flag for RBDOUT and MATSUM files */
    iprtf: number;
/** curve factor */
    irad: number;
/** rate effect switch */
    irate: number;
/** Lowest IRCNT modes */
    ircnt: number;
/** Flag to activate trimming of a multi-layer sandwiched part */
    irefine: number;
/** Uniform refinement level. Loadcurve if negative */
    ireflg: number;
/** Automatic control flag */
    irelal: number;
/** Converting the attachment modes to residual vectors flag */
    iresvec: number;
/** Residual vector control flag */
    iresvec_1: number;
/** Treatment of revolute joints */
    irevol: number;
/** Inertia relief flag */
    irflag: number;
/** Initial reference geometry calc flag */
    irgen: number;
/** Hughes-Liu shell normal update option */
    irnxx: number;
/** intg rule */
    irquad: number;
/** dt calc method for 4 noded shells */
    isdo: number;
/** Shell element formulation for implicit */
    ishell: number;
/** display option */
    ishow: number;
/** Initial penetration check flag */
    islchk: number;
/** Flag to check for a NaN in force and moment arrays */
    isnan: number;
/** Solid element formulation for implicit */
    isolid: number;
/** Flag to invoke output of *SET_SOLID data */
    isolsf: number;
/** Treatment of spherical joints */
    ispher: number;
/** kernel function */
    ispline: number;
/** Flag to invoke output of *SET_SHELL data */
    issf: number;
/** stabilisation type */
    istab: number;
/** Initial stiffness formulation flag */
    istif: number;
/** Stoning calculation option */
    istone: number;
/** Shell thickness change option */
    istupd: number;
/** symmetry option. Node set if negative */
    isym: number;
/** percentage of sph */
    isymp: number;
/** Optimum equilibrium iteration count per timestep */
    iteopt: number;
/** Allowable iteration window (no. of iterations) */
    itewin: number;
/** thermal contact heat transfer mode */
    ithcnt: number;
/** contact thickness option */
    ithk: number;
/** Flag for offsetting thermal contact surfaces for thick thermal shells */
    ithoff: number;
/** Flag for offsetting thermal contact surfaces for thick thermal shells */
    ithoff_1: number;
/** Treatment of "Real time" on *DEFIN_CONSTRUCTION_STAGES */
    itime: number;
/** Refinement option for enclosed area of trim curve */
    itriopt: number;
/** Initial thermal timestep */
    its: number;
/** Initial thermal time step size */
    its_1: number;
/** initial transverse shear stress */
    itsflg: number;
/** Thick shell element formulation for implicit */
    itshell: number;
/** Set type */
    itype: number;
/** Set type designation */
    itype_1: number;
/** Hardware specific cost profile */
    itype_2: number;
/** Database format */
    itype_3: number;
/** Velocity switching flag */
    ivel: number;
/** Flag to check and report open edge of CV airbag */
    ivolerr: number;
/** internal variable transfer in adaptive EFG */
    ivt: number;
/** Generalized joint stiffness formulation */
    jntf: number;
/** Strength coefficient for exponential hardening */
    k: number;
/** Strength coefficient for exponential hardening */
    k_1: number;
/** Thermal conductivity of fluid between the contact surfaces */
    k_2: number;
/** number of explicit cycles before switch */
    kcycle: number;
/** keep contact segs of failed shells */
    keepcs: number;
/** Terminate based on kinetic energy */
    ketol: number;
/** number of failed implicit attempts before switch */
    kfail: number;
/** Heat conductivity matrix. Constant float value if respective KxxTYP = 0,  Curve ID if respective KxxTYP = 1. */
    kxx: number;
/** Types of Kxx. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve. */
    kxxtyp: number;
/** Heat conductivity matrix. Constant float value if respective KxyTYP = 0,  Curve ID if respective KxyTYP = 1. */
    kxy: number;
/** Types of Kxy. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve. */
    kxytyp: number;
/** Heat conductivity matrix. Constant float value if respective KxzTYP = 0,  Curve ID if respective KxzTYP = 1. */
    kxz: number;
/** Types of Kxz. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve. */
    kxztyp: number;
/** Heat conductivity matrix. Constant float value if respective KyxTYP = 0,  Curve ID if respective KyxTYP = 1. */
    kyx: number;
/** Types of Kyx. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve. */
    kyxtyp: number;
/** Heat conductivity matrix. Constant float value if respective KyyTYP = 0,  Curve ID if respective KyyTYP = 1. */
    kyy: number;
/** Types of Kyy. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve. */
    kyytyp: number;
/** Heat conductivity matrix. Constant float value if respective KyzTYP = 0,  Curve ID if respective KyzTYP = 1. */
    kyz: number;
/** Types of Kyz. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve. */
    kyztyp: number;
/** Heat conductivity matrix. Constant float value if respective KzxTYP = 0,  Curve ID if respective KzxTYP = 1. */
    kzx: number;
/** Types of Kzx. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve. */
    kzxtyp: number;
/** Heat conductivity matrix. Constant float value if respective KzyTYP = 0,  Curve ID if respective KzyTYP = 1. */
    kzy: number;
/** Types of Kzy. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve. */
    kzytyp: number;
/** Heat conductivity matrix. Constant float value if respective KzzTYP = 0,  Curve ID if respective KzzTYP = 1. */
    kzz: number;
/** Types of Kzz. Valid values: 0-Constant, 1-Temperature vs Heat Conductivity Curve. */
    kzztyp: number;
/** Laminated shell theory update flag */
    lamsht: number;
/** Flag to truncate curves: 0 = no truncation; otherwise = truncate */
    lcacc: number;
/** Loadcurve: Adaptive interval vs time */
    lcadp: number;
/** Loadcurve ID defining modal damping coefficient */
    lcdam: number;
/** Loadcurve for scaling friction forces */
    lcdmu: number;
/** Loadcurve for scaling friction forces during dynamic relaxation */
    lcdmur: number;
/** Load curve number for dynamic coefficient of friction as a function of temperature */
    lcfdt: number;
/** Load curve number for static coefficient of friction as a function of temperature */
    lcfst: number;
/** Load curve ID for h (can be curve ID or function ID) */
    lch: number;
/** Load curve ID defining thickness vs distance */
    lcid: number;
/** The Curve ID specifying Temperature vs Time. */
    lcid_1: number;
/** Number of points in load curve discretization */
    lcint: number;
/** Loadcurve of maximum refinement level vs. time */
    lclvl: number;
/** Matrix assembly package */
    lcpack: number;
/** Loadcurve: shear response vs. shell size */
    lcs: number;
/** Loadcurve for stress-strain relationship */
    lcss: number;
/** Loadcurve for stress-strain relationship */
    lcss_1: number;
/** Loadcurve: tension response vs. shell size */
    lct: number;
/** Loadcurve: Max timestep vs time */
    lctm: number;
/** Loadcurve: timestep vs time */
    lcts: number;
/** Type of load curve */
    lctyp: number;
/** Length of the stone */
    length: number;
/** m = meter, mm = millimeter, cm = centimeter, in = inch, ft = foot */
    length_1: string;
/** Number of meters in the length unit for the input deck */
    length_scale: number;
/** Left end point finite flag */
    lflag: number;
/** Left end point of interval */
    lftend: number;
/** No thermal contact if gap is greater than this value */
    lmax: number;
/** Switch explicit/implicit joint formulation */
    lmf: number;
/** Minimum gap */
    lmin: number;
/** LCID that defines the function for normal stiffness vs norm pen ratio */
    lnorm: number;
/** Flag to activate an element csys. Valid values: 0-Vecids are considered in Global csys, 1-Vecids are considered in Local Csys. */
    local: number;
/** Linear solver print flag */
    lprint: number;
/** search direction */
    lsdir: number;
/** LCID that defines the function for shear stiffness vs norm pen ratio */
    lshear: number;
/** search method */
    lsmtd: number;
/** Linear equation solver method */
    lsolvr: number;
/** Line search convergence tolerance */
    lstol: number;
/** lump boundary condition */
    lumpbc: number;
/** Maximum adaptive level */
    lvlada: number;
/** Maximum adaptive level */
    lvlada_1: number;
/** Acoustic nodal motions will be calculated or not. */
    macdvp: boolean;
/** kg = kilogram, g = gram, mg = milligram, lb = pound, slug = pound x sec2/foot, slinch = pound x sec2/inch, mtrc_ton = metric_ton */
    mass: string;
/** Number of kilograms in the mass unit for the input deck */
    mass_scale: number;
/** Max number of elements for adaptivity */
    maxel: number;
/** Element ID number */
    maxide: number;
/** Node ID number */
    maxidn: number;
/** Maximum number of iterations */
    maxitr: number;
/** Max #refinement levels */
    maxlvl: number;
/** Stiffness reformation limit per time step */
    maxref: number;
/** max velocity */
    maxv: number;
/** Modal dynamic stress flag */
    md_strs: number;
/** Modal dynamic flag */
    mdflag: number;
/** Last mode employed in FRF computation */
    mdmax: number;
/** First mode employed in FRF computation */
    mdmin: number;
/** %age increase in memory for *MAT_NONLOCAL usage */
    mem: number;
/** Memory limit beyond which adaptivity will cease */
    memory: number;
/** memory alloc */
    memory_1: number;
/** metalforming option */
    metalf: number;
/** Advection method */
    meth: number;
/** Stoning method */
    method: number;
/** mass ratio gain required for remesh */
    mfrac: number;
/** Mid-plane position flag */
    midsf: number;
/** Output penetration information */
    minfo: number;
/** Factor of the minimum mass allowed in an element */
    minmas: number;
/** Plane stress plasticity option */
    miter: number;
/** Flag to invoke output of accumulated airbag mass leakage in ABSTAT */
    mlkbag: number;
/** monotonic mesh resizing */
    mm: number;
/** Selects the method that is used to include a reference pressure in a calculation involving ALE multi-material groups */
    mmgpref: number;
/** Option for merging common boundaries of all adapted materials */
    mmm2d: number;
/** The Multi-material Set ID. */
    mmset: number;
/** Large mass added per node. */
    mpn: number;
/** *CONTROL_MPP_CONTACT_GROUPABLE card */
    mpp_contact_groupable: object;
/** *CONTROL_MPP_DECOMPOSITION_AUTOMATIC card */
    mpp_decomposition_automatic: object;
/** *CONTROL_MPP_DECOMPOSITION_BAGREF card */
    mpp_decomposition_bagref: object;
/** *CONTROL_MPP_DECOMPOSITION_CHECK_SPEED card */
    mpp_decomposition_check_speed: object;
/** *CONTROL_MPP_DECOMPOSITION_CONTACT_ISOLATE card */
    mpp_decomposition_contact_isolate: object;
/** *CONTROL_MPP_DECOMPOSITION_DISABLE_UNREF_CURVES card */
    mpp_decomposition_disable_unref_curves: object;
/** *CONTROL_MPP_DECOMPOSITION_DISTRIBUTE_ALE_ELEMENTS card */
    mpp_decomposition_distribute_ale_elements: object;
/** *CONTROL_MPP_DECOMPOSITION_DISTRIBUTE_SPH_ELEMENTS card */
    mpp_decomposition_distribute_sph_elements: object;
/** *CONTROL_MPP_DECOMPOSITION_ELCOST card */
    mpp_decomposition_elcost: object;
/** *CONTROL_MPP_DECOMPOSITION_FILE card */
    mpp_decomposition_file: object;
/** *CONTROL_MPP_DECOMPOSITION_METHOD card */
    mpp_decomposition_method: object;
/** *CONTROL_MPP_DECOMPOSITION_NUMPROC card */
    mpp_decomposition_numproc: object;
/** *CONTROL_MPP_DECOMPOSITION_OUTDECOMP card */
    mpp_decomposition_outdecomp: object;
/** *CONTROL_MPP_DECOMPOSITION_RCBLOG card */
    mpp_decomposition_rcblog: object;
/** *CONTROL_MPP_DECOMPOSITION_SCALE_CONTACT_COST card */
    mpp_decomposition_scale_contact_cost: object;
/** *CONTROL_MPP_DECOMPOSITION_SCALE_FACTOR_SPH card */
    mpp_decomposition_scale_factor_sph: object;
/** *CONTROL_MPP_DECOMPOSITION_SHOW card */
    mpp_decomposition_show: object;
/** *CONTROL_MPP_DECOMPOSITION_TRANSFORMATION card */
    mpp_decomposition_transformation: object;
/** *CONTROL_MPP_IO_BINOUTONLY card */
    mpp_io_binoutonly: object;
/** *CONTROL_MPP_IO_LSTC_REDUCE card */
    mpp_io_lstc_reduce: object;
/** *CONTROL_MPP_IO_NOD3DUMP card */
    mpp_io_nod3dump: object;
/** *CONTROL_MPP_IO_NODUMP card */
    mpp_io_nodump: object;
/** *CONTROL_MPP_IO_NOFAIL card */
    mpp_io_nofail: object;
/** *CONTROL_MPP_IO_NOFULL card */
    mpp_io_nofull: object;
/** *CONTROL_MPP_IO_SWAPBYTES card */
    mpp_io_swapbytes: object;
/** *CONTROL_MPP_MATERIAL_MODEL_DRIVER card */
    mpp_mat_model_driver: object;
/** Limit mass scaling to 1st timestep flag */
    ms1st: number;
/** Option for printing detail message to d3msg */
    msgflg: number;
/** Output message level */
    msglvl: number;
/** max num messags */
    msgmax: number;
/** stress compute flag */
    mstres: number;
/** Scaling for computing velocity */
    mstrscl: number;
/** flag to dump matrix */
    mtxdmp: number;
/** Material type */
    mtyp: number;
/** Material type */
    mtype: number;
/** Matrix dumping. */
    mxdmp: number;
/** Refinement option */
    n: number;
/** Optional seed node ID 1 */
    n1: number;
/** Node (n1typ=0) / node set (n1typ=1) /segment set (n1typ=2) ID for excitation input */
    n1_1: number;
/** Type of N1 */
    n1typ: number;
/** Optional seed node ID 2 */
    n2: number;
/** Node (n2typ=0) /node set (n2typ=1) /segment set (n2typ=2) ID for response output */
    n2_1: number;
/** Type of N2 */
    n2typ: number;
/** Optional seed node ID 3 */
    n3: number;
/** Optional seed node ID 4 */
    n4: number;
/** Optional seed node ID 5 */
    n5: number;
/** Optional seed node ID 6 */
    n6: number;
/** Optional seed node ID 7 */
    n7: number;
/** Optional seed node ID 8 */
    n8: number;
/** Exponent for exponential hardening */
    n_1: number;
/** Exponent for exponential hardening */
    n_2: number;
/** number of processors */
    n_3: number;
/** Number of cycles between advections */
    nadv: number;
/** decomposition file */
    name: string;
/** decomposition method */
    name_1: string;
/** decomposition file */
    name_2: string;
/** Start node ID on a flange root boundary */
    nb1: number;
/** ID of a node in the middl of the flange root boundary */
    nb2: number;
/** End node ID on a flange root boundary */
    nb3: number;
/** Number of Lagrangian cycles between bucket sort searches */
    nbkt: number;
/** Asynchronous scheme and memory buffer option */
    nbuf: number;
/** Number of cycles between particle sorting */
    ncbs: number;
/** Cycle number at which to evaluate DEFINE_CURVE_FUNCTION */
    ncdcf: number;
/** Frequency of fission to fusion steps */
    ncfreq: number;
/** Number of Lagrangian cycles between coupling calculations */
    ncpl: number;
/** Control CPM output database to d3plot */
    ncpmout: number;
/** Timestep size estimation */
    ncpmts: number;
/** #cpus to use */
    ncpu: number;
/** Rebalancing frequency */
    ncrb: number;
/** Number of cycle between checks of new contact. */
    ncycle: number;
/** normal damping coefficient */
    ndamp: number;
/** A node ID on the outer flange boundary */
    ndouter: number;
/** Print suppression during input: echo file */
    neecho: number;
/** Negative eigenvalue flag */
    negev: number;
/** #eigenvalues to extract; loadcurve if negative */
    neig: number;
/** Number of eigenmodes */
    neig_1: number;
/** Number of eigenmodes to compute for the purpose of orthogonalizing the computed load */
    neig_2: number;
/** Number of eigen values to compute. */
    neig_3: number;
/** New legends */
    newleg: number;
/** Flag for distorted 1 intg point shell check */
    nfail1: number;
/** Flag for distorted 4 intg point shell check */
    nfail4: number;
/** Number of frequencies for FRF output */
    nfreq: number;
/** #intg points for quadratic tets */
    niptets: number;
/** non-linear convergence type */
    nlnorm: number;
/** non-linear solver print flag */
    nlprint: number;
/** Vector length */
    nlq: number;
/** Thermal nonlinear printout level */
    nlthpr: number;
/** Number of modes in modal stress/strain output */
    nmdstr: number;
/** Number of times to use Metis */
    nmetis: number;
/** memory alloc */
    nmneigh: number;
/** number of buckling modes to calculate */
    nmode: number;
/** Tail node defining stone moving direction */
    node1: number;
/** Head node defining stone moving direction */
    node1_1: number;
/** *CONTROL_NONLOCAL card */
    nonlocal: object;
/** Treatment of pressure loads on deleted elements */
    nopdel: number;
/** Flag to turn on unfolding simulation */
    noption: number;
/** Circumvent rigid body inertia check */
    norbic: number;
/** scale factor for normal spring constant */
    normk: number;
/** flag for non-solution run */
    nosol: number;
/** Number of cycles for repartition particles */
    np2p: number;
/** Print suppression during input: printer file */
    npopt: number;
/** #iterations between convergence checks */
    nrcyck: number;
/** Flag to update individual beam 3rd nodes */
    nrefup: number;
/** Normal direction of tool */
    nrmst: number;
/** Normal direction of blank */
    nrsst: number;
/** Nodal rotational convergence tolerance */
    nrtol: number;
/** #cycles between 3D bucket sorts */
    nsbcs: number;
/** Number of steps in non-linear springback */
    nsbs: number;
/** #extra "seed" nodes below */
    nseed: number;
/** erosion option */
    nserod: number;
/** An optional node set ID of three nodes from the source mesh */
    nsets: number;
/** An optional node set ID of three nodes from the target mesh */
    nsett: number;
/** Node set ID of the nodes in the modal model that are subjected to loads */
    nsid: number;
/** node set for attachment modes */
    nsida: number;
/** node set constraint modes */
    nsidc: number;
/** Optional excluded node set */
    nsidebc: number;
/** Optional skipping scheme */
    nskip: number;
/** max number of implicit steps */
    nsmax: number;
/** min number of implicit steps */
    nsmin: number;
/** Non-linear equation solver method */
    nsolvr: number;
/** Consecutive implicit time steps */
    nstep: number;
/** Nodal translational convergence tolerance */
    nttol: number;
/** #rh sides written */
    numrhs: number;
/** Estimated number of unbending */
    nunbend: number;
/** Relaxation parameter */
    omega: number;
/** Output interval for interface file */
    opifs: number;
/** Can be &lt;BLANK&gt; or _BINARY */
    opt: number;
/** Optimize the MPP communications (Range 0/1) */
    optimpp: number;
/** Keyword option */
    option: number;
/** Ordering option */
    order: number;
/** Ordering option */
    order_1: number;
/** Automatic contact segment orientation flag */
    orien: number;
/** Flag to set the global orientation of a forming contact */
    orient: number;
/** Orthogonalise modes wrt each other */
    orthmd: number;
/** Objective stress update for large timestep */
    osu: number;
/** *CONTROL_OUTPUT card */
    output: object;
/** Output Flag */
    output_1: number;
/** TRUE if _&lt;OPTION&gt; is OUTPUT. */
    output_2: boolean;
/** Output flag for stresses */
    output_3: number;
/** Spotweld output flag */
    outseg: number;
/** Decompose the structure and ALE domains together? */
    overlap: boolean;
/** Flag for parallel force assembly */
    para: number;
/** *CONTROL_PARALLEL card */
    parallel: object;
/** Option to force calculation of bonded DES */
    parallel_1: number;
/** Use global mass matrix for mass distribution */
    partm: number;
/** The Part Set ID. */
    partset: number;
/** The Part Set ID. */
    partset_1: number;
/** The  Part Set ID. */
    partset_2: number;
/** The Part Set ID. */
    partset_3: number;
/** Velocity profile of moving tool */
    patern: number;
/** Velocity profile of moving tool */
    patern_1: number;
/** Max pressure difference for stress zeroing */
    pdifmx: number;
/** Default local penalty scale factor */
    pen_sf: number;
/** penetration allowed as ratio of part thickness */
    penchk: number;
/** Penalty stiffness option flag */
    penopt: number;
/** Flag to output contact penetration for mortar contact */
    penout: number;
/** Default bulk modulus of pore fluid */
    pf_bulk: number;
/** Default pore water density */
    pf_rho: number;
/** Phase number */
    phase: number;
/** Phase change penalty parameter */
    phchpn: number;
/** Message to messag file for phase change on materials 216, 217 and 218 */
    phschng: number;
/** Part ID */
    pid: number;
/** Part ID of the sheet blank */
    pid_1: number;
/** Part ID of the sheet blank */
    pid_2: number;
/** Part id to remove adaptive constraints from */
    pid_3: number;
/** Part id of the thin shell elements */
    pid_4: number;
/** Part ID of tool */
    pid_5: number;
/** Part set id for objective stress updates */
    pidosu: number;
/** Automatic generation of *ELEMENT_PLOTEL */
    plotel: number;
/** 10 noded tetrahedral solid node ID 1 */
    pm1: number;
/** 10 noded tetrahedral solid node ID 10 */
    pm10: number;
/** 10 noded tetrahedral solid node ID 2 */
    pm2: number;
/** 10 noded tetrahedral solid node ID 3 */
    pm3: number;
/** 10 noded tetrahedral solid node ID 4 */
    pm4: number;
/** 10 noded tetrahedral solid node ID 5 */
    pm5: number;
/** 10 noded tetrahedral solid node ID 6 */
    pm6: number;
/** 10 noded tetrahedral solid node ID 7 */
    pm7: number;
/** 10 noded tetrahedral solid node ID 8 */
    pm8: number;
/** 10 noded tetrahedral solid node ID 9 */
    pm9: number;
/** Part that defines the punch */
    pnch: number;
/** *CONTROL_PORE_AIR card */
    pore_air: object;
/** *CONTROL_PORE_FLUID card */
    pore_fluid: object;
/** Poissons ratio */
    pr: number;
/** Poissons ratio */
    pr_1: number;
/** Distance between lower binder and punch */
    prebd: number;
/** ref pressure on boundary */
    pref: number;
/** Distance to pre-move tool in reverse direction */
    premove: number;
/** Pressure equalibrium flag */
    prit: number;
/** Projection method for warping stiffness */
    proj: number;
/** Flag to print data for spotwelds */
    prtflg: number;
/** Part set ID */
    pset: number;
/** Optional part set id */
    psfail: number;
/** excluded part set */
    psid: number;
/** Part set ID */
    psid_1: number;
/** part set id for check */
    psnfail: number;
/** part set for thichness update, -ve to exclude */
    psstupd: number;
/** method for penalty stiff calc */
    pstiff: number;
/** scale factor on the contact stress exerted onto shells */
    ptscl: number;
/** Thermal problem type */
    ptype: number;
/** Thermal problem type */
    ptype_1: number;
/** *CONTROL_PWP_AUTO_TMF card */
    pwp_auto_tmf: object;
/** Default linear viscosity coefficient */
    q1: number;
/** Default quadratic viscosity coefficient */
    q2: number;
/** Default hourglass coefficient */
    qh: number;
/** quasi-linear coefficient */
    ql: number;
/** Material anisotropic parameter R00 */
    r00: number;
/** Material anisotropic parameter R00 */
    r00_1: number;
/** Material anisotropic parameter R45 */
    r45: number;
/** Material anisotropic parameter R45 */
    r45_1: number;
/** Material anisotropic parameter R90 */
    r90: number;
/** Material anisotropic parameter R90 */
    r90_1: number;
/** Radius of pre-bending */
    radius: number;
/** Rebalancing option */
    rb: number;
/** Flag to apply consistent treatment of rigid bodies in selective mass scaling */
    rbsms: number;
/** Residual (force) convergence tolerance */
    rctol: number;
/** Factor for capping the amount of dynamic memory requested */
    rdcmem: number;
/** Flag for reference geometry in acoustic eigenvalue analysis */
    refgeo: number;
/** Max #matrix reformations per timestep */
    refmax: number;
/** Relative convergence tolerance */
    reltol: number;
/** *CONTROL_REMESHING card */
    remesh: object;
/** Restart option */
    restrt: number;
/** Restart option */
    restrt_1: number;
/** Surface normal reversing option */
    reverse: number;
/** Right end point finite flag */
    rflag: number;
/** Right end point of interval */
    rhtend: number;
/** *CONTROL_RIGID card */
    rigid: object;
/** Maximum edge length */
    rmax: number;
/** Minimum edge length */
    rmin: number;
/** flag to activate scaling of rotational inertia */
    rmscl: number;
/** Maximum residual convergence tolerance */
    rmtol: number;
/** Scale factor for rotary shell mass */
    rotascl: number;
/** Eigenvalue expansion factor (for eigmth=101) or Convergence tolerance (for eigmth=102) */
    rparm1: number;
/** Absolute tolerance for convergence */
    rparm1_1: number;
/** BLR preconditioner tolerance */
    rparm2: number;
/** Relative tolerance for convergence */
    rparm2_1: number;
/** Replace each beam with a cluster of RPBHX solids */
    rpbhx: number;
/** Rigid body rotational convergence tolerance */
    rrtol: number;
/** Rigid body translational convergence tolerance */
    rttol: number;
/** Rigid wall energy calc flag */
    rwen: number;
/** flag for gap stiffness */
    rwgaps: number;
/** death time for gap stiffness */
    rwgdth: number;
/** penalty scale factor */
    rwksf: number;
/** Scale factor for rigid wall penalties */
    rwpnal: number;
/** Rayleigh energy calc flag */
    rylen: number;
/** Stefan Boltzman constant (w/m**2/K) */
    sbc: number;
/** Static condensation control flag */
    sc_flag: number;
/** Node set ID for nodes to be preserved in the procedure */
    sc_nsid: number;
/** Part set ID for parts to be included in the procedure */
    sc_psid: number;
/** scale factor for artificial stabilization. Loadcurve if negative */
    scale: number;
/** Scale factor for friction stiffness */
    scl_k: number;
/** Name of superelement damping matrix */
    se_damp: string;
/** File name */
    se_filename: string;
/** File name */
    se_filename_1: string;
/** Name of superelement inertia matrix */
    se_inert: string;
/** Name of superelement inertia matrix */
    se_inert_1: string;
/** Name of superelement mass matrix */
    se_mass: string;
/** Name of superelement mass matrix */
    se_mass_1: string;
/** Name of superelement stiffness matrix */
    se_stiff: string;
/** Name of superelement stiffness matrix */
    se_stiff_1: string;
/** angular mesh size in 3-D axisymmetric remeshing */
    segang: number;
/** The  Set ID. Can be SOLID, SHELL or BEAM Set based on value of setyp. */
    set: number;
/** true if _SET option is present. */
    set_option: boolean;
/** Set ID of *SET_SHELL or *SET_SOLID. */
    setid: number;
/** Type of Set. Valid values: 1-Solid Set, 2-Shell Set, 3-Beam Set. */
    setyp: number;
/** Scale factor */
    sf: number;
/** Scale factor */
    sf_1: number;
/** Scale factor of force decay constant */
    sffdc: number;
/** Default static coefficient of friction */
    sfric: number;
/** The Segment Set ID. */
    sgset: number;
/** ratio between sheark/normk */
    sheark: number;
/** *CONTROL_SHELL card */
    shell: object;
/** Shift scale */
    shfscl: number;
/** Flag for assuming edge shape for shells */
    shledg: number;
/** Flag to extrapolate stresses for shells with 8 integration points to nodes */
    shlsig: number;
/** Shell thickness consideration flag */
    shlthk: number;
/** Shell thickness scale factor */
    shltrw: number;
/** Node/Shell set id */
    sid: number;
/** part set for type 4 thickness update where elastic strains are ignored. */
    sidt4tu: number;
/** Minimum element size permitted in the adaptive mesh */
    sizeada: number;
/** Minimum element size permitted in the adaptive mesh */
    sizeada_1: number;
/** Display rigidwall flag */
    skiprwg: number;
/** Contact energy calc flag */
    slnten: number;
/** Scale factor for sliding penalties */
    slsfac: number;
/** Maximum element size */
    smax: number;
/** Element dimension limit for refining */
    smin: number;
/** *CONTROL_SOLID card */
    solid: object;
/** TRUE if a plain (no _SHELL suffix) card exists */
    solitary: number;
/** Solution type flag */
    soln: number;
/** Flag to extrapolate stresses/history variables */
    solsig: number;
/** *CONTROL_SOLUTION card */
    solution: object;
/** Thermal analysis solver type */
    solver: number;
/** Thermal analysis solver type */
    solver_1: number;
/** Use sparse xply routines for modal &amp; stiffness damping matrices */
    sparse: number;
/** Flag to convert constraints on rigid bodies to equivalent *BOUNDARY_PRESCRIBED_MOTION_RIGID motion */
    spc2bnd: number;
/** If SPECIFIC option is used */
    specific: boolean;
/** *CONTROL_SPH card */
    sph: object;
/** Spotweld deletion flag */
    spotdel: number;
/** Optional thickness scale factor */
    spothin: number;
/** Error termination flag on unfound spotweld */
    spotstp: number;
/** *CONTROL_SPOTWELD_BEAM card */
    spotweld_beam: object;
/** factor for reducing feedback */
    sprfac: number;
/** radius of influence */
    srad: number;
/** step reduction factor */
    sred: number;
/** Flag for automatic sort of background triangular shells */
    ssort: number;
/** Shell thickness use flag for type 4 contacts */
    ssthk: number;
/** *CONTROL_STAGED_CONSTRUCTION card */
    staged_construction: object;
/** *CONTROL_START card */
    start: object;
/** Start time for smoothing */
    start_1: number;
/** start time */
    start_2: number;
/** *CONTROL_STEADY_STATE_ROLLING card */
    steady_state_rolling: object;
/** Stepping size of moving stone */
    step: number;
/** Unflanging stiffness */
    stfbend: number;
/** Normal stiffness */
    stfcnt: number;
/** end stage */
    stge: number;
/** start stage */
    stgs: number;
/** ref stage */
    stref: number;
/** Stretch ratio of element diagonals for element deletion */
    stretch: number;
/** *CONTROL_STRUCTURED card */
    structured: object;
/** 0-&gt;blkid is PART, 1-&gt;PARTSET NOTE don't use &lt;type&gt; as in stat_header */
    stype: number;
/** Flag for part/part set */
    stype_1: number;
/** Subcycling flag */
    subcyl: number;
/** output flag for stresses in solid spotwelds */
    swlocl: number;
/** Spot weld radius scale factor */
    swradf: number;
/** tolerance for jacobian in 4-point 10-noded quadratic tetrahedra */
    t10jtol: number;
/** Table ID for scaling shear response */
    t_ors: number;
/** Table for scaling response */
    t_ort: number;
/** target for change of excess pressure */
    targ: number;
/** Target max pwp change/thermal timestep */
    targ_1: number;
/**  */
    target: number;
/** Move tool PID to meet part TARGET */
    target_1: number;
/** Birth time for adaptivity */
    tbirth: number;
/** tangential damping coefficient */
    tdamp: number;
/** tied constraint offset contact update option */
    tdcnof: number;
/** Death time for adaptivity */
    tdeath: number;
/** birth time for dynamic terms. Loadcurve if negative */
    tdybir: number;
/** burial */
    tdybur: number;
/** death */
    tdydth: number;
/** K = Kelvin, C = Celsius, F = Fahrenheit, R = Rankine */
    temp: string;
/** Initial Temperature. */
    tempini: number;
/** End time */
    tend: number;
/** _TERM flag */
    term: number;
/** *CONTROL_TERMINATION card */
    termination: object;
/** tet connectivity output */
    tet10s8: number;
/** global flag for cohesive element deletion */
    tet13k: number;
/** Terminate based on total energy */
    tetol: number;
/** Default contact thickness */
    th: number;
/** Default thickness scale factor */
    th_sf: number;
/** Shell theory to use */
    theory: number;
/** thermal vol expansion coeff */
    therm: number;
/** *CONTROL_THERMAL_EIGENVALUE card */
    thermal_eigenvalue: object;
/** *CONTROL_THERMAL_FORMING card */
    thermal_forming: object;
/** *CONTROL_THERMAL_NONLINEAR card */
    thermal_nonlinear: object;
/** *CONTROL_THERMAL_SOLVER card */
    thermal_solver: object;
/** *CONTROL_THERMAL_TIMESTEP card */
    thermal_timestep: object;
/** Thickness of the thick shell elements */
    thick: number;
/** Blank thickness */
    thick_1: number;
/** Blank thickness */
    thick_2: number;
/** Consider shell thickness change flag */
    thkchg: number;
/** Line search convergence tolerance */
    thlstl: number;
/** Min thickness below which elements are deleted */
    thmn: number;
/** Max thickness beyond which elements are deleted */
    thmx: number;
/** Threshold for rigid body node */
    thresh: number;
/** Thermal shell option */
    thshel: number;
/** Projection bypass flag for TIED_ types */
    tiedprj: number;
/** sec = second, ms = msec/millisec, micro_s = microsec */
    time: string;
/** Number of seconds in the time unit for the input deck */
    time_scale: number;
/** *CONTROL_TIMESTEP card */
    timestep: object;
/** Idle time value */
    timidl: number;
/** Total number of adaptive steps during the forming simulation */
    timsada: number;
/** Thermal time integration parameter */
    tip: number;
/** Joint translational stiffness */
    tjadstf: number;
/** Joint translational damping */
    tjadvsc: number;
/** Maximum thermal timestep, or LC of tmax vs time if -ve */
    tmax: number;
/** Time magnification factor on seepage. Loadcurve if negative */
    tmf: number;
/** Minimum thermal timestep, or LC of tmin vs time if -ve */
    tmin: number;
/** Convergence tolerance for temperature */
    tol: number;
/** Timing output levels */
    tolev: number;
/** Distance to move tool along VID */
    travel: number;
/** Thermal timestep control flag */
    ts: number;
/** Timestep control parameter */
    tscp: number;
/** Thermal speedup factor. Loadcurve if negative */
    tsf: number;
/** Thermal Speedup Factor */
    tsf_1: number;
/** Thermal shell option */
    tshell: number;
/** Min timestep for shell modulus change */
    tslimt: number;
/** Scale factor for computed timestep */
    tssfac: number;
/** Optional timestep factor during DR */
    tssfdr: number;
/** Start time */
    tstart: number;
/** start time */
    tstart_1: number;
/** Thick shell bulk viscosity type */
    tstype: number;
/** Force conversion factor */
    unforc: number;
/** Units for simulation */
    unit: number;
/** Units for simulation */
    unit_1: number;
/** *CONTROL_UNITS card */
    units: object;
/** Length conversion factor */
    unleng: number;
/** Time conversion factor */
    untime: number;
/** Storage for user-controlled friction subroutine */
    usrfrc: number;
/** Storage for user-controlled control subroutine */
    usrstr: number;
/** Vector component defining stoning direction */
    v1: number;
/** Vector component defining stoning direction */
    v2: number;
/** Vector component defining stoning direction */
    v3: number;
/** Excitation input type */
    vad1: number;
/** Response output type */
    vad2: number;
/** Loading type */
    vaflag: number;
/** Flag for PSD broadband plots */
    vaplot: number;
/** Flag for including preload */
    vaprld: number;
/** Flag for PSD output */
    vapsd: number;
/** Variable thermal density flag */
    varden: number;
/** Flag for RMS output */
    varms: number;
/** Flag for including stress analysis */
    vastrs: number;
/** The Vector ID to define x-direction. */
    vecid1: number;
/** The Vector ID to define y-direction. */
    vecid2: number;
/** true if _VECTOR option is set */
    vector: boolean;
/** Void factor */
    vfact: number;
/** Default viscous friction coefficient */
    vfc: number;
/** necessary VF loss for remesh */
    vfloss: number;
/** *CONTROL_VIBRO_ACOUSTIC card */
    vibro_acoustic: object;
/** Vector ID defining direction of movement */
    vid: number;
/** Vector ID defining direction of travel */
    vid_1: number;
/** Vector ID for DOF1=4 */
    vid_2: number;
/** Maximum allowable tool velocity */
    vmax: number;
/** Maximum allowable tool velocity */
    vmax_1: number;
/** volume fraction */
    vol: number;
/** max number of subcycling cycles */
    vtk: number;
/** X component of vector defining the direction of distance in load curve */
    vx: number;
/** X component of axis about which blank will be bent */
    vx_1: number;
/** X vector component of movement of punch */
    vx_2: number;
/** Y component of vector defining the direction of distance in load curve */
    vy: number;
/** Y component of axis about which blank will be bent */
    vy_1: number;
/** Y vector component of movement of punch */
    vy_2: number;
/** Z component of vector defining the direction of distance in load curve */
    vz: number;
/** Z component of axis about which blank will be bent */
    vz_1: number;
/** Z vector component of movement of punch */
    vz_2: number;
/** Coefficient in equation */
    weight: number;
/** Coefficient in equation */
    weight_1: number;
/** Width of the stone */
    width: number;
/** W-mode amplitude for element deletion (deg) */
    wmode: number;
/** Shell warpage angle (deg) */
    wrpang: number;
/** Default elevation of water table */
    wtable: number;
/** Starting position x coordinate */
    x0: number;
/** Surface max penetration check multiplier */
    xpene: number;
/** Starting position y coordinate */
    y0: number;
/** Starting position z coordinate */
    z0: number;
/** flag to zero vels before switch to implicit */
    zero_v: number;
/** Modal dynamic damping constant */
    zeta: number;
/** Modal dynamic damping constant */
    zeta_1: number;
}


/** Object returned by GetSettings */
interface GetSettingsReturn {
    /** Angle tolerance */
    angle_tolerance: number;
    /** Adjust bolt mass when creating bolt entitites */
    bolt_adjust_mass: boolean;
    /** Add database history beam when bolt beam is created */
    bolt_dth_beam: boolean;
    /** Consider feature line for bolt holes */
    bolt_feature_line: boolean;
    /** Bolt rigid NRB minimum mass */
    bolt_nrb_min_mass: number;
    /** Bolt rigid part minimum mass */
    bolt_part_min_mass: number;
    /** Allow connections to join a clinch type connection */
    clinch: boolean;
    /** Edge distance */
    edge_distance: number;
    /** Glue break angle */
    glue_break_angle: number;
    /** Glue hard aspect ratio */
    glue_hard_aspect: number;
    /** Glue soft aspect ratio */
    glue_soft_aspect: number;
    /** Check length */
    length_check: boolean;
    /** Maximum length */
    max_length: number;
    /** Maximum number of panels */
    max_panels: number;
    /** Maximum warpage */
    max_warpage: number;
    /** Minimum length */
    min_length: number;
    /** Check for maximum number of panels */
    panel_check: boolean;
    /** Patch angle setting */
    patch_angle: number;
    /** Turn on or off patch angle check */
    patch_angle_check: boolean;
    /** Allow connections to join a part to itself */
    same_part: boolean;
    /** Consider free edges when orienting single solid spotwelds */
    solid_free_edges: boolean;
    /** Spotweld line search tolerance */
    spot_line_tol: number;
    /** Search thickness */
    spot_thickness: number;
    /** Total length */
    total_length: number;
    /** Use _PID for beam connections */
    use_pid: boolean;
    /** Check warpage value */
    warpage_check: boolean;
}


/** Object function argument in SetSettings */
interface SetSettingsArgument_data {
    /** Angle tolerance */
    angle_tolerance?: number;
    /** Adjust bolt mass when creating bolt entities */
    bolt_adjust_mass?: boolean;
    /** Add database history beam when bolt is created */
    bolt_dth_beam?: boolean;
    /** Consider feature line for bolt holes */
    bolt_feature_line?: boolean;
    /** Bolt NRB minimum mass */
    bolt_nrb_min_mass?: number;
    /** Bolt rigid part minimum mass */
    bolt_part_min_mass?: number;
    /** Allow connections to join a clinch type connection */
    clinch?: boolean;
    /** Edge distance */
    edge_distance?: number;
    /** Glue break angle */
    glue_break_angle?: number;
    /** Glue hard aspect ratio */
    glue_hard_aspect?: number;
    /** Glue soft aspect ratio */
    glue_soft_aspect?: number;
    /** Check the connection length */
    length_check?: boolean;
    /** Maximum length of connection */
    max_length?: number;
    /** Maximum number of panels */
    max_panels?: number;
    /** Maximum warpage */
    max_warpage?: number;
    /** Minimum length of connection */
    min_length?: number;
    /** Check for maximum number of panels */
    panel_check?: boolean;
    /** Patch angle */
    patch_angle?: number;
    /** Check the patch angle */
    patch_angle_check?: boolean;
    /** Allow connections to join a part to itself */
    same_part?: boolean;
    /** Consider free edges when orienting single solid spotwelds */
    solid_free_edges?: boolean;
    /** Spotweld line search tolerance */
    spot_line_tol?: number;
    /** Search thickness */
    spot_thickness?: number;
    /** Total length of connection */
    total_length?: number;
    /** Use _PID for beam connections */
    use_pid?: boolean;
    /** Check warpage value */
    warpage_check?: boolean;
}

declare class Conx {
/**
 * Blanks the connection
 */
    Blank(): void;

/**
 * Blanks all of the connections in the model.
 * @param Model Model that all connections will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged connections in the model.
 * @param Model Model that all the flagged connections will be blanked in
 * @param flag Flag set on the connections that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the connection is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the connection.
 * @param flag Flag to clear on the connection
 */
    ClearFlag(flag: number): void;

/**
 * Copies the connection.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Conx;

/**
 * Empties the patch topology/coordinates data.
 */
    EmptyPatch(): void;

/**
 * Adds an error for connection. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for connection. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the connection colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the connection.
 */
    ExtractColour(): number;

/**
 * Returns the first connection in the model.
 * @param Model Model to get first connection in
 */
    static First(Model: Model): Conx;

/**
 * Returns the first free connection label in the model. Also see Conx.LastFreeLabel(), Conx.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free connection label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the connections in the model with a defined flag.
 * @param Model Model that all connections will be flagged in
 * @param flag Flag to set on the connections
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the connection is flagged or not.
 * @param flag Flag to test on the connection
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each connection in the model. Note that ForEach has been designed to make looping over connections as fast as possible and so has some limitations. Firstly, a single temporary Conx object is created and on each function call it is updated with the current connection data. This means that you should not try to store the Conx object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new connections inside a ForEach loop. 
 * @param Model Model that all connections are in
 * @param func Function to call for each connection
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Conx objects for all of the connections in a model in Primer
 * @param Model Model to get connections from
 */
    static GetAll(Model: Model): Conx[];

/**
 * Returns the beams/solids that are used in the connection.
 */
    GetElements(): number[];

/**
 * Returns an array of Conx objects for all of the flagged connections in a model in Primer
 * @param Model Model to get connections from
 * @param flag Flag set on the connections that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Conx[];

/**
 * Returns the Conx object for a connection ID.
 * @param Model Model to find the connection in
 * @param number number of the connection you want the Conx object for
 */
    static GetFromID(Model: Model, number: number): Conx;

/**
 * Returns the data for a layer of the connection.
 * @param layer The layer you want the data for. Note that layers start at 0, not 1.
 */
    GetLayerData(layer: number): number[];

/**
 * Returns the attached shells for a layer of the connection.
 * @param layer The layer you want the data for. Note that layers start at 0, not 1.
 */
    GetLayerShells(layer: number): Shell[];

/**
 * Checks if a Conx property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Conx.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop connection property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the data for a patch coordinate of an adhesive patch connection.
 * @param point The point you want the data for. Note that points start at 0, not 1.
 */
    GetPatchCoords(point: number): number[];

/**
 * Returns the topology for a patch quad/tria of an adhesive patch connection.
 * @param point The patch quad/tria you want the data for. Note that points start at 0, not 1.
 */
    GetPatchTopol(point: number): number[];

/**
 * Returns the data for a path point of an adhesive/spotweld line connection.
 * @param point The point you want the data for. Note that points start at 0, not 1.
 */
    GetPathData(point: number): number[];

/**
 * Returns an array of Part objects for the connection FE entities. A connection can contain elements with different part ID's between different layers. If one part ID is returned, that part is used for all elements in the connection. Not applicable for bolts.
 */
    GetPidData(): Part[];

/**
 * Returns an object of settings stored with the connection.
 */
    GetSettings(): GetSettingsReturn;

/**
 * Returns the keyword for this connection (*CONNECTION_START_SPOTWELD etc). Note that a carriage return is not added. See also Conx.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the connection. Note that a carriage return is not added. See also Conx.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last connection in the model.
 * @param Model Model to get last connection in
 */
    static Last(Model: Model): Conx;

/**
 * Returns the last free connection label in the model. Also see Conx.FirstFreeLabel(), Conx.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free connection label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next connection in the model.
 */
    Next(): Conx;

/**
 * Returns the next free (highest+1) connection label in the model. Also see Conx.FirstFreeLabel(), Conx.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free connection label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a connection.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only connections from that model can be picked. If the argument is a Flag then only connections that are flagged with limit can be selected. If omitted, or null, any connections from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Conx;

/**
 * Returns the previous connection in the model.
 */
    Previous(): Conx;

/**
 * Realizes all of the connections in the model.
 * @param Model Model that all connections will be realized in
 */
    static RealizeAll(Model: Model): void;

/**
 * Realizes all of the flagged connections in the model.
 * @param Model Model that the flagged connections will be realized in
 * @param flag Flag set on the connections that you want to realize
 */
    static RealizeFlagged(Model: Model, flag: number): void;

/**
 * Reload all modules from primer_library/connectors
 */
    static ReloadConnectors(): void;

/**
 * Deletes the topology at a particular location for patch type adhesive.
 * @param layer The topology location you want to remove. Note that layers start at 0, not 1.
 */
    RemovePatchTopol(layer: number): void;

/**
 * Deletes a pathc point for a line adhesive connection.
 * @param layer The point you want to remove. Note that layers start at 0, not 1.
 */
    RemovePathData(layer: number): void;

/**
 * Renumbers all of the connections in the model.
 * @param Model Model that all connections will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged connections in the model.
 * @param Model Model that all the flagged connections will be renumbered in
 * @param flag Flag set on the connections that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select connections using standard PRIMER object menus.
 * @param flag Flag to use when selecting connections
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only connections from that model can be selected. If the argument is a Flag then only connections that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any connections can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the connection.
 * @param flag Flag to set on the connection
 */
    SetFlag(flag: number): void;

/**
 * Sets the data for a layer of the connection.
 * @param layer The layer you want to set the data for. Note that layers start at 0, not 1.
 * @param item1 The first item for the layer definition. As layer definitions can be part IDs, part names, CAD names, part set IDs, part set names or assemby names the following logic is used. If the item is an integer it is assumed to be a part ID. If the item is a string then it must be in the format 'P&lt;part ID&gt;', 'P:&lt;part name&gt;', 'C:&lt;CAD name&gt;', 'S&lt;set ID&gt;', 'S:&lt;set name&gt;'or 'A:&lt;assembly name&gt;'.
 * @param item2 The second item for the layer definition. This must be type same type as item1. e.g. if item1 is a part ID, item2 must be a part ID (it cannot be a part name etc).
 * @param ...vars The nth item for the layer definition. This must be type same type as item1. e.g. if item1 is a part ID, this item must be a part ID (it cannot be a part name etc).
 */
    SetLayerData(layer: number, item1: number, item2?: number, ...vars?: number[]): void;

/**
 * Sets a coordinate used by the adhesive patch connection type.
 * @param point The point you want to set the data for. Note that points start at 0, not 1.
 * @param x X coordinate of point
 * @param y Y coordinate of point
 * @param z Z coordinate of point
 */
    SetPatchCoords(point: number, x: number, y: number, z: number): void;

/**
 * Sets the topology used by the adhesive patch connection type.
 * @param point The point you want to set the data for. Note that points start at 0, not 1.
 * @param c1 1st coordinate location point
 * @param c2 2nd coordinate location point
 * @param c3 3rd coordinate location point
 * @param c4 4th coordinate location point
 */
    SetPatchTopol(point: number, c1: number, c2: number, c3: number, c4?: number): void;

/**
 * Sets the data for a path point of the connection.
 * @param point The point you want to set the data for. Note that points start at 0, not 1.
 * @param x X coordinate of point
 * @param y Y coordinate of point
 * @param z Z coordinate of point
 */
    SetPathData(point: number, x: number, y: number, z: number): void;

/**
 * Sets the element part IDs for the connection. A different part can be defined for elements in the connection between different layers. Not applicable for bolts.
 * @param item1 Part label of the first item in the PID layer list.
 * @param item2 The second item for the layer definition.
 * @param ...vars The nth item for the layer definition.
 */
    SetPidData(item1: number, item2?: number, ...vars?: number[]): void;

/**
 * Set the diameter for a spotweld ring when running a rule. Note that this method can only be called when running a connection rule script. It will not have any effect if used in a 'normal' script.
 * @param diameter The diameter to set for the ring
 */
    static SetRuleDiameter(diameter: number): void;

/**
 * Set the PID for spotweld beam/solid elements or adhesive solids when running a rule. Note that this method can only be called when running a connection rule script. It will not have any effect if used in a 'normal' script.
 * @param pid The PID to set for the spotweld or adhesive elements
 */
    static SetRuleFEPID(pid: number): void;

/**
 * Set the PID for a spotweld ring when running a rule. Note that this method can only be called when running a connection rule script. It will not have any effect if used in a 'normal' script.
 * @param pid The PID to set for the ring
 */
    static SetRulePID(pid: number): void;

/**
 * Sets the settings stored on a connection entity. Not applicable for bolts.
 * @param data Object containing the connection settings data. The properties can be:
 */
    SetSettings(data: SetSettingsArgument_data): void;

/**
 * Sketches the connection. The connection will be sketched until you either call Conx.Unsketch(), Conx.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the connection is sketched. If omitted redraw is true. If you want to sketch several connections and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged connections in the model. The connections will be sketched until you either call Conx.Unsketch(), Conx.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged connections will be sketched in
 * @param flag Flag set on the connections that you want to sketch
 * @param redraw If model should be redrawn or not after the connections are sketched. If omitted redraw is true. If you want to sketch flagged connections several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of connections in the model.
 * @param Model Model to get total for
 * @param exists true if only existing connections should be counted. If false or omitted referenced but undefined connections will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the connection
 */
    Unblank(): void;

/**
 * Unblanks all of the connections in the model.
 * @param Model Model that all connections will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged connections in the model.
 * @param Model Model that the flagged connections will be unblanked in
 * @param flag Flag set on the connections that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the connections in the model.
 * @param Model Model that the defined flag for all connections will be unset in
 * @param flag Flag to unset on the connections
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the connection.
 * @param redraw If model should be redrawn or not after the connection is unsketched. If omitted redraw is true. If you want to unsketch several connections and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all connections.
 * @param Model Model that all connections will be unblanked in
 * @param redraw If model should be redrawn or not after the connections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged connections in the model.
 * @param Model Model that all connections will be unsketched in
 * @param flag Flag set on the connections that you want to unsketch
 * @param redraw If model should be redrawn or not after the connections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Conx;

/**
 * Adds a warning for connection. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this connection.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Conx object.
 * @param Model Model that connection will be created in
 * @param x X coordinate
 * @param y Y coordinate
 * @param z Z coordinate
 * @param type Type of connection. Can be Conx.SPOTWELD, Conx.BOLT, Conx.ADHESIVE or Conx.SPOTWELD_LINEIf omitted type will be set to Conx.SPOTWELD.
 * @param subtype Subtype of connection. See property subtype for valid values. If omitted subtype will be set to the default subtype for this type of connection.
 * @param title Title for the connection
 */
    constructor(Model: Model, x: number, y: number, z: number, type?: number, subtype?: number, title?: string);

/**
 * Creates a string containing the connection data in keyword format. Note that this contains the keyword header and the keyword cards. See also Conx.Keyword() and Conx.KeywordCards().
 */
    toString(): string;

/** Element size along the length of the adhesive run */
    adhesive_esize: number;
/** The number of elements across the width of the adhesive */
    adhesive_nelem: number;
/** The width of the adhesive run */
    adhesive_width: number;
/** angle tolerance for bolt */
    angtol: number;
/** angle tolerance at end 2 for 2 point bolt */
    angtol2: number;
/** Assembly used to specify panels connection together, rather than individual layers. Integer for a part set ID, string for a Primer assembly (name). */
    assembly: number;
/** The assembly type. Can be Conx.PART_SET or Conx.ASSEMBLY. */
    assembly_type: number;
/** The colour of the connection */
    colour: Colour;
/** Diameter of spotweld/rigid */
    diameter: number;
/** Diameter of rigid at end 2 */
    diameter2: number;
/** Spotweld line edge distance */
    edge_distance: number;
/** true if a spotweld line is locked to an edge, false if not */
    edge_lock: boolean;
/** Description of the error if the connection cannot be made (read only) */
    readonly error: string;
/** Details of the error if the connection cannot be made (read only) */
    readonly error_details: string;
/** contact fitting method for library bolts */
    fit: number;
/** Conx number. Also see the label property which is an alternative name for this. */
    id: number;
/** The Include file number that the connection is in. */
    include: number;
/** Conx number. Also see the id property which is an alternative name for this. */
    label: number;
/** The number of layers the connection has. */
    layers: number;
/** Length of 1 point bolt, max thickness for 2 point bolt */
    length: number;
/** max thickness at end 2 for 2 point bolt */
    length2: number;
/** The ID of the Material used for 'merge' bolt connections. i.e. Conx.BOLT_MRG_CYL, Conx.BOLT_MRG_CYL_BEAM, */
    material: number;
/** The Model number that the connection is in. */
    model: number;
/** name of library module for bolt */
    module: string;
/** The ID of the Part used for adhesive or spotweld connections. Note that in v11.0 and above you are able to specify a different part IDs for elements in the connection between different layers. If you only have one part for the elements in the connection, then this is the value of this property. If there is more than one used, then the value of this property is the first part. If you set this property to a new value, then the all the elements in the connection will have this new part ID when it is realized. To set and retrieve information on parts used between different layers, the functions GetPidData() and SetPidData() should be used. */
    part: number;
/** The number of patch coordinate points the connection has (Adhesive patch only). */
    patch_coords: number;
/** The number of patch topology entries the connection has (Adhesive patch only). */
    patch_topol: number;
/** The number of path points the connection has (Adhesive only). Note that these points do NOT include the start and end points for the adhesive run. These are defined using the properties x, y, z and x2, y2, z2 */
    path: number;
/** Spotweld line pitch */
    pitch: number;
/** snap to points fitting method for library bolts */
    resize: number;
/** Whether settings are saved for a connection or not */
    saved_settings: boolean;
/** shape for bolt attachment */
    shape: number;
/** shape for bolt attachment at end 2 for 2 point bolt */
    shape2: number;
/** The status of the connection. (read only). Can be Conx.DORMANT, Conx.MADE, Conx.INVALID, Conx.REALIZED or Conx.BAD. */
    readonly status: number;
/** The connection subtype. For SPOTWELD and SPOTWELD_LINE connections the subtype can be:  Conx.SPOTWELD_BEAM Conx.SPOTWELD_MIG Conx.SPOTWELD_SOLID1 Conx.SPOTWELD_SOLID4 Conx.SPOTWELD_SOLID8 Conx.SPOTWELD_SOLID12 Conx.SPOTWELD_SOLID16  For BOLT connections the subtype can be:  Conx.BOLT_MRG_CYL Conx.BOLT_MRG_CYL_BEAM Conx.BOLT_MRG_CYL_BALL Conx.BOLT_MRG_2PTS Conx.BOLT_MRG_2PTS_RB Conx.BOLT_MRG_2PTS_RJ Conx.BOLT_MRG_CYL Conx.BOLT_NRB_CYL_BEAM Conx.BOLT_NRB_CYL_BALL Conx.BOLT_NRB_SPH Conx.BOLT_NRB_SPH_BALL Conx.BOLT_NRB_SPH_DISC Conx.BOLT_NRB_2PTS Conx.BOLT_MODULE  For ADHESIVE connections the subtype can be: Conx.ADHESIVE_SOLID. Conx.ADHESIVE_PATCH. */
    subtype: number;
/** Title for connection */
    title: string;
/** The transparency of the connection (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** The connection type. Can be Conx.SPOTWELD, Conx.BOLT or Conx.ADHESIVE. */
    type: number;
/** User data for connection */
    user_data: string;
/** X coordinate */
    x: number;
/** X coordinate for second point (adhesive only) */
    x2: number;
/** Y coordinate */
    y: number;
/** Y coordinate for second point (adhesive only) */
    y2: number;
/** Z coordinate */
    z: number;
/** Z coordinate for second point (adhesive only) */
    z2: number;
/** Connection is adhesive. */
    static ADHESIVE: number;
/** Connection adhesive type is a patch. */
    static ADHESIVE_PATCH: number;
/** Connection adhesive type is a solid line. */
    static ADHESIVE_SOLID: number;
/** If the connection refers to an assembly rather than individual layers, the assembly is defined by part tree assembly. */
    static ASSEMBLY: number;
/** Connection is bad (e.g. necessary data is missing). */
    static BAD: number;
/** Connection is a bolt. */
    static BOLT: number;
/** Library bolt. */
    static BOLT_MODULE: number;
/** 2pt Patch Beam. */
    static BOLT_MRG_2PTS: number;
/** 2pt Patch (Rigid Beam). */
    static BOLT_MRG_2PTS_RB: number;
/** 2pt Patch Revolute joint. */
    static BOLT_MRG_2PTS_RJ: number;
/** Cylindrical Merge. */
    static BOLT_MRG_CYL: number;
/** Cylindrical Patch Ball joint. */
    static BOLT_MRG_CYL_BALL: number;
/** Cylindrical Patch Beam. */
    static BOLT_MRG_CYL_BEAM: number;
/** 2pt NRB Beam. */
    static BOLT_NRB_2PTS: number;
/** Cylindrical NRB. */
    static BOLT_NRB_CYL: number;
/** Cylindrical NRB Ball joint. */
    static BOLT_NRB_CYL_BALL: number;
/** Cylindrical NRB Beam. */
    static BOLT_NRB_CYL_BEAM: number;
/** Spherical NRB. */
    static BOLT_NRB_SPH: number;
/** Spherical NRB Ball joint. */
    static BOLT_NRB_SPH_BALL: number;
/** Spherical NRB Discrete Beam. */
    static BOLT_NRB_SPH_DISC: number;
/** Connection is dormant (not yet made). */
    static DORMANT: number;
/** Connection has been made but something is wrong (e.g. part moved). */
    static INVALID: number;
/** Connection has been made but status is unknown. */
    static MADE: number;
/** If the connection refers to an assembly rather than individual layers, the assembly is defined by part set. */
    static PART_SET: number;
/** Connection has been made and is OK (checks OK). */
    static REALIZED: number;
/** Connection is a spotweld. */
    static SPOTWELD: number;
/** Connection spotweld type is beam. */
    static SPOTWELD_BEAM: number;
/** Connection is a spotweld line. */
    static SPOTWELD_LINE: number;
/** Connection spotweld type is (beam) MIG weld. */
    static SPOTWELD_MIG: number;
/** Connection spotweld type is one solid/spotweld layer. */
    static SPOTWELD_SOLID1: number;
/** Connection spotweld type is twelve solids/spotweld layer. */
    static SPOTWELD_SOLID12: number;
/** Connection spotweld type is sixteen solids/spotweld layer. */
    static SPOTWELD_SOLID16: number;
/** Connection spotweld type is four solids/spotweld layer. */
    static SPOTWELD_SOLID4: number;
/** Connection spotweld type is eight solids/spotweld layer. */
    static SPOTWELD_SOLID8: number;
}

declare class CoordinateSystem {
/**
 * Blanks the coordinate system
 */
    Blank(): void;

/**
 * Blanks all of the coordinate systems in the model.
 * @param Model Model that all coordinate systems will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged coordinate systems in the model.
 * @param Model Model that all the flagged coordinate systems will be blanked in
 * @param flag Flag set on the coordinate systems that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the coordinate system is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the coordinate system.
 * @param flag Flag to clear on the coordinate system
 */
    ClearFlag(flag: number): void;

/**
 * Copies the coordinate system.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): CoordinateSystem;

/**
 * Starts an interactive editing panel to create a csys.
 * @param Model Model that the csys will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): CoordinateSystem;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for coordinate system. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first coordinate system in the model.
 * @param Model Model to get first coordinate system in
 */
    static First(Model: Model): CoordinateSystem;

/**
 * Returns the first free coordinate system label in the model. Also see CoordinateSystem.LastFreeLabel(), CoordinateSystem.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free coordinate system label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the coordinate systems in the model with a defined flag.
 * @param Model Model that all coordinate systems will be flagged in
 * @param flag Flag to set on the coordinate systems
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the coordinate system is flagged or not.
 * @param flag Flag to test on the coordinate system
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each coordinate system in the model. Note that ForEach has been designed to make looping over coordinate systems as fast as possible and so has some limitations. Firstly, a single temporary CoordinateSystem object is created and on each function call it is updated with the current coordinate system data. This means that you should not try to store the CoordinateSystem object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new coordinate systems inside a ForEach loop. 
 * @param Model Model that all coordinate systems are in
 * @param func Function to call for each coordinate system
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of CoordinateSystem objects for all of the coordinate systems in a model in Primer
 * @param Model Model to get coordinate systems from
 */
    static GetAll(Model: Model): CoordinateSystem[];

/**
 * Returns an array of CoordinateSystem objects for all of the flagged coordinate systems in a model in Primer
 * @param Model Model to get coordinate systems from
 * @param flag Flag set on the coordinate systems that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): CoordinateSystem[];

/**
 * Returns the CoordinateSystem object for a coordinate system ID.
 * @param Model Model to find the coordinate system in
 * @param number number of the coordinate system you want the CoordinateSystem object for
 */
    static GetFromID(Model: Model, number: number): CoordinateSystem;

/**
 * Checks if a CoordinateSystem property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the CoordinateSystem.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop coordinate system property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this csys (*DEFINE_COORDINATE). Note that a carriage return is not added. See also CoordinateSystem.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the csys. Note that a carriage return is not added. See also CoordinateSystem.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last coordinate system in the model.
 * @param Model Model to get last coordinate system in
 */
    static Last(Model: Model): CoordinateSystem;

/**
 * Returns the last free coordinate system label in the model. Also see CoordinateSystem.FirstFreeLabel(), CoordinateSystem.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free coordinate system label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next coordinate system in the model.
 */
    Next(): CoordinateSystem;

/**
 * Returns the next free (highest+1) coordinate system label in the model. Also see CoordinateSystem.FirstFreeLabel(), CoordinateSystem.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free coordinate system label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a coordinate system.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only coordinate systems from that model can be picked. If the argument is a Flag then only coordinate systems that are flagged with limit can be selected. If omitted, or null, any coordinate systems from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): CoordinateSystem;

/**
 * Returns the previous coordinate system in the model.
 */
    Previous(): CoordinateSystem;

/**
 * Renumbers all of the coordinate systems in the model.
 * @param Model Model that all coordinate systems will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged coordinate systems in the model.
 * @param Model Model that all the flagged coordinate systems will be renumbered in
 * @param flag Flag set on the coordinate systems that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select coordinate systems using standard PRIMER object menus.
 * @param flag Flag to use when selecting coordinate systems
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only coordinate systems from that model can be selected. If the argument is a Flag then only coordinate systems that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any coordinate systems can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the coordinate system.
 * @param flag Flag to set on the coordinate system
 */
    SetFlag(flag: number): void;

/**
 * Sketches the coordinate system. The coordinate system will be sketched until you either call CoordinateSystem.Unsketch(), CoordinateSystem.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the coordinate system is sketched. If omitted redraw is true. If you want to sketch several coordinate systems and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged coordinate systems in the model. The coordinate systems will be sketched until you either call CoordinateSystem.Unsketch(), CoordinateSystem.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged coordinate systems will be sketched in
 * @param flag Flag set on the coordinate systems that you want to sketch
 * @param redraw If model should be redrawn or not after the coordinate systems are sketched. If omitted redraw is true. If you want to sketch flagged coordinate systems several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of coordinate systems in the model.
 * @param Model Model to get total for
 * @param exists true if only existing coordinate systems should be counted. If false or omitted referenced but undefined coordinate systems will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the coordinate system
 */
    Unblank(): void;

/**
 * Unblanks all of the coordinate systems in the model.
 * @param Model Model that all coordinate systems will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged coordinate systems in the model.
 * @param Model Model that the flagged coordinate systems will be unblanked in
 * @param flag Flag set on the coordinate systems that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the coordinate systems in the model.
 * @param Model Model that the defined flag for all coordinate systems will be unset in
 * @param flag Flag to unset on the coordinate systems
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the coordinate system.
 * @param redraw If model should be redrawn or not after the coordinate system is unsketched. If omitted redraw is true. If you want to unsketch several coordinate systems and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all coordinate systems.
 * @param Model Model that all coordinate systems will be unblanked in
 * @param redraw If model should be redrawn or not after the coordinate systems are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged coordinate systems in the model.
 * @param Model Model that all coordinate systems will be unsketched in
 * @param flag Flag set on the coordinate systems that you want to unsketch
 * @param redraw If model should be redrawn or not after the coordinate systems are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): CoordinateSystem;

/**
 * Adds a warning for coordinate system. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this coordinate system.
 */
    Xrefs(): Xrefs;

/**
 * Create a new CoordinateSystem object for *DEFINE_COORDINATE_NODES.
 * @param Model Model that csys will be created in
 * @param option Must be CoordinateSystem.NODES
 * @param cid CoordinateSystem number
 * @param n1 Node located at origin
 * @param n2 Node located along (DIR) axis
 * @param n3 Node located in plane defined by (DIR)
 * @param flag Flag for local system update each time step
 * @param dir Axis defined by N1N2
 * @param heading Title for the csys
 */
    constructor(Model: Model, option: number, cid: number, n1: number, n2: number, n3: number, flag: boolean, dir: number, heading?: string);

/**
 * Create a new CoordinateSystem object for *DEFINE_COORDINATE_SYSTEM.
 * @param Model Model that csys will be created in
 * @param option Must be CoordinateSystem.SYSTEM
 * @param cid CoordinateSystem number
 * @param ox X-coordinate of origin
 * @param oy Y-coordinate of origin
 * @param oz Z-coordinate of origin
 * @param lx X-coordinate of point on local X-axis
 * @param ly Y-coordinate of point on local X-axis
 * @param lz Z-coordinate of point on local X-axis
 * @param px X-coordinate of point in local X-Y plane
 * @param py Y-coordinate of point in local X-Y plane
 * @param pz Z-coordinate of point in local X-Y plane
 * @param heading Title for the csys
 */
    constructor(Model: Model, option: number, cid: number, ox: number, oy: number, oz: number, lx: number, ly: number, lz: number, px: number, py: number, pz: number, heading?: string);

/**
 * Create a new CoordinateSystem object for *DEFINE_COORDINATE_VECTOR.
 * @param Model Model that csys will be created in
 * @param option Must be CoordinateSystem.VECTOR
 * @param cid CoordinateSystem number
 * @param xx X-coordinate on local X-axis
 * @param xy Y-coordinate on local X-axis
 * @param xz Z-coordinate on local X-axis
 * @param vx X-coordinate of local X-Y vector
 * @param vy Y-coordinate of local X-Y vector
 * @param vz Z-coordinate of local X-Z vector
 * @param nid Optional node id for rotation
 */
    constructor(Model: Model, option: number, cid: number, xx: number, xy: number, xz: number, vx: number, vy: number, vz: number, nid: number);

/**
 * Creates a string containing the csys data in keyword format. Note that this contains the keyword header and the keyword cards. See also CoordinateSystem.Keyword() and CoordinateSystem.KeywordCards().
 */
    toString(): string;

/** CoordinateSystem number. Also see the label number. */
    cid: number;
/** Optional local coordinate system to define the points in */
    cidl: number;
/** Axis defined by N1N2 */
    dir: number;
/** true if csys exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Flag for updating local system each timestep */
    flag: boolean;
/** CoordinateSystem heading */
    heading: string;
/** The Include file number that the csys is in. */
    include: number;
/** CoordinateSystem number. Also see the cid property which is an alternative name for this. */
    label: number;
/** X-coordinate of point on local X-axis */
    lx: number;
/** Y-coordinate of point on local X-axis */
    ly: number;
/** Z-coordinate of point on local X-axis */
    lz: number;
/** The Model number that the coordinate system is in. */
    model: number;
/** Node located at local origin */
    n1: number;
/** Node located along local (dir) axis */
    n2: number;
/** Node located in local plane determined by (dir) */
    n3: number;
/** Optional node id for rotation */
    nid: number;
/** CoordinateSystem type (Can be CoordinateSystem.NODES, CoordinateSystem.SYSTEM or CoordinateSystem.VECTOR). */
    option: number;
/** X-coordinate of origin */
    ox: number;
/** Y-coordinate of origin */
    oy: number;
/** Z-coordinate of origin */
    oz: number;
/** X-coordinate of point in local X-Y plane */
    px: number;
/** Y-coordinate of point in local X-Y plane */
    py: number;
/** Z-coordinate of point in local X-Y plane */
    pz: number;
/** X-coordinate of local X-Y vector */
    vx: number;
/** Y-coordinate of local X-Y vector */
    vy: number;
/** Z-coordinate of local X-Z vector */
    vz: number;
/** X-coordinate on local X-axis */
    xx: number;
/** Y-coordinate on local X-axis */
    xy: number;
/** Z-coordinate on local X-axis */
    xz: number;
/** Csys is *DEFINE_COORDINATE_NODES. */
    static NODES: number;
/** Csys is *DEFINE_COORDINATE_SYSTEM. */
    static SYSTEM: number;
/** Csys is *DEFINE_COORDINATE_VECTOR. */
    static VECTOR: number;
}


/** Object returned by Properties */
interface PropertiesReturn {
    /** Area of material sliced by the cut section */
    area: number;
    /** First yield axial force */
    first_yield_axial: number;
    /** First yield bending moment (Mxx) */
    first_yield_mxx: number;
    /** First yield bending moment (Myy) */
    first_yield_myy: number;
    /** Fully plastic bending moment (Mxx) */
    fully_plastic_mxx: number;
    /** Fully plastic bending moment (Myy) */
    fully_plastic_myy: number;
    /** Eq force axis Xf */
    fully_plastic_xf: number;
    /** Fully plastic axial force */
    fully_plastic_yf: number;
    /** Iuu principal second moments (UU - major) */
    iuu: number;
    /** Ivv principal second moments (VV - minor) */
    ivv: number;
    /** Ixx component of second moment of area */
    ixx: number;
    /** Ixy component of second moment of area */
    ixy: number;
    /** Iyy component of second moment of area */
    iyy: number;
    /** X component of section origin */
    origin_x: number;
    /** Y component of section origin */
    origin_y: number;
    /** Z component of section origin */
    origin_z: number;
    /** Angle between Ixx and Iuu */
    theta: number;
    /** X component of X-axis vector */
    x_comp_axis_x: number;
    /** X component of Y-axis vector */
    x_comp_axis_y: number;
    /** X component of Z-axis vector */
    x_comp_axis_z: number;
    /** X component of centroid calculated from the first moment of area */
    xc: number;
    /** X component of centre of gravity calculated in global coordinates */
    xc_global: number;
    /** X component of equal area axis */
    xe: number;
    /** Y component of x-axis vector */
    y_comp_axis_x: number;
    /** Y component of Y-axis vector */
    y_comp_axis_y: number;
    /** Y component of Z-axis vector */
    y_comp_axis_z: number;
    /** Y component of centroid calculated from the first moment of area */
    yc: number;
    /** Y component of centre of gravity calculated in global coordinates */
    yc_global: number;
    /** Y component of equal area axis */
    ye: number;
    /** Z component of X-axis vector */
    z_comp_axis_x: number;
    /** Z component of Y-axis vector */
    z_comp_axis_y: number;
    /** Z component of Z-axis vector */
    z_comp_axis_z: number;
    /** Z component of centre of gravity calculated in global coordinates */
    zc_global: number;
    /** Plastic moduli Zxx */
    zxx: number;
    /** Plastic moduli Zyy */
    zyy: number;
}

declare class CrossSection {
/**
 * Blanks the cross section
 */
    Blank(): void;

/**
 * Blanks all of the cross sections in the model.
 * @param Model Model that all cross sections will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged cross sections in the model.
 * @param Model Model that all the flagged cross sections will be blanked in
 * @param flag Flag set on the cross sections that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the cross section is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the cross section.
 * @param flag Flag to clear on the cross section
 */
    ClearFlag(flag: number): void;

/**
 * Copies the cross section.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): CrossSection;

/**
 * Starts an interactive editing panel to create a cross_section.
 * @param Model Model that the cross_section will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): CrossSection;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Returns coordinates of the intersections between a shell and a database cross section. Note, ElemCut on the Shell class may be quicker
 * @param Shell_label The label of the shell.
 */
    ElemCut(Shell_label: number): number[];

/**
 * Adds an error for cross section. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first cross section in the model.
 * @param Model Model to get first cross section in
 */
    static First(Model: Model): CrossSection;

/**
 * Returns the first free cross section label in the model. Also see CrossSection.LastFreeLabel(), CrossSection.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free cross section label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the cross sections in the model with a defined flag.
 * @param Model Model that all cross sections will be flagged in
 * @param flag Flag to set on the cross sections
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Flags every element (solid,shell,tshell,beam) cut by the cross section. Note this function does not check that the element is in the cross section definition (part set)
 * @param Flag Flag bit.
 */
    FlagCut(Flag: number): boolean;

/**
 * Checks if the cross section is flagged or not.
 * @param flag Flag to test on the cross section
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each cross section in the model. Note that ForEach has been designed to make looping over cross sections as fast as possible and so has some limitations. Firstly, a single temporary CrossSection object is created and on each function call it is updated with the current cross section data. This means that you should not try to store the CrossSection object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new cross sections inside a ForEach loop. 
 * @param Model Model that all cross sections are in
 * @param func Function to call for each cross section
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of CrossSection objects for all of the cross sections in a model in Primer
 * @param Model Model to get cross sections from
 */
    static GetAll(Model: Model): CrossSection[];

/**
 * Returns an array of CrossSection objects for all of the flagged cross sections in a model in Primer
 * @param Model Model to get cross sections from
 * @param flag Flag set on the cross sections that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): CrossSection[];

/**
 * Returns the CrossSection object for a cross section ID.
 * @param Model Model to find the cross section in
 * @param number number of the cross section you want the CrossSection object for
 */
    static GetFromID(Model: Model, number: number): CrossSection;

/**
 * Checks if a CrossSection property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the CrossSection.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop cross section property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this cross_section (*DATABASE_CROSS_SECTION). Note that a carriage return is not added. See also CrossSection.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the cross_section. Note that a carriage return is not added. See also CrossSection.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last cross section in the model.
 * @param Model Model to get last cross section in
 */
    static Last(Model: Model): CrossSection;

/**
 * Returns the last free cross section label in the model. Also see CrossSection.FirstFreeLabel(), CrossSection.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free cross section label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next cross section in the model.
 */
    Next(): CrossSection;

/**
 * Returns the next free (highest+1) cross section label in the model. Also see CrossSection.FirstFreeLabel(), CrossSection.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free cross section label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns true if cross section is cutting the part, false otherwise. If option flag is active, will flag every element of the part cut by the cross section. Note this function does not check that the part is in the cross section definition (part set)
 * @param Part_label The label of the part.
 * @param Flag Optional Flag to flag the element which are cut by the cross section.
 */
    PartCut(Part_label: number, Flag?: number): boolean;

/**
 * Allows the user to pick a cross section.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only cross sections from that model can be picked. If the argument is a Flag then only cross sections that are flagged with limit can be selected. If omitted, or null, any cross sections from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): CrossSection;

/**
 * Returns the previous cross section in the model.
 */
    Previous(): CrossSection;

/**
 * Returns an object which describe various cross section properties
 */
    Properties(): PropertiesReturn;

/**
 * Renumbers all of the cross sections in the model.
 * @param Model Model that all cross sections will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged cross sections in the model.
 * @param Model Model that all the flagged cross sections will be renumbered in
 * @param flag Flag set on the cross sections that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select cross sections using standard PRIMER object menus.
 * @param flag Flag to use when selecting cross sections
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only cross sections from that model can be selected. If the argument is a Flag then only cross sections that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any cross sections can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the cross section.
 * @param flag Flag to set on the cross section
 */
    SetFlag(flag: number): void;

/**
 * Sketches the cross section. The cross section will be sketched until you either call CrossSection.Unsketch(), CrossSection.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the cross section is sketched. If omitted redraw is true. If you want to sketch several cross sections and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged cross sections in the model. The cross sections will be sketched until you either call CrossSection.Unsketch(), CrossSection.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged cross sections will be sketched in
 * @param flag Flag set on the cross sections that you want to sketch
 * @param redraw If model should be redrawn or not after the cross sections are sketched. If omitted redraw is true. If you want to sketch flagged cross sections several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of cross sections in the model.
 * @param Model Model to get total for
 * @param exists true if only existing cross sections should be counted. If false or omitted referenced but undefined cross sections will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the cross section
 */
    Unblank(): void;

/**
 * Unblanks all of the cross sections in the model.
 * @param Model Model that all cross sections will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged cross sections in the model.
 * @param Model Model that the flagged cross sections will be unblanked in
 * @param flag Flag set on the cross sections that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the cross sections in the model.
 * @param Model Model that the defined flag for all cross sections will be unset in
 * @param flag Flag to unset on the cross sections
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the cross section.
 * @param redraw If model should be redrawn or not after the cross section is unsketched. If omitted redraw is true. If you want to unsketch several cross sections and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all cross sections.
 * @param Model Model that all cross sections will be unblanked in
 * @param redraw If model should be redrawn or not after the cross sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged cross sections in the model.
 * @param Model Model that all cross sections will be unsketched in
 * @param flag Flag set on the cross sections that you want to unsketch
 * @param redraw If model should be redrawn or not after the cross sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): CrossSection;

/**
 * Adds a warning for cross section. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this cross section.
 */
    Xrefs(): Xrefs;

/**
 * Create a new CrossSection object for *DATABASE_CROSS_SECTION_SET.
 * @param Model Model that database cross section will be created in
 * @param option Database cross section type. Must be CrossSection.SET
 * @param nsid Node set number.
 * @param hsid Solid set number.
 * @param bsid Beam set number.
 * @param ssid Shell set number.
 * @param tsid Thick shell set number.
 * @param dsid Discrete set number.
 * @param id Rigid part or accelerometer or coordinate system number.
 * @param itype Flag for local system type.
 * @param csid Database cross_section number.
 * @param heading Database cross_section title.
 */
    constructor(Model: Model, option: number, nsid: number, hsid: number, bsid: number, ssid: number, tsid: number, dsid: number, id?: number, itype?: number, csid?: number, heading?: string);

/**
 * Create a new CrossSection object for *DATABASE_CROSS_SECTION_PLANE.
 * @param Model Model that database cross section will be created in
 * @param option Database cross section type. Must be CrossSection.PLANE
 * @param psid Part set number.
 * @param xct X coordinate of tail of normal vector.
 * @param yct Y coordinate of tail of normal vector.
 * @param zct Z coordinate of tail of normal vector.
 * @param xch X coordinate of head of normal vector.
 * @param ych Y coordinate of head of normal vector.
 * @param zch Z coordinate of head of normal vector.
 * @param xhev X coordinate of head of edge vector.
 * @param yhev Y coordinate of head of edge vector.
 * @param zhev Z coordinate of head of edge vector.
 * @param lenl Length in l direction.
 * @param lenm Length in m direction.
 * @param id Rigid part or accelerometer or coordinate system number.
 * @param itype Flag for local system type.
 * @param csid Database cross_section number.
 * @param heading Database cross_section title.
 */
    constructor(Model: Model, option: number, psid: number, xct: number, yct: number, zct: number, xch: number, ych: number, zch: number, xhev: number, yhev: number, zhev: number, lenl?: number, lenm?: number, id?: number, itype?: number, csid?: number, heading?: string);

/**
 * Creates a string containing the cross_section data in keyword format. Note that this contains the keyword header and the keyword cards. See also CrossSection.Keyword() and CrossSection.KeywordCards().
 */
    toString(): string;

/** Beam set number. */
    bsid: number;
/** Database cross section number (identical to label). */
    csid: number;
/** Discrete set number. */
    dsid: number;
/** true if database cross section exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Database cross section heading. */
    heading: string;
/** Solid set number. */
    hsid: number;
/** Rigid part or accelerometer or coordinate system number. */
    id: number;
/** true if _ID option is set, false if not */
    idset: boolean;
/** The Include file number that the database cross section is in. */
    include: number;
/** Flag for local system type. */
    itype: number;
/** Database cross section number. */
    label: number;
/** Length of L edge. */
    lenl: number;
/** Length of M edge. */
    lenm: number;
/** The Model number that the cross section is in. */
    model: number;
/** Node set number. */
    nsid: number;
/** The Database CrossSection option. Can be:  CrossSection.PLANE or CrossSection.SET  */
    option: number;
/** Part set number. */
    psid: number;
/** Radius. */
    radius: number;
/** Shell set number. */
    ssid: number;
/** Thick shell set number. */
    tsid: number;
/** Head X coord of N normal vector. */
    xch: number;
/** Tail X coord of N normal vector. */
    xct: number;
/** Head X coord of L edge vector. */
    xhev: number;
/** Head Y coord of N normal vector. */
    ych: number;
/** Tail Y coord of N normal vector. */
    yct: number;
/** Head Y coord of L edge vector. */
    yhev: number;
/** Head Z coord of N normal vector. */
    zch: number;
/** Tail Z coord of N normal vector. */
    zct: number;
/** Head Z coord of L edge vector. */
    zhev: number;
/** PLANE is *DATABASE_CROSS_SECTION_PLANE. */
    static PLANE: number;
/** SET is *DATABASE_CROSS_SECTION_SET. */
    static SET: number;
}

declare class Curve {
/**
 * Adds a point to a load curve.
 * @param xvalue The x value of the point.
 * @param yvalue The y value of the point.
 */
    AddPoint(xvalue: number, yvalue: number): void;

/**
 * Adds an entry line to a table.
 * @param value The value for for this entry in the table.
 * @param load_curve The load curve corresponding to the defined value.
 */
    AddTableEntry(value: number, load_curve: number): void;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the curve.
 * @param flag Flag to clear on the curve
 */
    ClearFlag(flag: number): void;

/**
 * Copies the curve.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Curve;

/**
 * Starts an interactive editing panel to create a curve.
 * @param Model Model that the curve will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Curve;

/**
 * Starts an interactive editing panel to create a table.
 * @param Model Model that the curve will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static CreateTable(Model: Model, modal?: boolean): Curve;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for curve. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first curve in the model.
 * @param Model Model to get first curve in
 */
    static First(Model: Model): Curve;

/**
 * Returns the first free curve label in the model. Also see Curve.LastFreeLabel(), Curve.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free curve label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the curves in the model with a defined flag.
 * @param Model Model that all curves will be flagged in
 * @param flag Flag to set on the curves
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the curve is flagged or not.
 * @param flag Flag to test on the curve
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each curve in the model. Note that ForEach has been designed to make looping over curves as fast as possible and so has some limitations. Firstly, a single temporary Curve object is created and on each function call it is updated with the current curve data. This means that you should not try to store the Curve object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new curves inside a ForEach loop. 
 * @param Model Model that all curves are in
 * @param func Function to call for each curve
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Curve objects for all of the curves in a model in Primer
 * @param Model Model to get curves from
 */
    static GetAll(Model: Model): Curve[];

/**
 * Returns an array of Curve objects for all of the flagged curves in a model in Primer
 * @param Model Model to get curves from
 * @param flag Flag set on the curves that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Curve[];

/**
 * Returns the Curve object for a curve ID.
 * @param Model Model to find the curve in
 * @param number number of the curve you want the Curve object for
 */
    static GetFromID(Model: Model, number: number): Curve;

/**
 * Checks if a Curve property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Curve.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop curve property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns x and y data for a point in a curve
 * @param row The row point you want the data for. Note that curve points start at 0, not 1.
 */
    GetPoint(row: number): number[];

/**
 * Returns the value and curve label for a row in a table
 * @param row The row point you want the data for. Note that curve points start at 0, not 1.
 */
    GetTableEntry(row: number): number[];

/**
 * Inserts point values before or after a specified row of data on a load curve.
 * @param ipt The row you want to insert the data before or after. Note that the row data starts at 0, not 1.
 * @param xvalue The x value of the point.
 * @param yvalue The y value of the point.
 * @param position Specify either before or after the selected row. Use 'Curve.BEFORE' for before, and 'Curve.AFTER' for after.
 */
    InsertPoint(ipt: number, xvalue: number, yvalue: number, position: number): void;

/**
 * Inserts a table row before or after a specified row of data on a table.
 * @param ipt The row you want to insert the data before or after. Note that the row data starts at 0, not 1.
 * @param value The value of the row.
 * @param lcid The load curve corresponding to the defined value.
 * @param position Specify either before or after the selected row. Use 'Curve.BEFORE' for before, and 'Curve.AFTER' for after.
 */
    InsertTableEntry(ipt: number, value: number, lcid: number, position: number): void;

/**
 * Returns the keyword for this curve (*DEFINE_CURVE_xxxx). Note that a carriage return is not added. See also Curve.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the curve. Note that a carriage return is not added. See also Curve.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last curve in the model.
 * @param Model Model to get last curve in
 */
    static Last(Model: Model): Curve;

/**
 * Returns the last free curve label in the model. Also see Curve.FirstFreeLabel(), Curve.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free curve label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next curve in the model.
 */
    Next(): Curve;

/**
 * Returns the next free (highest+1) curve label in the model. Also see Curve.FirstFreeLabel(), Curve.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free curve label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous curve in the model.
 */
    Previous(): Curve;

/**
 * Removes a row of data from a curve
 * @param row The row point you want to remove. Note that curve points start at 0, not 1.
 */
    RemovePoint(row: number): void;

/**
 * Removes the value and loadcurve values for a specified row of data on a load curve.
 * @param ipt The row you want to remove the data for. Note that the row data starts at 0, not 1.
 */
    RemoveTableEntry(ipt: number): void;

/**
 * Renumbers all of the curves in the model.
 * @param Model Model that all curves will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged curves in the model.
 * @param Model Model that all the flagged curves will be renumbered in
 * @param flag Flag set on the curves that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select curves using standard PRIMER object menus.
 * @param flag Flag to use when selecting curves
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only curves from that model can be selected. If the argument is a Flag then only curves that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any curves can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the curve.
 * @param flag Flag to set on the curve
 */
    SetFlag(flag: number): void;

/**
 * Sets the x and y values for a specified row of data on a load curve.
 * @param ipt The row you want to set the data for. Note that the row data starts at 0, not 1.
 * @param xvalue The x value of the point.
 * @param yvalue The y value of the point.
 */
    SetPoint(ipt: number, xvalue: number, yvalue: number): void;

/**
 * Sets the value and loadcurve values for a specified row of data on a load curve.
 * @param ipt The row you want to set the data for. Note that the row data starts at 0, not 1.
 * @param value The value for for this entry in the table.
 * @param load_curve The load curve corresponding to the defined value.
 */
    SetTableEntry(ipt: number, value: number, load_curve: number): void;

/**
 * Returns the total number of curves in the model.
 * @param Model Model to get total for
 * @param exists true if only existing curves should be counted. If false or omitted referenced but undefined curves will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the curves in the model.
 * @param Model Model that the defined flag for all curves will be unset in
 * @param flag Flag to unset on the curves
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Curve;

/**
 * Adds a warning for curve. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this curve.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Curve object.
 * @param Load_curve_type Type of load curve. Can be Curve.CURVE, Curve.TABLE, Note this does not have to be defined. In previous versions of Primer you could only construct a basic load curve type, therefore the type argument was not used. Primer is still backwards compatible with this method of load curve creation.
 * @param Model Model that curve will be created in
 * @param lcid Curve number
 * @param sidr Stress initialisation by dynamic relaxation
 * @param sfa Scale factor on abscissa value
 * @param sfo Scale factor on ordinate value
 * @param offa Offset on abscissa value
 * @param offo Offset on ordinate value
 * @param dattyp Data type
 * @param heading Title for the curve
 * @param lcint Number of discretization points for the curve
 */
    constructor(Load_curve_type: number, Model: Model, lcid: number, sidr?: number, sfa?: number, sfo?: number, offa?: number, offo?: number, dattyp?: number, heading?: string, lcint?: number);

/**
 * Create a new Curve *DEFINE_CURVE_FUNCTION object.
 * @param Load_curve_type Type of load curve. Must be Curve.CURVE_FUNCTION.
 * @param Model Model that curve will be created in
 * @param lcid Curve number
 * @param sidr Stress initialisation by dynamic relaxation
 * @param func Function expression
 * @param heading Title for the curve
 */
    constructor(Load_curve_type: number, Model: Model, lcid: number, sidr?: number, func?: string, heading?: string);

/**
 * Create a new Curve *DEFINE_FUNCTION object.
 * @param Load_curve_type Type of load curve. Must be Curve.FUNCTION.
 * @param Model Model that curve will be created in
 * @param lcid Curve number
 * @param func Function expression
 * @param heading Title for the curve
 */
    constructor(Load_curve_type: number, Model: Model, lcid: number, func?: string, heading?: string);

/**
 * Creates a string containing the curve data in keyword format. Note that this contains the keyword header and the keyword cards. See also Curve.Keyword() and Curve.KeywordCards().
 */
    toString(): string;

/** Data type */
    dattyp: number;
/** true if curve exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Function expression for Curve.CURVE_FUNCTION */
    function: string;
/** Curve heading */
    heading: string;
/** The Include file number that the curve is in. */
    include: number;
/** Curve number. Also see the lcid property which is an alternative name for this. */
    label: number;
/** Curve number. Also see the label property which is an alternative name for this. */
    lcid: number;
/** Number of discretization points for the curve */
    lcint: number;
/** The Model number that the curve is in. */
    model: number;
/** Number of points in curve or number of curves in table. The npoints property is an alternative name for this. (read only for tables) */
    ncurves: number;
/** Number of points in curve or number of curves in table. The ncurves property is an alternative name for this. (read only for tables) */
    npoints: number;
/** Offset for abscissa values */
    offa: number;
/** Offset for ordinate values */
    offo: number;
/** Scale factor on abscissa value */
    sfa: number;
/** Scale factor on ordinate value */
    sfo: number;
/** Stress initialisation by dynamic relaxation */
    sidr: number;
/** Load curve type (Can be Curve.CURVE, Curve.CURVE_FUNCTION, Curve.FUNCTION or Curve.TABLE). */
    type: number;
/** Version for discretization. Can be blank, "3858" or "5434a" */
    version: string;
/** Insertion of curve data option. */
    static AFTER: number;
/** Insertion of curve data option. */
    static BEFORE: number;
/** Load curve type *DEFINE_CURVE */
    static CURVE: number;
/** Load curve type *DEFINE_CURVE_FUNCTION */
    static CURVE_FUNCTION: number;
/** Load curve type *DEFINE_FUNCTION */
    static FUNCTION: number;
/** Load curve type *DEFINE_TABLE */
    static TABLE: number;
}

declare class Damping {
/** true if damping card exists */
    exists: boolean;
/** *DAMPING_GLOBAL card */
    global: object;
/** The Include file number that the damping card is in. */
    include: number;
/** Curve ID specifying system damping constant */
    lcid: number;
/** Scale factor on global x rotational damping moments */
    srx: number;
/** Scale factor on global y rotational damping moments */
    sry: number;
/** Scale factor on global z rotational damping moments */
    srz: number;
/** Scale factor on global x translational damping forces */
    stx: number;
/** Scale factor on global y translational damping forces */
    sty: number;
/** Scale factor on global z translational damping forces */
    stz: number;
/** System damping constant */
    valdmp: number;
}

declare class Database {
/** *DATABASE_ABSTAT card */
    abstat: object;
/** *DATABASE_ATDOUT card */
    atdout: object;
/** Beam option */
    beam: number;
/** Beam option */
    beam_1: number;
/** #beam int points to output */
    beamip: number;
/** *DATABASE_BEARING card */
    bearing: object;
/** *DATABASE_BINARY cards */
    binary: object;
/** Flag for binary file */
    binary_1: number;
/** Flag for binary file */
    binary_10: number;
/** Flag for binary file */
    binary_11: number;
/** Flag for binary file */
    binary_12: number;
/** Flag for binary file */
    binary_13: number;
/** Flag for binary file */
    binary_14: number;
/** Flag for binary file */
    binary_15: number;
/** Flag for binary file */
    binary_16: number;
/** Flag for binary file */
    binary_17: number;
/** Flag for binary file */
    binary_18: number;
/** Flag for binary file */
    binary_19: number;
/** Flag for binary file */
    binary_2: number;
/** Flag for binary file */
    binary_20: number;
/** Flag for binary file */
    binary_21: number;
/** Flag for binary file */
    binary_22: number;
/** Flag for binary file */
    binary_23: number;
/** Flag for binary file */
    binary_24: number;
/** Flag for binary file */
    binary_25: number;
/** Flag for binary file */
    binary_26: number;
/** Flag for binary file */
    binary_27: number;
/** Flag for binary file */
    binary_28: number;
/** Flag for binary file */
    binary_29: number;
/** Flag for binary file */
    binary_3: number;
/** Flag for binary file */
    binary_30: number;
/** Flag for binary file */
    binary_31: number;
/** Flag for binary file */
    binary_32: number;
/** Flag for binary file */
    binary_33: number;
/** Flag for binary file */
    binary_4: number;
/** Flag for binary file */
    binary_5: number;
/** Flag for binary file */
    binary_6: number;
/** Flag for binary file */
    binary_7: number;
/** Flag for binary file */
    binary_8: number;
/** Flag for binary file */
    binary_9: number;
/** *DATABASE_BINARY_BLSTFOR card */
    blstfor: object;
/** *DATABASE_BNDOUT card */
    bndout: object;
/** Output for beam elements. +n is output for elements in beam set n, 0 no beam, -1 all elements */
    bsetid: number;
/** Flag to output composite material stress in local csys */
    cmpflg: number;
/** *DATABASE_BINARY_CPMFOR card */
    cpmfor: object;
/** Output flag for quadratic solid types */
    cubsld: number;
/** Frequency cut-off C in Hz */
    cutoff: number;
/** Output interval in cycles */
    cycl: number;
/** Output interval in cycles */
    cycl_1: number;
/** Output interval in cycles */
    cycl_2: number;
/** *DATABASE_BINARY_D3CRACK card */
    d3crack: object;
/** *DATABASE_BINARY_D3DRLF card */
    d3drlf: object;
/** *DATABASE_BINARY_D3DUMP card */
    d3dump: object;
/** *DATABASE_BINARY_D3MEAN card */
    d3mean: object;
/** *DATABASE_BINARY_D3PART card */
    d3part: object;
/** *DATABASE_BINARY_D3PLOT card */
    d3plot: object;
/** *DATABASE_BINARY_D3PROP card */
    d3prop: object;
/** *DATABASE_BINARY_D3THDT card */
    d3thdt: object;
/** *DATABASE_DCFAIL card */
    dcfail: object;
/** Data compression flag */
    dcomp: number;
/** *DATABASE_DEFGEO card */
    defgeo: object;
/** *DATABASE_DEFORC card */
    deforc: object;
/** *DATABASE_BINARY_DEMFOR card */
    demfor: object;
/** *DATABASE_DESTAT card */
    destat: object;
/** Time interval between output */
    dt: number;
/** Time interval between output */
    dt_1: number;
/** Time interval between output */
    dt_10: number;
/** Time interval between output */
    dt_11: number;
/** Time interval between output */
    dt_12: number;
/** Time interval between output */
    dt_13: number;
/** Time interval between output */
    dt_14: number;
/** Time interval between output */
    dt_15: number;
/** Time interval between output */
    dt_16: number;
/** Time interval between output */
    dt_17: number;
/** Time interval between output */
    dt_18: number;
/** Time interval between output */
    dt_19: number;
/** Time interval between output */
    dt_2: number;
/** Time interval between output */
    dt_20: number;
/** Time interval between output */
    dt_21: number;
/** Time interval between output */
    dt_22: number;
/** Time interval between output */
    dt_23: number;
/** Time interval between output */
    dt_24: number;
/** Time interval between output */
    dt_25: number;
/** Time interval between output */
    dt_26: number;
/** Time interval between output */
    dt_27: number;
/** Time interval between output */
    dt_28: number;
/** Time interval between output */
    dt_29: number;
/** Time interval between output */
    dt_3: number;
/** Time interval between output */
    dt_30: number;
/** Time interval between output */
    dt_31: number;
/** Time interval between output */
    dt_32: number;
/** Time interval between outputs */
    dt_33: number;
/** Time interval between outputs */
    dt_34: number;
/** Time interval between outputs */
    dt_35: number;
/** Time interval between outputs */
    dt_36: number;
/** Time interval between outputs */
    dt_37: number;
/** Time interval between outputs */
    dt_38: number;
/** Time interval between outputs */
    dt_39: number;
/** Time interval between output */
    dt_4: number;
/** Time interval between outputs */
    dt_40: number;
/** Time interval between outputs */
    dt_41: number;
/** Time interval between outputs */
    dt_42: number;
/** Time interval between outputs */
    dt_43: number;
/** Time interval between outputs */
    dt_44: number;
/** Time interval between output */
    dt_5: number;
/** Time interval between output */
    dt_6: number;
/** Time interval between output */
    dt_7: number;
/** Time interval between output */
    dt_8: number;
/** Time interval between output */
    dt_9: number;
/** output of nodal temp */
    dtdt: number;
/** *DATABASE_ELOUT card */
    elout: object;
/** Flag to in/exclude shell energy &amp; thickness */
    engflg: number;
/** Flag to in/exclude shell energy &amp; thickness */
    engflg_1: number;
/** *DATABASE_ENVELOPE card */
    envelope: object;
/** Flag to in/exclude shell strains */
    epsflg: number;
/** Flag to in/exclude shell strains */
    epsflg_1: number;
/** true if database card exists */
    exists: boolean;
/** true if database card exists */
    exists_1: boolean;
/** true if database card exists */
    exists_10: boolean;
/** true if database card exists */
    exists_11: boolean;
/** true if database card exists */
    exists_12: boolean;
/** true if database card exists */
    exists_13: boolean;
/** true if database card exists */
    exists_14: boolean;
/** true if database card exists */
    exists_15: boolean;
/** true if database card exists */
    exists_16: boolean;
/** true if database card exists */
    exists_17: boolean;
/** true if database card exists */
    exists_18: boolean;
/** true if database card exists */
    exists_19: boolean;
/** true if database card exists */
    exists_2: boolean;
/** true if database card exists */
    exists_20: boolean;
/** true if database card exists */
    exists_21: boolean;
/** true if database card exists */
    exists_22: boolean;
/** true if database card exists */
    exists_23: boolean;
/** true if database card exists */
    exists_24: boolean;
/** true if database card exists */
    exists_25: boolean;
/** true if database card exists */
    exists_26: boolean;
/** true if database card exists */
    exists_27: boolean;
/** true if database card exists */
    exists_28: boolean;
/** true if database card exists */
    exists_29: boolean;
/** true if database card exists */
    exists_3: boolean;
/** true if database card exists */
    exists_30: boolean;
/** true if database card exists */
    exists_31: boolean;
/** true if database card exists */
    exists_32: boolean;
/** true if database card exists */
    exists_33: boolean;
/** true if database binary card exists */
    exists_34: boolean;
/** true if database binary card exists */
    exists_35: boolean;
/** true if database binary card exists */
    exists_36: boolean;
/** true if database binary card exists */
    exists_37: boolean;
/** true if database binary card exists */
    exists_38: boolean;
/** true if database binary card exists */
    exists_39: boolean;
/** true if database card exists */
    exists_4: boolean;
/** true if database binary card exists */
    exists_40: boolean;
/** true if database binary card exists */
    exists_41: boolean;
/** true if database binary card exists */
    exists_42: boolean;
/** true if database binary card exists */
    exists_43: boolean;
/** true if database binary card exists */
    exists_44: boolean;
/** true if database binary card exists */
    exists_45: boolean;
/** true if database binary card exists */
    exists_46: boolean;
/** true if database binary card exists */
    exists_47: boolean;
/** true if database binary card exists */
    exists_48: boolean;
/** true if database binary card exists */
    exists_49: boolean;
/** true if database card exists */
    exists_5: boolean;
/** true if database card exists */
    exists_50: boolean;
/** true if database card exists */
    exists_51: boolean;
/** true if database card exists */
    exists_52: boolean;
/** true if database card exists */
    exists_53: boolean;
/** true if database card exists */
    exists_54: boolean;
/** true if database card exists */
    exists_6: boolean;
/** true if database card exists */
    exists_7: boolean;
/** true if database card exists */
    exists_8: boolean;
/** true if database card exists */
    exists_9: boolean;
/** *DATABASE_EXTENT_BINARY card */
    extent_binary: object;
/** *DATABASE_EXTENT_BINARY_COMP card */
    extent_binary_comp: object;
/** *DATABASE_EXTENT_D3PART card */
    extent_d3part: object;
/** *DATABASE_EXTENT_INTFOR card */
    extent_intfor: object;
/** Filename of the database for the INTFOR data */
    fname: string;
/** *DATABASE_FORMAT card */
    format: object;
/** *DATABASE_BINARY_FSIFOR card */
    fsifor: object;
/** *DATABASE_BINARY_FSILNK card */
    fsilnk: object;
/** *DATABASE_GCEOUT card */
    gceout: object;
/** *DATABASE_GLSTAT card */
    glstat: object;
/** *DATABASE_H3OUT card */
    h3out: object;
/** adds extra history variables */
    hydro: number;
/** output of accleration data */
    iacc: string;
/** output ale materials */
    ialemat: number;
/** Averaging time interval */
    iavg: number;
/** Word size for binary output files */
    ibinary: number;
/** Every INTFOR database to separate file flag */
    ieverf: number;
/** Every D3PLOT file to separate database flag */
    ieverp: number;
/** Every D3PLOT file to separate database flag */
    ieverp_1: number;
/** Output data flag */
    ifile: number;
/** Output format for D3PLOT and D3THDT files */
    iform: number;
/** output of global data */
    iglb: string;
/** Output *EOS, *HOURGLASS, *MAT, *part and *SECTION data */
    imatl: number;
/** The Include file number that the database card is in. */
    include: number;
/** The Include file number that the database card is in. */
    include_1: number;
/** The Include file number that the database card is in. */
    include_10: number;
/** The Include file number that the database card is in. */
    include_11: number;
/** The Include file number that the database card is in. */
    include_12: number;
/** The Include file number that the database card is in. */
    include_13: number;
/** The Include file number that the database card is in. */
    include_14: number;
/** The Include file number that the database card is in. */
    include_15: number;
/** The Include file number that the database card is in. */
    include_16: number;
/** The Include file number that the database card is in. */
    include_17: number;
/** The Include file number that the database card is in. */
    include_18: number;
/** The Include file number that the database card is in. */
    include_19: number;
/** The Include file number that the database card is in. */
    include_2: number;
/** The Include file number that the database card is in. */
    include_20: number;
/** The Include file number that the database card is in. */
    include_21: number;
/** The Include file number that the database card is in. */
    include_22: number;
/** The Include file number that the database card is in. */
    include_23: number;
/** The Include file number that the database card is in. */
    include_24: number;
/** The Include file number that the database card is in. */
    include_25: number;
/** The Include file number that the database card is in. */
    include_26: number;
/** The Include file number that the database card is in. */
    include_27: number;
/** The Include file number that the database card is in. */
    include_28: number;
/** The Include file number that the database card is in. */
    include_29: number;
/** The Include file number that the database card is in. */
    include_3: number;
/** The Include file number that the database card is in. */
    include_30: number;
/** The Include file number that the database card is in. */
    include_31: number;
/** The Include file number that the database card is in. */
    include_32: number;
/** The Include file number that the database card is in. */
    include_33: number;
/** The Include file number that the database binary card is in. */
    include_34: number;
/** The Include file number that the database binary card is in. */
    include_35: number;
/** The Include file number that the database binary card is in. */
    include_36: number;
/** The Include file number that the database binary card is in. */
    include_37: number;
/** The Include file number that the database binary card is in. */
    include_38: number;
/** The Include file number that the database binary card is in. */
    include_39: number;
/** The Include file number that the database card is in. */
    include_4: number;
/** The Include file number that the database binary card is in. */
    include_40: number;
/** The Include file number that the database binary card is in. */
    include_41: number;
/** The Include file number that the database binary card is in. */
    include_42: number;
/** The Include file number that the database binary card is in. */
    include_43: number;
/** The Include file number that the database binary card is in. */
    include_44: number;
/** The Include file number that the database binary card is in. */
    include_45: number;
/** The Include file number that the database binary card is in. */
    include_46: number;
/** The Include file number that the database binary card is in. */
    include_47: number;
/** The Include file number that the database binary card is in. */
    include_48: number;
/** The Include file number that the database binary card is in. */
    include_49: number;
/** The Include file number that the database card is in. */
    include_5: number;
/** The Include file number that the database card is in. */
    include_50: number;
/** The Include file number that the database card is in. */
    include_51: number;
/** The Include file number that the database card is in. */
    include_52: number;
/** The Include file number that the database card is in. */
    include_53: number;
/** The Include file number that the database card is in. */
    include_54: number;
/** The Include file number that the database card is in. */
    include_6: number;
/** The Include file number that the database card is in. */
    include_7: number;
/** The Include file number that the database card is in. */
    include_8: number;
/** The Include file number that the database card is in. */
    include_9: number;
/** *DATABASE_BINARY_INTFOR card */
    intfor: object;
/** output of intg pt data */
    intout: string;
/** Flag for behaviour of load curve */
    ioopt: number;
/** Flag for behaviour of load curve */
    ioopt_1: number;
/** Flag for behaviour of load curve */
    ioopt_10: number;
/** Flag for behaviour of load curve */
    ioopt_11: number;
/** Flag for behaviour of load curve */
    ioopt_12: number;
/** Flag for behaviour of load curve */
    ioopt_13: number;
/** Flag for behaviour of load curve */
    ioopt_14: number;
/** Flag for behaviour of load curve */
    ioopt_15: number;
/** Flag for behaviour of load curve */
    ioopt_16: number;
/** Flag for behaviour of load curve */
    ioopt_17: number;
/** Flag for behaviour of load curve */
    ioopt_18: number;
/** Flag for behaviour of load curve */
    ioopt_19: number;
/** Flag for behaviour of load curve */
    ioopt_2: number;
/** Flag for behaviour of load curve */
    ioopt_20: number;
/** Flag for behaviour of load curve */
    ioopt_21: number;
/** Flag for behaviour of load curve */
    ioopt_22: number;
/** Flag for behaviour of load curve */
    ioopt_23: number;
/** Flag for behaviour of load curve */
    ioopt_24: number;
/** Flag for behaviour of load curve */
    ioopt_25: number;
/** Flag for behaviour of load curve */
    ioopt_26: number;
/** Flag for behaviour of load curve */
    ioopt_27: number;
/** Flag for behaviour of load curve */
    ioopt_28: number;
/** Flag for behaviour of load curve */
    ioopt_29: number;
/** Flag for behaviour of load curve */
    ioopt_3: number;
/** Flag for behaviour of load curve */
    ioopt_30: number;
/** Flag for behaviour of load curve */
    ioopt_31: number;
/** Flag for behaviour of load curve */
    ioopt_32: number;
/** Flag for lcdt behaviour */
    ioopt_33: number;
/** Flag for behaviour of load curve */
    ioopt_4: number;
/** Flag for behaviour of load curve */
    ioopt_5: number;
/** Flag for behaviour of load curve */
    ioopt_6: number;
/** Flag for behaviour of load curve */
    ioopt_7: number;
/** Flag for behaviour of load curve */
    ioopt_8: number;
/** Flag for behaviour of load curve */
    ioopt_9: number;
/** output of strain energy density data */
    ised: string;
/** Level of statistics */
    istats: number;
/** output of strain data */
    istra: string;
/** output of stress data */
    istrs: string;
/** output of velocity data */
    ivel: string;
/** Output *RIGIDWALL data */
    iwall: number;
/** output of geometry data */
    ixyz: string;
/** *DATABASE_JNTFORC card */
    jntforc: object;
/** Curve ID giving time interval between dumps */
    lcdt: number;
/** Curve ID giving time interval between dumps */
    lcdt_1: number;
/** Curve ID giving time interval between dumps */
    lcdt_2: number;
/** Curve ID giving time interval between dumps */
    lcdt_3: number;
/** Curve ID specifying time interval */
    lcur: number;
/** Curve ID specifying time interval */
    lcur_1: number;
/** Curve ID specifying time interval */
    lcur_10: number;
/** Curve ID specifying time interval */
    lcur_11: number;
/** Curve ID specifying time interval */
    lcur_12: number;
/** Curve ID specifying time interval */
    lcur_13: number;
/** Curve ID specifying time interval */
    lcur_14: number;
/** Curve ID specifying time interval */
    lcur_15: number;
/** Curve ID specifying time interval */
    lcur_16: number;
/** Curve ID specifying time interval */
    lcur_17: number;
/** Curve ID specifying time interval */
    lcur_18: number;
/** Curve ID specifying time interval */
    lcur_19: number;
/** Curve ID specifying time interval */
    lcur_2: number;
/** Curve ID specifying time interval */
    lcur_20: number;
/** Curve ID specifying time interval */
    lcur_21: number;
/** Curve ID specifying time interval */
    lcur_22: number;
/** Curve ID specifying time interval */
    lcur_23: number;
/** Curve ID specifying time interval */
    lcur_24: number;
/** Curve ID specifying time interval */
    lcur_25: number;
/** Curve ID specifying time interval */
    lcur_26: number;
/** Curve ID specifying time interval */
    lcur_27: number;
/** Curve ID specifying time interval */
    lcur_28: number;
/** Curve ID specifying time interval */
    lcur_29: number;
/** Curve ID specifying time interval */
    lcur_3: number;
/** Curve ID specifying time interval */
    lcur_30: number;
/** Curve ID specifying time interval */
    lcur_31: number;
/** Curve ID specifying time interval */
    lcur_32: number;
/** Curve ID specifying time interval */
    lcur_4: number;
/** Curve ID specifying time interval */
    lcur_5: number;
/** Curve ID specifying time interval */
    lcur_6: number;
/** Curve ID specifying time interval */
    lcur_7: number;
/** Curve ID specifying time interval */
    lcur_8: number;
/** Curve ID specifying time interval */
    lcur_9: number;
/** Flag to include mass and inertia properties */
    mass_properties: number;
/** *DATABASE_MATSUM card */
    matsum: object;
/** #integration points for shell output */
    maxint: number;
/** #integration points for shell output */
    maxint_1: number;
/** output nodal mass scaling data */
    msscl: number;
/** Output for material energies to D3THDT file */
    n3thdt: number;
/** *DATABASE_NCFORC card */
    ncforc: object;
/** Output of loop-stresses to d3plot */
    neipb: number;
/** #extra values for solids */
    neiph: number;
/** #extra values for solids */
    neiph_1: number;
/** #extra values for shells */
    neips: number;
/** #extra values for shells */
    neips_1: number;
/** Display deleted contact segments flag */
    nfail: number;
/** Output forces */
    nforc: number;
/** Output contact gaps */
    ngapc: number;
/** Output global variables */
    nglbv: number;
/** Number of user friction history variables to output from user defined friction routines */
    nhuf: number;
/** number of solid integration pts */
    nintsld: number;
/** number of solid integration pts */
    nintsld_1: number;
/** *DATABASE_NODFOR card */
    nodfor: object;
/** *DATABASE_NODOUT card */
    nodout: object;
/** output of connectivity nodes */
    nodout_1: string;
/** Number of plot files */
    npltc: number;
/** Number of plot files */
    npltc_1: number;
/** Output pressures */
    npresu: number;
/** Number of running restart files */
    nr: number;
/** Output shear stresses */
    nshear: number;
/** Output tied segments for Mortar contact */
    ntied: number;
/** Output nodal velocity */
    nvelo: number;
/** Output contact wear data mode */
    nwear: number;
/** Output (total) sliding interface energy density for mortar contact */
    nwrk: number;
/** Number of user wear history variables */
    nwusr: number;
/** extra history variables for solids */
    option1: number;
/** High frequency output interval */
    option1_1: number;
/** extra history variables for shells */
    option2: number;
/** Flag for binary file for high frequency output */
    option2_1: number;
/** extra history variables for thick shells */
    option3: number;
/** extra history variables for beams */
    option4: number;
/** Output format. Can be 0 or 1 */
    output: number;
/** *DATABASE_PBSTAT card */
    pbstat: object;
/** Flag to output peak pressure and surface energy for each contact interface */
    pkp_sen: number;
/** *DATABASE_PLLYOUT card */
    pllyout: object;
/** *DATABASE_PRTUBE card */
    prtube: object;
/** Part set ID for filtering */
    pset: number;
/** Part Set ID */
    psetid: number;
/** Part Set ID */
    psetid_1: number;
/** Output flag for cubic solid types */
    quadsld: number;
/** Time interval T between filter sampling */
    rate: number;
/** *DATABASE_RBDOUT card */
    rbdout: object;
/** *DATABASE_RCFORC card */
    rcforc: object;
/** Output of residual forces */
    resplt: number;
/** Flag to in/exclude shell force/moment resultants */
    rltflg: number;
/** Flag to in/exclude shell force/moment resultants */
    rltflg_1: number;
/** *DATABASE_BINARY_RUNRSF card */
    runrsf: object;
/** *DATABASE_RWFORC card */
    rwforc: object;
/** *DATABASE_SBTOUT card */
    sbtout: object;
/** Scaling parameter used in the computation of the peak pressure */
    sclp: number;
/** *DATABASE_SECFORC card */
    secforc: object;
/** Shell hourglass energy output flag */
    shge: number;
/** Shell hourglass energy output flag */
    shge_1: number;
/** Flag to in/exclude shell stress tensors */
    sigflg: number;
/** Flag to in/exclude shell stress tensors */
    sigflg_1: number;
/** *DATABASE_SLEOUT card */
    sleout: object;
/** *DATABASE_SPCFORC card */
    spcforc: object;
/** *DATABASE_SPHOUT card */
    sphout: object;
/** Output for shell elements. +n is output for elements in shell set n, 0 no shell, -1 all elements */
    ssetid: number;
/** Strain tensor output flag */
    strflg: number;
/** Strain tensor output flag */
    strflg_1: number;
/** Output shell element dt flag */
    stssz: number;
/** Output shell element dt flag */
    stssz_1: number;
/** *DATABASE_SWFORC card */
    swforc: object;
/** Time interval for backup output files during the analysis */
    tback: number;
/** Time interval for checking whether the previous maxima/minima are exceeded */
    tcheck: number;
/** Output of thermal data to d3plot */
    therm: number;
/** *DATABASE_TPRINT card */
    tprint: object;
/** *DATABASE_TRHIST card */
    trhist: object;
/** Start time */
    tstart: number;
/** Flag for filtering options */
    type: number;
/** Width of the window in units of time for storing single, forward filtering */
    window: number;
/** *DATABASE_BINARY_XTFILE card */
    xtfile: object;
}

declare class DeformableToRigid {
/**
 * Blanks the deformable to rigid
 */
    Blank(): void;

/**
 * Blanks all of the deformable to rigids in the model.
 * @param Model Model that all deformable to rigids will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged deformable to rigids in the model.
 * @param Model Model that all the flagged deformable to rigids will be blanked in
 * @param flag Flag set on the deformable to rigids that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the deformable to rigid is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the deformable to rigid.
 * @param flag Flag to clear on the deformable to rigid
 */
    ClearFlag(flag: number): void;

/**
 * Copies the deformable to rigid.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): DeformableToRigid;

/**
 * Starts an interactive editing panel to create an DeformableToRigid definition.
 * @param Model Model that the DeformableToRigid will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): DeformableToRigid;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for deformable to rigid. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first deformable to rigid in the model.
 * @param Model Model to get first deformable to rigid in
 */
    static First(Model: Model): DeformableToRigid;

/**
 * Returns the first free deformable to rigid label in the model. Also see DeformableToRigid.LastFreeLabel(), DeformableToRigid.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free deformable to rigid label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the deformable to rigids in the model with a defined flag.
 * @param Model Model that all deformable to rigids will be flagged in
 * @param flag Flag to set on the deformable to rigids
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the deformable to rigid is flagged or not.
 * @param flag Flag to test on the deformable to rigid
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each deformable to rigid in the model. Note that ForEach has been designed to make looping over deformable to rigids as fast as possible and so has some limitations. Firstly, a single temporary DeformableToRigid object is created and on each function call it is updated with the current deformable to rigid data. This means that you should not try to store the DeformableToRigid object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new deformable to rigids inside a ForEach loop. 
 * @param Model Model that all deformable to rigids are in
 * @param func Function to call for each deformable to rigid
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of DeformableToRigid objects for all of the deformable to rigids in a model in Primer
 * @param Model Model to get deformable to rigids from
 */
    static GetAll(Model: Model): DeformableToRigid[];

/**
 * Returns the D2R or R2D cards for *DEFORMABLE_TO_RIGID_AUTOMATC.
 * @param ctype The card type you want the data for. Can be D2R or R2D.
 * @param index The card index you want the data for. Note that card indices start at 0, not 1.
 */
    GetDefToRegAutoCard(ctype: number, index: number): number[];

/**
 * Returns an array of DeformableToRigid objects for all of the flagged deformable to rigids in a model in Primer
 * @param Model Model to get deformable to rigids from
 * @param flag Flag set on the deformable to rigids that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): DeformableToRigid[];

/**
 * Returns the DeformableToRigid object for a deformable to rigid ID.
 * @param Model Model to find the deformable to rigid in
 * @param number number of the deformable to rigid you want the DeformableToRigid object for
 */
    static GetFromID(Model: Model, number: number): DeformableToRigid;

/**
 * Checks if a DeformableToRigid property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the DeformableToRigid.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop deformable to rigid property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this DeformableToRigid (*DEFORMABLE_TO_RIGID_xxxx) Note that a carriage return is not added. See also DeformableToRigid.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the DeformableToRigid. Note that a carriage return is not added. See also DeformableToRigid.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last deformable to rigid in the model.
 * @param Model Model to get last deformable to rigid in
 */
    static Last(Model: Model): DeformableToRigid;

/**
 * Returns the last free deformable to rigid label in the model. Also see DeformableToRigid.FirstFreeLabel(), DeformableToRigid.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free deformable to rigid label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next deformable to rigid in the model.
 */
    Next(): DeformableToRigid;

/**
 * Returns the next free (highest+1) deformable to rigid label in the model. Also see DeformableToRigid.FirstFreeLabel(), DeformableToRigid.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free deformable to rigid label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a deformable to rigid.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only deformable to rigids from that model can be picked. If the argument is a Flag then only deformable to rigids that are flagged with limit can be selected. If omitted, or null, any deformable to rigids from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): DeformableToRigid;

/**
 * Returns the previous deformable to rigid in the model.
 */
    Previous(): DeformableToRigid;

/**
 * Removes the D2R or R2D cards for *DEFORMABLE_TO_RIGID_AUTOMATC.
 * @param ctype The card type you want removed. Can be D2R or R2D.
 * @param index The card index you want removed. Note that card indices start at 0, not 1.
 */
    RemoveDefToRegAutoCard(ctype: number, index: number): void;

/**
 * Renumbers all of the deformable to rigids in the model.
 * @param Model Model that all deformable to rigids will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged deformable to rigids in the model.
 * @param Model Model that all the flagged deformable to rigids will be renumbered in
 * @param flag Flag set on the deformable to rigids that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select deformable to rigids using standard PRIMER object menus.
 * @param flag Flag to use when selecting deformable to rigids
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only deformable to rigids from that model can be selected. If the argument is a Flag then only deformable to rigids that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any deformable to rigids can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets the D2r or R2D card data f*DEFORMABLE_TO_RIGID_AUTOMATIC.
 * @param ctype The card type you want to set. Can be D2R or R2D.
 * @param index The D2R or R2D card index you want to set. Note that cards start at 0, not 1.
 * @param ptype Part type (PTYPE). Can be DeformableToRigid.PART or DeformableToRigid.PSET.
 * @param pid Part or Part Set ID.
 * @param mrb MRB Part ID (only for card type D2R)
 */
    SetDefToRegAutoCard(ctype: number, index: number, ptype: number, pid: number, mrb?: number): void;

/**
 * Sets a flag on the deformable to rigid.
 * @param flag Flag to set on the deformable to rigid
 */
    SetFlag(flag: number): void;

/**
 * Sketches the deformable to rigid. The deformable to rigid will be sketched until you either call DeformableToRigid.Unsketch(), DeformableToRigid.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the deformable to rigid is sketched. If omitted redraw is true. If you want to sketch several deformable to rigids and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged deformable to rigids in the model. The deformable to rigids will be sketched until you either call DeformableToRigid.Unsketch(), DeformableToRigid.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged deformable to rigids will be sketched in
 * @param flag Flag set on the deformable to rigids that you want to sketch
 * @param redraw If model should be redrawn or not after the deformable to rigids are sketched. If omitted redraw is true. If you want to sketch flagged deformable to rigids several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of deformable to rigids in the model.
 * @param Model Model to get total for
 * @param exists true if only existing deformable to rigids should be counted. If false or omitted referenced but undefined deformable to rigids will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the deformable to rigid
 */
    Unblank(): void;

/**
 * Unblanks all of the deformable to rigids in the model.
 * @param Model Model that all deformable to rigids will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged deformable to rigids in the model.
 * @param Model Model that the flagged deformable to rigids will be unblanked in
 * @param flag Flag set on the deformable to rigids that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the deformable to rigids in the model.
 * @param Model Model that the defined flag for all deformable to rigids will be unset in
 * @param flag Flag to unset on the deformable to rigids
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the deformable to rigid.
 * @param redraw If model should be redrawn or not after the deformable to rigid is unsketched. If omitted redraw is true. If you want to unsketch several deformable to rigids and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all deformable to rigids.
 * @param Model Model that all deformable to rigids will be unblanked in
 * @param redraw If model should be redrawn or not after the deformable to rigids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged deformable to rigids in the model.
 * @param Model Model that all deformable to rigids will be unsketched in
 * @param flag Flag set on the deformable to rigids that you want to unsketch
 * @param redraw If model should be redrawn or not after the deformable to rigids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): DeformableToRigid;

/**
 * Adds a warning for deformable to rigid. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this deformable to rigid.
 */
    Xrefs(): Xrefs;

/**
 * Create a new DeformableToRigid object.
 * @param Model Model that deformable to rigid will be created in
 * @param Type Specify the type of DeformableToRigid (Can be DeformableToRigid.SIMPLE or DeformableToRigid.AUTOMATIC or DeformableToRigid.INERTIA )
 * @param pid Part  or Part set  ID which is switched to a rigid material. Depends on value of ptype. Used only for DeformableToRigid.SIMPLE or DeformableToRigid.INERTIA.
 * @param mrb Part ID of the master rigid body to which the part is merged. Used only for DeformableToRigid.SIMPLE.
 * @param ptype Type of PID. Valid values are: DeformableToRigid.PART or DeformableToRigid.PSET. Used only for DeformableToRigid.SIMPLE.
 */
    constructor(Model: Model, Type: number, pid?: number, mrb?: number, ptype?: number);

/**
 * Creates a string containing the DeformableToRigid data in keyword format. Note that this contains the keyword header and the keyword cards. See also DeformableToRigid.Keyword() and DeformableToRigid.KeywordCards().
 */
    toString(): string;

/** Activation switch code. (Valid values: 0-5). Used only for DeformableToRigid.AUTOMATIC. */
    code: number;
/** Number of deformable parts to be switched to rigid plus number of rigid parts for which new master/slave rigid body combinations will be defined. Used only for DeformableToRigid.AUTOMATIC. */
    d2r: number;
/** Maximum permitted time step size after switch. Used only for DeformableToRigid.AUTOMATIC. */
    dtmax: number;
/** Rigid wall/contact surface number for switch codes 1, 2, 3, 4. Used only for DeformableToRigid.AUTOMATIC. */
    entno: number;
/** true if deformable to rigid exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the deformable to rigid is in. */
    include: number;
/** The xx component of inertia tensor. Used only for DeformableToRigid.INERTIA. */
    ixx: number;
/** The xx component of inertia tensor. Used only for DeformableToRigid.INERTIA. */
    ixx_1: number;
/** The xy component of inertia tensor. Used only for DeformableToRigid.INERTIA. */
    ixy: number;
/** The xz component of inertia tensor. Used only for DeformableToRigid.INERTIA. */
    ixz: number;
/** The yz component of inertia tensor. Used only for DeformableToRigid.INERTIA. */
    iyz: number;
/** The zz component of inertia tensor. Used only for DeformableToRigid.INERTIA. */
    izz: number;
/** The Model number that the deformable to rigid is in. */
    model: number;
/** Part ID of the master rigid body to which the part is merged. Used only for DeformableToRigid.SIMPLE. */
    mrb: number;
/** Nodal constraint body flag. (Valid values : 0, 1, 2). Used only for DeformableToRigid.AUTOMATIC. */
    ncsf: number;
/** Nodal rigid body flag. (Valid values : 0, 1, 2). Used only for DeformableToRigid.AUTOMATIC. */
    nrbf: number;
/** Optional contact thickness for switch to deformable. Used only for DeformableToRigid.AUTOMATIC. */
    offset: number;
/** Define a pair of related switches. (Valid values : -1, 0, 1). Used only for DeformableToRigid.AUTOMATIC. */
    paired: number;
/** Part or Part set  ID which is switched to a rigid material. Depends on value of ptype. Used only for DeformableToRigid.SIMPLE or DeformableToRigid.INERTIA. */
    pid: number;
/** Type of PID. Valid values are: DeformableToRigid.PART or DeformableToRigid.PSET. Used only for DeformableToRigid.SIMPLE. */
    ptype: number;
/** Number of rigid parts to be switched to deformable. Used only for DeformableToRigid.AUTOMATIC. */
    r2d: number;
/** Related switch set. Used only for DeformableToRigid.AUTOMATIC. */
    relsw: number;
/** Flag to delete or activate rigid walls. (Valid values : 0, 1, 2). Used only for DeformableToRigid.AUTOMATIC. */
    rwf: number;
/** Set number for this automatic switch set. (read only). Used only for DeformableToRigid.AUTOMATIC. */
    readonly swset: number;
/** Switch will not take place before this time. Used only for DeformableToRigid.AUTOMATIC. */
    time1: number;
/** Switch will not take place after this time. Used only for DeformableToRigid.AUTOMATIC. */
    time2: number;
/** After this part switch has taken place, another automatic switch will not take place for the duration of the delay period. Used only for DeformableToRigid.AUTOMATIC. */
    time3: number;
/** Translational mass. Used only for DeformableToRigid.INERTIA. */
    tm: number;
/** Gives the type of DeformableToRigid Object. (read only) */
    readonly type: number;
/** x-coordinate of center of mass. Used only for DeformableToRigid.INERTIA. */
    xc: number;
/** y-coordinate of center of mass. Used only for DeformableToRigid.INERTIA. */
    yc: number;
/** z-coordinate of center of mass. Used only for DeformableToRigid.INERTIA. */
    zc: number;
/** *DEFORMABLE_TO_RIGID_AUTOMATIC. */
    static AUTOMATIC: number;
/** Identifies that card is being written/retreived/removed as D2R card. Used in methods GetDefToRegAutoCard, SetDefToRegAutoCard and RemoveDefToRegAutoCard. Used only for DeformableToRigid.AUTOMATIC. */
    static D2R: number;
/** *DEFORMABLE_TO_RIGID_INERTIA. */
    static INERTIA: number;
/** Identifies the PID type as Part. Used for field ptype. Used only for DeformableToRigid.SIMPLE or DeformableToRigid.INERTIA. */
    static PART: number;
/** Identifies the PID type as Part Set. Used for field ptype. Used only for DeformableToRigid.SIMPLE or DeformableToRigid.INERTIA. */
    static PSET: number;
/** Identifies that card is being written/retreived/removed as R2D card. Used in methods GetDefToRegAutoCard, SetDefToRegAutoCard and RemoveDefToRegAutoCard. Used only for DeformableToRigid.AUTOMATIC. */
    static R2D: number;
/** *DEFORMABLE_TO_RIGID. */
    static SIMPLE: number;
}

declare class Discrete {
/**
 * Blanks the discrete
 */
    Blank(): void;

/**
 * Blanks all of the discretes in the model.
 * @param Model Model that all discretes will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged discretes in the model.
 * @param Model Model that all the flagged discretes will be blanked in
 * @param flag Flag set on the discretes that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the discrete is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the discrete.
 * @param flag Flag to clear on the discrete
 */
    ClearFlag(flag: number): void;

/**
 * Copies the discrete.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Discrete;

/**
 * Starts an interactive editing panel to create a discrete.
 * @param Model Model that the discrete will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Discrete;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for discrete. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for discrete. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the discrete colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the discrete.
 */
    ExtractColour(): number;

/**
 * Returns the first discrete in the model.
 * @param Model Model to get first discrete in
 */
    static First(Model: Model): Discrete;

/**
 * Returns the first free discrete label in the model. Also see Discrete.LastFreeLabel(), Discrete.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free discrete label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the discretes in the model with a defined flag.
 * @param Model Model that all discretes will be flagged in
 * @param flag Flag to set on the discretes
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the discrete is flagged or not.
 * @param flag Flag to test on the discrete
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each discrete in the model. Note that ForEach has been designed to make looping over discretes as fast as possible and so has some limitations. Firstly, a single temporary Discrete object is created and on each function call it is updated with the current discrete data. This means that you should not try to store the Discrete object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new discretes inside a ForEach loop. 
 * @param Model Model that all discretes are in
 * @param func Function to call for each discrete
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Discrete objects for all of the discretes in a model in Primer
 * @param Model Model to get discretes from
 */
    static GetAll(Model: Model): Discrete[];

/**
 * Returns an array of Discrete objects for all of the flagged discretes in a model in Primer
 * @param Model Model to get discretes from
 * @param flag Flag set on the discretes that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Discrete[];

/**
 * Returns the Discrete object for a discrete ID.
 * @param Model Model to find the discrete in
 * @param number number of the discrete you want the Discrete object for
 */
    static GetFromID(Model: Model, number: number): Discrete;

/**
 * Checks if a Discrete property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Discrete.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop discrete property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this discrete (*ELEMENT_DISCRETE). Note that a carriage return is not added. See also Discrete.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the discrete. Note that a carriage return is not added. See also Discrete.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last discrete in the model.
 * @param Model Model to get last discrete in
 */
    static Last(Model: Model): Discrete;

/**
 * Returns the last free discrete label in the model. Also see Discrete.FirstFreeLabel(), Discrete.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free discrete label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next discrete in the model.
 */
    Next(): Discrete;

/**
 * Returns the next free (highest+1) discrete label in the model. Also see Discrete.FirstFreeLabel(), Discrete.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free discrete label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a discrete.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only discretes from that model can be picked. If the argument is a Flag then only discretes that are flagged with limit can be selected. If omitted, or null, any discretes from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Discrete;

/**
 * Returns the previous discrete in the model.
 */
    Previous(): Discrete;

/**
 * Renumbers all of the discretes in the model.
 * @param Model Model that all discretes will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged discretes in the model.
 * @param Model Model that all the flagged discretes will be renumbered in
 * @param flag Flag set on the discretes that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select discretes using standard PRIMER object menus.
 * @param flag Flag to use when selecting discretes
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only discretes from that model can be selected. If the argument is a Flag then only discretes that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any discretes can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the discrete.
 * @param flag Flag to set on the discrete
 */
    SetFlag(flag: number): void;

/**
 * Sketches the discrete. The discrete will be sketched until you either call Discrete.Unsketch(), Discrete.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the discrete is sketched. If omitted redraw is true. If you want to sketch several discretes and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged discretes in the model. The discretes will be sketched until you either call Discrete.Unsketch(), Discrete.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged discretes will be sketched in
 * @param flag Flag set on the discretes that you want to sketch
 * @param redraw If model should be redrawn or not after the discretes are sketched. If omitted redraw is true. If you want to sketch flagged discretes several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Calculates the timestep for the discrete
 */
    Timestep(): number;

/**
 * Returns the total number of discretes in the model.
 * @param Model Model to get total for
 * @param exists true if only existing discretes should be counted. If false or omitted referenced but undefined discretes will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the discrete
 */
    Unblank(): void;

/**
 * Unblanks all of the discretes in the model.
 * @param Model Model that all discretes will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged discretes in the model.
 * @param Model Model that the flagged discretes will be unblanked in
 * @param flag Flag set on the discretes that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the discretes in the model.
 * @param Model Model that the defined flag for all discretes will be unset in
 * @param flag Flag to unset on the discretes
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the discrete.
 * @param redraw If model should be redrawn or not after the discrete is unsketched. If omitted redraw is true. If you want to unsketch several discretes and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all discretes.
 * @param Model Model that all discretes will be unblanked in
 * @param redraw If model should be redrawn or not after the discretes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged discretes in the model.
 * @param Model Model that all discretes will be unsketched in
 * @param flag Flag set on the discretes that you want to unsketch
 * @param redraw If model should be redrawn or not after the discretes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Discrete;

/**
 * Adds a warning for discrete. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this discrete.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Discrete object.
 * @param Model Model that discrete will be created in
 * @param eid Discrete number
 * @param pid Part number
 * @param n1 Node number 1
 * @param n2 Node number 2
 * @param vid Orientation vector
 * @param s Scale factor on forces
 * @param pf Print flag. Set to write forces to the DEFORC file
 * @param offset Initial offset
 */
    constructor(Model: Model, eid: number, pid: number, n1: number, n2: number, vid?: number, s?: number, pf?: number, offset?: number);

/**
 * Creates a string containing the discrete data in keyword format. Note that this contains the keyword header and the keyword cards. See also Discrete.Keyword() and Discrete.KeywordCards().
 */
    toString(): string;

/** The colour of the discrete */
    colour: Colour;
/** Discrete number. Also see the label property which is an alternative name for this. */
    eid: number;
/** true if discrete exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the discrete is in. */
    include: number;
/** Discrete number. Also see the eid property which is an alternative name for this. */
    label: number;
/** Loadcurve for offset vs time */
    lcid: number;
/** Loadcurve for offset vs time during dynamic relaxation */
    lciddr: number;
/** If LCO option is set. Can be true or false */
    lco: boolean;
/** The Model number that the discrete is in. */
    model: number;
/** Node number 1 */
    n1: number;
/** Node number 2 */
    n2: number;
/** Initial offset */
    offset: number;
/** Print flag. Set to write forces to the DEFORC file */
    pf: number;
/** Part number */
    pid: number;
/** Scale factor on forces */
    s: number;
/** The transparency of the discrete (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Orientation vector */
    vid: number;
}

declare class DiscreteSphere {
/**
 * Blanks the discrete sphere
 */
    Blank(): void;

/**
 * Blanks all of the discrete spheres in the model.
 * @param Model Model that all discrete spheres will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged discrete spheres in the model.
 * @param Model Model that all the flagged discrete spheres will be blanked in
 * @param flag Flag set on the discrete spheres that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the discrete sphere is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the discrete sphere.
 * @param flag Flag to clear on the discrete sphere
 */
    ClearFlag(flag: number): void;

/**
 * Copies the discrete sphere.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): DiscreteSphere;

/**
 * Starts an interactive editing panel to create a discrete sphere.
 * @param Model Model that the discrete sphere will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): DiscreteSphere;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for discrete sphere. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for discrete sphere. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the discrete sphere colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the discrete sphere.
 */
    ExtractColour(): number;

/**
 * Returns the first discrete sphere in the model.
 * @param Model Model to get first discrete sphere in
 */
    static First(Model: Model): DiscreteSphere;

/**
 * Returns the first free discrete sphere label in the model. Also see DiscreteSphere.LastFreeLabel(), DiscreteSphere.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free discrete sphere label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the discrete spheres in the model with a defined flag.
 * @param Model Model that all discrete spheres will be flagged in
 * @param flag Flag to set on the discrete spheres
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the discrete sphere is flagged or not.
 * @param flag Flag to test on the discrete sphere
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each discrete sphere in the model. Note that ForEach has been designed to make looping over discrete spheres as fast as possible and so has some limitations. Firstly, a single temporary DiscreteSphere object is created and on each function call it is updated with the current discrete sphere data. This means that you should not try to store the DiscreteSphere object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new discrete spheres inside a ForEach loop. 
 * @param Model Model that all discrete spheres are in
 * @param func Function to call for each discrete sphere
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of DiscreteSphere objects for all of the discrete spheres in a model in Primer
 * @param Model Model to get discrete spheres from
 */
    static GetAll(Model: Model): DiscreteSphere[];

/**
 * Returns an array of DiscreteSphere objects for all of the flagged discrete spheres in a model in Primer
 * @param Model Model to get discrete spheres from
 * @param flag Flag set on the discrete spheres that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): DiscreteSphere[];

/**
 * Returns the DiscreteSphere object for a discrete sphere ID.
 * @param Model Model to find the discrete sphere in
 * @param number number of the discrete sphere you want the DiscreteSphere object for
 */
    static GetFromID(Model: Model, number: number): DiscreteSphere;

/**
 * Checks if a DiscreteSphere property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the DiscreteSphere.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop discrete sphere property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this discrete sphere (*ELEMENT_DISCRETE_SPHERE or *ELEMENT_DISCRETE_SPHERE_VOLUME). Note that a carriage return is not added. See also DiscreteSphere.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the discrete sphere. Note that a carriage return is not added. See also DiscreteSphere.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last discrete sphere in the model.
 * @param Model Model to get last discrete sphere in
 */
    static Last(Model: Model): DiscreteSphere;

/**
 * Returns the last free discrete sphere label in the model. Also see DiscreteSphere.FirstFreeLabel(), DiscreteSphere.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free discrete sphere label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next discrete sphere in the model.
 */
    Next(): DiscreteSphere;

/**
 * Returns the next free (highest+1) discrete sphere label in the model. Also see DiscreteSphere.FirstFreeLabel(), DiscreteSphere.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free discrete sphere label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a discrete sphere.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only discrete spheres from that model can be picked. If the argument is a Flag then only discrete spheres that are flagged with limit can be selected. If omitted, or null, any discrete spheres from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): DiscreteSphere;

/**
 * Returns the previous discrete sphere in the model.
 */
    Previous(): DiscreteSphere;

/**
 * Allows the user to select discrete spheres using standard PRIMER object menus.
 * @param flag Flag to use when selecting discrete spheres
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only discrete spheres from that model can be selected. If the argument is a Flag then only discrete spheres that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any discrete spheres can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the discrete sphere.
 * @param flag Flag to set on the discrete sphere
 */
    SetFlag(flag: number): void;

/**
 * Sketches the discrete sphere. The discrete sphere will be sketched until you either call DiscreteSphere.Unsketch(), DiscreteSphere.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the discrete sphere is sketched. If omitted redraw is true. If you want to sketch several discrete spheres and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged discrete spheres in the model. The discrete spheres will be sketched until you either call DiscreteSphere.Unsketch(), DiscreteSphere.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged discrete spheres will be sketched in
 * @param flag Flag set on the discrete spheres that you want to sketch
 * @param redraw If model should be redrawn or not after the discrete spheres are sketched. If omitted redraw is true. If you want to sketch flagged discrete spheres several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of discrete spheres in the model.
 * @param Model Model to get total for
 * @param exists true if only existing discrete spheres should be counted. If false or omitted referenced but undefined discrete spheres will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the discrete sphere
 */
    Unblank(): void;

/**
 * Unblanks all of the discrete spheres in the model.
 * @param Model Model that all discrete spheres will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged discrete spheres in the model.
 * @param Model Model that the flagged discrete spheres will be unblanked in
 * @param flag Flag set on the discrete spheres that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the discrete spheres in the model.
 * @param Model Model that the defined flag for all discrete spheres will be unset in
 * @param flag Flag to unset on the discrete spheres
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the discrete sphere.
 * @param redraw If model should be redrawn or not after the discrete sphere is unsketched. If omitted redraw is true. If you want to unsketch several discrete spheres and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all discrete spheres.
 * @param Model Model that all discrete spheres will be unblanked in
 * @param redraw If model should be redrawn or not after the discrete spheres are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged discrete spheres in the model.
 * @param Model Model that all discrete spheres will be unsketched in
 * @param flag Flag set on the discrete spheres that you want to unsketch
 * @param redraw If model should be redrawn or not after the discrete spheres are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): DiscreteSphere;

/**
 * Adds a warning for discrete sphere. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this discrete sphere.
 */
    Xrefs(): Xrefs;

/**
 * Create a new DiscreteSphere object.
 * @param Model Model that discrete sphere will be created in
 * @param nid Node ID and Element ID are the same for discrete spheres.
 * @param pid Part ID to which this element belongs.
 * @param mass Mass or volume value.
 * @param inertia Mass moment of inertia.
 * @param radius Particle radius.
 */
    constructor(Model: Model, nid: number, pid: number, mass: number, inertia: number, radius: number);

/**
 * Creates a string containing the discrete sphere data in keyword format. Note that this contains the keyword header and the keyword cards. See also DiscreteSphere.Keyword() and DiscreteSphere.KeywordCards().
 */
    toString(): string;

/** The colour of the discrete sphere */
    colour: Colour;
/** true if discrete sphere exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the discrete sphere is in. */
    include: number;
/** Mass moment of inertia. */
    inertia: number;
/** Mass or volume value (depending on whether the _VOLUME option is set). */
    mass: number;
/** The Model number that the discrete sphere is in. */
    model: number;
/** Node ID. */
    nid: number;
/** Part ID to which this element belongs. */
    pid: number;
/** Particle radius. */
    radius: number;
/** The transparency of the discrete sphere (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Turns _VOLUME on or OFF. Note that this does NOT refer to the data field VOLUME. For the latter see the mass property. */
    volume: boolean;
}


/** Object returned by GetAssembly */
interface GetAssemblyReturn {
    /** Assembly label */
    label: number;
    /** Parent assembly label */
    parent: number;
    /** Assembly title */
    title: string;
}


/** Object returned by GetPoint */
interface GetPointReturn {
    /** Assembly label */
    assembly: number;
    /** Coordinate system */
    csys: number;
    /** If point has been automatically created by PRIMER at the H-point */
    hpt: boolean;
    /** Point label */
    label: number;
    /** Node label (0 if coordinate) */
    node: number;
    /** Point restrained rotationally in X */
    rx: boolean;
    /** Point restrained rotationally in Y */
    ry: boolean;
    /** Point restrained rotationally in Z */
    rz: boolean;
    /** Point title */
    title: string;
    /** Point restrained translationally in X */
    tx: boolean;
    /** Point restrained translationally in Y */
    ty: boolean;
    /** Point restrained translationally in Z */
    tz: boolean;
    /** Node/point x coordinate */
    x: number;
    /** Node/point y coordinate */
    y: number;
    /** Node/point z coordinate */
    z: number;
}


/** Object function argument in SetPoint */
interface SetPointArgument_data {
    /** Assembly label */
    assembly: number;
    /** Coordinate system label */
    csys?: number;
    /** Node label (not rewuired if using x, y and z) */
    node?: number;
    /** Point restrained rotationally in X */
    rx?: boolean;
    /** Point restrained rotationally in Y */
    ry?: boolean;
    /** Point restrained rotationally in Z */
    rz?: boolean;
    /** Title */
    title?: string;
    /** Point restrained translationally in X */
    tx?: boolean;
    /** Point restrained translationally in Y */
    ty?: boolean;
    /** Point restrained translationally in Z */
    tz?: boolean;
    /** X coordinate (not required if using node) */
    x?: number;
    /** Y coordinate (not required if using node) */
    y?: number;
    /** Z coordinate (not required if using node) */
    z?: number;
}

declare class Dummy {
/**
 * Blanks the dummy
 */
    Blank(): void;

/**
 * Blanks all of the dummys in the model.
 * @param Model Model that all dummys will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged dummys in the model.
 * @param Model Model that all the flagged dummys will be blanked in
 * @param flag Flag set on the dummys that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the dummy is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the dummy.
 * @param flag Flag to clear on the dummy
 */
    ClearFlag(flag: number): void;

/**
 * Copies the dummy.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Dummy;

/**
 * Adds an error for dummy. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first dummy in the model.
 * @param Model Model to get first dummy in
 */
    static First(Model: Model): Dummy;

/**
 * Returns the first free dummy label in the model. Also see Dummy.LastFreeLabel(), Dummy.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free dummy label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the dummys in the model with a defined flag.
 * @param Model Model that all dummys will be flagged in
 * @param flag Flag to set on the dummys
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the dummy is flagged or not.
 * @param flag Flag to test on the dummy
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each dummy in the model. Note that ForEach has been designed to make looping over dummys as fast as possible and so has some limitations. Firstly, a single temporary Dummy object is created and on each function call it is updated with the current dummy data. This means that you should not try to store the Dummy object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new dummys inside a ForEach loop. 
 * @param Model Model that all dummys are in
 * @param func Function to call for each dummy
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Dummy objects for all of the dummys in a model in Primer
 * @param Model Model to get dummys from
 */
    static GetAll(Model: Model): Dummy[];

/**
 * Returns the information for an assembly
 * @param index The index of the assembly you want the coordinates for. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies
 */
    GetAssembly(index: number): GetAssemblyReturn;

/**
 * Returns an array of Dummy objects for all of the flagged dummys in a model in Primer
 * @param Model Model to get dummys from
 * @param flag Flag set on the dummys that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Dummy[];

/**
 * Returns the Dummy object for a dummy ID.
 * @param Model Model to find the dummy in
 * @param number number of the dummy you want the Dummy object for
 */
    static GetFromID(Model: Model, number: number): Dummy;

/**
 * Checks if a Dummy property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Dummy.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop dummy property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the information for a reference point
 * @param index The index of the reference point you want the information for. Note that reference points start at 0, not 1. 0 &lt;= index &lt; points
 */
    GetPoint(index: number): GetPointReturn;

/**
 * Returns the coordinates of a reference point
 * @param rpt The reference point you want the coordinates for. Note that reference points start at 0, not 1.
 */
    GetPointData(rpt: number): number[];

/**
 * Returns the title of a reference point
 * @param rpt The reference point you want the title for. Note that reference points start at 0, not 1.
 */
    GetPointTitle(rpt: number): number;

/**
 * Returns the last dummy in the model.
 * @param Model Model to get last dummy in
 */
    static Last(Model: Model): Dummy;

/**
 * Returns the last free dummy label in the model. Also see Dummy.FirstFreeLabel(), Dummy.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free dummy label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next dummy in the model.
 */
    Next(): Dummy;

/**
 * Returns the next free (highest+1) dummy label in the model. Also see Dummy.FirstFreeLabel(), Dummy.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free dummy label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a dummy.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only dummys from that model can be picked. If the argument is a Flag then only dummys that are flagged with limit can be selected. If omitted, or null, any dummys from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Dummy;

/**
 * Returns the previous dummy in the model.
 */
    Previous(): Dummy;

/**
 * Removes a reference point from a dummy
 * @param index The index of the reference point you want to remove. Note that reference points start at 0, not 1. 0 &lt;= index &lt; points
 */
    RemovePoint(index: number): void;

/**
 * Renumbers all of the dummys in the model.
 * @param Model Model that all dummys will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged dummys in the model.
 * @param Model Model that all the flagged dummys will be renumbered in
 * @param flag Flag set on the dummys that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select dummys using standard PRIMER object menus.
 * @param flag Flag to use when selecting dummys
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only dummys from that model can be selected. If the argument is a Flag then only dummys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any dummys can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the dummy.
 * @param flag Flag to set on the dummy
 */
    SetFlag(flag: number): void;

/**
 * Sets the data for a reference point in a dummy
 * @param index The index of the reference point you want to set. Note that reference points start at 0, not 1. To add a new point use index points
 * @param data Object containing the reference point data. The properties can be:
 */
    SetPoint(index: number, data: SetPointArgument_data): void;

/**
 * Sketches the dummy. The dummy will be sketched until you either call Dummy.Unsketch(), Dummy.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the dummy is sketched. If omitted redraw is true. If you want to sketch several dummys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged dummys in the model. The dummys will be sketched until you either call Dummy.Unsketch(), Dummy.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged dummys will be sketched in
 * @param flag Flag set on the dummys that you want to sketch
 * @param redraw If model should be redrawn or not after the dummys are sketched. If omitted redraw is true. If you want to sketch flagged dummys several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of dummys in the model.
 * @param Model Model to get total for
 * @param exists true if only existing dummys should be counted. If false or omitted referenced but undefined dummys will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the dummy
 */
    Unblank(): void;

/**
 * Unblanks all of the dummys in the model.
 * @param Model Model that all dummys will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged dummys in the model.
 * @param Model Model that the flagged dummys will be unblanked in
 * @param flag Flag set on the dummys that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the dummys in the model.
 * @param Model Model that the defined flag for all dummys will be unset in
 * @param flag Flag to unset on the dummys
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the dummy.
 * @param redraw If model should be redrawn or not after the dummy is unsketched. If omitted redraw is true. If you want to unsketch several dummys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all dummys.
 * @param Model Model that all dummys will be unblanked in
 * @param redraw If model should be redrawn or not after the dummys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged dummys in the model.
 * @param Model Model that all dummys will be unsketched in
 * @param flag Flag set on the dummys that you want to unsketch
 * @param redraw If model should be redrawn or not after the dummys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Dummy;

/**
 * Adds a warning for dummy. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this dummy.
 */
    Xrefs(): Xrefs;

/** Number of assemblies defined. (read only) */
    readonly assemblies: number;
/** true if dummy exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Dummy number. Also see the label property which is an alternative name for this. (read only) */
    readonly id: number;
/** The Include file number that the dummy is in. */
    include: number;
/** Dummy number. Also see the id property which is an alternative name for this. (read only) */
    readonly label: number;
/** The Model number that the dummy is in. */
    model: number;
/** Number of reference points defined. (read only) */
    readonly points: number;
/** Dummy title. */
    title: string;
/** H-Point X coordinate. (read only) */
    readonly xhpoint: number;
/** H-Point Y coordinate. (read only) */
    readonly yhpoint: number;
/** H-Point Z coordinate. (read only) */
    readonly zhpoint: number;
}

declare class ElementDeath {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the element death.
 * @param flag Flag to clear on the element death
 */
    ClearFlag(flag: number): void;

/**
 * Copies the element death.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): ElementDeath;

/**
 * Starts an interactive editing panel to create an element death.
 * @param Model Model that the element death will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): ElementDeath;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for element death. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first element death in the model.
 * @param Model Model to get first element death in
 */
    static First(Model: Model): ElementDeath;

/**
 * Flags all of the element deaths in the model with a defined flag.
 * @param Model Model that all element deaths will be flagged in
 * @param flag Flag to set on the element deaths
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the element death is flagged or not.
 * @param flag Flag to test on the element death
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each element death in the model. Note that ForEach has been designed to make looping over element deaths as fast as possible and so has some limitations. Firstly, a single temporary ElementDeath object is created and on each function call it is updated with the current element death data. This means that you should not try to store the ElementDeath object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new element deaths inside a ForEach loop. 
 * @param Model Model that all element deaths are in
 * @param func Function to call for each element death
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of ElementDeath objects for all of the element deaths in a model in Primer
 * @param Model Model to get element deaths from
 */
    static GetAll(Model: Model): ElementDeath[];

/**
 * Returns an array of ElementDeath objects for all of the flagged element deaths in a model in Primer
 * @param Model Model to get element deaths from
 * @param flag Flag set on the element deaths that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): ElementDeath[];

/**
 * Returns the ElementDeath object for a element death ID.
 * @param Model Model to find the element death in
 * @param number number of the element death you want the ElementDeath object for
 */
    static GetFromID(Model: Model, number: number): ElementDeath;

/**
 * Checks if a ElementDeath property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ElementDeath.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop element death property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this element death (*DEFINE_ELEMENT_DEATH). Note that a carriage return is not added. See also ElementDeath.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the element death. Note that a carriage return is not added. See also ElementDeath.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last element death in the model.
 * @param Model Model to get last element death in
 */
    static Last(Model: Model): ElementDeath;

/**
 * Returns the next element death in the model.
 */
    Next(): ElementDeath;

/**
 * Returns the previous element death in the model.
 */
    Previous(): ElementDeath;

/**
 * Allows the user to select element deaths using standard PRIMER object menus.
 * @param flag Flag to use when selecting element deaths
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only element deaths from that model can be selected. If the argument is a Flag then only element deaths that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any element deaths can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the element death.
 * @param flag Flag to set on the element death
 */
    SetFlag(flag: number): void;

/**
 * Returns the total number of element deaths in the model.
 * @param Model Model to get total for
 * @param exists true if only existing element deaths should be counted. If false or omitted referenced but undefined element deaths will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the element deaths in the model.
 * @param Model Model that the defined flag for all element deaths will be unset in
 * @param flag Flag to unset on the element deaths
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): ElementDeath;

/**
 * Adds a warning for element death. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this element death.
 */
    Xrefs(): Xrefs;

/**
 * Create a new ElementDeath object.
 * @param Model Model that element death will be created in
 * @param type ElementDeath type. Can be ElementDeath.SOLID, ElementDeath.SOLID_SET, ElementDeath.BEAM, ElementDeath.BEAM_SET, ElementDeath.SHELL, ElementDeath.SHELL_SET, ElementDeath.THICK_SHELL or ElementDeath.THICK_SHELL_SET
 * @param eid_sid Element or element set ID
 */
    constructor(Model: Model, type: string, eid_sid: number);

/**
 * Creates a string containing the element death data in keyword format. Note that this contains the keyword header and the keyword cards. See also ElementDeath.Keyword() and ElementDeath.KeywordCards().
 */
    toString(): string;

/** Box restricting element deletion */
    boxid: number;
/** Coordinate ID for transforming boxid. */
    cid: number;
/** Element ID or element set ID. The sid property is an alternative name for this. */
    eid: number;
/** true if element death exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Group ID for simultaneous deletion. */
    idgrp: number;
/** The Include file number that the element death is in. */
    include: number;
/** If true, LS_DYNA deletes elements outside box, otherwise inside box. */
    inout: boolean;
/** The Model number that the element death is in. */
    model: number;
/** ElementDeath option. Can be ElementDeath.SOLID, ElementDeath.SOLID_SET, ElementDeath.BEAM, ElementDeath.BEAM_SET, ElementDeath.SHELL, ElementDeath.SHELL_SET, ElementDeath.THICK_SHELL or ElementDeath.THICK_SHELL_SET. The type property is an alternative name for this. */
    option: number;
/** Deletion percentage. */
    percent: number;
/** Element ID or element set ID. The eid property is an alternative name for this. */
    sid: number;
/** Deletion time for elimination */
    time: number;
/** ElementDeath title */
    title: string;
/** ElementDeath option. Can be ElementDeath.SOLID, ElementDeath.SOLID_SET, ElementDeath.BEAM, ElementDeath.BEAM_SET, ElementDeath.SHELL, ElementDeath.SHELL_SET, ElementDeath.THICK_SHELL or ElementDeath.THICK_SHELL_SET The option property is an alternative name for this. */
    type: number;
/** Beam option */
    static BEAM: number;
/** Beam set option */
    static BEAM_SET: number;
/** Shell option */
    static SHELL: number;
/** Shell set option */
    static SHELL_SET: number;
/** Solid option */
    static SOLID: number;
/** Solid set option */
    static SOLID_SET: number;
/** Thick shell option */
    static THICK_SHELL: number;
/** Thick shell set option */
    static THICK_SHELL_SET: number;
}

declare class ExtraNodes {
/**
 * Blanks the constrained extra node
 */
    Blank(): void;

/**
 * Blanks all of the constrained extra nodes in the model.
 * @param Model Model that all constrained extra nodes will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged constrained extra nodes in the model.
 * @param Model Model that all the flagged constrained extra nodes will be blanked in
 * @param flag Flag set on the constrained extra nodes that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the constrained extra node is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the constrained extra node.
 * @param flag Flag to clear on the constrained extra node
 */
    ClearFlag(flag: number): void;

/**
 * Copies the constrained extra node.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): ExtraNodes;

/**
 * Starts an interactive editing panel to create a constrained extra nodes card.
 * @param Model Model that the constrained extra nodes card will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): ExtraNodes;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for constrained extra node. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first constrained extra node in the model.
 * @param Model Model to get first constrained extra node in
 */
    static First(Model: Model): ExtraNodes;

/**
 * Flags all of the constrained extra nodes in the model with a defined flag.
 * @param Model Model that all constrained extra nodes will be flagged in
 * @param flag Flag to set on the constrained extra nodes
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the constrained extra node is flagged or not.
 * @param flag Flag to test on the constrained extra node
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each constrained extra node in the model. Note that ForEach has been designed to make looping over constrained extra nodes as fast as possible and so has some limitations. Firstly, a single temporary ExtraNodes object is created and on each function call it is updated with the current constrained extra node data. This means that you should not try to store the ExtraNodes object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new constrained extra nodes inside a ForEach loop. 
 * @param Model Model that all constrained extra nodes are in
 * @param func Function to call for each constrained extra node
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of ExtraNodes objects for all of the constrained extra nodes in a model in Primer
 * @param Model Model to get constrained extra nodes from
 */
    static GetAll(Model: Model): ExtraNodes[];

/**
 * Returns an array of ExtraNodes objects for all of the flagged constrained extra nodes in a model in Primer
 * @param Model Model to get constrained extra nodes from
 * @param flag Flag set on the constrained extra nodes that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): ExtraNodes[];

/**
 * Returns the ExtraNodes object for a constrained extra node ID.
 * @param Model Model to find the constrained extra node in
 * @param number number of the constrained extra node you want the ExtraNodes object for
 */
    static GetFromID(Model: Model, number: number): ExtraNodes;

/**
 * Checks if a ExtraNodes property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ExtraNodes.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop constrained extra node property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this constrained extra nodes (*CONSTRAINED_EXTRA_NODES). Note that a carriage return is not added. See also ExtraNodes.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the constrained extra nodes. Note that a carriage return is not added. See also ExtraNodes.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last constrained extra node in the model.
 * @param Model Model to get last constrained extra node in
 */
    static Last(Model: Model): ExtraNodes;

/**
 * Returns the next constrained extra node in the model.
 */
    Next(): ExtraNodes;

/**
 * Allows the user to pick a constrained extra node.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only constrained extra nodes from that model can be picked. If the argument is a Flag then only constrained extra nodes that are flagged with limit can be selected. If omitted, or null, any constrained extra nodes from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): ExtraNodes;

/**
 * Returns the previous constrained extra node in the model.
 */
    Previous(): ExtraNodes;

/**
 * Allows the user to select constrained extra nodes using standard PRIMER object menus.
 * @param flag Flag to use when selecting constrained extra nodes
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only constrained extra nodes from that model can be selected. If the argument is a Flag then only constrained extra nodes that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any constrained extra nodes can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the constrained extra node.
 * @param flag Flag to set on the constrained extra node
 */
    SetFlag(flag: number): void;

/**
 * Sketches the constrained extra node. The constrained extra node will be sketched until you either call ExtraNodes.Unsketch(), ExtraNodes.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the constrained extra node is sketched. If omitted redraw is true. If you want to sketch several constrained extra nodes and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged constrained extra nodes in the model. The constrained extra nodes will be sketched until you either call ExtraNodes.Unsketch(), ExtraNodes.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged constrained extra nodes will be sketched in
 * @param flag Flag set on the constrained extra nodes that you want to sketch
 * @param redraw If model should be redrawn or not after the constrained extra nodes are sketched. If omitted redraw is true. If you want to sketch flagged constrained extra nodes several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of constrained extra nodes in the model.
 * @param Model Model to get total for
 * @param exists true if only existing constrained extra nodes should be counted. If false or omitted referenced but undefined constrained extra nodes will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the constrained extra node
 */
    Unblank(): void;

/**
 * Unblanks all of the constrained extra nodes in the model.
 * @param Model Model that all constrained extra nodes will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged constrained extra nodes in the model.
 * @param Model Model that the flagged constrained extra nodes will be unblanked in
 * @param flag Flag set on the constrained extra nodes that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the constrained extra nodes in the model.
 * @param Model Model that the defined flag for all constrained extra nodes will be unset in
 * @param flag Flag to unset on the constrained extra nodes
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the constrained extra node.
 * @param redraw If model should be redrawn or not after the constrained extra node is unsketched. If omitted redraw is true. If you want to unsketch several constrained extra nodes and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all constrained extra nodes.
 * @param Model Model that all constrained extra nodes will be unblanked in
 * @param redraw If model should be redrawn or not after the constrained extra nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged constrained extra nodes in the model.
 * @param Model Model that all constrained extra nodes will be unsketched in
 * @param flag Flag set on the constrained extra nodes that you want to unsketch
 * @param redraw If model should be redrawn or not after the constrained extra nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): ExtraNodes;

/**
 * Adds a warning for constrained extra node. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this constrained extra node.
 */
    Xrefs(): Xrefs;

/**
 * Create a new ExtraNodes object.
 * @param Model Model that constrained extra nodes will be created in
 * @param option Specify the type of constrained extra nodes. Can be ExtraNodes.NODE or ExtraNodes.SET)
 * @param pid Part ID of rigid body
 * @param id Node node ID or node set ID
 * @param iflag Flag for adding node mass inertia to PART_INERTIA
 */
    constructor(Model: Model, option: number, pid: number, id: number, iflag: boolean);

/**
 * Creates a string containing the constrained extra nodes data in keyword format. Note that this contains the keyword header and the keyword cards. See also ExtraNodes.Keyword() and ExtraNodes.KeywordCards().
 */
    toString(): string;

/** true if constrained extra nodes exists, false if referred to but not defined (read only) */
    readonly exists: boolean;
/** Node ID or node set ID (not internal label) */
    id: number;
/** Flag for adding node mass inertia to PART_INERTIA */
    iflag: boolean;
/** The Include file number that the constrained extra nodes is in. */
    include: number;
/** The label the constrained extra nodes has in PRIMER (read only) */
    readonly label: number;
/** The Model number that the constrained extra node is in. */
    model: number;
/** The Constrained Extra Nodes option. Can be ExtraNodes.NODE or ExtraNodes.SET. */
    option: number;
/** Part ID of rigid body. */
    pid: number;
/** CNST is *CONSTRAINED_EXTRA_NODES_NODE. */
    static NODE: number;
/** CNST is *CONSTRAINED_EXTRA_NODES_SET. */
    static SET: number;
}


/** Object function argument in Get */
interface GetArgument_options {
    /** Password */
    password?: string;
    /** If set to true, then the response code will be returned instead of true/false. This can be used to retieve error messages and codes when the file is not returned successfully. */
    response?: boolean;
    /** Username */
    username?: string;
}


/** Object function argument in Upload */
interface UploadArgument_options {
    /** Password */
    password?: string;
    /** Username */
    username?: string;
}

declare class File {
/**
 * Close a file opened by a File object.
 */
    Close(): void;

/**
 * Copies a file
 * @param source Source filename you want to copy.
 * @param dest Destination filename you want to copy source file to.
 */
    static Copy(source: string, dest: string): boolean;

/**
 * Deletes a file
 * @param filename Filename you want to delete.
 */
    static Delete(filename: string): boolean;

/**
 * Changes a filename or directory name to the correct format for a specific operating system using the directory mappings (if present)
 * @param filename Filename you want to drive map.
 * @param format The format for the file/directory name. Can be Include.NATIVE, Include.UNIX or Include.WINDOWS
 */
    static DriveMapFilename(filename: string, format: number): string;

/**
 * Check if a file exists. See also File.IsDirectory() and See also File.IsFile().
 * @param filename Filename you want to check for existance.
 */
    static Exists(filename: string): boolean;

/**
 * Find any files and/or directories in a directory.
 * @param directory Directory to look for files/directories in.
 * @param type Type of things to find. Can be bitwise OR of File.FILE and File.DIRECTORY. If omitted only files will be returned.
 */
    static FindFiles(directory: string, type?: number): string[];

/**
 * Reads a line from a file which contains contain, opened for reading by a File object. Although this is possible using core JavaScript functions this function should be significantly faster as most of the processing is done by Primer in C rather than in the JavaScript interpreter. To enable this function to be as fast as possible a maximum line length of 512 characters is used. If you expect a file to have lines longer than 512 characters then use ReadLongLine which allows lines of any length. If one argument is used then the line must contain that string. If more than one argument is used then lines which contain the string contain1 OR contain2 OR contain3 etc will be returned
 * @param contain1 String which matching lines must contain
 * @param contain2 alternative string which matching lines must contain
 * @param contain3 alternative string which matching lines must contain
 * @param ...vars_containn alternative string which matching lines must contain
 */
    FindLineContaining(contain1: string, contain2?: string, contain3?: string, ...vars_containn?: string[]): string;

/**
 * Reads a line from a file which starts with start, opened for reading by a File object. Although this is possible using core JavaScript functions this function should be significantly faster as most of the processing is done by Primer in C rather than in the JavaScript interpreter. To enable this function to be as fast as possible a maximum line length of 512 characters is used. If you expect a file to have lines longer than 512 characters then use ReadLongLine which allows lines of any length. If one argument is used then the line must start with that string. If more than one argument is used then lines which start with start1 OR start2 OR start3 etc will be returned
 * @param start1 String which matching lines must start with
 * @param start2 alternative string which matching lines must start with
 * @param start3 alternative string which matching lines must start with
 * @param ...vars_startn alternative string which matching lines must start with
 */
    FindLineStarting(start1: string, start2?: string, start3?: string, ...vars_startn?: string[]): string;

/**
 * Flushes a file opened for writing by a File object.
 */
    Flush(): void;

/**
 * Get a file from a remote location. See also File.Proxy(), File.ProxyPassword() and File.ProxyUsername().
 * @param url URL (uniform resource locator) of remote file you want to get. Currently http and ftp are supported. For http give the full address including the leading 'http://'. e.g. 'http://www.example.com/file.html'. For ftp an optional username and password can be given. e.g. 'ftp://ftp.example.com' retrieves the directory listing for the root directory. 'ftp://ftp.example.com/readme.txt' downloads the file readme.txt from the root directory. 'ftp://user:password@ftp.example.com/readme.txt' retrieves the readme.txt file from the user's home directory.
 * @param filename Filename you want to save the file to.
 * @param options Options for get. If 'username' and 'password' are set then basic authorization using the username and password will be used.
 */
    static Get(url: string, filename: string, options?: GetArgument_options): boolean;

/**
 * Check if a filename is absolute or relative.
 * @param filename Filename you want to check.
 */
    static IsAbsolute(filename: string): boolean;

/**
 * Check if a filename is a directory. See also File.Exists(), File.IsFile(), File.IsReadable() and File.IsWritable().
 * @param filename Filename you want to check.
 */
    static IsDirectory(filename: string): boolean;

/**
 * Check if a filename is a file. See also File.Exists(), File.IsDirectory(), File.IsReadable() and File.IsWritable().
 * @param filename Filename you want to check.
 */
    static IsFile(filename: string): boolean;

/**
 * Check if a filename has read permissions. See also File.Exists(), File.IsDirectory() and File.IsWritable().
 * @param filename Filename you want to check.
 */
    static IsReadable(filename: string): boolean;

/**
 * Check if a filename has write permissions. If filename exists and it is a file then it is checked to see if it can be opened with write (File.APPEND permissions). If filename exists and it is a directory then the directory is checked for write permission (can files be created in the directory). If filename does not exist then it is assumed to be a file and is checked to see if it can be opened for writing (File.WRITE permissions). See also File.Exists(), File.IsDirectory() and File.IsReadable().
 * @param filename Filename you want to check.
 */
    static IsWritable(filename: string): boolean;

/**
 * Make a directory. If Primer preference 'directory_permission' is set e.g.755 then this will apply (same as if set by chmod 755) ignoring any setting of umask. If there is no preference then the users current setting of umask will control permissions (same as system mkdir)
 * @param directory The name of the directory you want to create.
 */
    static Mkdir(directory: string): boolean;

/**
 * Make a temporary filename for writing a temporary file.
 */
    static Mktemp(): string;

/**
 * Set a proxy for files opened by http, ftp etc. See also File.Get(), File.ProxyPassword() and File.ProxyUsername().
 * @param name The name of the proxy.
 */
    static Proxy(name: string): void;

/**
 * Set a proxy password for files opened by http, ftp etc. See also File.Get(), File.Proxy() and File.ProxyUsername().
 * @param name Password for the proxy server.
 */
    static ProxyPassword(name: string): void;

/**
 * Set a proxy username for files opened by http, ftp etc. See also File.Get(), File.Proxy() and File.ProxyPassword().
 * @param username The username for the proxy.
 */
    static ProxyUsername(username: string): void;

/**
 * Reads all the remaining characters from a file opened for reading by a File object. As this function can read the entire file as a string be careful when reading large files as it will consume large amounts of memory.
 */
    ReadAll(): string;

/**
 * Reads binary data from a file opened for reading by a File object. The data is returned as an ArrayBuffer object. For more details on how to use an ArrayBuffer see the following links: https://developer.mozilla.org/en/JavaScript_typed_arrays https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBufferView https://developer.mozilla.org/en/JavaScript_typed_arrays/DataView.
 * @param length Number of bytes to try to read from the file. If omitted all the remaining data from the file will be read.
 */
    ReadArrayBuffer(length?: number): ArrayBuffer;

/**
 * Reads the input CSV file and returns an array of string arrays. If the CSV file has legitimate records the function returns an Array object containing sub-arrays of strings otherwise the function returns NULL. The lengths of all the sub-arrays are the same and equal to maximum number of fields in any of the records. For records in a CSV file having fewer fields, the respective sub-arrays are padded with NULL elements to the maximum array length.
 * @param filename Filename you want to read CSV options from.
 * @param delimiter Delimiter string to be used. Default is a comma (",").
 * @param comment Comment string to be used. Default is a dollar sign ("$").
 */
    static ReadCSV(filename: string, delimiter?: string, comment?: string): string[];

/**
 * Reads a single character from a file opened for reading by a File object.
 */
    ReadChar(): string;

/**
 * Reads a line from a file opened for reading by a File object. To enable this function to be as fast as possible a maximum line length of 512 characters is used. If you expect a file to have lines longer than 512 characters then use ReadLongLine which allows lines of any length.
 */
    ReadLine(): string;

/**
 * Reads a line from a file opened for reading by a File object. The line can be any length. If your file has lines shorter than 512 characters then you may want to use ReadLine instead which is faster.
 */
    ReadLongLine(): string;

/**
 * Rename an existing file to have a different name.
 * @param oldname Existing filename you want to rename
 * @param newname New filename you want to rename to
 */
    static Rename(oldname: string, newname: string): boolean;

/**
 * Set the current position for reading or writing in a File object.
 * @param offset Offset to seek to in the file
 * @param origin Origin for offset. Must be one of File.START, File.END or File.CURRENT. If omitted File.START will be used.
 */
    Seek(offset: number, origin?: number): void;

/**
 * Return the size of a file in bytes
 * @param filename Filename you want the size of.
 */
    static Size(filename: string): number;

/**
 * Return the current file position for a File object. Note that on Windows when reading files if the file is not opened with File.BINARY this may not return the correct file position for files with unix line endings.
 */
    Tell(): number;

/**
 * Uploads a file to a remote location. See also File.Proxy(), File.ProxyPassword() and File.ProxyUsername().
 * @param filename Filename you want to upload.
 * @param url URL (uniform resource locator) of the remote location you want to upload the file to. Currently only http is supported. Give the full address including the leading 'http://'. e.g. 'http://www.example.com/file.html'.
 * @param options Options for upload. If both of these are set then basic authorization using the username and password will be used.
 */
    static Upload(filename: string, url: string, options?: UploadArgument_options): boolean;

/**
 * Write a string to a file opened for writing by a File object. Note that a carriage return is not added.
 * @param string The string/item that you want to write
 */
    Write(string: any): void;

/**
 * Writes binary data to a file opened for writing by a File object. The data to write is an ArrayBuffer object. For more details on how to use an ArrayBuffer see the following links: https://developer.mozilla.org/en/JavaScript_typed_arrays https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBufferView https://developer.mozilla.org/en/JavaScript_typed_arrays/DataView.
 * @param buffer ArrayBuffer to write to file
 * @param length Number of bytes to write to the file. If omitted all the data in the ArrayBuffer will be written (buffer.byteLength bytes)
 */
    WriteArrayBuffer(buffer: ArrayBuffer, length?: number): void;

/**
 * Write a string to a file opened for writing by a File object adding a carriage return.
 * @param string The string/item that you want to write
 */
    Writeln(string: any): void;

/**
 * Create a new File object for reading and writing text files.
 * @param filename Filename of the file you want to read/write. If reading, the file must exist. If writing, the file will be overwritten (if it exists) if mode is File.WRITE, or if mode is File.APPEND it will be appended to if it exists, or created if it does not. When reading a file the filename can also be a URL (uniform resource locator) in which case the file will be read from the remote site. See File.Get() for more details on the format of the URL.
 * @param mode The mode to open the file with. Can be File.READ, File.WRITE or File.APPEND. For File.WRITE or File.APPEND it can also be ORed with File.BINARY if required. By default text is read and written as ASCII. To read/write text in utf-8 mode can also be ORed with File.UTF8 if required.
 */
    constructor(filename: string, mode: number);

/** Name of the file */
    readonly filename: string;
/** Mode the file was opened with (File.READ, File.WRITE etc) */
    readonly mode: number;
/** Flag to open file for appending */
    static APPEND: number;
/** Flag to open file in binary mode. This will have no effect on unix/linux but for windows if a file is opened for writing with binary mode \n will not be translated to \r\n (CRLF), it will be written as \n (LF) */
    static BINARY: number;
/** Seek relative to current file position */
    static CURRENT: number;
/** Find directories */
    static DIRECTORY: number;
/** Seek relative to end of the file */
    static END: number;
/** Find files */
    static FILE: number;
/** Flag to open file for reading */
    static READ: number;
/** Seek relative to start of the file */
    static START: number;
/** Flag to open file for reading as UTF-8 encoding. */
    static UTF8: number;
/** Flag to open file for writing */
    static WRITE: number;
}

declare class GeneralizedWeld {
/**
 * Blanks the generalized weld
 */
    Blank(): void;

/**
 * Blanks all of the generalized welds in the model.
 * @param Model Model that all generalized welds will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged generalized welds in the model.
 * @param Model Model that all the flagged generalized welds will be blanked in
 * @param flag Flag set on the generalized welds that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the generalized weld is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the generalized weld.
 * @param flag Flag to clear on the generalized weld
 */
    ClearFlag(flag: number): void;

/**
 * Copies the generalized weld.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): GeneralizedWeld;

/**
 * Starts an interactive editing panel to create a gwld.
 * @param Model Model that the gwld will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): GeneralizedWeld;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for generalized weld. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first generalized weld in the model.
 * @param Model Model to get first generalized weld in
 */
    static First(Model: Model): GeneralizedWeld;

/**
 * Returns the first free generalized weld label in the model. Also see GeneralizedWeld.LastFreeLabel(), GeneralizedWeld.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free generalized weld label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the generalized welds in the model with a defined flag.
 * @param Model Model that all generalized welds will be flagged in
 * @param flag Flag to set on the generalized welds
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the generalized weld is flagged or not.
 * @param flag Flag to test on the generalized weld
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each generalized weld in the model. Note that ForEach has been designed to make looping over generalized welds as fast as possible and so has some limitations. Firstly, a single temporary GeneralizedWeld object is created and on each function call it is updated with the current generalized weld data. This means that you should not try to store the GeneralizedWeld object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new generalized welds inside a ForEach loop. 
 * @param Model Model that all generalized welds are in
 * @param func Function to call for each generalized weld
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of GeneralizedWeld objects for all of the generalized welds in a model in Primer
 * @param Model Model to get generalized welds from
 */
    static GetAll(Model: Model): GeneralizedWeld[];

/**
 * Returns the combined data for a specific nodal pair as an array.
 * @param index Index you want the data for. Note that indices start at 0.
 */
    GetCombinedData(index: number): number[];

/**
 * Returns the cross fillet data for a specific nodal pair as an array.
 * @param index Index you want the data for. Note that indices start at 0.
 */
    GetCrossFilletData(index: number): number[];

/**
 * Returns an array of GeneralizedWeld objects for all of the flagged generalized welds in a model in Primer
 * @param Model Model to get generalized welds from
 * @param flag Flag set on the generalized welds that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): GeneralizedWeld[];

/**
 * Returns the GeneralizedWeld object for a generalized weld ID.
 * @param Model Model to find the generalized weld in
 * @param number number of the generalized weld you want the GeneralizedWeld object for
 */
    static GetFromID(Model: Model, number: number): GeneralizedWeld;

/**
 * Checks if a GeneralizedWeld property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the GeneralizedWeld.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop generalized weld property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this gwld (*CONSTRAINED_GENERALIZED_WELD_xxxx). Note that a carriage return is not added. See also GeneralizedWeld.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the gwld. Note that a carriage return is not added. See also GeneralizedWeld.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last generalized weld in the model.
 * @param Model Model to get last generalized weld in
 */
    static Last(Model: Model): GeneralizedWeld;

/**
 * Returns the last free generalized weld label in the model. Also see GeneralizedWeld.FirstFreeLabel(), GeneralizedWeld.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free generalized weld label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next generalized weld in the model.
 */
    Next(): GeneralizedWeld;

/**
 * Returns the next free (highest+1) generalized weld label in the model. Also see GeneralizedWeld.FirstFreeLabel(), GeneralizedWeld.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free generalized weld label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a generalized weld.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only generalized welds from that model can be picked. If the argument is a Flag then only generalized welds that are flagged with limit can be selected. If omitted, or null, any generalized welds from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): GeneralizedWeld;

/**
 * Returns the previous generalized weld in the model.
 */
    Previous(): GeneralizedWeld;

/**
 * Renumbers all of the generalized welds in the model.
 * @param Model Model that all generalized welds will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged generalized welds in the model.
 * @param Model Model that all the flagged generalized welds will be renumbered in
 * @param flag Flag set on the generalized welds that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select generalized welds using standard PRIMER object menus.
 * @param flag Flag to use when selecting generalized welds
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only generalized welds from that model can be selected. If the argument is a Flag then only generalized welds that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any generalized welds can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets the combined data for a specific nodal pair.
 * @param index Index you want to set the data for. Note that indices start at 0.
 * @param data Array containing the data. The array length should be 12 (tfail, epsf, sigy, beta, l, w, a, alpha, nodea, nodeb, ncid, wtyp)
 */
    SetCombinedData(index: number, data: number[]): void;

/**
 * Sets the cross fillet data for a specific nodal pair.
 * @param index Index you want to set the data for. Note that indices start at 0.
 * @param data Array containing the data. The array length should be 3 (nodea, nodeb, ncid)
 */
    SetCrossFilletData(index: number, data: number[]): void;

/**
 * Sets a flag on the generalized weld.
 * @param flag Flag to set on the generalized weld
 */
    SetFlag(flag: number): void;

/**
 * Sketches the generalized weld. The generalized weld will be sketched until you either call GeneralizedWeld.Unsketch(), GeneralizedWeld.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the generalized weld is sketched. If omitted redraw is true. If you want to sketch several generalized welds and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged generalized welds in the model. The generalized welds will be sketched until you either call GeneralizedWeld.Unsketch(), GeneralizedWeld.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged generalized welds will be sketched in
 * @param flag Flag set on the generalized welds that you want to sketch
 * @param redraw If model should be redrawn or not after the generalized welds are sketched. If omitted redraw is true. If you want to sketch flagged generalized welds several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of generalized welds in the model.
 * @param Model Model to get total for
 * @param exists true if only existing generalized welds should be counted. If false or omitted referenced but undefined generalized welds will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the generalized weld
 */
    Unblank(): void;

/**
 * Unblanks all of the generalized welds in the model.
 * @param Model Model that all generalized welds will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged generalized welds in the model.
 * @param Model Model that the flagged generalized welds will be unblanked in
 * @param flag Flag set on the generalized welds that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the generalized welds in the model.
 * @param Model Model that the defined flag for all generalized welds will be unset in
 * @param flag Flag to unset on the generalized welds
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the generalized weld.
 * @param redraw If model should be redrawn or not after the generalized weld is unsketched. If omitted redraw is true. If you want to unsketch several generalized welds and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all generalized welds.
 * @param Model Model that all generalized welds will be unblanked in
 * @param redraw If model should be redrawn or not after the generalized welds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged generalized welds in the model.
 * @param Model Model that all generalized welds will be unsketched in
 * @param flag Flag set on the generalized welds that you want to unsketch
 * @param redraw If model should be redrawn or not after the generalized welds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): GeneralizedWeld;

/**
 * Adds a warning for generalized weld. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this generalized weld.
 */
    Xrefs(): Xrefs;

/**
 * Create a new GeneralizedWeld object.
 * @param Model Model that gwld will be created in
 * @param option Constrained generalized weld type (any).
 * @param nsid Set Node Set ID.
 * @param cid Coordinate System ID.
 * @param filter Number of force vectors saved for filtering.
 * @param window Filter time window.
 * @param npr Number of individual nodal pairs in cross fillet and combined weld.
 * @param nprt Printout option.
 * @param wid Constrained Generalized weld number.
 */
    constructor(Model: Model, option: number, nsid: number, cid?: number, filter?: number, window?: number, npr?: number, nprt?: number, wid?: number);

/**
 * Creates a string containing the gwld data in keyword format. Note that this contains the keyword header and the keyword cards. See also GeneralizedWeld.Keyword() and GeneralizedWeld.KeywordCards().
 */
    toString(): string;

/** Width of fillet (GeneralizedWeld.FILLET, GeneralizedWeld.CROSS_FILLET) */
    a: number;
/** Weld angle (GeneralizedWeld.FILLET, GeneralizedWeld.CROSS_FILLET) */
    alpha: number;
/** Failure parameter (GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET) */
    beta: number;
/** Coordinate System ID. */
    cid: number;
/** Thickness of weld (GeneralizedWeld.BUTT) */
    d: number;
/** Effective plastic strain at failure (GeneralizedWeld.SPOT, GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET) */
    epsf: number;
/** true if gwld exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Number of force vectors saved for filtering. */
    filter: number;
/** true if _ID option is set, false if not */
    id: boolean;
/** The Include file number that the gwld is in. */
    include: number;
/** Length of weld (GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET) */
    l: number;
/** Constrained Generalized weld number. */
    label: number;
/** Transverse length (GeneralizedWeld.BUTT) */
    lt: number;
/** Exponent for shear force (GeneralizedWeld.SPOT) */
    m: number;
/** The Model number that the generalized weld is in. */
    model: number;
/** Exponent for normal force (GeneralizedWeld.SPOT) */
    n: number;
/** Number of individual nodal pairs in cross fillet and combined weld. */
    npr: number;
/** Printout option. */
    nprt: number;
/** Set Node Set ID. */
    nsid: number;
/** GeneralizedWeld type. Can be GeneralizedWeld.SPOT, GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET, GeneralizedWeld.COMBINED */
    option: number;
/** Stress at failure (GeneralizedWeld.FILLET) */
    sigf: number;
/** Stress at failure (GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET) */
    sigy: number;
/** Normal force at failure (GeneralizedWeld.SPOT) */
    sn: number;
/** Shear force at faliure (GeneralizedWeld.SPOT) */
    ss: number;
/** Failure time for constraint set (GeneralizedWeld.SPOT, GeneralizedWeld.FILLET, GeneralizedWeld.BUTT, GeneralizedWeld.CROSS_FILLET) */
    tfail: number;
/** Width of flange (GeneralizedWeld.FILLET, GeneralizedWeld.CROSS_FILLET) */
    w: number;
/** Constrained Generalized weld number (identical to label). */
    wid: number;
/** Filter time window. */
    window: number;
/** GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_BUTT. */
    static BUTT: number;
/** GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_COMBINED. */
    static COMBINED: number;
/** GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_CROSS_FILLET. */
    static CROSS_FILLET: number;
/** GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_FILLET. */
    static FILLET: number;
/** GeneralizedWeld is *CONSTRAINED_GENERALIZED_WELD_SPOT. */
    static SPOT: number;
}

declare class GeometrySurface {
/**
 * Blanks the surface
 */
    Blank(): void;

/**
 * Blanks all of the surfaces in the model.
 * @param Model Model that all surfaces will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged surfaces in the model.
 * @param Model Model that all the flagged surfaces will be blanked in
 * @param flag Flag set on the surfaces that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the surface is blanked or not.
 */
    Blanked(): boolean;

/**
 * Calculate the normal vector for a parametric point on a surface.
 * @param u u parametric coordinate
 * @param y v parametric coordinate
 */
    CalculateNormal(u: number, y: number): number[];

/**
 * Calculate the X, Y and Z coordinates for a parametric point on a surface.
 * @param u u parametric coordinate
 * @param v v parametric coordinate
 */
    CalculatePoint(u: number, v: number): number[];

/**
 * Clears a flag on the surface.
 * @param flag Flag to clear on the surface
 */
    ClearFlag(flag: number): void;

/**
 * Copies the surface.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): GeometrySurface;

/**
 * Adds an error for surface. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first surface in the model.
 * @param Model Model to get first surface in
 */
    static First(Model: Model): GeometrySurface;

/**
 * Returns the first free surface label in the model. Also see GeometrySurface.LastFreeLabel(), GeometrySurface.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free surface label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the surfaces in the model with a defined flag.
 * @param Model Model that all surfaces will be flagged in
 * @param flag Flag to set on the surfaces
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the surface is flagged or not.
 * @param flag Flag to test on the surface
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each surface in the model. Note that ForEach has been designed to make looping over surfaces as fast as possible and so has some limitations. Firstly, a single temporary GeometrySurface object is created and on each function call it is updated with the current surface data. This means that you should not try to store the GeometrySurface object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new surfaces inside a ForEach loop. 
 * @param Model Model that all surfaces are in
 * @param func Function to call for each surface
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of GeometrySurface objects for all of the surfaces in a model in Primer
 * @param Model Model to get surfaces from
 */
    static GetAll(Model: Model): GeometrySurface[];

/**
 * Return an array of all the edge indices for a surface (in pairs).
 */
    GetEdgeIndices(): number[];

/**
 * Returns an array of GeometrySurface objects for all of the flagged surfaces in a model in Primer
 * @param Model Model to get surfaces from
 * @param flag Flag set on the surfaces that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): GeometrySurface[];

/**
 * Returns the GeometrySurface object for a surface ID.
 * @param Model Model to find the surface in
 * @param number number of the surface you want the GeometrySurface object for
 */
    static GetFromID(Model: Model, number: number): GeometrySurface;

/**
 * Checks if a GeometrySurface property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the GeometrySurface.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop surface property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Return an array of all the tria indices for a surface (in triplets).
 */
    GetTriaIndices(): number[];

/**
 * Return an array of all the vertex coordinates for a surface (in triplets).
 */
    GetVertices(): number[];

/**
 * Returns the last surface in the model.
 * @param Model Model to get last surface in
 */
    static Last(Model: Model): GeometrySurface;

/**
 * Returns the last free surface label in the model. Also see GeometrySurface.FirstFreeLabel(), GeometrySurface.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free surface label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next surface in the model.
 */
    Next(): GeometrySurface;

/**
 * Returns the next free (highest+1) surface label in the model. Also see GeometrySurface.FirstFreeLabel(), GeometrySurface.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free surface label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a surface.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only surfaces from that model can be picked. If the argument is a Flag then only surfaces that are flagged with limit can be selected. If omitted, or null, any surfaces from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): GeometrySurface;

/**
 * Returns the previous surface in the model.
 */
    Previous(): GeometrySurface;

/**
 * Project a point onto the surface.
 * @param x X coordinate of point to project
 * @param y Y coordinate of point to project
 * @param z Z coordinate of point to project
 */
    ProjectPoint(x: number, y: number, z: number): number[];

/**
 * Renumbers all of the surfaces in the model.
 * @param Model Model that all surfaces will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged surfaces in the model.
 * @param Model Model that all the flagged surfaces will be renumbered in
 * @param flag Flag set on the surfaces that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select surfaces using standard PRIMER object menus.
 * @param flag Flag to use when selecting surfaces
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only surfaces from that model can be selected. If the argument is a Flag then only surfaces that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any surfaces can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the surface.
 * @param flag Flag to set on the surface
 */
    SetFlag(flag: number): void;

/**
 * Sketches the surface. The surface will be sketched until you either call GeometrySurface.Unsketch(), GeometrySurface.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the surface is sketched. If omitted redraw is true. If you want to sketch several surfaces and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged surfaces in the model. The surfaces will be sketched until you either call GeometrySurface.Unsketch(), GeometrySurface.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged surfaces will be sketched in
 * @param flag Flag set on the surfaces that you want to sketch
 * @param redraw If model should be redrawn or not after the surfaces are sketched. If omitted redraw is true. If you want to sketch flagged surfaces several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of surfaces in the model.
 * @param Model Model to get total for
 * @param exists true if only existing surfaces should be counted. If false or omitted referenced but undefined surfaces will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the surface
 */
    Unblank(): void;

/**
 * Unblanks all of the surfaces in the model.
 * @param Model Model that all surfaces will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged surfaces in the model.
 * @param Model Model that the flagged surfaces will be unblanked in
 * @param flag Flag set on the surfaces that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the surfaces in the model.
 * @param Model Model that the defined flag for all surfaces will be unset in
 * @param flag Flag to unset on the surfaces
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the surface.
 * @param redraw If model should be redrawn or not after the surface is unsketched. If omitted redraw is true. If you want to unsketch several surfaces and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all surfaces.
 * @param Model Model that all surfaces will be unblanked in
 * @param redraw If model should be redrawn or not after the surfaces are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged surfaces in the model.
 * @param Model Model that all surfaces will be unsketched in
 * @param flag Flag set on the surfaces that you want to unsketch
 * @param redraw If model should be redrawn or not after the surfaces are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): GeometrySurface;

/**
 * Adds a warning for surface. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this surface.
 */
    Xrefs(): Xrefs;

/** true if gsrf exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** GeometrySurface number. Also see the label property which is an alternative name for this. (read only) */
    readonly id: number;
/** The Include file number that the gsrf is in. */
    include: number;
/** GeometrySurface number. Also see the id property which is an alternative name for this. (read only) */
    readonly label: number;
/** The Model number that the surface is in. */
    model: number;
}

declare class Graphics {
/**
 * Allows depth testing (hidden surface removal) to be turned on or off. Temporarily turning depth testing off may be used to ensure that an item (e.g. some text) is always drawn in front and will not be obscured.
 * @param enable Whether depth testing (hidden surface removal) is performed (true) or not (false)
 */
    static DepthTest(enable: boolean): void;

/**
 * Set the function to draw graphics from javaScript. This function will be called each time the graphics are redrawn after PRIMER has finished drawing everything else. This allows you to add extra items to the graphics. To remove the graphics drawing function use Graphics.DrawingFunction(null). It is the responsibility of the script developer to ensure that any objects or variables that are used in the drawing function do not refer to items in Primer that no longer exist. Not doing so may cause PRIMER to crash. For example, if you use some Node objects in the drawing function that refer to nodes in model 1 and you delete the model, when the graphics are redrawn PRIMER may crash as the nodes referred to by the Node objects no longer exist. You should either remove the drawing function by calling Graphics.DrawingFunction(null) or set the Node variables to null (and test that they exist before using them) in your drawing function before deleting the model.
 * @param name The name of the function (or null to remove a function)
 */
    static DrawingFunction(name: () => void): void;

/**
 * Sets the colour for drawing polygons. See the Colour class for more details on colours.
 * @param colour The colour you want to fill polygons with
 */
    static FillColour(colour: Colour): void;

/**
 * Finish any graphics. See also Graphics.Start(). This must be used to finish drawing.
 */
    static Finish(): void;

/**
 * Draws a line from (x1, y1, z1) to (x2, y2, z2). See also Graphics.LineTo() and Graphics.MoveTo()
 * @param x1 X coordinate of point 1
 * @param y1 Y coordinate of point 1
 * @param z1 Z coordinate of point 1
 * @param x2 X coordinate of point 2
 * @param y2 Y coordinate of point 2
 * @param z2 Z coordinate of point 2
 */
    static Line(x1: number, y1: number, z1: number, x2: number, y2: number, z2: number): void;

/**
 * Sets the colour for drawing lines. See the Colour class for more details on colours.
 * @param colour The colour you want to draw lines with
 */
    static LineColour(colour: Colour): void;

/**
 * Sets the style for drawing lines.
 * @param style The style to draw lines with. Can be: Graphics.SOLID_LINE, Graphics.DASH_LINE, Graphics.DASHDOT_LINE or Graphics.DOT_LINE
 */
    static LineStyle(style: number): void;

/**
 * Draws a line from the current point to (x, y, z). After drawing the line the current point will be (x, y, z). See also Graphics.Line() and Graphics.MoveTo()
 * @param x X coordinate
 * @param y Y coordinate
 * @param z Z coordinate
 */
    static LineTo(x: number, y: number, z: number): void;

/**
 * Sets the width for drawing lines.
 * @param width The width to draw lines with
 */
    static LineWidth(width: number): void;

/**
 * Sets the current point to (x, y, z). See also Graphics.Line() and Graphics.LineTo()
 * @param x X coordinate
 * @param y Y coordinate
 * @param z Z coordinate
 */
    static MoveTo(x: number, y: number, z: number): void;

/**
 * Ends drawing a polygon. See also Graphics.PolygonStart()
 */
    static PolygonFinish(): void;

/**
 * Starts drawing a polygon. See also Graphics.PolygonFinish()
 */
    static PolygonStart(): void;

/**
 * Draws a simple shape.
 * @param shape The style to draw lines with. Can be: Graphics.POINT, Graphics.SQUARE, Graphics.CIRCLE, Graphics.DIAMOND, Graphics.HOURGLASS, Graphics.FILLED_SQUARE, Graphics.FILLED_CIRCLE, Graphics.FILLED_DIAMOND or Graphics.FILLED_HOURGLASS
 * @param size Size the shape should be drawn at.
 */
    static Shape(shape: number, size: number): void;

/**
 * Start any graphics. See also Graphics.Finish(). This must be used before any drawing is done.
 */
    static Start(): void;

/**
 * Draws text at current position. See Graphics.MoveTo() to set the current position.
 * @param text The text to write
 */
    static Text(text: string): void;

/**
 * Sets the colour for drawing text. See the Colour class for more details on colours.
 * @param colour The colour you want to draw text with
 */
    static TextColour(colour: Colour): void;

/**
 * Sets the size for drawing text.
 * @param size The size to draw text with
 */
    static TextSize(size: number): void;

/** Circle shape. See Graphics.Shape() for use. */
    static CIRCLE: number;
/** Dashed and dotted lines. See Graphics.LineStyle() for use. */
    static DASHDOT_LINE: number;
/** Dashed lines. See Graphics.LineStyle() for use. */
    static DASH_LINE: number;
/** Diamond shape. See Graphics.Shape() for use. */
    static DIAMOND: number;
/** Dotted lines. See Graphics.LineStyle() for use. */
    static DOT_LINE: number;
/** Filled circle shape. See Graphics.Shape() for use. */
    static FILLED_CIRCLE: number;
/** Filled diamond shape. See Graphics.Shape() for use. */
    static FILLED_DIAMOND: number;
/** Filled hourglass shape. See Graphics.Shape() for use. */
    static FILLED_HOURGLASS: number;
/** Filled square shape. See Graphics.Shape() for use. */
    static FILLED_SQUARE: number;
/** Hourglass shape. See Graphics.Shape() for use. */
    static HOURGLASS: number;
/** Point shape. See Graphics.Shape() for use. */
    static POINT: number;
/** Solid lines. See Graphics.LineStyle() for use. */
    static SOLID_LINE: number;
/** Square shape. See Graphics.Shape() for use. */
    static SQUARE: number;
}

declare class Group {
/**
 * Blanks the group
 */
    Blank(): void;

/**
 * Blanks all of the groups in the model.
 * @param Model Model that all groups will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged groups in the model.
 * @param Model Model that all the flagged groups will be blanked in
 * @param flag Flag set on the groups that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the group is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the group.
 * @param flag Flag to clear on the group
 */
    ClearFlag(flag: number): void;

/**
 * Copies the group.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Group;

/**
 * Starts an interactive editing panel to create a group.
 * @param Model Model that the group will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Group;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for group. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first group in the model.
 * @param Model Model to get first group in
 */
    static First(Model: Model): Group;

/**
 * Returns the first free group label in the model. Also see Group.LastFreeLabel(), Group.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free group label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the groups in the model with a defined flag.
 * @param Model Model that all groups will be flagged in
 * @param flag Flag to set on the groups
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the group is flagged or not.
 * @param flag Flag to test on the group
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each group in the model. Note that ForEach has been designed to make looping over groups as fast as possible and so has some limitations. Firstly, a single temporary Group object is created and on each function call it is updated with the current group data. This means that you should not try to store the Group object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new groups inside a ForEach loop. 
 * @param Model Model that all groups are in
 * @param func Function to call for each group
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Group objects for all of the groups in a model in Primer
 * @param Model Model to get groups from
 */
    static GetAll(Model: Model): Group[];

/**
 * Returns 'all' data for a given row number and type in the group.
 * @param type The type of the item
 * @param index Index of 'all' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalAll()
 */
    GetDataAll(type: string, index: number): number[];

/**
 * Returns 'list' data for a given row number and type in the group.
 * @param type The type of the item
 * @param index Index of 'list' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalList()
 */
    GetDataList(type: string, index: number): number[];

/**
 * Returns 'range' data for a given row number and type in the group.
 * @param type The type of the item
 * @param index Index of 'range' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalRange()
 */
    GetDataRange(type: string, index: number): number[];

/**
 * Returns an array of Group objects for all of the flagged groups in a model in Primer
 * @param Model Model to get groups from
 * @param flag Flag set on the groups that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Group[];

/**
 * Returns the Group object for a group ID.
 * @param Model Model to find the group in
 * @param number number of the group you want the Group object for
 */
    static GetFromID(Model: Model, number: number): Group;

/**
 * Checks if a Group property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Group.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop group property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the total number of 'all' rows for a type in a group
 * @param type The type of the item
 */
    GetTotalAll(type: string): number;

/**
 * Returns the total number of 'list' rows for a type in a group
 * @param type The type of the item
 */
    GetTotalList(type: string): number;

/**
 * Returns the total number of 'range' rows for a type in a group
 * @param type The type of the item
 */
    GetTotalRange(type: string): number;

/**
 * Returns the total number of 'all', 'list' and 'range' rows for a type in a group
 * @param type The type of the item
 */
    GetTotals(type: string): number[];

/**
 * Returns the type for an entry in a group
 * @param row The entry in the group types that you want the type for. Note that entries start at 0, not 1
 */
    GetType(row: number): string;

/**
 * Returns the keyword for this group. Note that a carriage return is not added. See also Group.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the Group. Note that a carriage return is not added. See also Group.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last group in the model.
 * @param Model Model to get last group in
 */
    static Last(Model: Model): Group;

/**
 * Returns the last free group label in the model. Also see Group.FirstFreeLabel(), Group.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free group label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next group in the model.
 */
    Next(): Group;

/**
 * Returns the next free (highest+1) group label in the model. Also see Group.FirstFreeLabel(), Group.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free group label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a group.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only groups from that model can be picked. If the argument is a Flag then only groups that are flagged with limit can be selected. If omitted, or null, any groups from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Group;

/**
 * Returns the previous group in the model.
 */
    Previous(): Group;

/**
 * Removes 'all' data for a given row number and type in the group.
 * @param type The type of the item
 * @param index Index of 'all' row you want to Remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalAll()
 */
    RemoveDataAll(type: string, index: number): void;

/**
 * Removes 'list' data for a given row number and type in the group.
 * @param type The type of the item
 * @param index Index of 'list' row you want to Remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalList()
 */
    RemoveDataList(type: string, index: number): void;

/**
 * Removes 'range' data for a given row number and type in the group.
 * @param type The type of the item
 * @param index Index of 'range' row you want to Remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; Group.GetTotalRange()
 */
    RemoveDataRange(type: string, index: number): void;

/**
 * Renumbers all of the groups in the model.
 * @param Model Model that all groups will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged groups in the model.
 * @param Model Model that all the flagged groups will be renumbered in
 * @param flag Flag set on the groups that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select groups using standard PRIMER object menus.
 * @param flag Flag to use when selecting groups
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only groups from that model can be selected. If the argument is a Flag then only groups that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any groups can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets 'all' data for a given row number and type in the group.
 * @param type The type of the item
 * @param index Index of 'all' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt;= Group.GetTotalAll()
 * @param data An array containing data [Group.ADD or Group.REMOVE, BOX (if defined)].
 */
    SetDataAll(type: string, index: number, data: number[]): void;

/**
 * Sets 'list' data for a given row number and type in the group.
 * @param type The type of the item
 * @param index Index of 'list' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt;= Group.GetTotalList()
 * @param data An array containing data [Group.ADD or Group.REMOVE, ITEM1 (if defined), ITEM2 (if defined), ITEM3 (if defined), ITEM4 (if defined), ITEM5 (if defined), BOX (if defined)].
 */
    SetDataList(type: string, index: number, data: number[]): void;

/**
 * Sets 'range' data for a given row number and type in the group.
 * @param type The type of the item
 * @param index Index of 'all' row you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt;= Group.GetTotalRange()
 * @param data An array containing data [Group.ADD or Group.REMOVE, START, END, BOX (if defined)].
 */
    SetDataRange(type: string, index: number, data: number[]): void;

/**
 * Sets a flag on the group.
 * @param flag Flag to set on the group
 */
    SetFlag(flag: number): void;

/**
 * Sketches the group. The group will be sketched until you either call Group.Unsketch(), Group.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the group is sketched. If omitted redraw is true. If you want to sketch several groups and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged groups in the model. The groups will be sketched until you either call Group.Unsketch(), Group.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged groups will be sketched in
 * @param flag Flag set on the groups that you want to sketch
 * @param redraw If model should be redrawn or not after the groups are sketched. If omitted redraw is true. If you want to sketch flagged groups several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of groups in the model.
 * @param Model Model to get total for
 * @param exists true if only existing groups should be counted. If false or omitted referenced but undefined groups will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the group
 */
    Unblank(): void;

/**
 * Unblanks all of the groups in the model.
 * @param Model Model that all groups will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged groups in the model.
 * @param Model Model that the flagged groups will be unblanked in
 * @param flag Flag set on the groups that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the groups in the model.
 * @param Model Model that the defined flag for all groups will be unset in
 * @param flag Flag to unset on the groups
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the group.
 * @param redraw If model should be redrawn or not after the group is unsketched. If omitted redraw is true. If you want to unsketch several groups and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all groups.
 * @param Model Model that all groups will be unblanked in
 * @param redraw If model should be redrawn or not after the groups are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged groups in the model.
 * @param Model Model that all groups will be unsketched in
 * @param flag Flag set on the groups that you want to unsketch
 * @param redraw If model should be redrawn or not after the groups are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Group;

/**
 * Adds a warning for group. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this group.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Group object.
 * @param Model Model that Group will be created in
 * @param label Group number.
 * @param title Title for the group
 */
    constructor(Model: Model, label: number, title?: string);

/**
 * Creates a string containing the Group data in keyword format. Note that this contains the keyword header and the keyword cards. See also Group.Keyword() and Group.KeywordCards().
 */
    toString(): string;

/** true if group exists, false if referred to but not defined (read only) */
    readonly exists: boolean;
/** The Include file number that the group is in */
    include: number;
/** Group number */
    label: number;
/** Whether Group contents are locked against deletion. */
    lock: boolean;
/** The Model number that the group is in. */
    model: number;
/** Number of types in the group. */
    readonly numtypes: number;
/** Group title */
    title: string;
/** Add contents to group */
    static ADD: number;
/** Remove contents from group */
    static REMOVE: number;
}

declare class History {
/**
 * Blanks all of the database histories in the model.
 * @param Model Model that all database histories will be blanked in
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, type?: number, redraw?: boolean): void;

/**
 * Blanks all of the flagged database histories in the model.
 * @param Model Model that all the flagged database histories will be blanked in
 * @param flag Flag set on the database histories that you want to blank
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, type?: number, redraw?: boolean): void;

/**
 * Checks if the database history is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the database history.
 * @param flag Flag to clear on the database history
 */
    ClearFlag(flag: number): void;

/**
 * Starts an interactive editing panel to create a database history.
 * @param Model Model that the database history will be created in
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, type: number, modal?: boolean): History;

/**
 * Starts an interactive editing panel to edit the database history.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Returns the first database history in the model.
 * @param Model Model to get first database history in
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 */
    static First(Model: Model, type?: number): History;

/**
 * Flags all of the database histories in the model with a defined flag.
 * @param Model Model that all database histories will be flagged in
 * @param flag Flag to set on the database histories
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 */
    static FlagAll(Model: Model, flag: number, type?: number): void;

/**
 * Checks if the database history is flagged or not.
 * @param flag Flag to clear on the database history
 */
    Flagged(flag: number): boolean;

/**
 * Returns an array of History objects for all of the database histories in a models in Primer
 * @param Model Model to get database histories from
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 */
    static GetAll(Model: Model, type?: number): History[];

/**
 * Returns the History object for a database history ID.
 * @param Model Model to find the database history in
 * @param database_history_number number of the database history you want the History object for
 */
    static GetFromID(Model: Model, database_history_number: number): History;

/**
 * Returns the keyword for this database history (*DATABASE_HISTORY). Note that a carriage return is not added. See also History.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the database history. Note that a carriage return is not added. See also History.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last database history in the model.
 * @param Model Model to get last database history in
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 */
    static Last(Model: Model, type?: number): History;

/**
 * Returns the next database history in the model.
 */
    Next(): History;

/**
 * Allows the user to pick a database history.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only database histories from that model can be picked. If the argument is a Flag then only database histories that are flagged with limit can be selected. If omitted, or null, any database histories from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean): History;

/**
 * Returns the previous database history in the model.
 */
    Previous(): History;

/**
 * Allows the user to select database histories using standard PRIMER object menus.
 * @param flag Flag to use when selecting database histories
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only database histories from that model can be selected. If the argument is a Flag then only database histories that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any database histories from any model can be selected.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the database history.
 * @param flag Flag to set on the database history
 */
    SetFlag(flag: number): void;

/**
 * Sketches the database history. The database history will be sketched until you either call History.Unsketch(), History.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the database history is sketched. If omitted redraw is true. If you want to sketch several database histories and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged database histories in the model.
 * @param Model Model that all the flagged database histories will be sketched in
 * @param flag Flag set on the database histories that you want to sketch
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 * @param redraw If model should be redrawn or not. If omitted redraw is true. If you want to do several (un)sketches and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, type?: number, redraw?: boolean): void;

/**
 * Unblanks all of the database histories in the model.
 * @param Model Model that all database histories will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 */
    static UnblankAll(Model: Model, redraw?: boolean, type?: number): void;

/**
 * Unblanks all of the flagged database histories in the model.
 * @param Model Model that the flagged database histories will be unblanked in
 * @param flag Flag set on the database histories that you want to unblank
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, type?: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the database histories in the model.
 * @param Model Model that the defined flag for all database histories will be unset in
 * @param flag Flag to unset on the database histories
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 */
    static UnflagAll(Model: Model, flag: number, type?: number): void;

/**
 * Unsketches the database history.
 * @param redraw If model should be redrawn or not after the database history is unsketched. If omitted redraw is true. If you want to unsketch several database histories and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all database histories.
 * @param Model Model that all database histories will be unblanked in
 * @param redraw If model should be redrawn or not after the database histories are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged database histories.
 * @param Model Model that all database histories will be unblanked in
 * @param flag Flag set on the database histories that you want to sketch
 * @param type The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET or History.ALL_TYPES. If omitted, applied to all database history types.
 * @param redraw If model should be redrawn or not after the database histories are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, type?: number, redraw?: boolean): void;

/**
 * Returns the cross references for this database history.
 */
    Xrefs(): Xrefs;

/**
 * Create a new History object.
 * @param Model Model that database history will be created in
 * @param type Entity type
 * @param id ID of the item
 * @param heading Optional heading
 */
    constructor(Model: Model, type: number, id: number, heading?: string);

/**
 * Creates a string containing the database history data in keyword format. Note that this contains the keyword header and the keyword cards. See also History.Keyword() and History.KeywordCards().
 */
    toString(): string;

/** Coordinate system ID for _LOCAL */
    cid: number;
/** true if database history exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Optional heading */
    heading: string;
/** High frequency flag for _LOCAL */
    hfo: number;
/** ID of the item */
    id: number;
/** The Include file number that the database history is in. */
    include: number;
/** Turns _LOCAL on or off */
    local: boolean;
/** The Model number that the database history is in. */
    model: number;
/** Output reference for _LOCAL */
    ref: number;
/** The database history type. Can be Set.BEAM or History.BEAM or History.BEAM_SET or History.DISCRETE or History.DISCRETE_SET or History.NODE or History.NODE_SET or History.SEATBELT or History.SHELL or History.SHELL_SET or History.SOLID or History.SOLID_SET or History.SPH or History.SPH_SET or History.TSHELL or History.TSHELL_SET. */
    readonly type: number;
/** All *DATABASE_HISTORY_ types. */
    static ALL_TYPES: number;
/** BEAM is *DATABASE_HISTORY_BEAM. */
    static BEAM: number;
/** BEAM_SET is *DATABASE_HISTORY_BEAM_SET. */
    static BEAM_SET: number;
/** DISCRETE is *DATABASE_HISTORY_DISCRETE. */
    static DISCRETE: number;
/** DISCRETE_SET is *DATABASE_HISTORY_DISCRETE_SET. */
    static DISCRETE_SET: number;
/** NODE is *DATABASE_HISTORY_NODE. */
    static NODE: number;
/** NODE_SET is *DATABASE_HISTORY_NODE_SET. */
    static NODE_SET: number;
/** SEATBELT is *DATABASE_HISTORY_SEATBELT. */
    static SEATBELT: number;
/** SHELL is *DATABASE_HISTORY_SHELL. */
    static SHELL: number;
/** SHELL_SET is *DATABASE_HISTORY_SHELL_SET. */
    static SHELL_SET: number;
/** SOLID is *DATABASE_HISTORY_SOLID. */
    static SOLID: number;
/** SOLID_SET is *DATABASE_HISTORY_SOLID_SET. */
    static SOLID_SET: number;
/** SPH is *DATABASE_HISTORY_SPH. */
    static SPH: number;
/** SPH_SET is *DATABASE_HISTORY_SPH_SET. */
    static SPH_SET: number;
/** TSHELL is *DATABASE_HISTORY_TSHELL. */
    static TSHELL: number;
/** TSHELL_SET is *DATABASE_HISTORY_TSHELL_SET. */
    static TSHELL_SET: number;
}

declare class Hourglass {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the hourglass.
 * @param flag Flag to clear on the hourglass
 */
    ClearFlag(flag: number): void;

/**
 * Copies the hourglass.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Hourglass;

/**
 * Starts an interactive editing panel to create a hourglass.
 * @param Model Model that the hourglass will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Hourglass;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for hourglass. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first hourglass in the model.
 * @param Model Model to get first hourglass in
 */
    static First(Model: Model): Hourglass;

/**
 * Returns the first free hourglass label in the model. Also see Hourglass.LastFreeLabel(), Hourglass.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free hourglass label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the hourglasss in the model with a defined flag.
 * @param Model Model that all hourglasss will be flagged in
 * @param flag Flag to set on the hourglasss
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the hourglass is flagged or not.
 * @param flag Flag to test on the hourglass
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each hourglass in the model. Note that ForEach has been designed to make looping over hourglasss as fast as possible and so has some limitations. Firstly, a single temporary Hourglass object is created and on each function call it is updated with the current hourglass data. This means that you should not try to store the Hourglass object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new hourglasss inside a ForEach loop. 
 * @param Model Model that all hourglasss are in
 * @param func Function to call for each hourglass
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Hourglass objects for all of the hourglasss in a model in Primer
 * @param Model Model to get hourglasss from
 */
    static GetAll(Model: Model): Hourglass[];

/**
 * Returns an array of Hourglass objects for all of the flagged hourglasss in a model in Primer
 * @param Model Model to get hourglasss from
 * @param flag Flag set on the hourglasss that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Hourglass[];

/**
 * Returns the Hourglass object for a hourglass ID.
 * @param Model Model to find the hourglass in
 * @param number number of the hourglass you want the Hourglass object for
 */
    static GetFromID(Model: Model, number: number): Hourglass;

/**
 * Checks if a Hourglass property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Hourglass.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop hourglass property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this hourglass (*HOURGLASS). Note that a carriage return is not added. See also Hourglass.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the hourglass. Note that a carriage return is not added. See also Hourglass.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last hourglass in the model.
 * @param Model Model to get last hourglass in
 */
    static Last(Model: Model): Hourglass;

/**
 * Returns the last free hourglass label in the model. Also see Hourglass.FirstFreeLabel(), Hourglass.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free hourglass label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next hourglass in the model.
 */
    Next(): Hourglass;

/**
 * Returns the next free (highest+1) hourglass label in the model. Also see Hourglass.FirstFreeLabel(), Hourglass.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free hourglass label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous hourglass in the model.
 */
    Previous(): Hourglass;

/**
 * Renumbers all of the hourglasss in the model.
 * @param Model Model that all hourglasss will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged hourglasss in the model.
 * @param Model Model that all the flagged hourglasss will be renumbered in
 * @param flag Flag set on the hourglasss that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select hourglasss using standard PRIMER object menus.
 * @param flag Flag to use when selecting hourglasss
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only hourglasss from that model can be selected. If the argument is a Flag then only hourglasss that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any hourglasss can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the hourglass.
 * @param flag Flag to set on the hourglass
 */
    SetFlag(flag: number): void;

/**
 * Returns the total number of hourglasss in the model.
 * @param Model Model to get total for
 * @param exists true if only existing hourglasss should be counted. If false or omitted referenced but undefined hourglasss will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the hourglasss in the model.
 * @param Model Model that the defined flag for all hourglasss will be unset in
 * @param flag Flag to unset on the hourglasss
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Hourglass;

/**
 * Adds a warning for hourglass. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this hourglass.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Hourglass object.
 * @param Model Model that hourglass will be created in
 * @param hgid Hourglass number
 * @param title Title for the hourglass
 */
    constructor(Model: Model, hgid: number, title?: string);

/**
 * Creates a string containing the hourglass data in keyword format. Note that this contains the keyword header and the keyword cards. See also Hourglass.Keyword() and Hourglass.KeywordCards().
 */
    toString(): string;

/** true if hourglass exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Hourglass number. Also see the label property which is an alternative name for this. */
    hgid: number;
/** Bulk viscosity type */
    ibq: number;
/** Hourglass control type */
    ihq: number;
/** The Include file number that the hourglass is in. */
    include: number;
/** Hourglass number. Also see the hgid property which is an alternative name for this. */
    label: number;
/** The Model number that the hourglass is in. */
    model: number;
/** Quadratic bulk viscosity coefficient */
    q1: number;
/** Linear bulk viscosity coefficient */
    q2: number;
/** Coefficient for shell bending */
    qb: number;
/** Hourglass coefficient */
    qm: number;
/** Coefficient for shell warping */
    qw: number;
/** Title for hourglass */
    title: string;
/** Viscous damping coefficient */
    vdc: number;
}

declare class Image {
/**
 * Create a bmp image of the current screen image
 * @param filename Filename you want to write. The file will be overwritten if it already exists.
 * @param resolution The resolution to write the image at. Can be Image.SCREEN, Image.X2 or Image.X4. If omitted screen resolution will be used
 * @param 8bit BMP images can be written using either 8 bit (256 colours) or 24 bit (16 million colours). If this is true then an 8 bit image will be written. If false (or omitted) a 24 bit image will be written.
 * @param options For 8 bit images (see '8bit' argument) the palette can be optimised (Image.OPTIMISE) and/or dithered (Image.DITHER) and/or compressed (Image.COMPRESS) If 0 (or omitted) no palette optimising, dithering or compression will be done.
 */
    static WriteBMP(filename: string, resolution?: number, 8bit?: boolean, options?: number): void;

/**
 * Create a gif image of the current screen image
 * @param filename Filename you want to write. The file will be overwritten if it already exists.
 * @param resolution The resolution to write the image at. Can be Image.SCREEN, Image.X2 or Image.X4. If omitted screen resolution will be used
 * @param palette The palette can be optimised (Image.OPTIMISE) and/or dithered (Image.DITHER). If 0 (or omitted) no palette optimising or dithering will be done.
 */
    static WriteGIF(filename: string, resolution?: number, palette?: number): void;

/**
 * Create a jpeg image of the current screen image
 * @param filename Filename you want to write. The file will be overwritten if it already exists.
 * @param resolution The resolution to write the image at. Can be Image.SCREEN, Image.X2 or Image.X4. If omitted screen resolution will be used
 * @param quality Quality of the image in percent. Can be in the range [10,100]. If omitted, the quality is 90.
 */
    static WriteJPEG(filename: string, resolution?: number, quality?: number): void;

/**
 * Create a png image of the current screen image
 * @param filename Filename you want to write. The file will be overwritten if it already exists.
 * @param resolution The resolution to write the image at. Can be Image.SCREEN, Image.X2 or Image.X4. If omitted screen resolution will be used
 * @param 8bit PNG images can be written using either 8 bit (256 colours) or 24 bit (16 million colours). If this is true then an 8 bit image will be written. If false (or omitted) a 24 bit image will be written.
 * @param palette For 8 bit images (see '8bit' argument) the palette can be optimised (Image.OPTIMISE) and/or dithered (Image.DITHER). If 0 (or omitted) no palette optimising or dithering will be done.
 */
    static WritePNG(filename: string, resolution?: number, 8bit?: boolean, palette?: number): void;

/** If compression is done for 8 bit bmp images. */
    static COMPRESS: number;
/** If dithering is done for 8 bit images. */
    static DITHER: number;
/** If palette optimisation is done for 8 bit images. */
    static OPTIMISE: number;
/** Image will be created at screen resolution. */
    static SCREEN: number;
/** Image will be created at 2x screen resolution. */
    static X2: number;
/** Image will be created at 4x screen resolution. */
    static X4: number;
}


/** Object function argument in Write */
interface WriteArgument_options {
    /** If true then the output file will be written out in binary. If false (default) then an ascii file will be written. */
    binary?: boolean;
    /** If true then the output file will be compressed. If false (default) then an uncompressed file will be written. */
    compress?: boolean;
    /** Compression level for .gz and .zip files. Must be in the range 1 to 9 with 1 being the least compression (fastest speed) to 9 being the greatest compression (slowest speed) */
    compressLevel?: number;
    /** This option can be used to specify the mode of compression. Can be Include.KEEP_ORIGINAL or Include.INDIVIDUAL_GZIP or Include.INDIVIDUAL_ZIP */
    compressMode?: number;
    /** If true then the begining of the file (*CONTROL etc) file is written out in ascii. If false (default) then the entire file is converted to binary.  */
    fileStartAscii?: boolean;
    /** If true then i10 format will be used to write the file. If false (default) then the normal LS-DYNA format will be used. */
    i10?: boolean;
    /** If true then large format will be used to write the file. If false (default) then the normal LS-DYNA format will be used. Note that large format is only available from version R7.1 and above. */
    large?: boolean;
    /** The method used to write include paths. Can be Include.ABSOLUTE (default) or Include.RELATIVE */
    path?: number;
    /** The directory separator used when writing include files. Can be Include.NATIVE (default), Include.UNIX or Include.WINDOWS */
    separator?: number;
    /** The LS-DYNA version used to write the file. Can be "971R5", "971R4", "971R3", "970v6763" etc (see the version popup in Model-&gt;Write '&gt;&gt;&gt; LS-Dyna output options' for a full list). See also Options.dyna_version */
    version?: string;
}

declare class Include {
/**
 * Blanks all of the includes in the model.
 * @param Model Model that all includes will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 * @param masterInclude If masterInclude file should be blanked or not. If omitted masterInclude is false. The master file is include file number 0.
 */
    static BlankAll(Model: Model, redraw?: boolean, masterInclude?: boolean): void;

/**
 * Blanks all of the flagged include files in the model.
 * @param Model Model that all the flagged includes will be blanked in
 * @param flag Flag set on the includes that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Clears a flag on the include.
 * @param flag Flag to clear on the include
 * @param clear_contents If true then the items in the include file will also have flag cleared. If false (default) then the include file contents are not cleared.
 */
    ClearFlag(flag: number, clear_contents?: boolean): number;

/**
 * Adds an error for an include file. For more details on checking see the Check class. Note that this function is not supported for the master include file.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first include file in the model.
 * @param Model Model to get first include in
 */
    static First(Model: Model): Include;

/**
 * Flags all of the includes in the model with a defined flag.
 * @param Model Model that all includes will be flagged in
 * @param flag Flag to set on the includes
 * @param masterInclude If masterInclude file should be flagged or not. If omitted masterInclude is false. The master file is include file number 0.
 */
    static FlagAll(Model: Model, flag: number, masterInclude?: boolean): void;

/**
 * Checks if the include is flagged or not.
 * @param flag Flag to test on the include
 */
    Flagged(flag: number): boolean;

/**
 * Returns an array of Include objects for all of the includes in a model in Primer
 * @param Model Model to get includes from
 * @param masterInclude If masterInclude file should be included or not. If omitted masterInclude is false. The master file is include file number 0.
 */
    static GetAll(Model: Model, masterInclude?: boolean): Include[];

/**
 * Gets detailed min and max label ranges for specified type from the include.
 * @param type_argument Entity type for which ranges are returned
 */
    GetDetailedRange(type_argument: string): number[];

/**
 * Returns the Include object for an include label.Note that items that are in the main keyword file will have a layer value of 0 which can be used as the include number argument to this function to return master include file.
 * @param Model Model to find the include in
 * @param include_number number of the include you want the Include object for
 */
    static GetFromID(Model: Model, include_number: number): Include;

/**
 * Returns the locked label data for include files. Also see the n_locked_range property
 * @param rangenum The range number you want the data for; includes can have multiple ranges. Note that range numbers start at 0, not 1.
 */
    GetLockedLabelData(rangenum: number): number[];

/**
 * Returns true if include is Empty (contains no INSTALLED static/sort/kid/include items).
 */
    IsEmpty(): boolean;

/**
 * Returns the keyword for this include (*INCLUDE, *INCLUDE_TRANSFORM). Note that a carriage return is not added. See also Include.KeywordCards(). This function is not supported for the master include file.
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the include. Note that a carriage return is not added. See also Include.Keyword(). Also note that this function is not supported for the master include file.
 */
    KeywordCards(): string;

/**
 * Returns the last include file in the model.
 * @param Model Model to get last include in
 */
    static Last(Model: Model): Include;

/**
 * Sets this include file to be the current layer so that any newly created items are put in this include file. Also see the Model.layer property.
 */
    MakeCurrentLayer(): void;

/**
 * Returns true if include has been modified.
 * @param listing false for no listing output, true for listing output
 */
    Modified(listing: boolean): boolean;

/**
 * Returns the next include in the model. Note that this function is not supported for the master include file.
 */
    Next(): Include;

/**
 * Allows the user to pick an include.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only includes from that model can be picked. If the argument is a Flag then only includes that are flagged with limit can be selected. If omitted, or null, any includes from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Include;

/**
 * Returns the previous include in the model. Note that this function is not supported for the master include file.
 */
    Previous(): Include;

/**
 * Removes the locked label data for a range in include files. Also see the n_locked_range property
 * @param rangenum The locked label range you want to remove. Note that range numbers start at 0, not 1.
 */
    RemoveLockedLabelData(rangenum: number): void;

/**
 * Allows the user to select includes using standard PRIMER object menus.
 * @param flag Flag to use when selecting includes
 * @param prompt Text to display as a prompt to the user
 * @param Model Model to select from
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, Model?: Model, modal?: boolean): number;

/**
 * Sets detailed min and max label ranges for specified type on the include.
 * @param type_argument Entity type for which ranges are to be defined
 * @param min_label Defines the smallest label for entities of this type
 * @param max_label Defines the largest label for entities of this type
 */
    SetDetailedRange(type_argument: string, min_label: number, max_label: number): void;

/**
 * Sets a flag on the include.
 * @param flag Flag to set on the include
 * @param flag_contents If true then the items in the include file will also be flagged. If false (default) then the include file contents are not flagged.
 */
    SetFlag(flag: number, flag_contents?: boolean): number;

/**
 * Sets the locked label data for a particular range for an include file. Also see the n_locked_range property
 * @param rangenum The range you want to set the data for. Note that range numbers start at 0, not 1.
 * @param min Start (min) label for a locked range.
 * @param max End (max) label for a locked range.
 * @param type Entity type code - "NODE", "SHELL" etc. Can also be "ALL" (for a list of types see Appendix I of the PRIMER manual).
 * @param safe Determines whether a locked range is safe (protected).
 * @param all_includes Specified range will be set model-wide (all includes). Only useful when working with the 'master' include.
 */
    SetLockedLabelData(rangenum: number, min: number, max: number, type: string, safe?: boolean, all_includes?: boolean): void;

/**
 * Sets offset values for include transform. This function is required to change the offset values rather than changing the properties directly so that the include can be checked to ensure that the new value does not cause any label clashes with existing items or any negative labels when the transform is unapplied when writing the include. Note that this function is not supported for the master include file.
 * @param offset The include transform offset type to change. Can be Include.IDNOFF, Include.IDEOFF, Include.IDPOFF, Include.IDMOFF, Include.IDSOFF, Include.IDFOFF, Include.IDDOFF or Include.IDROFF.
 * @param value The value to change the offset to
 * @param check_only Sometimes it may be necessary to check if changing an offset for an include will cause an error or label clash rather than actually changing it. If check only is true then Primer will just check to see if the new value for the offset will cause any label clashes or negative labels and not change the offset value or any item labels. If false or omitted then the offset and labels will be updated if there are no errors.
 */
    SetTransformOffset(offset: number, value: number, check_only?: boolean): boolean;

/**
 * Returns the total number of include files in the model.
 * @param Model Model to get include total from
 */
    static Total(Model: Model): number;

/**
 * Unblanks all of the includes in the model.
 * @param Model Model that all includes will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged include files in the model.
 * @param Model Model that all the flagged includes will be unblanked in
 * @param flag Flag set on the includes that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the includes in the model.
 * @param Model Model that the defined flag for all includes will be unset in
 * @param flag Flag to unset on the includes
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Adds a warning for an include file. For more details on checking see the Check class. Note that this function is not supported for the master include file.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Warning(message: string, details?: string): void;

/**
 * Writes an include file. Note that this function is not supported for the master include file.
 * @param filename Filename of the LS-Dyna keyword file you want to write
 * @param options Options specifying how the file should be written out. If omitted the default values below will be used. The properties available are:
 */
    Write(filename: string, options?: WriteArgument_options): void;

/**
 * Create a new Include object.
 * @param Model Model that include will be created in
 * @param name Include filename
 * @param parent Parent include file number. If omitted parent will be 0 (main file).
 */
    constructor(Model: Model, name: string, parent?: number);

/**
 * Creates a string containing the include data in keyword format. Note that this contains the keyword header and the keyword cards. See also Include.Keyword() and Include.KeywordCards(). Also note that this function is not supported for the master include file.
 */
    toString(): string;

/** Comments stored at the top of the include file. Note that this property is not supported for master include file. */
    comments: string;
/** Length transformation factor. Note that this property is not supported for master include file. */
    fctlen: number;
/** Mass transformation factor. Note that this property is not supported for master include file. */
    fctmas: number;
/** Temperature transformation factor. Note that this property is not supported for master include file. */
    fcttem: string;
/** Time transformation factor. Note that this property is not supported for master include file. */
    fcttim: number;
/** The absolute filename for this include file.Note that this property is not supported for master include file. Also see the name and path properties. */
    file: string;
/** Include maximum label range value for general items */
    genmax: number;
/** Include minimum label range value for general items */
    genmin: number;
/** Offset to define ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file. */
    readonly iddoff: number;
/** Offset to element ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file. */
    readonly ideoff: number;
/** Offset to function and table ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file. */
    readonly idfoff: number;
/** Offset to material and equation of state ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file. */
    readonly idmoff: number;
/** Offset to node ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file. */
    readonly idnoff: number;
/** Offset to part, nodal rigid body and constrained node set ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file. */
    readonly idpoff: number;
/** Offset to other ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file. */
    readonly idroff: number;
/** Offset to set ID. To set property use Include.SetTransformOffset(). Note that this property is not supported for master include file. */
    readonly idsoff: number;
/** Create file containing transformed data. Note that this property is not supported for master include file. */
    incout: number;
/** Include number. This number is used to identify the include file. A number is required as it is possible (with include transforms) to have multiple include files with the same name so they cannot be identified by name. The master file is include file number 0. Also see the parent property. */
    readonly label: number;
/** The Model number that the include is in. */
    model: number;
/** Number of locked label ranges. Note that this does not include label ranges locked model-wide (ALL includes). */
    n_locked_range: number;
/** The filename for this include file excluding any path. Note that this property is not supported for master include file. Also see the file and path properties. */
    name: string;
/** Include maximum label range value for nodes/elements/nrbc/const. spotwelds/define HWA items */
    nelmax: number;
/** Include minimum label range value for nodes/elements/nrbc/const. spotwelds/define HWA items */
    nelmin: number;
/** Include number for the parent include file of this include. This number is used to identify the parent include file. A number is required as it is possible (with include transforms) to have multiple include files with the same name so they cannot be identified by name. The master file is include file number 0. Also see the label property. Note that this property is not supported for master include file. */
    parent: number;
/** The path for this include file. Note that this property is not supported for master include file. Also see the file and name properties. */
    path: string;
/** If keyout of Include file has been suppressed. Note that this property is not supported for master include file. */
    suppressed: boolean;
/** Define transformation number. Note that this property is not supported for master include file. */
    tranid: number;
/** true if this include file is an *INCLUDE_TRANSFORM, false otherwise. Note that this property is not supported for master include file. */
    transform: boolean;
/** Write include file with absolute pathname. See also Model.Write() */
    static ABSOLUTE: number;
/** Offset applied to Primer post end keywords (Dummy, Mechanism etc.) */
    static ENDOFF: number;
/** Offset to define ID (used in Include.SetTransformOffset() ) */
    static IDDOFF: number;
/** Offset to element ID (used in Include.SetTransformOffset() ) */
    static IDEOFF: number;
/** Offset to function and table ID (used in Include.SetTransformOffset() ) */
    static IDFOFF: number;
/** Offset to material ID (used in Include.SetTransformOffset() ) */
    static IDMOFF: number;
/** Offset to node ID (used in Include.SetTransformOffset() ) */
    static IDNOFF: number;
/** Offset to part ID (used in Include.SetTransformOffset() ) */
    static IDPOFF: number;
/** Offset to other ID (used in Include.SetTransformOffset() ) */
    static IDROFF: number;
/** Offset to set ID (used in Include.SetTransformOffset() ) */
    static IDSOFF: number;
/** Each file 'name.key' is 'gzipped' to become the individual file 'name.key.gz' */
    static INDIVIDUAL_GZIP: number;
/** Each file 'name.key' is 'zipped' to become the individual file 'name.key.zip' */
    static INDIVIDUAL_ZIP: number;
/** Each file 'name.key' is written using its original compression: uncompressed, '.gz. or '.zip' format */
    static KEEP_ORIGINAL: number;
/** Only write the master file. See also Model.Write() */
    static MASTER_ONLY: number;
/** Merge include files into the master file. See also Model.Write() */
    static MERGE: number;
/** Use directory separators native to this machine when writing directory names. See also Model.Write() */
    static NATIVE: number;
/** Prevent include files from being written. See also Model.Write() */
    static NOT_WRITTEN: number;
/** Write include file with relative pathname. See also Model.Write() */
    static RELATIVE: number;
/** Write master and include files into the same directory. See also Model.Write() */
    static SAME_DIR: number;
/** Write include files to subdirectory. See also Model.Write() */
    static SUBDIR: number;
/** Use unix directory separators when writing directory names. See also Model.Write() */
    static UNIX: number;
/** Use windows directory separators when writing directory names. See also Model.Write() */
    static WINDOWS: number;
}

declare class IntegrationBeam {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the integration beam.
 * @param flag Flag to clear on the integration beam
 */
    ClearFlag(flag: number): void;

/**
 * Copies the integration beam.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Starts an interactive editing panel to create a intb.
 * @param Model Model that the intb will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): number;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for integration beam. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first integration beam in the model.
 * @param Model Model to get first integration beam in
 */
    static First(Model: Model): number;

/**
 * Returns the first free integration beam label in the model. Also see IntegrationBeam.LastFreeLabel(), IntegrationBeam.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free integration beam label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the integration beams in the model with a defined flag.
 * @param Model Model that all integration beams will be flagged in
 * @param flag Flag to set on the integration beams
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the integration beam is flagged or not.
 * @param flag Flag to test on the integration beam
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each integration beam in the model. Note that ForEach has been designed to make looping over integration beams as fast as possible and so has some limitations. Firstly, a single temporary IntegrationBeam object is created and on each function call it is updated with the current integration beam data. This means that you should not try to store the IntegrationBeam object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new integration beams inside a ForEach loop. 
 * @param Model Model that all integration beams are in
 * @param func Function to call for each integration beam
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of IntegrationBeam objects for all of the integration beams in a model in Primer
 * @param Model Model to get integration beams from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns an array of IntegrationBeam objects for all of the flagged integration beams in a model in Primer
 * @param Model Model to get integration beams from
 * @param flag Flag set on the integration beams that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the IntegrationBeam object for a integration beam ID.
 * @param Model Model to find the integration beam in
 * @param number number of the integration beam you want the IntegrationBeam object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Returns the data for an integration point in *INTEGRATION_BEAM.Note data is only available when NIP&gt;0.
 * @param index Index you want the integration point data for. Note that indices start at 0.
 */
    GetIntegrationPoint(index: number): number[];

/**
 * Checks if a IntegrationBeam property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the IntegrationBeam.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop integration beam property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this intb (*INTEGRATION_BEAM). Note that a carriage return is not added. See also IntegrationBeam.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the intb. Note that a carriage return is not added. See also IntegrationBeam.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last integration beam in the model.
 * @param Model Model to get last integration beam in
 */
    static Last(Model: Model): number;

/**
 * Returns the last free integration beam label in the model. Also see IntegrationBeam.FirstFreeLabel(), IntegrationBeam.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free integration beam label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next integration beam in the model.
 */
    Next(): number;

/**
 * Returns the next free (highest+1) integration beam label in the model. Also see IntegrationBeam.FirstFreeLabel(), IntegrationBeam.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free integration beam label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous integration beam in the model.
 */
    Previous(): number;

/**
 * Renumbers all of the integration beams in the model.
 * @param Model Model that all integration beams will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged integration beams in the model.
 * @param Model Model that all the flagged integration beams will be renumbered in
 * @param flag Flag set on the integration beams that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select integration beams using standard PRIMER object menus.
 * @param flag Flag to use when selecting integration beams
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only integration beams from that model can be selected. If the argument is a Flag then only integration beams that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any integration beams can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the integration beam.
 * @param flag Flag to set on the integration beam
 */
    SetFlag(flag: number): void;

/**
 * Sets the integration point data for an *INTEGRATION_BEAM.
 * @param index Index you want to set the integration point data for. Note that indices start at 0.
 * @param s s coordinate of integration point in range -1 to 1.
 * @param t s coordinate of integration point in range -1 to 1.
 * @param wf Weighting factor, area associated with the integration point divided by actual beam cross sectional area.
 * @param pid Optional part ID if different from the PID specified on the element card.
 */
    SetIntegrationPoint(index: number, s: number, t: number, wf: number, pid?: number): void;

/**
 * Returns the total number of integration beams in the model.
 * @param Model Model to get total for
 * @param exists true if only existing integration beams should be counted. If false or omitted referenced but undefined integration beams will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the integration beams in the model.
 * @param Model Model that the defined flag for all integration beams will be unset in
 * @param flag Flag to unset on the integration beams
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for integration beam. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this integration beam.
 */
    Xrefs(): Xrefs;

/**
 * Create a new IntegrationBeam object.
 * @param Model Model that intb will be created in.
 * @param irid Integration_Beam ID.
 * @param nip Number of integration points. If omitted nip will be 0.
 * @param ra Relative area of cross section. If omitted ra will be 0.
 * @param icst Standard cross section type. If omitted icst will be 0.
 * @param k Integration refinement parameter for standard cross section types. If omitted k will be 0.
 */
    constructor(Model: Model, irid: number, nip?: number, ra?: number, icst?: number, k?: number);

/**
 * Creates a string containing the intb data in keyword format. Note that this contains the keyword header and the keyword cards. See also IntegrationBeam.Keyword() and IntegrationBeam.KeywordCards().
 */
    toString(): string;

/** Cross-section dimension. */
    d1: number;
/** Cross-section dimension. */
    d2: number;
/** Cross-section dimension. */
    d3: number;
/** Cross-section dimension. */
    d4: number;
/** true if intb exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Standard cross section type. */
    icst: number;
/** The Include file number that the intb is in. */
    include: number;
/** Integration rule id. */
    irid: number;
/** Integration refinement parameter for standard cross section types. */
    k: number;
/** The Model number that the integration beam is in. */
    model: number;
/** Number of integration points. */
    nip: number;
/** Optional part ID if different from the PID specified on the element card. */
    pid: Part;
/** Relative area of cross section. */
    ra: number;
/** Normalized s coordinate of integration point. */
    s: number;
/** Location of reference surface normal to s, for the Hughes-Liu beam only. */
    sref: number;
/** Normalized t coordinate of integration point. */
    t: number;
/** Location of reference surface normal to t, for the Hughes-Liu beam only. */
    tref: number;
/** Weighting factor (area associated with integration point divided by actual cross sectional area). */
    wf: number;
}

declare class IntegrationShell {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the integration shell.
 * @param flag Flag to clear on the integration shell
 */
    ClearFlag(flag: number): void;

/**
 * Copies the integration shell.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Starts an interactive editing panel to create a ints.
 * @param Model Model that the ints will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): number;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for integration shell. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first integration shell in the model.
 * @param Model Model to get first integration shell in
 */
    static First(Model: Model): number;

/**
 * Returns the first free integration shell label in the model. Also see IntegrationShell.LastFreeLabel(), IntegrationShell.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free integration shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the integration shells in the model with a defined flag.
 * @param Model Model that all integration shells will be flagged in
 * @param flag Flag to set on the integration shells
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the integration shell is flagged or not.
 * @param flag Flag to test on the integration shell
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each integration shell in the model. Note that ForEach has been designed to make looping over integration shells as fast as possible and so has some limitations. Firstly, a single temporary IntegrationShell object is created and on each function call it is updated with the current integration shell data. This means that you should not try to store the IntegrationShell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new integration shells inside a ForEach loop. 
 * @param Model Model that all integration shells are in
 * @param func Function to call for each integration shell
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of IntegrationShell objects for all of the integration shells in a model in Primer
 * @param Model Model to get integration shells from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns an array of IntegrationShell objects for all of the flagged integration shells in a model in Primer
 * @param Model Model to get integration shells from
 * @param flag Flag set on the integration shells that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the IntegrationShell object for a integration shell ID.
 * @param Model Model to find the integration shell in
 * @param number number of the integration shell you want the IntegrationShell object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Returns the data for an integration point in *INTEGRATION_SHELL.Note data is only available when NIP&gt;0 and ESOP=0.
 * @param index Index you want the integration point data for. Note that indices start at 0.
 */
    GetIntegrationPoint(index: number): number[];

/**
 * Checks if a IntegrationShell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the IntegrationShell.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop integration shell property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this ints (*INTEGRATION_SHELL). Note that a carriage return is not added. See also IntegrationShell.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the ints. Note that a carriage return is not added. See also IntegrationShell.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last integration shell in the model.
 * @param Model Model to get last integration shell in
 */
    static Last(Model: Model): number;

/**
 * Returns the last free integration shell label in the model. Also see IntegrationShell.FirstFreeLabel(), IntegrationShell.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free integration shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next integration shell in the model.
 */
    Next(): number;

/**
 * Returns the next free (highest+1) integration shell label in the model. Also see IntegrationShell.FirstFreeLabel(), IntegrationShell.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free integration shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous integration shell in the model.
 */
    Previous(): number;

/**
 * Renumbers all of the integration shells in the model.
 * @param Model Model that all integration shells will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged integration shells in the model.
 * @param Model Model that all the flagged integration shells will be renumbered in
 * @param flag Flag set on the integration shells that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select integration shells using standard PRIMER object menus.
 * @param flag Flag to use when selecting integration shells
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only integration shells from that model can be selected. If the argument is a Flag then only integration shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any integration shells can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the integration shell.
 * @param flag Flag to set on the integration shell
 */
    SetFlag(flag: number): void;

/**
 * Sets the integration point data for an *INTEGRATION_SHELL.
 * @param index Index you want to set the integration point data for. Note that indices start at 0.
 * @param s Coordinate of integration point in range -1 to 1.
 * @param wf Weighting factor, thickness associated with the integration point divided by actual shell thickness.
 * @param pid Optional part ID if different from the PID specified on the element card.
 */
    SetIntegrationPoint(index: number, s: number, wf: number, pid?: number): void;

/**
 * Returns the total number of integration shells in the model.
 * @param Model Model to get total for
 * @param exists true if only existing integration shells should be counted. If false or omitted referenced but undefined integration shells will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the integration shells in the model.
 * @param Model Model that the defined flag for all integration shells will be unset in
 * @param flag Flag to unset on the integration shells
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for integration shell. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this integration shell.
 */
    Xrefs(): Xrefs;

/**
 * Create a new IntegrationShell object.
 * @param Model Model that ints will be created in.
 * @param irid Integration_Beam ID.
 * @param nip Number of integration points.
 * @param esop Equal spacing of integration points option. If omitted esop will be 0.
 * @param failopt Treatment of failure when mixing different constitutive types. If omitted failopt will be 0.
 */
    constructor(Model: Model, irid: number, nip: number, esop?: number, failopt?: number);

/**
 * Creates a string containing the ints data in keyword format. Note that this contains the keyword header and the keyword cards. See also IntegrationShell.Keyword() and IntegrationShell.KeywordCards().
 */
    toString(): string;

/** Equal spacing of integration points option. */
    esop: number;
/** true if ints exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Treatment of failure when mixing different constitutive types. */
    failopt: number;
/** The Include file number that the ints is in. */
    include: number;
/** Integration rule id. */
    irid: number;
/** The Model number that the integration shell is in. */
    model: number;
/** Number of integration points. */
    nip: number;
/** Optional part ID if different from the PID specified on the element card. */
    pid: Part;
/** Coordinate of integration point in range -1 to 1. */
    s: number;
/** Weighting factor (thickness associated with integration point divided by actual shell thickness). */
    wf: number;
}

declare class InterfaceComponent {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the interface component.
 * @param flag Flag to clear on the interface component
 */
    ClearFlag(flag: number): void;

/**
 * Copies the interface component.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Starts an interactive editing panel to create an InterfaceComponent.
 * @param Model Model that the InterfaceComponent will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): number;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for interface component. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first interface component in the model.
 * @param Model Model to get first interface component in
 */
    static First(Model: Model): number;

/**
 * Returns the first free interface component label in the model. Also see InterfaceComponent.LastFreeLabel(), InterfaceComponent.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free interface component label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the interface components in the model with a defined flag.
 * @param Model Model that all interface components will be flagged in
 * @param flag Flag to set on the interface components
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the interface component is flagged or not.
 * @param flag Flag to test on the interface component
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each interface component in the model. Note that ForEach has been designed to make looping over interface components as fast as possible and so has some limitations. Firstly, a single temporary InterfaceComponent object is created and on each function call it is updated with the current interface component data. This means that you should not try to store the InterfaceComponent object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new interface components inside a ForEach loop. 
 * @param Model Model that all interface components are in
 * @param func Function to call for each interface component
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of InterfaceComponent objects for all of the interface components in a model in Primer
 * @param Model Model to get interface components from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns an array of InterfaceComponent objects for all of the flagged interface components in a model in Primer
 * @param Model Model to get interface components from
 * @param flag Flag set on the interface components that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the InterfaceComponent object for a interface component ID.
 * @param Model Model to find the interface component in
 * @param number number of the interface component you want the InterfaceComponent object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Checks if a InterfaceComponent property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the InterfaceComponent.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop interface component property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this InterfaceComponent (*INTERFACE_COMPONENT). Note that a carriage return is not added. See also InterfaceComponent.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the InterfaceComponent. Note that a carriage return is not added. See also InterfaceComponent.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last interface component in the model.
 * @param Model Model to get last interface component in
 */
    static Last(Model: Model): number;

/**
 * Returns the last free interface component label in the model. Also see InterfaceComponent.FirstFreeLabel(), InterfaceComponent.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free interface component label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next interface component in the model.
 */
    Next(): number;

/**
 * Returns the next free (highest+1) interface component label in the model. Also see InterfaceComponent.FirstFreeLabel(), InterfaceComponent.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free interface component label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous interface component in the model.
 */
    Previous(): number;

/**
 * Renumbers all of the interface components in the model.
 * @param Model Model that all interface components will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged interface components in the model.
 * @param Model Model that all the flagged interface components will be renumbered in
 * @param flag Flag set on the interface components that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select interface components using standard PRIMER object menus.
 * @param flag Flag to use when selecting interface components
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only interface components from that model can be selected. If the argument is a Flag then only interface components that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any interface components can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the interface component.
 * @param flag Flag to set on the interface component
 */
    SetFlag(flag: number): void;

/**
 * Returns the total number of interface components in the model.
 * @param Model Model to get total for
 * @param exists true if only existing interface components should be counted. If false or omitted referenced but undefined interface components will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the interface components in the model.
 * @param Model Model that the defined flag for all interface components will be unset in
 * @param flag Flag to unset on the interface components
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for interface component. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this interface component.
 */
    Xrefs(): Xrefs;

/**
 * Create a new InterfaceComponent object.
 * @param Model Model that InterfaceComponent will be created in
 * @param type InterfaceComponent type. Can be InterfaceComponent.NODE, InterfaceComponent.SEGMENT,
 * @param snid_ssid Set node or set segment ID
 * @param cid Coordinate system ID
 * @param nid Node ID
 * @param label InterfaceComponent number
 * @param title Title for this interface
 */
    constructor(Model: Model, type: number, snid_ssid: number, cid: number, nid: number, label?: number, title?: string);

/**
 * Creates a string containing the InterfaceComponent data in keyword format. Note that this contains the keyword header and the keyword cards. See also InterfaceComponent.Keyword() and InterfaceComponent.KeywordCards().
 */
    toString(): string;

/** Coordinate system ID. */
    cid: number;
/** true if interface component exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the interface component is in. */
    include: number;
/** The Model number that the interface component is in. */
    model: number;
/** Node ID. */
    nid: number;
/** Element ID or element set ID. The ssid property is an alternative name for this. */
    nsid: number;
/** InterfaceComponent option. Can be InterfaceComponent.NODE, InterfaceComponent.SEGMENT, */
    option: number;
/** Element ID or element set ID. The nsid property is an alternative name for this. */
    ssid: number;
/** InterfaceComponent title */
    title: string;
/** Node option */
    static NODE: number;
/** Segment option */
    static SEGMENT: number;
}

declare class InterfaceLinkingEdge {
/**
 * Clears a flag on the Interface Linking Edge.
 * @param flag Flag to clear on the Interface Linking Edge
 */
    ClearFlag(flag: number): void;

/**
 * Copies the Interface Linking Edge.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Adds an error for Interface Linking Edge. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first Interface Linking Edge in the model.
 * @param Model Model to get first Interface Linking Edge in
 */
    static First(Model: Model): number;

/**
 * Flags all of the Interface Linking Edges in the model with a defined flag.
 * @param Model Model that all Interface Linking Edges will be flagged in
 * @param flag Flag to set on the Interface Linking Edges
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the Interface Linking Edge is flagged or not.
 * @param flag Flag to test on the Interface Linking Edge
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each Interface Linking Edge in the model. Note that ForEach has been designed to make looping over Interface Linking Edges as fast as possible and so has some limitations. Firstly, a single temporary InterfaceLinkingEdge object is created and on each function call it is updated with the current Interface Linking Edge data. This means that you should not try to store the InterfaceLinkingEdge object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new Interface Linking Edges inside a ForEach loop. 
 * @param Model Model that all Interface Linking Edges are in
 * @param func Function to call for each Interface Linking Edge
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of InterfaceLinkingEdge objects for all of the Interface Linking Edges in a model in Primer
 * @param Model Model to get Interface Linking Edges from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns an array of InterfaceLinkingEdge objects for all of the flagged Interface Linking Edges in a model in Primer
 * @param Model Model to get Interface Linking Edges from
 * @param flag Flag set on the Interface Linking Edges that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the InterfaceLinkingEdge object for a Interface Linking Edge ID.
 * @param Model Model to find the Interface Linking Edge in
 * @param number number of the Interface Linking Edge you want the InterfaceLinkingEdge object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Checks if a InterfaceLinkingEdge property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the InterfaceLinkingEdge.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop Interface Linking Edge property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this Interface Linking Edge (*INTERFACE_LINKING_EDGE). Note that a carriage return is not added. See also InterfaceLinkingEdge.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the Interface Linking Edge. Note that a carriage return is not added. See also InterfaceLinkingEdge.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last Interface Linking Edge in the model.
 * @param Model Model to get last Interface Linking Edge in
 */
    static Last(Model: Model): number;

/**
 * Returns the next Interface Linking Edge in the model.
 */
    Next(): number;

/**
 * Returns the previous Interface Linking Edge in the model.
 */
    Previous(): number;

/**
 * Allows the user to select Interface Linking Edges using standard PRIMER object menus.
 * @param flag Flag to use when selecting Interface Linking Edges
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only Interface Linking Edges from that model can be selected. If the argument is a Flag then only Interface Linking Edges that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any Interface Linking Edges can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the Interface Linking Edge.
 * @param flag Flag to set on the Interface Linking Edge
 */
    SetFlag(flag: number): void;

/**
 * Returns the total number of Interface Linking Edges in the model.
 * @param Model Model to get total for
 * @param exists true if only existing Interface Linking Edges should be counted. If false or omitted referenced but undefined Interface Linking Edges will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the Interface Linking Edges in the model.
 * @param Model Model that the defined flag for all Interface Linking Edges will be unset in
 * @param flag Flag to unset on the Interface Linking Edges
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for Interface Linking Edge. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this Interface Linking Edge.
 */
    Xrefs(): Xrefs;

/**
 * Create a new InterfaceLinkingEdge object.
 * @param Model Model that Interface Linking Edge will be created in
 * @param nsid Node set ID
 * @param ifid Interface ID
 */
    constructor(Model: Model, nsid: number, ifid: number);

/**
 * Creates a string containing the Interface Linking Edge data in keyword format. Note that this contains the keyword header and the keyword cards. See also InterfaceLinkingEdge.Keyword() and InterfaceLinkingEdge.KeywordCards().
 */
    toString(): string;

/** true if Interface Linking Edge exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Interface ID. */
    ifid: number;
/** The Include file number that the Interface Linking Edge is in. */
    include: number;
/** The Model number that the Interface Linking Edge is in. */
    model: number;
/** Node set  ID */
    nsid: number;
}

declare class InterfaceSpringback {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the interface springback.
 * @param flag Flag to clear on the interface springback
 */
    ClearFlag(flag: number): void;

/**
 * Copies the interface springback.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Starts an interactive editing panel to create an InterfaceSpringback definition.
 * @param Model Model that the InterfaceSpringback will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): number;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for interface springback. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first interface springback in the model.
 * @param Model Model to get first interface springback in
 */
    static First(Model: Model): number;

/**
 * Flags all of the interface springbacks in the model with a defined flag.
 * @param Model Model that all interface springbacks will be flagged in
 * @param flag Flag to set on the interface springbacks
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the interface springback is flagged or not.
 * @param flag Flag to test on the interface springback
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each interface springback in the model. Note that ForEach has been designed to make looping over interface springbacks as fast as possible and so has some limitations. Firstly, a single temporary InterfaceSpringback object is created and on each function call it is updated with the current interface springback data. This means that you should not try to store the InterfaceSpringback object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new interface springbacks inside a ForEach loop. 
 * @param Model Model that all interface springbacks are in
 * @param func Function to call for each interface springback
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of InterfaceSpringback objects for all of the interface springbacks in a model in Primer
 * @param Model Model to get interface springbacks from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns the keyword string excluded at given index in Keyword list. Needed only for InterfaceSpringback.EXCLUDE.
 * @param idx The index in Keyword list you want the Keyword string for. Note that indices start at 0, not 1.
 */
    GetExcludeKeyword(idx: number): string;

/**
 * Returns an array of InterfaceSpringback objects for all of the flagged interface springbacks in a model in Primer
 * @param Model Model to get interface springbacks from
 * @param flag Flag set on the interface springbacks that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the InterfaceSpringback object for a interface springback ID.
 * @param Model Model to find the interface springback in
 * @param number number of the interface springback you want the InterfaceSpringback object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Returns the data for nodal point constrained for *INTERFACE_SPRINGBACK.
 * @param npt The nodal point you want the data for. Note that nodal points start at 0, not 1.
 */
    GetNodalPoint(npt: number): number[];

/**
 * Checks if a InterfaceSpringback property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the InterfaceSpringback.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop interface springback property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this Interface Springback (*INTERFACE_SPRINGBACK_xxxx_xxxx) Note that a carriage return is not added. See also InterfaceSpringback.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the InterfaceSpringback. Note that a carriage return is not added. See also InterfaceSpringback.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last interface springback in the model.
 * @param Model Model to get last interface springback in
 */
    static Last(Model: Model): number;

/**
 * Returns the next interface springback in the model.
 */
    Next(): number;

/**
 * Returns the previous interface springback in the model.
 */
    Previous(): number;

/**
 * Removes the keyword string excluded at given index in Keyword list. Needed only for InterfaceSpringback.EXCLUDE
 * @param idx The index in Keyword list you removed. Note that indices start at 0, not 1.
 */
    RemoveExcludeKeyword(idx: number): void;

/**
 * Removes the nodal point for constrained node for *INTERFACE_SPRINGBACK.
 * @param npt The nodal point you want to remove. Note that nodal points start at 0, not 1.
 */
    RemoveNodalPoint(npt: number): void;

/**
 * Allows the user to select interface springbacks using standard PRIMER object menus.
 * @param flag Flag to use when selecting interface springbacks
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only interface springbacks from that model can be selected. If the argument is a Flag then only interface springbacks that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any interface springbacks can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a keyword string to be excluded. Adds a new keyword if index value is not given, else replaces the keyword string at given index. Note that indices start at 0, not 1. Needed only for InterfaceSpringback.EXCLUDE
 * @param keystr The keyword string you want to be excluded.
 * @param index The index at which keyword string should be set.
 */
    SetExcludeKeyword(keystr: string, index?: number): void;

/**
 * Sets a flag on the interface springback.
 * @param flag Flag to set on the interface springback
 */
    SetFlag(flag: number): void;

/**
 * Sets the nodal point data for a node in *INTERFACE_SPRINGBACK.
 * @param npt The nodal point you want to set the data for. Note that nodal points start at 0, not 1.
 * @param nid Node ID for the nodal point.
 * @param tc Translational constraint constant of the nodal point. (0-7)
 * @param rc Rotational constraint constant of the nodal point. (0-7)
 */
    SetNodalPoint(npt: number, nid: number, tc: number, rc: number): void;

/**
 * Returns the total number of interface springbacks in the model.
 * @param Model Model to get total for
 * @param exists true if only existing interface springbacks should be counted. If false or omitted referenced but undefined interface springbacks will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the interface springbacks in the model.
 * @param Model Model that the defined flag for all interface springbacks will be unset in
 * @param flag Flag to unset on the interface springbacks
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for interface springback. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this interface springback.
 */
    Xrefs(): Xrefs;

/**
 * Create a new InterfaceSpringback object.
 * @param Model Model that interface springback will be created in
 * @param Type Specify the type of InterfaceSpringback (Can be InterfaceSpringback.NIKE3D or InterfaceSpringback.LSDYNA or InterfaceSpringback.NASTRAN or InterfaceSpringback.SEAMLESS )
 * @param psid Part set  ID for springback.
 * @param nshv Num additional Shell/Solid history variables number.
 * @param ftype Filetype (0-3, 10-12).
 * @param ftensr Flag for dumping tensor data from the element history variables into the dynain file (0/1).
 * @param nthhsv Number of thermal history variables.
 * @param intstrn Output of strains at all integration points of shell element is requested.
 * @param optcard Whether to have an optional card. Can be true or false.
 * @param sldo Output of solid element data as 0 - *ELEMENT_SOLID, 1- *ELEM_SOLID_ORTHO. Used only for optional card.
 * @param ncyc Number of process cycles. Used only for optional card.
 * @param fsplit Flag for splitting of the dynain file (0 - One file, 1 - Two files.). Used only for optional card.
 * @param ndflag Flag to dump nodes into dynain file.
 * @param cflag Output contact state.
 */
    constructor(Model: Model, Type: number, psid?: number, nshv?: number, ftype?: number, ftensr?: number, nthhsv?: number, intstrn?: number, optcard?: boolean, sldo?: number, ncyc?: number, fsplit?: number, ndflag?: number, cflag?: number);

/**
 * Create a new InterfaceSpringback object with InterfaceSpringback.EXCLUDE option.
 * @param Model Model that interface springback will be created in
 * @param Type Specify the type of InterfaceSpringback (Should be InterfaceSpringback.EXCLUDE )
 * @param keylist List of keywords to be excluded.
 */
    constructor(Model: Model, Type: number, keylist?: string[]);

/**
 * Creates a string containing the InterfaceSpringback data in keyword format. Note that this contains the keyword header and the keyword cards. See also InterfaceSpringback.Keyword() and InterfaceSpringback.KeywordCards().
 */
    toString(): string;

/** Output contact state. */
    cflag: number;
/** true if interface springback exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Flag for splitting of the dynain file (0 - One file, 1 - Two files.). Used for OPTCARD field. */
    fsplit: number;
/** Flag for dumping tensor data from the element history variables into the dynain file (0/1). */
    ftensr: number;
/** Filetype (0-3, 10-12). */
    ftype: number;
/** The Include file number that the interface springback is in. */
    include: number;
/** Output of strains at all integration points of shell element is requested. */
    intstrn: number;
/** The Model number that the interface springback is in. */
    model: number;
/** Number of process cycles. Used for OPTCARD field. */
    ncyc: number;
/** Flag to dump nodes into dynain file. */
    ndflag: number;
/** gives the number of excluded keywords. Needed only for InterfaceSpringback.EXCLUDE. */
    nexclude: number;
/** gives the number of nodal points constrained for this keyword. (read_only) */
    nnodes: number;
/** true if _NOTHICKNESS (option2) is set. _NOTHICKNESS can be used only for InterfaceSpringback.LSDYNA or InterfaceSpringback.NASTRAN. */
    nothickness: boolean;
/** Num additional Shell/Solid history variables number. */
    nshv: number;
/** Number of thermal history variables. */
    nthhsv: number;
/** Whether to have a OPTCARD. Can be true or false. */
    optcard: boolean;
/** Part set  ID for springback. */
    psid: number;
/** Output of solid element data as 0 - *ELEMENT_SOLID, 1- *ELEM_SOLID_ORTHO. Used for OPTCARD field. */
    sldo: number;
/** gives the type of InterfaceSpringback object. (read only) */
    readonly type: number;
/** INTERFACE is *INTERFACE_SPRINGBACK_EXCLUDE. */
    static EXCLUDE: number;
/** INTERFACE is *INTERFACE_SPRINGBACK_LSDYNA. */
    static LSDYNA: number;
/** INTERFACE is *INTERFACE_SPRINGBACK_NASTRAN. */
    static NASTRAN: number;
/** INTERFACE is *INTERFACE_SPRINGBACK_NIKE3D. */
    static NIKE3D: number;
/** INTERFACE is *INTERFACE_SPRINGBACK_SEAMLESS. */
    static SEAMLESS: number;
}

declare class Interpolation {
/**
 * Used to add additional independent node card and local coordinate card (if ITYP is Interpolation.NODE_SET) to the keyword. Adds this data to the end of the selected *CONSTRAINED_INTERPOLATION
 * @param inid Independent Node or Node Set id.
 * @param idof Independent Degrees-of-Freedom. The default value is 123456.
 * @param twghtx Weighting factor for INID. Scales the x-translational component. The default value is 1.0.
 * @param twghty Weighting factor for INID. Scales the y-translational component. The default value is twghtx.
 * @param twghtz Weighting factor for INID. Scales the z-translational component. The default value is twghtx.
 * @param rwghtx Weighting factor for INID. Scales the x-rotational component. The default value is twghtx.
 * @param rwghty Weighting factor for INID. Scales the y-rotational component. The default value is twghtx.
 * @param rwghtz Weighting factor for INID. Scales the z-rotational component. The default value is twghtx.
 * @param cidi Coordinate System ID if LOCAL option is active. The default value is 0.
 */
    AddRowData(inid: number, idof?: number, twghtx?: number, twghty?: number, twghtz?: number, rwghtx?: number, rwghty?: number, rwghtz?: number, cidi?: number): void;

/**
 * Blanks the constrained interpolation
 */
    Blank(): void;

/**
 * Blanks all of the constrained interpolations in the model.
 * @param Model Model that all constrained interpolations will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged constrained interpolations in the model.
 * @param Model Model that all the flagged constrained interpolations will be blanked in
 * @param flag Flag set on the constrained interpolations that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the constrained interpolation is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the constrained interpolation.
 * @param flag Flag to clear on the constrained interpolation
 */
    ClearFlag(flag: number): void;

/**
 * Copies the constrained interpolation.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Starts an interactive editing panel to create a Interpolation.
 * @param Model Model that the constrainedInterpolation will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): number;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for constrained interpolation. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first constrained interpolation in the model.
 * @param Model Model to get first constrained interpolation in
 */
    static First(Model: Model): number;

/**
 * Returns the first free constrained interpolation label in the model. Also see Interpolation.LastFreeLabel(), Interpolation.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free constrained interpolation label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the constrained interpolations in the model with a defined flag.
 * @param Model Model that all constrained interpolations will be flagged in
 * @param flag Flag to set on the constrained interpolations
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the constrained interpolation is flagged or not.
 * @param flag Flag to test on the constrained interpolation
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each constrained interpolation in the model. Note that ForEach has been designed to make looping over constrained interpolations as fast as possible and so has some limitations. Firstly, a single temporary Interpolation object is created and on each function call it is updated with the current constrained interpolation data. This means that you should not try to store the Interpolation object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new constrained interpolations inside a ForEach loop. 
 * @param Model Model that all constrained interpolations are in
 * @param func Function to call for each constrained interpolation
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Interpolation objects for all of the constrained interpolations in a model in Primer
 * @param Model Model to get constrained interpolations from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns an array of Interpolation objects for all of the flagged constrained interpolations in a model in Primer
 * @param Model Model to get constrained interpolations from
 * @param flag Flag set on the constrained interpolations that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the Interpolation object for a constrained interpolation ID.
 * @param Model Model to find the constrained interpolation in
 * @param number number of the constrained interpolation you want the Interpolation object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Checks if a Interpolation property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Interpolation.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop constrained interpolation property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns independent node cards and local coordinate cards (if ITYP is Interpolation.NODE_SET) for the selected row of the *CONSTRAINED_INTERPOLATION.
 * @param row_index The row index of the data to return. Note that indices start at 0, not 1. 0 &lt;= row_index &lt; Interpolation.total
 */
    GetRowData(row_index: number): number[];

/**
 * Returns the keyword for this Interpolation (*constrained_interpolation). Note that a carriage return is not added. See also Interpolation.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the Interpolation. Note that a carriage return is not added. See also Interpolation.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last constrained interpolation in the model.
 * @param Model Model to get last constrained interpolation in
 */
    static Last(Model: Model): number;

/**
 * Returns the last free constrained interpolation label in the model. Also see Interpolation.FirstFreeLabel(), Interpolation.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free constrained interpolation label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next constrained interpolation in the model.
 */
    Next(): number;

/**
 * Returns the next free (highest+1) constrained interpolation label in the model. Also see Interpolation.FirstFreeLabel(), Interpolation.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free constrained interpolation label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a constrained interpolation.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only constrained interpolations from that model can be picked. If the argument is a Flag then only constrained interpolations that are flagged with limit can be selected. If omitted, or null, any constrained interpolations from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): number;

/**
 * Returns the previous constrained interpolation in the model.
 */
    Previous(): number;

/**
 * Removes an independent node card and a local coordinate card (if ITYP is Interpolation.NODE_SET) for the selected row on the *CONSTRAINED_INTERPOLATION.
 * @param row_index The row index of the data to return. Note that indices start at 0, not 1. 0 &lt;= row_index &lt; Interpolation.total
 */
    RemoveRowData(row_index: number): void;

/**
 * Renumbers all of the constrained interpolations in the model.
 * @param Model Model that all constrained interpolations will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged constrained interpolations in the model.
 * @param Model Model that all the flagged constrained interpolations will be renumbered in
 * @param flag Flag set on the constrained interpolations that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select constrained interpolations using standard PRIMER object menus.
 * @param flag Flag to use when selecting constrained interpolations
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only constrained interpolations from that model can be selected. If the argument is a Flag then only constrained interpolations that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any constrained interpolations can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the constrained interpolation.
 * @param flag Flag to set on the constrained interpolation
 */
    SetFlag(flag: number): void;

/**
 * Used to reset values in already existing independent node cards and local coordinate cards (if ITYP is Interpolation.NODE_SET) in the selected row of *CONSTRAINED_INTERPOLATION
 * @param row_index The row index of the data to return. Note that indices start at 0, not 1. 0 &lt;= row_index &lt; Interpolation.total
 * @param inid Independent Node or Node Set id.
 * @param idof Independent Degrees-of-Freedom. The default value is 123456.
 * @param twghtx Weighting factor for INID. Scales the x-translational component. The default value is 1.0.
 * @param twghty Weighting factor for INID. Scales the y-translational component. The default value is twghtx.
 * @param twghtz Weighting factor for INID. Scales the z-translational component. The default value is twghtx.
 * @param rwghtx Weighting factor for INID. Scales the x-rotational component. The default value is twghtx.
 * @param rwghty Weighting factor for INID. Scales the y-rotational component. The default value is twghtx.
 * @param rwghtz Weighting factor for INID. Scales the z-rotational component. The default value is twghtx.
 * @param cidi Coordinate System ID if LOCAL option is active. The default value is 0
 */
    SetRowData(row_index: number, inid: number, idof?: number, twghtx?: number, twghty?: number, twghtz?: number, rwghtx?: number, rwghty?: number, rwghtz?: number, cidi?: number): void;

/**
 * Sketches the constrained interpolation. The constrained interpolation will be sketched until you either call Interpolation.Unsketch(), Interpolation.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the constrained interpolation is sketched. If omitted redraw is true. If you want to sketch several constrained interpolations and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged constrained interpolations in the model. The constrained interpolations will be sketched until you either call Interpolation.Unsketch(), Interpolation.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged constrained interpolations will be sketched in
 * @param flag Flag set on the constrained interpolations that you want to sketch
 * @param redraw If model should be redrawn or not after the constrained interpolations are sketched. If omitted redraw is true. If you want to sketch flagged constrained interpolations several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of constrained interpolations in the model.
 * @param Model Model to get total for
 * @param exists true if only existing constrained interpolations should be counted. If false or omitted referenced but undefined constrained interpolations will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the constrained interpolation
 */
    Unblank(): void;

/**
 * Unblanks all of the constrained interpolations in the model.
 * @param Model Model that all constrained interpolations will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged constrained interpolations in the model.
 * @param Model Model that the flagged constrained interpolations will be unblanked in
 * @param flag Flag set on the constrained interpolations that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the constrained interpolations in the model.
 * @param Model Model that the defined flag for all constrained interpolations will be unset in
 * @param flag Flag to unset on the constrained interpolations
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the constrained interpolation.
 * @param redraw If model should be redrawn or not after the constrained interpolation is unsketched. If omitted redraw is true. If you want to unsketch several constrained interpolations and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all constrained interpolations.
 * @param Model Model that all constrained interpolations will be unblanked in
 * @param redraw If model should be redrawn or not after the constrained interpolations are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged constrained interpolations in the model.
 * @param Model Model that all constrained interpolations will be unsketched in
 * @param flag Flag set on the constrained interpolations that you want to unsketch
 * @param redraw If model should be redrawn or not after the constrained interpolations are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for constrained interpolation. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this constrained interpolation.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Interpolation object.
 * @param Model Model that Interpolation will be created in
 * @param icid Interpolation label
 * @param dnid Dependent Node id.
 * @param inid Independent Node or Node Set id.
 * @param ddof Dependent Degrees-of-Freedom. The default value is 123456.
 * @param local true if _LOCAL is set.
 * @param cidd Coordinate System ID if LOCAL option is active. The default value is 0.
 * @param ityp The Independent Node type. Can be Interpolation.NODE or Interpolation.NODE_SET. The default value is Interpolation.NODE.
 * @param idof Independent Degrees-of-Freedom. The default value is 123456.
 * @param twghtx Weighting factor for INID. Scales the x-translational component. The default value is 1.0.
 * @param twghty Weighting factor for INID. Scales the y-translational component. The default value is twghtx.
 * @param twghtz Weighting factor for INID. Scales the z-translational component. The default value is twghtx.
 * @param rwghtx Weighting factor for INID. Scales the x-rotational component. The default value is twghtx.
 * @param rwghty Weighting factor for INID. Scales the y-rotational component. The default value is twghtx.
 * @param rwghtz Weighting factor for INID. Scales the z-rotational component. The default value is twghtx.
 * @param cidi Coordinate System ID if LOCAL option is active. The default value is 0
 */
    constructor(Model: Model, icid: number, dnid: number, inid: number, ddof?: number, local?: boolean, cidd?: number, ityp?: number, idof?: number, twghtx?: number, twghty?: number, twghtz?: number, rwghtx?: number, rwghty?: number, rwghtz?: number, cidi?: number);

/**
 * Creates a string containing the Interpolation data in keyword format. Note that this contains the keyword header and the keyword cards. See also Interpolation.Keyword() and Interpolation.KeywordCards().
 */
    toString(): string;

/** Coordinate System ID if LOCAL option is active. */
    cidd: number;
/** Dependent Degrees-of-Freedom. */
    ddof: number;
/** Dependent Node id. */
    dnid: number;
/** true if Interpolation exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Interpolation label */
    icid: number;
/** The Include file number that the Interpolation is in. */
    include: number;
/** Switch for controlling the explicit solution when an independent (or dependent) node is deleted. */
    indsw: number;
/** The Independent Node type. Can be Interpolation.NODE or Interpolation.NODE_SET. */
    ityp: number;
/** true if _LOCAL is set. */
    local: boolean;
/** The Model number that the constrained interpolation is in. */
    model: number;
/** Total number of INID fields in the keyword. */
    readonly total: number;
/** INID is a node. */
    static NODE: number;
/** INID is a node set. */
    static NODE_SET: number;
}

declare class InterpolationSpotweld {
/**
 * Blanks the interpolation spotweld
 */
    Blank(): void;

/**
 * Blanks all of the interpolation spotwelds in the model.
 * @param Model Model that all interpolation spotwelds will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged interpolation spotwelds in the model.
 * @param Model Model that all the flagged interpolation spotwelds will be blanked in
 * @param flag Flag set on the interpolation spotwelds that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the interpolation spotweld is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the interpolation spotweld.
 * @param flag Flag to clear on the interpolation spotweld
 */
    ClearFlag(flag: number): void;

/**
 * Copies the interpolation spotweld.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Adds an error for interpolation spotweld. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first interpolation spotweld in the model.
 * @param Model Model to get first interpolation spotweld in
 */
    static First(Model: Model): number;

/**
 * Flags all of the interpolation spotwelds in the model with a defined flag.
 * @param Model Model that all interpolation spotwelds will be flagged in
 * @param flag Flag to set on the interpolation spotwelds
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the interpolation spotweld is flagged or not.
 * @param flag Flag to test on the interpolation spotweld
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each interpolation spotweld in the model. Note that ForEach has been designed to make looping over interpolation spotwelds as fast as possible and so has some limitations. Firstly, a single temporary InterpolationSpotweld object is created and on each function call it is updated with the current interpolation spotweld data. This means that you should not try to store the InterpolationSpotweld object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new interpolation spotwelds inside a ForEach loop. 
 * @param Model Model that all interpolation spotwelds are in
 * @param func Function to call for each interpolation spotweld
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of InterpolationSpotweld objects for all of the interpolation spotwelds in a model in Primer
 * @param Model Model to get interpolation spotwelds from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns an array of InterpolationSpotweld objects for all of the flagged interpolation spotwelds in a model in Primer
 * @param Model Model to get interpolation spotwelds from
 * @param flag Flag set on the interpolation spotwelds that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the InterpolationSpotweld object for a interpolation spotweld ID.
 * @param Model Model to find the interpolation spotweld in
 * @param number number of the interpolation spotweld you want the InterpolationSpotweld object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Checks if a InterpolationSpotweld property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the InterpolationSpotweld.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop interpolation spotweld property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this interpolation spotweld (*CONSTRAINED_INTERPOLATION_SPOTWELD). Note that a carriage return is not added. See also InterpolationSpotweld.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the interpolation spotweld. Note that a carriage return is not added. See also InterpolationSpotweld.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last interpolation spotweld in the model.
 * @param Model Model to get last interpolation spotweld in
 */
    static Last(Model: Model): number;

/**
 * Returns the next interpolation spotweld in the model.
 */
    Next(): number;

/**
 * Allows the user to pick a interpolation spotweld.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only interpolation spotwelds from that model can be picked. If the argument is a Flag then only interpolation spotwelds that are flagged with limit can be selected. If omitted, or null, any interpolation spotwelds from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): number;

/**
 * Returns the previous interpolation spotweld in the model.
 */
    Previous(): number;

/**
 * Allows the user to select interpolation spotwelds using standard PRIMER object menus.
 * @param flag Flag to use when selecting interpolation spotwelds
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only interpolation spotwelds from that model can be selected. If the argument is a Flag then only interpolation spotwelds that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any interpolation spotwelds can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the interpolation spotweld.
 * @param flag Flag to set on the interpolation spotweld
 */
    SetFlag(flag: number): void;

/**
 * Sketches the interpolation spotweld. The interpolation spotweld will be sketched until you either call InterpolationSpotweld.Unsketch(), InterpolationSpotweld.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the interpolation spotweld is sketched. If omitted redraw is true. If you want to sketch several interpolation spotwelds and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged interpolation spotwelds in the model. The interpolation spotwelds will be sketched until you either call InterpolationSpotweld.Unsketch(), InterpolationSpotweld.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged interpolation spotwelds will be sketched in
 * @param flag Flag set on the interpolation spotwelds that you want to sketch
 * @param redraw If model should be redrawn or not after the interpolation spotwelds are sketched. If omitted redraw is true. If you want to sketch flagged interpolation spotwelds several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of interpolation spotwelds in the model.
 * @param Model Model to get total for
 * @param exists true if only existing interpolation spotwelds should be counted. If false or omitted referenced but undefined interpolation spotwelds will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the interpolation spotweld
 */
    Unblank(): void;

/**
 * Unblanks all of the interpolation spotwelds in the model.
 * @param Model Model that all interpolation spotwelds will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged interpolation spotwelds in the model.
 * @param Model Model that the flagged interpolation spotwelds will be unblanked in
 * @param flag Flag set on the interpolation spotwelds that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the interpolation spotwelds in the model.
 * @param Model Model that the defined flag for all interpolation spotwelds will be unset in
 * @param flag Flag to unset on the interpolation spotwelds
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the interpolation spotweld.
 * @param redraw If model should be redrawn or not after the interpolation spotweld is unsketched. If omitted redraw is true. If you want to unsketch several interpolation spotwelds and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all interpolation spotwelds.
 * @param Model Model that all interpolation spotwelds will be unblanked in
 * @param redraw If model should be redrawn or not after the interpolation spotwelds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged interpolation spotwelds in the model.
 * @param Model Model that all interpolation spotwelds will be unsketched in
 * @param flag Flag set on the interpolation spotwelds that you want to unsketch
 * @param redraw If model should be redrawn or not after the interpolation spotwelds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for interpolation spotweld. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this interpolation spotweld.
 */
    Xrefs(): Xrefs;

/**
 * Create a new InterpolationSpotweld object.
 * @param Model Model that constrained interpolation spotweld will be created in
 * @param pid1 Part ID of first sheet.
 * @param pid2 Part ID of second sheet.
 * @param nsid Node Set ID of spotweld location nodes.
 */
    constructor(Model: Model, pid1: number, pid2: number, nsid: number);

/**
 * Creates a string containing the interpolation spotweld data in keyword format. Note that this contains the keyword header and the keyword cards. See also InterpolationSpotweld.Keyword() and InterpolationSpotweld.KeywordCards().
 */
    toString(): string;

/** Scaling factor alpha 1. Function ID if MODEL &gt; 10. */
    alpha1: number;
/** Plastic initiation displacement scaling factor alpha2. */
    alpha2: number;
/** Plastic initiation displacement scaling factor alpha3. */
    alpha3: number;
/** Exponent for plastic potential beta 1. Function ID if MODEL &gt; 10. */
    beta: number;
/** Exponent for plastic initiation displacement beta2. */
    beta2: number;
/** Exponent for plastic initiation displacement beta3. */
    beta3: number;
/** Spotweld density (necessary for time step calculation). */
    dens: number;
/** true if constrained interpolation spotweld exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Scaling factor. */
    gamma: number;
/** The Include file number that the constrained interpolation spotweld is in. */
    include: number;
/** Flag for interpolation. Values can be InterpolationSpotweld.LINEAR, InterpolationSpotweld.UNIFORM or InterpolationSpotweld.INVERSE. */
    intp: number;
/** Load curve ID for damage exponent vs. mode mixity */
    lcdexp: number;
/** Load curve ID describing force versus plastic displacement. */
    lcf: number;
/** Load curve ID describing plastic initiation displacement versus mode mixity. Required only for MODEL values = InterpolationSpotweld.SPR3, InterpolationSpotweld.SPR3_MAT_PARAM or InterpolationSpotweld.SPR3_MAT_PARAM_MOD. */
    lcupf: number;
/** Load curve ID describing plastic rupture displacement versus mode mixity. Required only for MODEL values = InterpolationSpotweld.SPR3, InterpolationSpotweld.SPR3_MAT_PARAM or InterpolationSpotweld.SPR3_MAT_PARAM_MOD. */
    lcupr: number;
/** The Model number that the interpolation spotweld is in. */
    model: number;
/** Proportionality factor for dependency RN. */
    mrn: number;
/** Proportionality factor for dependency RS. */
    mrs: number;
/** Node Set ID of spotweld location nodes. */
    nsid: number;
/** Part ID of first sheet. */
    pid1: number;
/** Part ID */
    pid2: number;
/** Part ID for visualization beams representing SPR3 in post-processing. */
    pidvb: number;
/** Spotweld Radius. */
    r: number;
/** Tensile strength factor. Function ID if MODEL &gt; 10. */
    rn: number;
/** Shear strength factor. Function ID if MODEL &gt; 10. */
    rs: number;
/** Shear rotation option. */
    sropt: number;
/** Elastic stiffness OR material ID if less than 0. Function ID if MODEL &gt; 10. */
    stf: number;
/** Elastic shear stiffness. */
    stiff2: number;
/** Elastic bending stiffness. */
    stiff3: number;
/** Elastic torsional stiffness. */
    stiff4: number;
/** Total thickness of both sheets. */
    thick: number;
/** Plastic initiation displacement in normal direction. */
    upfn: number;
/** Plastic initiation displacement in shear direction. */
    upfs: number;
/** Plastic rupture displacement in normal direction. */
    uprn: number;
/** Plastic rupture displacement in shear direction. */
    uprs: number;
/** Property INTP value EQ.2.0: Inverse distance weighting. */
    static INVERSE: number;
/** Property INTP value EQ.0.0: Linear (default). */
    static LINEAR: number;
/** Property MODEL value EQ.1.0: SPR3 (default). */
    static SPR3: number;
/** Property MODEL value EQ.11.0: Same as 1 with selected material parameters as functions. */
    static SPR3_MAT_PARAM: number;
/** Property MODEL value EQ.21.0: Same as 11 with slight modification. */
    static SPR3_MAT_PARAM_MOD: number;
/** Property MODEL value EQ.2.0: SPR4. */
    static SPR4: number;
/** Property MODEL value EQ.12.0: Same as 2 with selected material parameters as functions. */
    static SPR4_MAT_PARAM: number;
/** Property MODEL value EQ.22.0: Same as 12 with slight modification. */
    static SPR4_MAT_PARAM_MOD: number;
/** Property INTP value EQ.1.0: Uniform. */
    static UNIFORM: number;
}

declare class Joint {
/**
 * Blanks the joint
 */
    Blank(): void;

/**
 * Blanks all of the joints in the model.
 * @param Model Model that all joints will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged joints in the model.
 * @param Model Model that all the flagged joints will be blanked in
 * @param flag Flag set on the joints that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the joint is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the joint.
 * @param flag Flag to clear on the joint
 */
    ClearFlag(flag: number): void;

/**
 * Copies the joint.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Starts an interactive editing panel to create a joint.
 * @param Model Model that the joint will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): number;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for joint. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first joint in the model.
 * @param Model Model to get first joint in
 */
    static First(Model: Model): number;

/**
 * Returns the first free joint label in the model. Also see Joint.LastFreeLabel(), Joint.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free joint label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the joints in the model with a defined flag.
 * @param Model Model that all joints will be flagged in
 * @param flag Flag to set on the joints
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the joint is flagged or not.
 * @param flag Flag to test on the joint
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each joint in the model. Note that ForEach has been designed to make looping over joints as fast as possible and so has some limitations. Firstly, a single temporary Joint object is created and on each function call it is updated with the current joint data. This means that you should not try to store the Joint object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new joints inside a ForEach loop. 
 * @param Model Model that all joints are in
 * @param func Function to call for each joint
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Joint objects for all of the joints in a model in Primer
 * @param Model Model to get joints from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns an array of Joint objects for all of the flagged joints in a model in Primer
 * @param Model Model to get joints from
 * @param flag Flag set on the joints that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the Joint object for a joint ID.
 * @param Model Model to find the joint in
 * @param number number of the joint you want the Joint object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Checks if a Joint property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Joint.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop joint property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this joint (*CONSTRAINED_JOINT). Note that a carriage return is not added. See also Joint.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the joint. Note that a carriage return is not added. See also Joint.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last joint in the model.
 * @param Model Model to get last joint in
 */
    static Last(Model: Model): number;

/**
 * Returns the last free joint label in the model. Also see Joint.FirstFreeLabel(), Joint.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free joint label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next joint in the model.
 */
    Next(): number;

/**
 * Returns the next free (highest+1) joint label in the model. Also see Joint.FirstFreeLabel(), Joint.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free joint label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a joint.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only joints from that model can be picked. If the argument is a Flag then only joints that are flagged with limit can be selected. If omitted, or null, any joints from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): number;

/**
 * Returns the previous joint in the model.
 */
    Previous(): number;

/**
 * Renumbers all of the joints in the model.
 * @param Model Model that all joints will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged joints in the model.
 * @param Model Model that all the flagged joints will be renumbered in
 * @param flag Flag set on the joints that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select joints using standard PRIMER object menus.
 * @param flag Flag to use when selecting joints
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only joints from that model can be selected. If the argument is a Flag then only joints that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any joints can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the joint.
 * @param flag Flag to set on the joint
 */
    SetFlag(flag: number): void;

/**
 * Sketches the joint. The joint will be sketched until you either call Joint.Unsketch(), Joint.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the joint is sketched. If omitted redraw is true. If you want to sketch several joints and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged joints in the model. The joints will be sketched until you either call Joint.Unsketch(), Joint.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged joints will be sketched in
 * @param flag Flag set on the joints that you want to sketch
 * @param redraw If model should be redrawn or not after the joints are sketched. If omitted redraw is true. If you want to sketch flagged joints several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of joints in the model.
 * @param Model Model to get total for
 * @param exists true if only existing joints should be counted. If false or omitted referenced but undefined joints will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the joint
 */
    Unblank(): void;

/**
 * Unblanks all of the joints in the model.
 * @param Model Model that all joints will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged joints in the model.
 * @param Model Model that the flagged joints will be unblanked in
 * @param flag Flag set on the joints that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the joints in the model.
 * @param Model Model that the defined flag for all joints will be unset in
 * @param flag Flag to unset on the joints
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the joint.
 * @param redraw If model should be redrawn or not after the joint is unsketched. If omitted redraw is true. If you want to unsketch several joints and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all joints.
 * @param Model Model that all joints will be unblanked in
 * @param redraw If model should be redrawn or not after the joints are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged joints in the model.
 * @param Model Model that all joints will be unsketched in
 * @param flag Flag set on the joints that you want to unsketch
 * @param redraw If model should be redrawn or not after the joints are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for joint. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this joint.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Joint object.
 * @param Model Model that constrained joint will be created in
 * @param option Constrained joint type (any).
 * @param n1 Node 1.
 * @param n2 Node 2.
 * @param jid Constrained joint number.
 * @param heading Constrained joint title.
 */
    constructor(Model: Model, option: number, n1: number, n2: number, jid?: number, heading?: string);

/**
 * Create a new Joint object.
 * @param Model Model that constrained joint will be created in
 * @param option Constrained joint type. Can be Joint.REVOLUTE, Joint.CYLINDRICAL, Joint.PLANAR, Joint.UNIVERSAL or Joint.TRANSLATIONAL_MOTOR.
 * @param n1 Node 1.
 * @param n2 Node 2.
 * @param n3 Node 3.
 * @param n4 Node 4.
 * @param jid Constrained joint number.
 * @param heading Constrained joint title.
 */
    constructor(Model: Model, option: number, n1: number, n2: number, n3: number, n4: number, jid?: number, heading?: string);

/**
 * Create a new Joint object.
 * @param Model Model that constrained joint will be created in
 * @param option Constrained joint type. Can be Joint.TRANSLATIONAL, Joint.LOCKING, Joint.ROTATIONAL_MOTOR, Joint.GEARS, Joint.RACK_AND_PINION, Joint.CONSTANT_VELOCITY, Joint.PULLEY or Joint.SCREW.
 * @param n1 Node 1.
 * @param n2 Node 2.
 * @param n3 Node 3.
 * @param n4 Node 4.
 * @param n5 Node 5.
 * @param n6 Node 6.
 * @param jid Constrained joint number.
 * @param heading Constrained joint title.
 */
    constructor(Model: Model, option: number, n1: number, n2: number, n3: number, n4: number, n5: number, n6: number, jid?: number, heading?: string);

/**
 * Creates a string containing the joint data in keyword format. Note that this contains the keyword header and the keyword cards. See also Joint.Keyword() and Joint.KeywordCards().
 */
    toString(): string;

/** Coordinate system number. */
    cid: number;
/** Coupling between force and moment failure. */
    coupl: number;
/** Damping scale factor. */
    damp: number;
/** true if constrained joint exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** true if _FAILURE option is set, false if not. */
    failure: boolean;
/** Helix angle for gears. */
    h_angle: number;
/** Constrained joint heading. */
    heading: string;
/** true if _ID option is set, false if not */
    id: boolean;
/** The Include file number that the constrained joint is in. */
    include: number;
/** Constrained joint number (identical to label). */
    jid: number;
/** Constrained joint number. */
    label: number;
/** Loadcuve number. */
    lcid: number;
/** true if _LOCAL option is set, false if not. */
    local: boolean;
/** Local system type is accelerometer if lst is 1, rigid body if 0. */
    lst: number;
/** The Model number that the joint is in. */
    model: number;
/** Torsional moment resultant at failure. */
    mxx: number;
/** Moment resultant at failure. */
    myy: number;
/** Moment resultant at failure. */
    mzz: number;
/** Node number 1. */
    n1: number;
/** Node number 2. */
    n2: number;
/** Node number 3. */
    n3: number;
/** Node number 4. */
    n4: number;
/** Node number 5. */
    n5: number;
/** Node number 6. */
    n6: number;
/** Axial force resultant at failure. */
    nxx: number;
/** Force resultant at failure. */
    nyy: number;
/** Force resultant at failure. */
    nzz: number;
/** The Constrained Joint option. Can be: Joint.SPHERICAL, Joint.REVOLUTE, Joint.CYLINDRICAL, Joint.PLANAR, Joint.UNIVERSAL, Joint.TRANSLATIONAL, Joint.LOCKING, Joint.TRANSLATIONAL_MOTOR, Joint.ROTATIONAL_MOTOR, Joint.GEARS, Joint.RACK_AND_PINION, Joint.CONSTANT_VELOCITY, Joint.PULLEY or Joint.SCREW */
    option: number;
/** Parameter for function. */
    parm: number;
/** Gear and pulley radius. */
    r1: number;
/** Rigid body or accelerometer number. */
    raid: number;
/** Relative penalty stiffness. */
    rps: number;
/** Time for joint failure. */
    tfail: number;
/** Flag for motor type. */
    type: number;
/** CONSTANT_VELOCITY is *CONSTRAINED_JOINT_CONSTANT_VELOCITY. */
    static CONSTANT_VELOCITY: number;
/** CYLINDRICAL is *CONSTRAINED_JOINT_CYLINDRICAL. */
    static CYLINDRICAL: number;
/** GEARS is *CONSTRAINED_JOINT_GEARS. */
    static GEARS: number;
/** LOCKING is *CONSTRAINED_JOINT_LOCKING. */
    static LOCKING: number;
/** PLANAR is *CONSTRAINED_JOINT_PLANAR. */
    static PLANAR: number;
/** PULLEY is *CONSTRAINED_JOINT_PULLEY. */
    static PULLEY: number;
/** RACK_AND_PINION is *CONSTRAINED_JOINT_RACK_AND_PINION. */
    static RACK_AND_PINION: number;
/** REVOLUTE is *CONSTRAINED_JOINT_REVOLUTE. */
    static REVOLUTE: number;
/** ROTATIONAL_MOTOR is *CONSTRAINED_JOINT_ROTATIONAL_MOTOR. */
    static ROTATIONAL_MOTOR: number;
/** SCREW is *CONSTRAINED_JOINT_SCREW. */
    static SCREW: number;
/** SPHERICAL is *CONSTRAINED_JOINT_SPHERICAL. */
    static SPHERICAL: number;
/** TRANSLATIONAL is *CONSTRAINED_JOINT_TRANSLATIONAL. */
    static TRANSLATIONAL: number;
/** TRANSLATIONAL_MOTOR is *CONSTRAINED_JOINT_TRANSLATIONAL_MOTOR. */
    static TRANSLATIONAL_MOTOR: number;
/** UNIVERSAL is *CONSTRAINED_JOINT_UNIVERSAL. */
    static UNIVERSAL: number;
}

declare class JointStiffness {
/**
 * Blanks the joint stiffness
 */
    Blank(): void;

/**
 * Blanks all of the joint stiffnesss in the model.
 * @param Model Model that all joint stiffnesss will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged joint stiffnesss in the model.
 * @param Model Model that all the flagged joint stiffnesss will be blanked in
 * @param flag Flag set on the joint stiffnesss that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the joint stiffness is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the joint stiffness.
 * @param flag Flag to clear on the joint stiffness
 */
    ClearFlag(flag: number): void;

/**
 * Copies the joint stiffness.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Starts an interactive editing panel to create a jstf.
 * @param Model Model that the jstf will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): number;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for joint stiffness. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first joint stiffness in the model.
 * @param Model Model to get first joint stiffness in
 */
    static First(Model: Model): number;

/**
 * Returns the first free joint stiffness label in the model. Also see JointStiffness.LastFreeLabel(), JointStiffness.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free joint stiffness label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the joint stiffnesss in the model with a defined flag.
 * @param Model Model that all joint stiffnesss will be flagged in
 * @param flag Flag to set on the joint stiffnesss
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the joint stiffness is flagged or not.
 * @param flag Flag to test on the joint stiffness
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each joint stiffness in the model. Note that ForEach has been designed to make looping over joint stiffnesss as fast as possible and so has some limitations. Firstly, a single temporary JointStiffness object is created and on each function call it is updated with the current joint stiffness data. This means that you should not try to store the JointStiffness object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new joint stiffnesss inside a ForEach loop. 
 * @param Model Model that all joint stiffnesss are in
 * @param func Function to call for each joint stiffness
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of JointStiffness objects for all of the joint stiffnesss in a model in Primer
 * @param Model Model to get joint stiffnesss from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns an array of JointStiffness objects for all of the flagged joint stiffnesss in a model in Primer
 * @param Model Model to get joint stiffnesss from
 * @param flag Flag set on the joint stiffnesss that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the JointStiffness object for a joint stiffness ID.
 * @param Model Model to find the joint stiffness in
 * @param number number of the joint stiffness you want the JointStiffness object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Checks if a JointStiffness property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the JointStiffness.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop joint stiffness property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this jstf (*CONSTRAINED_JOINT_STIFFNESS). Note that a carriage return is not added. See also JointStiffness.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the jstf. Note that a carriage return is not added. See also JointStiffness.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last joint stiffness in the model.
 * @param Model Model to get last joint stiffness in
 */
    static Last(Model: Model): number;

/**
 * Returns the last free joint stiffness label in the model. Also see JointStiffness.FirstFreeLabel(), JointStiffness.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free joint stiffness label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next joint stiffness in the model.
 */
    Next(): number;

/**
 * Returns the next free (highest+1) joint stiffness label in the model. Also see JointStiffness.FirstFreeLabel(), JointStiffness.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free joint stiffness label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a joint stiffness.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only joint stiffnesss from that model can be picked. If the argument is a Flag then only joint stiffnesss that are flagged with limit can be selected. If omitted, or null, any joint stiffnesss from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): number;

/**
 * Returns the previous joint stiffness in the model.
 */
    Previous(): number;

/**
 * Renumbers all of the joint stiffnesss in the model.
 * @param Model Model that all joint stiffnesss will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged joint stiffnesss in the model.
 * @param Model Model that all the flagged joint stiffnesss will be renumbered in
 * @param flag Flag set on the joint stiffnesss that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select joint stiffnesss using standard PRIMER object menus.
 * @param flag Flag to use when selecting joint stiffnesss
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only joint stiffnesss from that model can be selected. If the argument is a Flag then only joint stiffnesss that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any joint stiffnesss can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the joint stiffness.
 * @param flag Flag to set on the joint stiffness
 */
    SetFlag(flag: number): void;

/**
 * Sketches the joint stiffness. The joint stiffness will be sketched until you either call JointStiffness.Unsketch(), JointStiffness.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the joint stiffness is sketched. If omitted redraw is true. If you want to sketch several joint stiffnesss and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged joint stiffnesss in the model. The joint stiffnesss will be sketched until you either call JointStiffness.Unsketch(), JointStiffness.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged joint stiffnesss will be sketched in
 * @param flag Flag set on the joint stiffnesss that you want to sketch
 * @param redraw If model should be redrawn or not after the joint stiffnesss are sketched. If omitted redraw is true. If you want to sketch flagged joint stiffnesss several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of joint stiffnesss in the model.
 * @param Model Model to get total for
 * @param exists true if only existing joint stiffnesss should be counted. If false or omitted referenced but undefined joint stiffnesss will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the joint stiffness
 */
    Unblank(): void;

/**
 * Unblanks all of the joint stiffnesss in the model.
 * @param Model Model that all joint stiffnesss will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged joint stiffnesss in the model.
 * @param Model Model that the flagged joint stiffnesss will be unblanked in
 * @param flag Flag set on the joint stiffnesss that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the joint stiffnesss in the model.
 * @param Model Model that the defined flag for all joint stiffnesss will be unset in
 * @param flag Flag to unset on the joint stiffnesss
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the joint stiffness.
 * @param redraw If model should be redrawn or not after the joint stiffness is unsketched. If omitted redraw is true. If you want to unsketch several joint stiffnesss and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all joint stiffnesss.
 * @param Model Model that all joint stiffnesss will be unblanked in
 * @param redraw If model should be redrawn or not after the joint stiffnesss are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged joint stiffnesss in the model.
 * @param Model Model that all joint stiffnesss will be unsketched in
 * @param flag Flag set on the joint stiffnesss that you want to unsketch
 * @param redraw If model should be redrawn or not after the joint stiffnesss are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for joint stiffness. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this joint stiffness.
 */
    Xrefs(): Xrefs;

/**
 * Create a new JointStiffness object for *CONSTRAINED_JOINT_STIFFNESS_GENERALIZED.
 * @param Model Model that jstf will be created in
 * @param option Must be JointStiffness.GENERALIZED.
 * @param label JointStiffness ID of the JSTF. Also see the label argument which is an alternative name for this.
 * @param pida Part ID #A.
 * @param pidb Part ID #B.
 * @param cida Coordinate System ID #A.
 * @param cidb Coordinate System ID #B.
 * @param jid Joint for restraint/table uses.
 * @param lcidph LC: Phi moment vs rotation.
 * @param lcidt LC: Theta moment vs rotation.
 * @param lcidps LC: Psi moment vs rotation.
 * @param dlcidph LC: Phi damping moment vs rotation vel.
 * @param dlcidt LC: Theta damping moment vs rotation vel.
 * @param dlcidps LC: Psi damping moment vs rotation vel.
 * @param esph Stiffness/angle in Phi direction.
 * @param fmph LC: Psi frictional moment vs rotation.
 * @param est Stiffness/angle in Theta direction.
 * @param fmt LC: Theta frictional moment vs rotation.
 * @param esps Stiffness/angle in Psi direction.
 * @param fmps LC: Psi frictional moment vs rotation.
 * @param nsaph Stop angle for -ve Phi rotation.
 * @param psaph Stop angle for +ve Phi rotation.
 * @param nsat Stop angle for -ve Theta rotation.
 * @param psat Stop angle for +ve Theta rotation.
 * @param nsaps Stop angle for -ve Psi rotation.
 * @param psaps Stop angle for +ve Psi rotation.
 */
    constructor(Model: Model, option: number, label: number, pida: number, pidb: number, cida: number, cidb: number, jid: number, lcidph: number, lcidt: number, lcidps: number, dlcidph: number, dlcidt: number, dlcidps: number, esph: number, fmph: number, est: number, fmt: number, esps: number, fmps: number, nsaph: number, psaph: number, nsat: number, psat: number, nsaps: number, psaps: number);

/**
 * Create a new JointStiffness object for *CONSTRAINED_JOINT_STIFFNESS_FLEXION-TORSION.
 * @param Model Model that jstf will be created in
 * @param option Must be JointStiffness.FLEXION-TORSION.
 * @param label JointStiffness ID of the JSTF. Also see the label argument which is an alternative name for this.
 * @param pida Part ID #A.
 * @param pidb Part ID #B.
 * @param cida Coordinate System ID #A.
 * @param cidb Coordinate System ID #B.
 * @param jid Joint for restraint/table uses.
 * @param lcidal LC: Alpha moment vs Rotation.
 * @param lcidg LC: Gamma angle vs factor on Alpha blending.
 * @param lcidbt LC: Beta moment vs Rotation.
 * @param dlcidal LC: Alpha damping moment vs Rotl vel.
 * @param dlcidg LC: Gamma damping factor vs factor on Alpha damping moment.
 * @param dlcidbt LC: Beta damping moment vs Rotl vel.
 * @param esal Stiffness/angle in Alpha direction.
 * @param fmal LC: Alpha Frictional moment vs rotation.
 * @param esbt Stiffness/angle in Beta direction.
 * @param fmbt LC: Beta Frictional moment vs rotation.
 * @param saal Stop angle for Alpha rotation.
 * @param nsabt Stop angle for -ve Beta rotation.
 * @param psabt Stop angle for +ve Beta rotation.
 */
    constructor(Model: Model, option: number, label: number, pida: number, pidb: number, cida: number, cidb: number, jid: number, lcidal: number, lcidg: number, lcidbt: number, dlcidal: number, dlcidg: number, dlcidbt: number, esal: number, fmal: number, esbt: number, fmbt: number, saal: number, nsabt: number, psabt: number);

/**
 * Create a new JointStiffness object for *CONSTRAINED_JOINT_STIFFNESS_TRANSLATIONAL.
 * @param Model Model that jstf will be created in
 * @param option Must be JointStiffness.TRANSLATIONAL.
 * @param label JointStiffness ID of the JSTF. Also see the label argument which is an alternative name for this.
 * @param pida Part ID #A.
 * @param pidb Part ID #B.
 * @param cida Coordinate System ID #A.
 * @param cidb Coordinate System ID #B.
 * @param jid Joint for restraint/table uses.
 * @param lcidx LC: X force vs X rel displ.
 * @param lcidy LC: Y force vs Y rel displ.
 * @param lcidz LC: Z force vs Z rel displ.
 * @param dlcidx LC: X damping vs X rel velocity.
 * @param dlcidy LC: Y damping vs Y rel velocity.
 * @param dlcidz LC: Z damping vs Z rel velocity.
 * @param esx Elastic stiffness for X stop and friction.
 * @param ffx LC: Lim X force, or yield force vs X translation.
 * @param esy Elastic stiffness for Y stop and friction.
 * @param ffy LC: Lim Y force, or yield force vs Y translation.
 * @param esz Elastic stiffness for Z stop and friction.
 * @param ffz LC: Lim Z force, or yield force vs Z translation.
 * @param nsdx Limiting -ve X translation.
 * @param psdx Limiting +ve X translation.
 * @param nsdy Limiting -ve Y translation.
 * @param psdy Limiting +ve Y translation.
 * @param nsdz Limiting -ve Z translation.
 * @param psdz Limiting +ve Z translation.
 */
    constructor(Model: Model, option: number, label: number, pida: number, pidb: number, cida: number, cidb: number, jid: number, lcidx: number, lcidy: number, lcidz: number, dlcidx: number, dlcidy: number, dlcidz: number, esx: number, ffx: number, esy: number, ffy: number, esz: number, ffz: number, nsdx: number, psdx: number, nsdy: number, psdy: number, nsdz: number, psdz: number);

/**
 * Create a new JointStiffness object for *CONSTRAINED_JOINT_STIFFNESS_CYLINDRICAL.
 * @param Model Model that jstf will be created in
 * @param option Must be JointStiffness.CYLINDRICAL.
 * @param label JointStiffness ID of the JSTF. Also see the label argument which is an alternative name for this.
 * @param pida Part ID #A.
 * @param pidb Part ID #B.
 * @param cida Coordinate System ID #A.
 * @param cidb Coordinate System ID #B.
 * @param jid Joint for restraint/table uses.
 * @param lcidr LC: R force vs R rel displ.
 * @param lcidz LC: Z force vs Z rel displ.
 * @param dlcidr LC: R damping vs R rel velocity.
 * @param dlcidp LC: P damping vs P rel velocity.
 * @param dlcidz LC: Z damping vs Z rel velocity.
 * @param lcidt LC: Theta moment vs rotation.
 * @param dlcidt LC: Theta damping moment vs rotation vel.
 * @param esr Elastic stiffness for R stop and friction.
 * @param ffr LC: Lim R force, or yield force vs R translation.
 * @param esz Elastic stiffness for Z stop and friction.
 * @param ffz LC: Lim Z force, or yield force vs Z translation.
 * @param rad1 Radius of pin.
 * @param rad2 Radius of hole.
 * @param psdr Limiting R translation.
 * @param nsdz Limiting -ve Z translation.
 * @param psdz Limiting +ve Z translation.
 */
    constructor(Model: Model, option: number, label: number, pida: number, pidb: number, cida: number, cidb: number, jid: number, lcidr: number, lcidz: number, dlcidr: number, dlcidp: number, dlcidz: number, lcidt: number, dlcidt: number, esr: number, ffr: number, esz: number, ffz: number, rad1: number, rad2: number, psdr: number, nsdz: number, psdz: number);

/**
 * Creates a string containing the jstf data in keyword format. Note that this contains the keyword header and the keyword cards. See also JointStiffness.Keyword() and JointStiffness.KeywordCards().
 */
    toString(): string;

/** Coordinate System ID #A. */
    cida: number;
/** Coordinate System ID #B. */
    cidb: number;
/** LC: Alpha damping moment vs Rotl vel. */
    dlcidal: number;
/** LC: Beta damping moment vs Rotl vel. */
    dlcidbt: number;
/** LC: Gamma damping factor vs factor on Alpha damping moment. */
    dlcidg: number;
/** LC: P damping vs P rel velocity. */
    dlcidp: number;
/** LC: Phi damping moment vs rotation vel. */
    dlcidph: number;
/** LC: Psi damping moment vs rotation vel. */
    dlcidps: number;
/** LC: R damping vs R rel velocity. */
    dlcidr: number;
/** LC: Theta damping moment vs rotation vel. */
    dlcidt: number;
/** LC: X damping vs X rel velocity. */
    dlcidx: number;
/** LC: Y damping vs Y rel velocity. */
    dlcidy: number;
/** LC: Z damping vs Z rel velocity. */
    dlcidz: number;
/** Stiffness/angle in Alpha direction. */
    esal: number;
/** Stiffness/angle in Beta direction. */
    esbt: number;
/** Stiffness/angle in Phi direction. */
    esph: number;
/** Stiffness/angle in Psi direction. */
    esps: number;
/** Elastic stiffness for R stop and friction. */
    esr: number;
/** Stiffness/angle in Theta direction. */
    est: number;
/** Elastic stiffness for X stop and friction. */
    esx: number;
/** Elastic stiffness for Y stop and friction. */
    esy: number;
/** Elastic stiffness for Z stop and friction. */
    esz: number;
/** true if jstf exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** LC: Lim R force, or yield force vs R translation. */
    ffr: number;
/** LC: Lim X force, or yield force vs X translation. */
    ffx: number;
/** LC: Lim Y force, or yield force vs Y translation. */
    ffy: number;
/** LC: Lim Z force, or yield force vs Z translation. */
    ffz: number;
/** LC: Alpha Frictional moment vs rotation. */
    fmal: number;
/** LC: Beta Frictional moment vs rotation. */
    fmbt: number;
/** LC: Psi frictional moment vs rotation. */
    fmph: number;
/** LC: Psi frictional moment vs rotation. */
    fmps: number;
/** LC: Theta frictional moment vs rotation. */
    fmt: number;
/** The Include file number that the jstf is in. */
    include: number;
/** Joint for restraint/table uses. */
    jid: number;
/** JointStiffness ID of the JSTF. Also see the label property which is an alternative name for this. */
    label: number;
/** LC: Alpha moment vs Rotation. */
    lcidal: number;
/** LC: Beta moment vs Rotation. */
    lcidbt: number;
/** LC: Gamma angle vs factor on Alpha blending. */
    lcidg: number;
/** LC: Phi moment vs rotation. */
    lcidph: number;
/** LC: Psi moment vs rotation. */
    lcidps: number;
/** LC: R force vs R rel displ. */
    lcidr: number;
/** LC: Theta moment vs rotation. */
    lcidt: number;
/** LC: X force vs X rel displ. */
    lcidx: number;
/** LC: Y force vs Y rel displ. */
    lcidy: number;
/** LC: Z force vs Z rel displ. */
    lcidz: number;
/** The Model number that the joint stiffness is in. */
    model: number;
/** Stop angle for -ve Beta rotation. */
    nsabt: number;
/** Stop angle for -ve Phi rotation. */
    nsaph: number;
/** Stop angle for -ve Psi rotation. */
    nsaps: number;
/** Stop angle for -ve Theta rotation. */
    nsat: number;
/** Limiting -ve X translation. */
    nsdx: number;
/** Limiting -ve Y translation. */
    nsdy: number;
/** Limiting -ve Z translation. */
    nsdz: number;
/** JointStiffness type. Can be JointStiffness.GENERALIZED, JointStiffness.FLEXION_TORSION, JointStiffness.TRANSLATIONAL or JointStiffness.CYLINDRICAL. */
    option: number;
/** Part ID #A. */
    pida: number;
/** Part ID #B. */
    pidb: number;
/** Stop angle for +ve Beta rotation. */
    psabt: number;
/** Stop angle for +ve Phi rotation. */
    psaph: number;
/** Stop angle for +ve Psi rotation. */
    psaps: number;
/** Stop angle for +ve Theta rotation. */
    psat: number;
/** Limiting R translation. */
    psdr: number;
/** Limiting +ve X translation. */
    psdx: number;
/** Limiting +ve Y translation. */
    psdy: number;
/** Limiting +ve Z translation. */
    psdz: number;
/** Radius of pin. */
    rad1: number;
/** Radius of hole. */
    rad2: number;
/** Stop angle for Alpha rotation. */
    saal: number;
/** JointStiffness is *CONSTRAINED_JOINT_STIFFNESS_CYLINDRICAL. */
    static CYLINDRICAL: number;
/** JointStiffness is *CONSTRAINED_JOINT_STIFFNESS_FLEXION-TORSION. */
    static FLEXION_TORSION: number;
/** JointStiffness is *CONSTRAINED_JOINT_STIFFNESS_GENERALIZED. */
    static GENERALIZED: number;
/** JointStiffness is *CONSTRAINED_JOINT_STIFFNESS_TRANSLATIONAL. */
    static TRANSLATIONAL: number;
}

declare class LoadBeam {
/**
 * Blanks the load beam
 */
    Blank(): void;

/**
 * Blanks all of the load beams in the model.
 * @param Model Model that all load beams will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged load beams in the model.
 * @param Model Model that all the flagged load beams will be blanked in
 * @param flag Flag set on the load beams that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the load beam is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the load beam.
 * @param flag Flag to clear on the load beam
 */
    ClearFlag(flag: number): void;

/**
 * Copies the load beam.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): LoadBeam;

/**
 * Starts an interactive editing panel to create a load beam definition.
 * @param Model Model that the load beam will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): LoadBeam;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for load beam. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first load beam in the model.
 * @param Model Model to get first load beam in
 */
    static First(Model: Model): LoadBeam;

/**
 * Flags all of the load beams in the model with a defined flag.
 * @param Model Model that all load beams will be flagged in
 * @param flag Flag to set on the load beams
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the load beam is flagged or not.
 * @param flag Flag to test on the load beam
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each load beam in the model. Note that ForEach has been designed to make looping over load beams as fast as possible and so has some limitations. Firstly, a single temporary LoadBeam object is created and on each function call it is updated with the current load beam data. This means that you should not try to store the LoadBeam object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load beams inside a ForEach loop. 
 * @param Model Model that all load beams are in
 * @param func Function to call for each load beam
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of LoadBeam objects for all of the load beams in a model in Primer
 * @param Model Model to get load beams from
 */
    static GetAll(Model: Model): LoadBeam[];

/**
 * Returns an array of LoadBeam objects for all of the flagged load beams in a model in Primer
 * @param Model Model to get load beams from
 * @param flag Flag set on the load beams that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): LoadBeam[];

/**
 * Returns the LoadBeam object for a load beam ID.
 * @param Model Model to find the load beam in
 * @param number number of the load beam you want the LoadBeam object for
 */
    static GetFromID(Model: Model, number: number): LoadBeam;

/**
 * Checks if a LoadBeam property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadBeam.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop load beam property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this load beam (*LOAD_BEAM_xxxx). Note that a carriage return is not added. See also LoadBeam.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the load beam. Note that a carriage return is not added. See also LoadBeam.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last load beam in the model.
 * @param Model Model to get last load beam in
 */
    static Last(Model: Model): LoadBeam;

/**
 * Returns the next load beam in the model.
 */
    Next(): LoadBeam;

/**
 * Allows the user to pick a load beam.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load beams from that model can be picked. If the argument is a Flag then only load beams that are flagged with limit can be selected. If omitted, or null, any load beams from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): LoadBeam;

/**
 * Returns the previous load beam in the model.
 */
    Previous(): LoadBeam;

/**
 * Allows the user to select load beams using standard PRIMER object menus.
 * @param flag Flag to use when selecting load beams
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load beams from that model can be selected. If the argument is a Flag then only load beams that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load beams can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the load beam.
 * @param flag Flag to set on the load beam
 */
    SetFlag(flag: number): void;

/**
 * Sketches the load beam. The load beam will be sketched until you either call LoadBeam.Unsketch(), LoadBeam.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the load beam is sketched. If omitted redraw is true. If you want to sketch several load beams and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged load beams in the model. The load beams will be sketched until you either call LoadBeam.Unsketch(), LoadBeam.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged load beams will be sketched in
 * @param flag Flag set on the load beams that you want to sketch
 * @param redraw If model should be redrawn or not after the load beams are sketched. If omitted redraw is true. If you want to sketch flagged load beams several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of load beams in the model.
 * @param Model Model to get total for
 * @param exists true if only existing load beams should be counted. If false or omitted referenced but undefined load beams will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the load beam
 */
    Unblank(): void;

/**
 * Unblanks all of the load beams in the model.
 * @param Model Model that all load beams will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged load beams in the model.
 * @param Model Model that the flagged load beams will be unblanked in
 * @param flag Flag set on the load beams that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the load beams in the model.
 * @param Model Model that the defined flag for all load beams will be unset in
 * @param flag Flag to unset on the load beams
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the load beam.
 * @param redraw If model should be redrawn or not after the load beam is unsketched. If omitted redraw is true. If you want to unsketch several load beams and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all load beams.
 * @param Model Model that all load beams will be unblanked in
 * @param redraw If model should be redrawn or not after the load beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged load beams in the model.
 * @param Model Model that all load beams will be unsketched in
 * @param flag Flag set on the load beams that you want to unsketch
 * @param redraw If model should be redrawn or not after the load beams are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): LoadBeam;

/**
 * Adds a warning for load beam. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this load beam.
 */
    Xrefs(): Xrefs;

/**
 * Create a new LoadBeam object.
 * @param Model Model that load beam will be created in
 * @param type Specify the type of load beam (Can be LoadBeam.ELEMENT or LoadBeam.SET)
 * @param eid_esid Beam ID or beam set ID
 * @param dal Direction of applied load. 1 for r-axis, 2 for s-axis or 3 for t-axis of beam.
 * @param lcid Curve ID
 * @param sf Load curve scale factor
 */
    constructor(Model: Model, type: number, eid_esid: number, dal: number, lcid: number, sf?: number);

/**
 * Creates a string containing the load beam data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadBeam.Keyword() and LoadBeam.KeywordCards().
 */
    toString(): string;

/** Direction of applied load. 1 for r-axis, 2 for s-axis or 3 for t-axis of beam. */
    dal: number;
/** NodeBeam ID or beam set ID. The esid property is an alternative name for this. */
    eid: number;
/** NodeBeam ID or beam set ID. The eid property is an alternative name for this. */
    esid: number;
/** true if load beam exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the load beam is in. */
    include: number;
/** Curve ID or function ID */
    lcid: number;
/** The Model number that the load beam is in. */
    model: number;
/** Load curve scale factor */
    sf: number;
/** The Load Beam type. Can be LoadBeam.ELEMENT or LoadBeam.SET. */
    type: number;
/** Load is *LOAD_BEAM_ELEMENT. */
    static ELEMENT: number;
/** LOAD is *LOAD_BEAM_SET. */
    static SET: number;
}

declare class LoadBody {
/** Coordinate system ID (not _PARTS) */
    cid: number;
/** true if LoadBody card exists */
    exists: boolean;
/** The Include file number that the LoadBody card is in. */
    include: number;
/** Load curve ID (not _PARTS) */
    lcid: number;
/** Load curve ID for dynamic relaxation (not _PARTS) */
    lciddr: number;
/** *LOAD_BODY_PARTS card */
    parts: object;
/** Part set id (_PARTS only) */
    psid: number;
/** *LOAD_BODY_RX card */
    rx: object;
/** *LOAD_BODY_RY card */
    ry: object;
/** *LOAD_BODY_RZ card */
    rz: object;
/** Load curve scale factor (not _PARTS) */
    sf: number;
/** X-component of Vector */
    v1: number;
/** Y-component of Vector */
    v2: number;
/** Z-component of Vector */
    v3: number;
/** *LOAD_BODY_VECTOR card */
    vector: object;
/** *LOAD_BODY_X card */
    x: object;
/** X centre of rotation (_RX, _RY and _RZ) */
    xc: number;
/** *LOAD_BODY_Y card */
    y: object;
/** Y centre of rotation (_RX, _RY and _RZ) */
    yc: number;
/** *LOAD_BODY_Z card */
    z: object;
/** Z centre of rotation (_RX, _RY and _RZ) */
    zc: number;
}

declare class LoadBodyGeneralized {
/**
 * Blanks the load body generalized
 */
    Blank(): void;

/**
 * Blanks all of the load body generalizeds in the model.
 * @param Model Model that all load body generalizeds will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged load body generalizeds in the model.
 * @param Model Model that all the flagged load body generalizeds will be blanked in
 * @param flag Flag set on the load body generalizeds that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the load body generalized is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the load body generalized.
 * @param flag Flag to clear on the load body generalized
 */
    ClearFlag(flag: number): void;

/**
 * Copies the load body generalized.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): LoadBodyGeneralized;

/**
 * Adds an error for load body generalized. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first load body generalized in the model.
 * @param Model Model to get first load body generalized in
 */
    static First(Model: Model): LoadBodyGeneralized;

/**
 * Flags all of the load body generalizeds in the model with a defined flag.
 * @param Model Model that all load body generalizeds will be flagged in
 * @param flag Flag to set on the load body generalizeds
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the load body generalized is flagged or not.
 * @param flag Flag to test on the load body generalized
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each load body generalized in the model. Note that ForEach has been designed to make looping over load body generalizeds as fast as possible and so has some limitations. Firstly, a single temporary LoadBodyGeneralized object is created and on each function call it is updated with the current load body generalized data. This means that you should not try to store the LoadBodyGeneralized object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load body generalizeds inside a ForEach loop. 
 * @param Model Model that all load body generalizeds are in
 * @param func Function to call for each load body generalized
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of LoadBodyGeneralized objects for all of the load body generalizeds in a model in Primer
 * @param Model Model to get load body generalizeds from
 */
    static GetAll(Model: Model): LoadBodyGeneralized[];

/**
 * Returns an array of LoadBodyGeneralized objects for all of the flagged load body generalizeds in a model in Primer
 * @param Model Model to get load body generalizeds from
 * @param flag Flag set on the load body generalizeds that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): LoadBodyGeneralized[];

/**
 * Returns the LoadBodyGeneralized object for a load body generalized ID.
 * @param Model Model to find the load body generalized in
 * @param number number of the load body generalized you want the LoadBodyGeneralized object for
 */
    static GetFromID(Model: Model, number: number): LoadBodyGeneralized;

/**
 * Checks if a LoadBodyGeneralized property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadBodyGeneralized.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop load body generalized property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this load body generalized (*LOAD_NODE_xxxx). Note that a carriage return is not added. See also LoadBodyGeneralized.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the load body generalized. Note that a carriage return is not added. See also LoadBodyGeneralized.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last load body generalized in the model.
 * @param Model Model to get last load body generalized in
 */
    static Last(Model: Model): LoadBodyGeneralized;

/**
 * Returns the next load body generalized in the model.
 */
    Next(): LoadBodyGeneralized;

/**
 * Allows the user to pick a load body generalized.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load body generalizeds from that model can be picked. If the argument is a Flag then only load body generalizeds that are flagged with limit can be selected. If omitted, or null, any load body generalizeds from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): LoadBodyGeneralized;

/**
 * Returns the previous load body generalized in the model.
 */
    Previous(): LoadBodyGeneralized;

/**
 * Allows the user to select load body generalizeds using standard PRIMER object menus.
 * @param flag Flag to use when selecting load body generalizeds
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load body generalizeds from that model can be selected. If the argument is a Flag then only load body generalizeds that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load body generalizeds can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the load body generalized.
 * @param flag Flag to set on the load body generalized
 */
    SetFlag(flag: number): void;

/**
 * Sketches the load body generalized. The load body generalized will be sketched until you either call LoadBodyGeneralized.Unsketch(), LoadBodyGeneralized.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the load body generalized is sketched. If omitted redraw is true. If you want to sketch several load body generalizeds and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged load body generalizeds in the model. The load body generalizeds will be sketched until you either call LoadBodyGeneralized.Unsketch(), LoadBodyGeneralized.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged load body generalizeds will be sketched in
 * @param flag Flag set on the load body generalizeds that you want to sketch
 * @param redraw If model should be redrawn or not after the load body generalizeds are sketched. If omitted redraw is true. If you want to sketch flagged load body generalizeds several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of load body generalizeds in the model.
 * @param Model Model to get total for
 * @param exists true if only existing load body generalizeds should be counted. If false or omitted referenced but undefined load body generalizeds will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the load body generalized
 */
    Unblank(): void;

/**
 * Unblanks all of the load body generalizeds in the model.
 * @param Model Model that all load body generalizeds will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged load body generalizeds in the model.
 * @param Model Model that the flagged load body generalizeds will be unblanked in
 * @param flag Flag set on the load body generalizeds that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the load body generalizeds in the model.
 * @param Model Model that the defined flag for all load body generalizeds will be unset in
 * @param flag Flag to unset on the load body generalizeds
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the load body generalized.
 * @param redraw If model should be redrawn or not after the load body generalized is unsketched. If omitted redraw is true. If you want to unsketch several load body generalizeds and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all load body generalizeds.
 * @param Model Model that all load body generalizeds will be unblanked in
 * @param redraw If model should be redrawn or not after the load body generalizeds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged load body generalizeds in the model.
 * @param Model Model that all load body generalizeds will be unsketched in
 * @param flag Flag set on the load body generalizeds that you want to unsketch
 * @param redraw If model should be redrawn or not after the load body generalizeds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): LoadBodyGeneralized;

/**
 * Adds a warning for load body generalized. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this load body generalized.
 */
    Xrefs(): Xrefs;

/**
 * Create a new LoadBodyGeneralized object.
 * @param Model Model that load body generalized will be created in
 * @param type Specify the type of load body generalized (Can be LoadBodyGeneralized.NODE or LoadBodyGeneralized.SET_NODE or LoadBodyGeneralized.SET_PART)
 * @param n1 Beginning Node ID for body force load or the node or Part set ID
 * @param n2 Ending Node ID for body force load. Set to zero if a set ID is defined
 * @param lcid Curve ID
 * @param drlcid Curve ID for dynamic relaxation phase
 * @param xc X-center of rotation
 * @param yc Y-center of rotation
 * @param zc Z-center of rotation
 * @param ax Scale factor for acceleration in x-direction
 * @param ay Scale factor for acceleration in y-direction
 * @param az Scale factor for acceleration in z-direction
 * @param omx Scale factor for x-angular velocity or acceleration
 * @param omy Scale factor for y-angular velocity or acceleration
 * @param omz Scale factor for z-angular velocity or acceleration
 * @param cid Coordinate system ID to define acceleration
 * @param angtyp Type of body loads
 */
    constructor(Model: Model, type: number, n1: number, n2: number, lcid: number, drlcid?: number, xc?: number, yc?: number, zc?: number, ax?: number, ay?: number, az?: number, omx?: number, omy?: number, omz?: number, cid?: number, angtyp?: string);

/**
 * Creates a string containing the load body generalized data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadBodyGeneralized.Keyword() and LoadBodyGeneralized.KeywordCards().
 */
    toString(): string;

/** Type of body loads */
    angtyp: string;
/** Scale factor for acceleration in x-direction */
    ax: number;
/** Scale factor for acceleration in y-direction */
    ay: number;
/** Scale factor for acceleration in z-direction */
    az: number;
/** Coordinate system ID to define acceleration */
    cid: number;
/** Curve ID for dynamic relaxation phase */
    drlcid: number;
/** true if load body generalized exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the load body generalized is in. */
    include: number;
/** Curve ID */
    lcid: number;
/** The Model number that the load body generalized is in. */
    model: number;
/** Beginning Node ID for body force load or the node or Part set ID */
    n1: number;
/** Ending Node ID for body force load. Set to zero if a set ID is defined */
    n2: number;
/** Scale factor for x-angular velocity or acceleration */
    omx: number;
/** Scale factor for y-angular velocity or acceleration */
    omy: number;
/** Scale factor for z-angular velocity or acceleration */
    omz: number;
/** The Load Node type, can be LoadBodyGeneralized.NODE or LoadBodyGeneralized.SET_NODE or LoadBodyGeneralized.SET_PART. */
    type: number;
/** X-center of rotation */
    xc: number;
/** Y-center of rotation */
    yc: number;
/** Z-center of rotation */
    zc: number;
/** Load is *LOAD_BODY_GENERALIZED. */
    static NODE: number;
/** Load is *LOAD_BODY_GENERALIZED_SET_NODE. */
    static SET_NODE: number;
/** LOAD is *LOAD_BODY_GENERALIZED_SET_PART. */
    static SET_PART: number;
}

declare class LoadGravity {
/**
 * Blanks the load gravity
 */
    Blank(): void;

/**
 * Blanks all of the load gravitys in the model.
 * @param Model Model that all load gravitys will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged load gravitys in the model.
 * @param Model Model that all the flagged load gravitys will be blanked in
 * @param flag Flag set on the load gravitys that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the load gravity is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the load gravity.
 * @param flag Flag to clear on the load gravity
 */
    ClearFlag(flag: number): void;

/**
 * Copies the load gravity.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): LoadGravity;

/**
 * Adds an error for load gravity. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first load gravity in the model.
 * @param Model Model to get first load gravity in
 */
    static First(Model: Model): LoadGravity;

/**
 * Flags all of the load gravitys in the model with a defined flag.
 * @param Model Model that all load gravitys will be flagged in
 * @param flag Flag to set on the load gravitys
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the load gravity is flagged or not.
 * @param flag Flag to test on the load gravity
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each load gravity in the model. Note that ForEach has been designed to make looping over load gravitys as fast as possible and so has some limitations. Firstly, a single temporary LoadGravity object is created and on each function call it is updated with the current load gravity data. This means that you should not try to store the LoadGravity object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load gravitys inside a ForEach loop. 
 * @param Model Model that all load gravitys are in
 * @param func Function to call for each load gravity
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of LoadGravity objects for all of the load gravitys in a model in Primer
 * @param Model Model to get load gravitys from
 */
    static GetAll(Model: Model): LoadGravity[];

/**
 * Returns an array of LoadGravity objects for all of the flagged load gravitys in a model in Primer
 * @param Model Model to get load gravitys from
 * @param flag Flag set on the load gravitys that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): LoadGravity[];

/**
 * Returns the LoadGravity object for a load gravity ID.
 * @param Model Model to find the load gravity in
 * @param number number of the load gravity you want the LoadGravity object for
 */
    static GetFromID(Model: Model, number: number): LoadGravity;

/**
 * Checks if a LoadGravity property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadGravity.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop load gravity property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this LoadGravity (*LOAD_GRAVITY_PART). Note that a carriage return is not added. See also LoadGravity.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the LoadGravity. Note that a carriage return is not added. See also LoadGravity.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last load gravity in the model.
 * @param Model Model to get last load gravity in
 */
    static Last(Model: Model): LoadGravity;

/**
 * Returns the next load gravity in the model.
 */
    Next(): LoadGravity;

/**
 * Allows the user to pick a load gravity.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load gravitys from that model can be picked. If the argument is a Flag then only load gravitys that are flagged with limit can be selected. If omitted, or null, any load gravitys from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): LoadGravity;

/**
 * Returns the previous load gravity in the model.
 */
    Previous(): LoadGravity;

/**
 * Allows the user to select load gravitys using standard PRIMER object menus.
 * @param flag Flag to use when selecting load gravitys
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load gravitys from that model can be selected. If the argument is a Flag then only load gravitys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load gravitys can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the load gravity.
 * @param flag Flag to set on the load gravity
 */
    SetFlag(flag: number): void;

/**
 * Sketches the load gravity. The load gravity will be sketched until you either call LoadGravity.Unsketch(), LoadGravity.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the load gravity is sketched. If omitted redraw is true. If you want to sketch several load gravitys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged load gravitys in the model. The load gravitys will be sketched until you either call LoadGravity.Unsketch(), LoadGravity.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged load gravitys will be sketched in
 * @param flag Flag set on the load gravitys that you want to sketch
 * @param redraw If model should be redrawn or not after the load gravitys are sketched. If omitted redraw is true. If you want to sketch flagged load gravitys several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of load gravitys in the model.
 * @param Model Model to get total for
 * @param exists true if only existing load gravitys should be counted. If false or omitted referenced but undefined load gravitys will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the load gravity
 */
    Unblank(): void;

/**
 * Unblanks all of the load gravitys in the model.
 * @param Model Model that all load gravitys will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged load gravitys in the model.
 * @param Model Model that the flagged load gravitys will be unblanked in
 * @param flag Flag set on the load gravitys that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the load gravitys in the model.
 * @param Model Model that the defined flag for all load gravitys will be unset in
 * @param flag Flag to unset on the load gravitys
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the load gravity.
 * @param redraw If model should be redrawn or not after the load gravity is unsketched. If omitted redraw is true. If you want to unsketch several load gravitys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all load gravitys.
 * @param Model Model that all load gravitys will be unblanked in
 * @param redraw If model should be redrawn or not after the load gravitys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged load gravitys in the model.
 * @param Model Model that all load gravitys will be unsketched in
 * @param flag Flag set on the load gravitys that you want to unsketch
 * @param redraw If model should be redrawn or not after the load gravitys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): LoadGravity;

/**
 * Adds a warning for load gravity. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this load gravity.
 */
    Xrefs(): Xrefs;

/**
 * Create a new LoadGravity object.
 * @param Model Model that LoadGravity will be created in
 * @param type Specify the type of LoadGravity (Can be LoadGravity.PART or LoadGravity.SET_PART
 * @param pid Part ID or Part set ID
 * @param dof Direction: enter 1, 2 or 3 for x, y or z
 * @param lc Curve ID. Load curve defining factor vs. time (or zero if STGA, STGR are defined)
 * @param accel Acceleration (will be multiplied by factor from curve)
 * @param lcdr Curve ID. Load curve defining factor vs. time during dynamic relaxation
 * @param stga Construction Stage ID at which part is added (optional)
 * @param stgr Construction Stage ID at which part is removed (optional)
 */
    constructor(Model: Model, type: number, pid: number, dof: number, lc: number, accel: number, lcdr: number, stga?: number, stgr?: number);

/**
 * Creates a string containing the LoadGravity data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadGravity.Keyword() and LoadGravity.KeywordCards().
 */
    toString(): string;

/** Acceleration (will be multiplied by factor from curve) */
    accel: number;
/** Direction: enter 1, 2 or 3 for x, y, or z */
    dof: number;
/** true if LoadGravity exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the LoadGravity is in. */
    include: number;
/** Curve ID. Load curve defining factor vs. time (or zero if STGA, STGR are defined) */
    lc: number;
/** Curve ID. Load curve defining factor vs. time during dynamic relaxation */
    lcdr: number;
/** The Model number that the load gravity is in. */
    model: number;
/** Part ID or Part set ID */
    pid: number;
/** Construction Stages ID at which part is added (optional) */
    stga: number;
/** Construction Stages ID at which part is removed (optional) */
    stgr: number;
/** The Load Gravity type. Can be LoadGravity.PART or LoadGravity.SET_PART. */
    type: number;
/** LOAD is *LOAD_GRAVITY_PART. */
    static PART: number;
/** LOAD is *LOAD_GRAVITY_PART_SET. */
    static SET_PART: number;
}

declare class LoadNode {
/**
 * Blanks the load node
 */
    Blank(): void;

/**
 * Blanks all of the load nodes in the model.
 * @param Model Model that all load nodes will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged load nodes in the model.
 * @param Model Model that all the flagged load nodes will be blanked in
 * @param flag Flag set on the load nodes that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the load node is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the load node.
 * @param flag Flag to clear on the load node
 */
    ClearFlag(flag: number): void;

/**
 * Copies the load node.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): LoadNode;

/**
 * Adds an error for load node. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first load node in the model.
 * @param Model Model to get first load node in
 */
    static First(Model: Model): LoadNode;

/**
 * Flags all of the load nodes in the model with a defined flag.
 * @param Model Model that all load nodes will be flagged in
 * @param flag Flag to set on the load nodes
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the load node is flagged or not.
 * @param flag Flag to test on the load node
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each load node in the model. Note that ForEach has been designed to make looping over load nodes as fast as possible and so has some limitations. Firstly, a single temporary LoadNode object is created and on each function call it is updated with the current load node data. This means that you should not try to store the LoadNode object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load nodes inside a ForEach loop. 
 * @param Model Model that all load nodes are in
 * @param func Function to call for each load node
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of LoadNode objects for all of the load nodes in a model in Primer
 * @param Model Model to get load nodes from
 */
    static GetAll(Model: Model): LoadNode[];

/**
 * Returns an array of LoadNode objects for all of the flagged load nodes in a model in Primer
 * @param Model Model to get load nodes from
 * @param flag Flag set on the load nodes that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): LoadNode[];

/**
 * Returns the LoadNode object for a load node ID.
 * @param Model Model to find the load node in
 * @param number number of the load node you want the LoadNode object for
 */
    static GetFromID(Model: Model, number: number): LoadNode;

/**
 * Checks if a LoadNode property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadNode.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop load node property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this load node (*LOAD_NODE_xxxx). Note that a carriage return is not added. See also LoadNode.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the load node. Note that a carriage return is not added. See also LoadNode.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last load node in the model.
 * @param Model Model to get last load node in
 */
    static Last(Model: Model): LoadNode;

/**
 * Returns the next load node in the model.
 */
    Next(): LoadNode;

/**
 * Allows the user to pick a load node.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load nodes from that model can be picked. If the argument is a Flag then only load nodes that are flagged with limit can be selected. If omitted, or null, any load nodes from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): LoadNode;

/**
 * Returns the previous load node in the model.
 */
    Previous(): LoadNode;

/**
 * Allows the user to select load nodes using standard PRIMER object menus.
 * @param flag Flag to use when selecting load nodes
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load nodes from that model can be selected. If the argument is a Flag then only load nodes that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load nodes can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the load node.
 * @param flag Flag to set on the load node
 */
    SetFlag(flag: number): void;

/**
 * Sketches the load node. The load node will be sketched until you either call LoadNode.Unsketch(), LoadNode.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the load node is sketched. If omitted redraw is true. If you want to sketch several load nodes and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged load nodes in the model. The load nodes will be sketched until you either call LoadNode.Unsketch(), LoadNode.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged load nodes will be sketched in
 * @param flag Flag set on the load nodes that you want to sketch
 * @param redraw If model should be redrawn or not after the load nodes are sketched. If omitted redraw is true. If you want to sketch flagged load nodes several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of load nodes in the model.
 * @param Model Model to get total for
 * @param exists true if only existing load nodes should be counted. If false or omitted referenced but undefined load nodes will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the load node
 */
    Unblank(): void;

/**
 * Unblanks all of the load nodes in the model.
 * @param Model Model that all load nodes will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged load nodes in the model.
 * @param Model Model that the flagged load nodes will be unblanked in
 * @param flag Flag set on the load nodes that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the load nodes in the model.
 * @param Model Model that the defined flag for all load nodes will be unset in
 * @param flag Flag to unset on the load nodes
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the load node.
 * @param redraw If model should be redrawn or not after the load node is unsketched. If omitted redraw is true. If you want to unsketch several load nodes and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all load nodes.
 * @param Model Model that all load nodes will be unblanked in
 * @param redraw If model should be redrawn or not after the load nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged load nodes in the model.
 * @param Model Model that all load nodes will be unsketched in
 * @param flag Flag set on the load nodes that you want to unsketch
 * @param redraw If model should be redrawn or not after the load nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): LoadNode;

/**
 * Adds a warning for load node. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this load node.
 */
    Xrefs(): Xrefs;

/**
 * Create a new LoadNode object.
 * @param Model Model that load node will be created in
 * @param type Specify the type of load node (Can be LoadNode.POINT or LoadNode.SET)
 * @param nid Node ID or node set ID
 * @param dof Applicable degrees-of-freedom
 * @param lcid Curve ID
 * @param sf Curve scale factor
 * @param cid Coordinate system ID
 * @param m1 Node 1 ID
 * @param m2 Node 2 ID
 * @param m3 Node 3 ID
 */
    constructor(Model: Model, type: number, nid: number, dof: number, lcid: number, sf?: number, cid?: number, m1?: number, m2?: number, m3?: number);

/**
 * Creates a string containing the load node data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadNode.Keyword() and LoadNode.KeywordCards().
 */
    toString(): string;

/** Coordinate system ID */
    cid: number;
/** Applicable degrees-of-freedom */
    dof: number;
/** true if load node exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the load node is in. */
    include: number;
/** Curve ID */
    lcid: number;
/** Node 1 ID */
    m1: number;
/** Node 2 ID */
    m2: number;
/** Node 3 ID */
    m3: number;
/** The Model number that the load node is in. */
    model: number;
/** Node ID or node set ID */
    nid: number;
/** Curve scale factor */
    sf: number;
/** The Load Node type. Can be LoadNode.POINT or LoadNode.SET. */
    type: number;
/** Load is *LOAD_NODE_POINT. */
    static POINT: number;
/** LOAD is *LOAD_NODE_SET. */
    static SET: number;
}

declare class LoadRemovePart {
/**
 * Blanks the load remove_part
 */
    Blank(): void;

/**
 * Blanks all of the load remove_parts in the model.
 * @param Model Model that all load remove_parts will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged load remove_parts in the model.
 * @param Model Model that all the flagged load remove_parts will be blanked in
 * @param flag Flag set on the load remove_parts that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the load remove_part is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the load remove_part.
 * @param flag Flag to clear on the load remove_part
 */
    ClearFlag(flag: number): void;

/**
 * Copies the load remove_part.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): LoadRemovePart;

/**
 * Adds an error for load remove_part. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first load remove_part in the model.
 * @param Model Model to get first load remove_part in
 */
    static First(Model: Model): LoadRemovePart;

/**
 * Flags all of the load remove_parts in the model with a defined flag.
 * @param Model Model that all load remove_parts will be flagged in
 * @param flag Flag to set on the load remove_parts
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the load remove_part is flagged or not.
 * @param flag Flag to test on the load remove_part
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each load remove_part in the model. Note that ForEach has been designed to make looping over load remove_parts as fast as possible and so has some limitations. Firstly, a single temporary LoadRemovePart object is created and on each function call it is updated with the current load remove_part data. This means that you should not try to store the LoadRemovePart object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load remove_parts inside a ForEach loop. 
 * @param Model Model that all load remove_parts are in
 * @param func Function to call for each load remove_part
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of LoadRemovePart objects for all of the load remove_parts in a model in Primer
 * @param Model Model to get load remove_parts from
 */
    static GetAll(Model: Model): LoadRemovePart[];

/**
 * Returns an array of LoadRemovePart objects for all of the flagged load remove_parts in a model in Primer
 * @param Model Model to get load remove_parts from
 * @param flag Flag set on the load remove_parts that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): LoadRemovePart[];

/**
 * Returns the LoadRemovePart object for a load remove_part ID.
 * @param Model Model to find the load remove_part in
 * @param number number of the load remove_part you want the LoadRemovePart object for
 */
    static GetFromID(Model: Model, number: number): LoadRemovePart;

/**
 * Checks if a LoadRemovePart property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadRemovePart.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop load remove_part property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this LoadRemovePart (*LOAD_REMOVE_PART). Note that a carriage return is not added. See also LoadRemovePart.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the LoadRemovePart. Note that a carriage return is not added. See also LoadRemovePart.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last load remove_part in the model.
 * @param Model Model to get last load remove_part in
 */
    static Last(Model: Model): LoadRemovePart;

/**
 * Returns the next load remove_part in the model.
 */
    Next(): LoadRemovePart;

/**
 * Allows the user to pick a load remove_part.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load remove_parts from that model can be picked. If the argument is a Flag then only load remove_parts that are flagged with limit can be selected. If omitted, or null, any load remove_parts from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): LoadRemovePart;

/**
 * Returns the previous load remove_part in the model.
 */
    Previous(): LoadRemovePart;

/**
 * Allows the user to select load remove_parts using standard PRIMER object menus.
 * @param flag Flag to use when selecting load remove_parts
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load remove_parts from that model can be selected. If the argument is a Flag then only load remove_parts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load remove_parts can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the load remove_part.
 * @param flag Flag to set on the load remove_part
 */
    SetFlag(flag: number): void;

/**
 * Sketches the load remove_part. The load remove_part will be sketched until you either call LoadRemovePart.Unsketch(), LoadRemovePart.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the load remove_part is sketched. If omitted redraw is true. If you want to sketch several load remove_parts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged load remove_parts in the model. The load remove_parts will be sketched until you either call LoadRemovePart.Unsketch(), LoadRemovePart.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged load remove_parts will be sketched in
 * @param flag Flag set on the load remove_parts that you want to sketch
 * @param redraw If model should be redrawn or not after the load remove_parts are sketched. If omitted redraw is true. If you want to sketch flagged load remove_parts several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of load remove_parts in the model.
 * @param Model Model to get total for
 * @param exists true if only existing load remove_parts should be counted. If false or omitted referenced but undefined load remove_parts will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the load remove_part
 */
    Unblank(): void;

/**
 * Unblanks all of the load remove_parts in the model.
 * @param Model Model that all load remove_parts will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged load remove_parts in the model.
 * @param Model Model that the flagged load remove_parts will be unblanked in
 * @param flag Flag set on the load remove_parts that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the load remove_parts in the model.
 * @param Model Model that the defined flag for all load remove_parts will be unset in
 * @param flag Flag to unset on the load remove_parts
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the load remove_part.
 * @param redraw If model should be redrawn or not after the load remove_part is unsketched. If omitted redraw is true. If you want to unsketch several load remove_parts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all load remove_parts.
 * @param Model Model that all load remove_parts will be unblanked in
 * @param redraw If model should be redrawn or not after the load remove_parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged load remove_parts in the model.
 * @param Model Model that all load remove_parts will be unsketched in
 * @param flag Flag set on the load remove_parts that you want to unsketch
 * @param redraw If model should be redrawn or not after the load remove_parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): LoadRemovePart;

/**
 * Adds a warning for load remove_part. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this load remove_part.
 */
    Xrefs(): Xrefs;

/**
 * Create a new LoadRemovePart object.
 * @param Model Model that LoadRemovePart will be created in
 * @param type Specify the type of LoadRemovePart (Can be LoadRemovePart.PART or LoadRemovePart.SET_PART
 * @param pid Part ID or Part Set ID
 * @param time0 Time at which stress reduction starts.
 * @param time1 Time at which stresses become zero and elements are deleted.
 * @param stgr Construction Stage ID at which part is removed.
 */
    constructor(Model: Model, type: number, pid: number, time0?: number, time1?: number, stgr?: number);

/**
 * Creates a string containing the LoadRemovePart data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadRemovePart.Keyword() and LoadRemovePart.KeywordCards().
 */
    toString(): string;

/** true if LoadRemovePart exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the LoadRemovePart is in. */
    include: number;
/** The Model number that the load remove_part is in. */
    model: number;
/** Part ID or Part Set ID */
    pid: number;
/** Construction Stages ID at which part is removed. */
    stgr: number;
/** Time at which stress reduction starts. */
    time0: number;
/** Time at which stresses become zero and elements are deleted. */
    time1: number;
/** The Load RemovePart type. Can be LoadRemovePart.PART or LoadRemovePart.SET_PART. */
    type: number;
/** LOAD is *LOAD_REMOVE_PART. */
    static PART: number;
/** LOAD is *LOAD_REMOVE_PART_SET. */
    static SET_PART: number;
}

declare class LoadRigidBody {
/**
 * Blanks the load rigidbody
 */
    Blank(): void;

/**
 * Blanks all of the load rigidbodys in the model.
 * @param Model Model that all load rigidbodys will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged load rigidbodys in the model.
 * @param Model Model that all the flagged load rigidbodys will be blanked in
 * @param flag Flag set on the load rigidbodys that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the load rigidbody is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the load rigidbody.
 * @param flag Flag to clear on the load rigidbody
 */
    ClearFlag(flag: number): void;

/**
 * Copies the load rigidbody.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): LoadRigidBody;

/**
 * Adds an error for load rigidbody. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first load rigidbody in the model.
 * @param Model Model to get first load rigidbody in
 */
    static First(Model: Model): LoadRigidBody;

/**
 * Flags all of the load rigidbodys in the model with a defined flag.
 * @param Model Model that all load rigidbodys will be flagged in
 * @param flag Flag to set on the load rigidbodys
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the load rigidbody is flagged or not.
 * @param flag Flag to test on the load rigidbody
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each load rigidbody in the model. Note that ForEach has been designed to make looping over load rigidbodys as fast as possible and so has some limitations. Firstly, a single temporary LoadRigidBody object is created and on each function call it is updated with the current load rigidbody data. This means that you should not try to store the LoadRigidBody object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load rigidbodys inside a ForEach loop. 
 * @param Model Model that all load rigidbodys are in
 * @param func Function to call for each load rigidbody
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of LoadRigidBody objects for all of the load rigidbodys in a model in Primer
 * @param Model Model to get load rigidbodys from
 */
    static GetAll(Model: Model): LoadRigidBody[];

/**
 * Returns an array of LoadRigidBody objects for all of the flagged load rigidbodys in a model in Primer
 * @param Model Model to get load rigidbodys from
 * @param flag Flag set on the load rigidbodys that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): LoadRigidBody[];

/**
 * Returns the LoadRigidBody object for a load rigidbody ID.
 * @param Model Model to find the load rigidbody in
 * @param number number of the load rigidbody you want the LoadRigidBody object for
 */
    static GetFromID(Model: Model, number: number): LoadRigidBody;

/**
 * Checks if a LoadRigidBody property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadRigidBody.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop load rigidbody property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this load rigidbody (*LOAD_RIGIDBODY). Note that a carriage return is not added. See also LoadRigidBody.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the load rigidbody. Note that a carriage return is not added. See also LoadRigidBody.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last load rigidbody in the model.
 * @param Model Model to get last load rigidbody in
 */
    static Last(Model: Model): LoadRigidBody;

/**
 * Returns the next load rigidbody in the model.
 */
    Next(): LoadRigidBody;

/**
 * Allows the user to pick a load rigidbody.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load rigidbodys from that model can be picked. If the argument is a Flag then only load rigidbodys that are flagged with limit can be selected. If omitted, or null, any load rigidbodys from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): LoadRigidBody;

/**
 * Returns the previous load rigidbody in the model.
 */
    Previous(): LoadRigidBody;

/**
 * Allows the user to select load rigidbodys using standard PRIMER object menus.
 * @param flag Flag to use when selecting load rigidbodys
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load rigidbodys from that model can be selected. If the argument is a Flag then only load rigidbodys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load rigidbodys can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the load rigidbody.
 * @param flag Flag to set on the load rigidbody
 */
    SetFlag(flag: number): void;

/**
 * Sketches the load rigidbody. The load rigidbody will be sketched until you either call LoadRigidBody.Unsketch(), LoadRigidBody.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the load rigidbody is sketched. If omitted redraw is true. If you want to sketch several load rigidbodys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged load rigidbodys in the model. The load rigidbodys will be sketched until you either call LoadRigidBody.Unsketch(), LoadRigidBody.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged load rigidbodys will be sketched in
 * @param flag Flag set on the load rigidbodys that you want to sketch
 * @param redraw If model should be redrawn or not after the load rigidbodys are sketched. If omitted redraw is true. If you want to sketch flagged load rigidbodys several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of load rigidbodys in the model.
 * @param Model Model to get total for
 * @param exists true if only existing load rigidbodys should be counted. If false or omitted referenced but undefined load rigidbodys will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the load rigidbody
 */
    Unblank(): void;

/**
 * Unblanks all of the load rigidbodys in the model.
 * @param Model Model that all load rigidbodys will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged load rigidbodys in the model.
 * @param Model Model that the flagged load rigidbodys will be unblanked in
 * @param flag Flag set on the load rigidbodys that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the load rigidbodys in the model.
 * @param Model Model that the defined flag for all load rigidbodys will be unset in
 * @param flag Flag to unset on the load rigidbodys
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the load rigidbody.
 * @param redraw If model should be redrawn or not after the load rigidbody is unsketched. If omitted redraw is true. If you want to unsketch several load rigidbodys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all load rigidbodys.
 * @param Model Model that all load rigidbodys will be unblanked in
 * @param redraw If model should be redrawn or not after the load rigidbodys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged load rigidbodys in the model.
 * @param Model Model that all load rigidbodys will be unsketched in
 * @param flag Flag set on the load rigidbodys that you want to unsketch
 * @param redraw If model should be redrawn or not after the load rigidbodys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): LoadRigidBody;

/**
 * Adds a warning for load rigidbody. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this load rigidbody.
 */
    Xrefs(): Xrefs;

/**
 * Create a new LoadRigidBody object.
 * @param Model Model that load rigidbody will be created in
 * @param pid Part ID
 * @param dof Applicable degrees-of-freedom
 * @param lcid Curve ID
 * @param sf Curve scale factor
 * @param cid Coordinate system ID
 * @param m1 Node 1 ID
 * @param m2 Node 2 ID
 * @param m3 Node 3 ID
 */
    constructor(Model: Model, pid: number, dof: number, lcid: number, sf?: number, cid?: number, m1?: number, m2?: number, m3?: number);

/**
 * Creates a string containing the load rigidbody data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadRigidBody.Keyword() and LoadRigidBody.KeywordCards().
 */
    toString(): string;

/** Coordinate system ID */
    cid: number;
/** Applicable degrees-of-freedom */
    dof: number;
/** true if load rigidbody exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the load rigidbody is in. */
    include: number;
/** Curve ID */
    lcid: number;
/** Node 1 ID */
    m1: number;
/** Node 2 ID */
    m2: number;
/** Node 3 ID */
    m3: number;
/** The Model number that the load rigidbody is in. */
    model: number;
/** Part ID */
    pid: number;
/** Curve scale factor */
    sf: number;
}

declare class LoadShell {
/**
 * Blanks the load shell
 */
    Blank(): void;

/**
 * Blanks all of the load shells in the model.
 * @param Model Model that all load shells will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged load shells in the model.
 * @param Model Model that all the flagged load shells will be blanked in
 * @param flag Flag set on the load shells that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the load shell is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the load shell.
 * @param flag Flag to clear on the load shell
 */
    ClearFlag(flag: number): void;

/**
 * Copies the load shell.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): LoadShell;

/**
 * Adds an error for load shell. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first load shell in the model.
 * @param Model Model to get first load shell in
 */
    static First(Model: Model): LoadShell;

/**
 * Returns the first free load shell label in the model. Also see LoadShell.LastFreeLabel(), LoadShell.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free load shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the load shells in the model with a defined flag.
 * @param Model Model that all load shells will be flagged in
 * @param flag Flag to set on the load shells
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the load shell is flagged or not.
 * @param flag Flag to test on the load shell
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each load shell in the model. Note that ForEach has been designed to make looping over load shells as fast as possible and so has some limitations. Firstly, a single temporary LoadShell object is created and on each function call it is updated with the current load shell data. This means that you should not try to store the LoadShell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new load shells inside a ForEach loop. 
 * @param Model Model that all load shells are in
 * @param func Function to call for each load shell
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of LoadShell objects for all of the load shells in a model in Primer
 * @param Model Model to get load shells from
 */
    static GetAll(Model: Model): LoadShell[];

/**
 * Returns an array of LoadShell objects for all of the flagged load shells in a model in Primer
 * @param Model Model to get load shells from
 * @param flag Flag set on the load shells that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): LoadShell[];

/**
 * Returns the LoadShell object for a load shell ID.
 * @param Model Model to find the load shell in
 * @param number number of the load shell you want the LoadShell object for
 */
    static GetFromID(Model: Model, number: number): LoadShell;

/**
 * Checks if a LoadShell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the LoadShell.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop load shell property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this LoadShell (*LOAD_SHELL_xxxx). Note that a carriage return is not added. See also LoadShell.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the LoadShell. Note that a carriage return is not added. See also LoadShell.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last load shell in the model.
 * @param Model Model to get last load shell in
 */
    static Last(Model: Model): LoadShell;

/**
 * Returns the last free load shell label in the model. Also see LoadShell.FirstFreeLabel(), LoadShell.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free load shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next load shell in the model.
 */
    Next(): LoadShell;

/**
 * Returns the next free (highest+1) load shell label in the model. Also see LoadShell.FirstFreeLabel(), LoadShell.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free load shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a load shell.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load shells from that model can be picked. If the argument is a Flag then only load shells that are flagged with limit can be selected. If omitted, or null, any load shells from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): LoadShell;

/**
 * Returns the previous load shell in the model.
 */
    Previous(): LoadShell;

/**
 * Renumbers all of the load shells in the model.
 * @param Model Model that all load shells will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged load shells in the model.
 * @param Model Model that all the flagged load shells will be renumbered in
 * @param flag Flag set on the load shells that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select load shells using standard PRIMER object menus.
 * @param flag Flag to use when selecting load shells
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only load shells from that model can be selected. If the argument is a Flag then only load shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any load shells can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the load shell.
 * @param flag Flag to set on the load shell
 */
    SetFlag(flag: number): void;

/**
 * Sketches the load shell. The load shell will be sketched until you either call LoadShell.Unsketch(), LoadShell.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the load shell is sketched. If omitted redraw is true. If you want to sketch several load shells and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged load shells in the model. The load shells will be sketched until you either call LoadShell.Unsketch(), LoadShell.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged load shells will be sketched in
 * @param flag Flag set on the load shells that you want to sketch
 * @param redraw If model should be redrawn or not after the load shells are sketched. If omitted redraw is true. If you want to sketch flagged load shells several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of load shells in the model.
 * @param Model Model to get total for
 * @param exists true if only existing load shells should be counted. If false or omitted referenced but undefined load shells will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the load shell
 */
    Unblank(): void;

/**
 * Unblanks all of the load shells in the model.
 * @param Model Model that all load shells will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged load shells in the model.
 * @param Model Model that the flagged load shells will be unblanked in
 * @param flag Flag set on the load shells that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the load shells in the model.
 * @param Model Model that the defined flag for all load shells will be unset in
 * @param flag Flag to unset on the load shells
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the load shell.
 * @param redraw If model should be redrawn or not after the load shell is unsketched. If omitted redraw is true. If you want to unsketch several load shells and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all load shells.
 * @param Model Model that all load shells will be unblanked in
 * @param redraw If model should be redrawn or not after the load shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged load shells in the model.
 * @param Model Model that all load shells will be unsketched in
 * @param flag Flag set on the load shells that you want to unsketch
 * @param redraw If model should be redrawn or not after the load shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): LoadShell;

/**
 * Adds a warning for load shell. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this load shell.
 */
    Xrefs(): Xrefs;

/**
 * Create a new LoadShell object.
 * @param Model Model that LoadShell will be created in
 * @param type Specify the type of LoadShell (Can be LoadShell.ELEMENT or LoadShell.SET)
 * @param eid Shell ID or shell set ID
 * @param lcid Curve ID
 * @param sf Curve scale factor
 * @param at Arrival time for pressure
 * @param lsid LoadShell number
 * @param heading Title for the LoadShell
 */
    constructor(Model: Model, type: number, eid: number, lcid: number, sf?: number, at?: number, lsid?: number, heading?: string);

/**
 * Creates a string containing the LoadShell data in keyword format. Note that this contains the keyword header and the keyword cards. See also LoadShell.Keyword() and LoadShell.KeywordCards().
 */
    toString(): string;

/** Arrival time for pressure */
    at: number;
/** Shell ID or shell set ID */
    eid: number;
/** true if LoadShell exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** LoadShell heading */
    heading: string;
/** true if _ID option is set, false if not */
    id: boolean;
/** The Include file number that the LoadShell is in. */
    include: number;
/** LoadShell number. */
    label: number;
/** Curve ID */
    lcid: number;
/** LoadShell number (identical to label). */
    lsid: number;
/** The Model number that the load shell is in. */
    model: number;
/** Curve scale factor */
    sf: number;
/** The Load Node type. Can be LoadShell.ELEMENT or LoadShell.SET. */
    type: number;
/** Load is *LOAD_SHELL_ELEMENT. */
    static ELEMENT: number;
/** LOAD is *LOAD_SHELL_SET. */
    static SET: number;
}

declare class Mass {
/**
 * Blanks the mass
 */
    Blank(): void;

/**
 * Blanks all of the masss in the model.
 * @param Model Model that all masss will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged masss in the model.
 * @param Model Model that all the flagged masss will be blanked in
 * @param flag Flag set on the masss that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the mass is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the mass.
 * @param flag Flag to clear on the mass
 */
    ClearFlag(flag: number): void;

/**
 * Copies the mass.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Mass;

/**
 * Starts an interactive editing panel to create a mass.
 * @param Model Model that the mass will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Mass;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for mass. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for mass. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the mass colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the mass.
 */
    ExtractColour(): number;

/**
 * Returns the first mass in the model.
 * @param Model Model to get first mass in
 */
    static First(Model: Model): Mass;

/**
 * Returns the first free mass label in the model. Also see Mass.LastFreeLabel(), Mass.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free mass label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the masss in the model with a defined flag.
 * @param Model Model that all masss will be flagged in
 * @param flag Flag to set on the masss
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the mass is flagged or not.
 * @param flag Flag to test on the mass
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each mass in the model. Note that ForEach has been designed to make looping over masss as fast as possible and so has some limitations. Firstly, a single temporary Mass object is created and on each function call it is updated with the current mass data. This means that you should not try to store the Mass object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new masss inside a ForEach loop. 
 * @param Model Model that all masss are in
 * @param func Function to call for each mass
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Mass objects for all of the masss in a model in Primer
 * @param Model Model to get masss from
 */
    static GetAll(Model: Model): Mass[];

/**
 * Returns an array of Mass objects for all of the flagged masss in a model in Primer
 * @param Model Model to get masss from
 * @param flag Flag set on the masss that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Mass[];

/**
 * Returns the Mass object for a mass ID.
 * @param Model Model to find the mass in
 * @param number number of the mass you want the Mass object for
 */
    static GetFromID(Model: Model, number: number): Mass;

/**
 * Checks if a Mass property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Mass.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop mass property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this mass (*ELEMENT_MASS or *ELEMENT_MASS_NODE_SET). Note that a carriage return is not added. See also Mass.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the mass. Note that a carriage return is not added. See also Mass.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last mass in the model.
 * @param Model Model to get last mass in
 */
    static Last(Model: Model): Mass;

/**
 * Returns the last free mass label in the model. Also see Mass.FirstFreeLabel(), Mass.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free mass label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next mass in the model.
 */
    Next(): Mass;

/**
 * Returns the next free (highest+1) mass label in the model. Also see Mass.FirstFreeLabel(), Mass.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free mass label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a mass.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only masss from that model can be picked. If the argument is a Flag then only masss that are flagged with limit can be selected. If omitted, or null, any masss from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Mass;

/**
 * Returns the previous mass in the model.
 */
    Previous(): Mass;

/**
 * Renumbers all of the masss in the model.
 * @param Model Model that all masss will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged masss in the model.
 * @param Model Model that all the flagged masss will be renumbered in
 * @param flag Flag set on the masss that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select masss using standard PRIMER object menus.
 * @param flag Flag to use when selecting masss
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only masss from that model can be selected. If the argument is a Flag then only masss that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any masss can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the mass.
 * @param flag Flag to set on the mass
 */
    SetFlag(flag: number): void;

/**
 * Sketches the mass. The mass will be sketched until you either call Mass.Unsketch(), Mass.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the mass is sketched. If omitted redraw is true. If you want to sketch several masss and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged masss in the model. The masss will be sketched until you either call Mass.Unsketch(), Mass.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged masss will be sketched in
 * @param flag Flag set on the masss that you want to sketch
 * @param redraw If model should be redrawn or not after the masss are sketched. If omitted redraw is true. If you want to sketch flagged masss several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of masss in the model.
 * @param Model Model to get total for
 * @param exists true if only existing masss should be counted. If false or omitted referenced but undefined masss will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the mass
 */
    Unblank(): void;

/**
 * Unblanks all of the masss in the model.
 * @param Model Model that all masss will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged masss in the model.
 * @param Model Model that the flagged masss will be unblanked in
 * @param flag Flag set on the masss that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the masss in the model.
 * @param Model Model that the defined flag for all masss will be unset in
 * @param flag Flag to unset on the masss
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the mass.
 * @param redraw If model should be redrawn or not after the mass is unsketched. If omitted redraw is true. If you want to unsketch several masss and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all masss.
 * @param Model Model that all masss will be unblanked in
 * @param redraw If model should be redrawn or not after the masss are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged masss in the model.
 * @param Model Model that all masss will be unsketched in
 * @param flag Flag set on the masss that you want to unsketch
 * @param redraw If model should be redrawn or not after the masss are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Mass;

/**
 * Adds a warning for mass. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this mass.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Mass object.
 * @param Model Model that mass will be created in
 * @param eid Mass number
 * @param id Node id or node set id
 * @param mass Mass value
 * @param node_set Only used if a node set is used
 */
    constructor(Model: Model, eid: number, id: number, mass: number, node_set?: number);

/**
 * Creates a string containing the mass data in keyword format. Note that this contains the keyword header and the keyword cards. See also Mass.Keyword() and Mass.KeywordCards().
 */
    toString(): string;

/** The colour of the mass */
    colour: Colour;
/** Mass number. Also see the label property which is an alternative name for this. */
    eid: number;
/** true if mass exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Node id or node set id */
    id: number;
/** The Include file number that the mass is in. */
    include: number;
/** Mass number. Also see the eid property which is an alternative name for this. */
    label: number;
/** Mass value */
    mass: number;
/** The Model number that the mass is in. */
    model: number;
/** The type of the mass. Can be false (*MASS) or Mass.NODE_SET (*MASS_NODE_SET) */
    node_set: number;
/** Part ID */
    pid: number;
/** The transparency of the mass (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Mass is *MASS_NODE_SET. */
    static NODE_SET: number;
}

declare class MassPart {
/**
 * Blanks the element mass part
 */
    Blank(): void;

/**
 * Blanks all of the element mass parts in the model.
 * @param Model Model that all element mass parts will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged element mass parts in the model.
 * @param Model Model that all the flagged element mass parts will be blanked in
 * @param flag Flag set on the element mass parts that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the element mass part is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the element mass part.
 * @param flag Flag to clear on the element mass part
 */
    ClearFlag(flag: number): void;

/**
 * Copies the element mass part.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): MassPart;

/**
 * Starts an interactive editing panel to create a mass part.
 * @param Model Model that the mass part will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): MassPart;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for element mass part. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for element mass part. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the element mass part colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the element mass part.
 */
    ExtractColour(): number;

/**
 * Returns the first element mass part in the model.
 * @param Model Model to get first element mass part in
 */
    static First(Model: Model): MassPart;

/**
 * Flags all of the element mass parts in the model with a defined flag.
 * @param Model Model that all element mass parts will be flagged in
 * @param flag Flag to set on the element mass parts
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the element mass part is flagged or not.
 * @param flag Flag to test on the element mass part
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each element mass part in the model. Note that ForEach has been designed to make looping over element mass parts as fast as possible and so has some limitations. Firstly, a single temporary MassPart object is created and on each function call it is updated with the current element mass part data. This means that you should not try to store the MassPart object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new element mass parts inside a ForEach loop. 
 * @param Model Model that all element mass parts are in
 * @param func Function to call for each element mass part
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of MassPart objects for all of the element mass parts in a model in Primer
 * @param Model Model to get element mass parts from
 */
    static GetAll(Model: Model): MassPart[];

/**
 * Returns an array of MassPart objects for all of the flagged element mass parts in a model in Primer
 * @param Model Model to get element mass parts from
 * @param flag Flag set on the element mass parts that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): MassPart[];

/**
 * Returns the MassPart object for a element mass part ID.
 * @param Model Model to find the element mass part in
 * @param number number of the element mass part you want the MassPart object for
 */
    static GetFromID(Model: Model, number: number): MassPart;

/**
 * Checks if a MassPart property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the MassPart.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop element mass part property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this mass part (*ELEMENT_MASS_PART) Note that a carriage return is not added. See also MassPart.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the mass part. Note that a carriage return is not added. See also MassPart.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last element mass part in the model.
 * @param Model Model to get last element mass part in
 */
    static Last(Model: Model): MassPart;

/**
 * Returns the next element mass part in the model.
 */
    Next(): MassPart;

/**
 * Allows the user to pick a element mass part.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only element mass parts from that model can be picked. If the argument is a Flag then only element mass parts that are flagged with limit can be selected. If omitted, or null, any element mass parts from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): MassPart;

/**
 * Returns the previous element mass part in the model.
 */
    Previous(): MassPart;

/**
 * Allows the user to select element mass parts using standard PRIMER object menus.
 * @param flag Flag to use when selecting element mass parts
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only element mass parts from that model can be selected. If the argument is a Flag then only element mass parts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any element mass parts can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the element mass part.
 * @param flag Flag to set on the element mass part
 */
    SetFlag(flag: number): void;

/**
 * Sketches the element mass part. The element mass part will be sketched until you either call MassPart.Unsketch(), MassPart.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the element mass part is sketched. If omitted redraw is true. If you want to sketch several element mass parts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged element mass parts in the model. The element mass parts will be sketched until you either call MassPart.Unsketch(), MassPart.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged element mass parts will be sketched in
 * @param flag Flag set on the element mass parts that you want to sketch
 * @param redraw If model should be redrawn or not after the element mass parts are sketched. If omitted redraw is true. If you want to sketch flagged element mass parts several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of element mass parts in the model.
 * @param Model Model to get total for
 * @param exists true if only existing element mass parts should be counted. If false or omitted referenced but undefined element mass parts will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the element mass part
 */
    Unblank(): void;

/**
 * Unblanks all of the element mass parts in the model.
 * @param Model Model that all element mass parts will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged element mass parts in the model.
 * @param Model Model that the flagged element mass parts will be unblanked in
 * @param flag Flag set on the element mass parts that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the element mass parts in the model.
 * @param Model Model that the defined flag for all element mass parts will be unset in
 * @param flag Flag to unset on the element mass parts
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the element mass part.
 * @param redraw If model should be redrawn or not after the element mass part is unsketched. If omitted redraw is true. If you want to unsketch several element mass parts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all element mass parts.
 * @param Model Model that all element mass parts will be unblanked in
 * @param redraw If model should be redrawn or not after the element mass parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged element mass parts in the model.
 * @param Model Model that all element mass parts will be unsketched in
 * @param flag Flag set on the element mass parts that you want to unsketch
 * @param redraw If model should be redrawn or not after the element mass parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): MassPart;

/**
 * Adds a warning for element mass part. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this element mass part.
 */
    Xrefs(): Xrefs;

/**
 * Create a new MassPart object.
 * @param Model Model that mass part will be created in
 * @param option Suffix for element mass part. Can be MassPart.PART or MassPart.SET.
 * @param id Part or part set ID.
 * @param addmass Added translational mass.
 * @param finmass Final translational mass.
 */
    constructor(Model: Model, option: number, id: number, addmass?: number, finmass?: number);

/**
 * Creates a string containing the mass part data in keyword format. Note that this contains the keyword header and the keyword cards. See also MassPart.Keyword() and MassPart.KeywordCards().
 */
    toString(): string;

/** Added translational mass to be distributed to the nodes of the part or part set ID. */
    addmass: number;
/** The colour of the mass part */
    colour: Colour;
/** true if mass part exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Final translational mass of the part or part set ID. */
    finmass: number;
/** Part or part set ID if the SET option is active. */
    id: number;
/** The Include file number that the mass part is in. */
    include: number;
/** Optional load curve ID to scale the added mass at time = 0. */
    lcid: number;
/** The Model number that the element mass part is in. */
    model: number;
/** Optional flag for mass-weighted distribution. */
    mwd: number;
/** The Element Mass Part option. Can be MassPart.PART or MassPart.SET */
    option: number;
/** The transparency of the mass part (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Element is *ELEMENT_MASS_PART. */
    static PART: number;
/** Element is *ELEMENT_MASS_PART_SET. */
    static SET: number;
}

declare class Material {
/**
 * Adds any optional cards for the material. Some materials have extra optional cards in the input. If they are there LS-DYNA will read them but they are not required input. For example a material could have three required cards and one extra optional card. If PRIMER reads this material from a keyword file and it only has the three required cards then the properties in the material will only be defined for those cards. i.e. there will not be any properties in the material for the extra optional line. If you edit the material interactively in PRIMER then the extra optional card will be shown so you can add values if required. When writing the material to a keyword file the extra optional card will be omitted if none of the fields are used. If you want to add one of the properties for the extra optional card in JavaScript this method will ensure that the extra card is defined and the properties added to the material as zero values. You can then use Material.SetPropertyByIndex(), Material.SetPropertyByName() or Material.SetPropertyByRowCol() as normal to set the properties. Also see the optionalCards property.
 */
    AddOptionalCards(): void;

/**
 * Blanks the material
 */
    Blank(): void;

/**
 * Blanks all of the materials in the model.
 * @param Model Model that all materials will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged materials in the model.
 * @param Model Model that all the flagged materials will be blanked in
 * @param flag Flag set on the materials that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the material is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the material.
 * @param flag Flag to clear on the material
 */
    ClearFlag(flag: number): void;

/**
 * Copies the material.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Material;

/**
 * Starts an interactive editing panel to create a material.
 * @param Model Model that the material will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Material;

/**
 * Get the density material.
 */
    Density(): number;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for material. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for material. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the material colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the material.
 */
    ExtractColour(): number;

/**
 * Returns the first material in the model.
 * @param Model Model to get first material in
 */
    static First(Model: Model): Material;

/**
 * Returns the first free material label in the model. Also see Material.LastFreeLabel(), Material.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free material label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the materials in the model with a defined flag.
 * @param Model Model that all materials will be flagged in
 * @param flag Flag to set on the materials
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the material is flagged or not.
 * @param flag Flag to test on the material
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each material in the model. Note that ForEach has been designed to make looping over materials as fast as possible and so has some limitations. Firstly, a single temporary Material object is created and on each function call it is updated with the current material data. This means that you should not try to store the Material object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new materials inside a ForEach loop. 
 * @param Model Model that all materials are in
 * @param func Function to call for each material
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Material objects for all of the materials in a model in Primer
 * @param Model Model to get materials from
 */
    static GetAll(Model: Model): Material[];

/**
 * Returns the value of Erosion property string acronym for this Material object or null if Erosion is not set on Material or no such Erosion property exists.
 * @param acronym The acronym of the Erosion property value to retrieve
 * @param idam_index Required if property is one of IDAM cards pair property (for IDAM value less than zero) . If the argument is not given, returns the property value for first IDAM cards Pair. The index value starts from zero.
 */
    GetErosionPropertyByName(acronym: string, idam_index?: number): number;

/**
 * Returns an array of Material objects for all of the flagged materials in a model in Primer
 * @param Model Model to get materials from
 * @param flag Flag set on the materials that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Material[];

/**
 * Returns the Material object for a material ID.
 * @param Model Model to find the material in
 * @param number number of the material you want the Material object for
 */
    static GetFromID(Model: Model, number: number): Material;

/**
 * Checks if the Erosion properties are defined for this Material object.
 */
    GetMaterialErosionExists(): boolean;

/**
 * Checks if a Material property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Material.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop material property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the value of property at index index for this Material object or null if no property exists.
 * @param index The index of the property value to retrieve. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for a material may not have adjacent indices.
 */
    GetPropertyByIndex(index: number): number;

/**
 * Returns the value of property string acronym for this Material object or null if no property exists.
 * @param acronym The acronym of the property value to retrieve
 */
    GetPropertyByName(acronym: string): number;

/**
 * Returns the value of the property for row and col for this Material object or null if no property exists. Note that rows and columns start at 0.
 * @param row The row of the property value to retrieve
 * @param col The column of the property value to retrieve
 */
    GetPropertyByRowCol(row: number, col: number): number;

/**
 * Returns the name of the property at index index for this Material object or null if there is no property.
 * @param index The index of the property name to retrieve. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for a material may not have adjacent indices.
 */
    GetPropertyNameForIndex(index: number): string;

/**
 * Returns the name of the property at row and col for this Material object or null if there is no property. Note that rows and columns start at 0.
 * @param row The row of the property name to retrieve
 * @param col The column of the property name to retrieve
 */
    GetPropertyNameForRowCol(row: number, col: number): string;

/**
 * Returns the keyword for this material (e.g. *MAT_RIGID, *MAT_ELASTIC etc). Note that a carriage return is not added. See also Material.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the material. Note that a carriage return is not added. See also Material.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last material in the model.
 * @param Model Model to get last material in
 */
    static Last(Model: Model): Material;

/**
 * Returns the last free material label in the model. Also see Material.FirstFreeLabel(), Material.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free material label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next material in the model.
 */
    Next(): Material;

/**
 * Returns the next free (highest+1) material label in the model. Also see Material.FirstFreeLabel(), Material.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free material label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a material.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only materials from that model can be picked. If the argument is a Flag then only materials that are flagged with limit can be selected. If omitted, or null, any materials from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Material;

/**
 * Get Poissons ratio for the material.
 */
    PoissonsRatio(): number;

/**
 * Returns the previous material in the model.
 */
    Previous(): Material;

/**
 * Removes the Erosion properties for this Material object.
 */
    RemoveMaterialErosion(): void;

/**
 * Renumbers all of the materials in the model.
 * @param Model Model that all materials will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged materials in the model.
 * @param Model Model that all the flagged materials will be renumbered in
 * @param flag Flag set on the materials that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select materials using standard PRIMER object menus.
 * @param flag Flag to use when selecting materials
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only materials from that model can be selected. If the argument is a Flag then only materials that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any materials can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets the value of Erosion property string acronym for this Material object
 * @param acronym The acronym of the property value to set
 * @param value The value of the property to set.
 * @param idam_index Required if property is one of IDAM cards pair property (for IDAM value less than zero) . If the argument is not given, set the property values for first IDAM cards Pair. The index value starts from zero.
 */
    SetErosionPropertyByName(acronym: string, value: number, idam_index?: number): void;

/**
 * Sets a flag on the material.
 * @param flag Flag to set on the material
 */
    SetFlag(flag: number): void;

/**
 * Initializes the Erosion properties for this Material object.
 */
    SetMaterialErosion(): void;

/**
 * Sets the value of property at index index for this Material object
 * @param index The index of the property value to set. (the number of properties can be found from properties) Note that indices start at 0. There is no link between indices and rows/columns so adjacent fields on a line for a material may not have adjacent indices.
 * @param value The value of the property to set.
 */
    SetPropertyByIndex(index: number, value: number): void;

/**
 * Sets the value of property string acronym for this Material object
 * @param acronym The acronym of the property value to set
 * @param value The value of the property to set.
 */
    SetPropertyByName(acronym: string, value: number): void;

/**
 * Sets the value of the property for row and col for this Material object.Note that rows and columns start at 0.
 * @param row The row of the property value to set
 * @param col The column of the property value to set
 * @param value The value of the property to set.
 */
    SetPropertyByRowCol(row: number, col: number, value: number): void;

/**
 * Sketches the material. The material will be sketched until you either call Material.Unsketch(), Material.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the material is sketched. If omitted redraw is true. If you want to sketch several materials and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged materials in the model. The materials will be sketched until you either call Material.Unsketch(), Material.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged materials will be sketched in
 * @param flag Flag set on the materials that you want to sketch
 * @param redraw If model should be redrawn or not after the materials are sketched. If omitted redraw is true. If you want to sketch flagged materials several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of materials in the model.
 * @param Model Model to get total for
 * @param exists true if only existing materials should be counted. If false or omitted referenced but undefined materials will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the material
 */
    Unblank(): void;

/**
 * Unblanks all of the materials in the model.
 * @param Model Model that all materials will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged materials in the model.
 * @param Model Model that the flagged materials will be unblanked in
 * @param flag Flag set on the materials that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the materials in the model.
 * @param Model Model that the defined flag for all materials will be unset in
 * @param flag Flag to unset on the materials
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the material.
 * @param redraw If model should be redrawn or not after the material is unsketched. If omitted redraw is true. If you want to unsketch several materials and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all materials.
 * @param Model Model that all materials will be unblanked in
 * @param redraw If model should be redrawn or not after the materials are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged materials in the model.
 * @param Model Model that all materials will be unsketched in
 * @param flag Flag set on the materials that you want to unsketch
 * @param redraw If model should be redrawn or not after the materials are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Material;

/**
 * Adds a warning for material. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this material.
 */
    Xrefs(): Xrefs;

/**
 * Get Yield stress for the material.
 */
    YieldStress(): number;

/**
 * Get Youngs modulus for the material.
 */
    YoungsModulus(): number;

/**
 * Create a new Material object.
 * @param Model Model that material will be created in
 * @param mid Material number or character label
 * @param type Material type. Either give the LS-DYNA material name or 3 digit number.
 */
    constructor(Model: Model, mid: number, type: string);

/**
 * Creates a string containing the material data in keyword format. Note that this contains the keyword header and the keyword cards. See also Material.Keyword() and Material.KeywordCards().
 */
    toString(): string;

/** The colour of the material */
    colour: Colour;
/** The number of columns of data the material has (read only) */
    readonly cols: number;
/** true if material exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the material is in. */
    include: number;
/** Material number. Also see the mid property which is an alternative name for this. */
    label: number;
/** Material number. Also see the label property which is an alternative name for this. */
    mid: number;
/** The Model number that the material is in. */
    model: number;
/** The number of optional extra cards that this material definition can have (read only). Also see Material.AddOptionalCards() */
    readonly optionalCards: number;
/** The total number of properties that the material has */
    properties: number;
/** The number of rows of data the material has (read only) */
    readonly rows: number;
/** Material title */
    title: string;
/** The transparency of the material (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** The material type (e.g. 'ELASTIC', 'RIGID' etc). */
    type: string;
}


/** Object returned by GetAssembly */
interface GetAssemblyReturn {
    /** Assembly label */
    label: number;
    /** Parent assembly label */
    parent: number;
    /** Assembly title */
    title: string;
}


/** Object returned by GetConnection */
interface GetConnectionReturn {
    /** Current angle in degrees (for Mechanism.LINE and Mechanism.HINGE) */
    angle: number;
    /** Assembly 1 label */
    assembly1: number;
    /** Assembly 2 label */
    assembly2: number;
    /** Assembly 3 label */
    assembly3: number;
    /** Coefficient for linear coupler equation for connection 1 (for Mechanism.COUPLER) */
    coefficient1: number;
    /** Coefficient for linear coupler equation for connection 2 (for Mechanism.COUPLER) */
    coefficient2: number;
    /** Coefficient for linear coupler equation for connection 3 (for Mechanism.COUPLER) */
    coefficient3: number;
    /** Connection 1 label (for Mechanism.COUPLER) */
    connection1: number;
    /** Connection 2 label (for Mechanism.COUPLER) */
    connection2: number;
    /** Connection 3 label (for Mechanism.COUPLER) */
    connection3: number;
    /** Current distance (for Mechanism.LINE) */
    distance: number;
    /** Factor 1 on Assembly 3 (Mechanism.LINE only) */
    factor1: number;
    /** Factor 2 on Assembly 3 (Mechanism.LINE only) */
    factor2: number;
    /** Connection label */
    label: number;
    /** 1 if locked (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    locked: number;
    /** Coupling mode for connection 1. 0 = translational coupling, 1 = rotational coupling (for Mechanism.COUPLER) */
    mode1: number;
    /** Coupling mode for connection 2. 0 = translational coupling, 1 = rotational coupling (for Mechanism.COUPLER) */
    mode2: number;
    /** Coupling mode for connection 3. 0 = translational coupling, 1 = rotational coupling (for Mechanism.COUPLER) */
    mode3: number;
    /** Node 1 label (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    node1: number;
    /** Node 2 label (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    node2: number;
    /** -ve rotation limit in degrees (for Mechanism.LINE and Mechanism.HINGE) */
    nrotation: number;
    /** -ve slide translation (for Mechanism.LINE) */
    nslide: number;
    /** +ve rotation limit in degrees (for Mechanism.LINE and Mechanism.HINGE) */
    protation: number;
    /** +ve slide translation (for Mechanism.LINE) */
    pslide: number;
    /** Connection label */
    title: string;
    /** Mechanism type (Mechanism.COUPLER, Mechanism.HINGE, Mechanism.LINE, Mechanism.PIN) */
    type: number;
    /** X1 coordinates (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    x1: number;
    /** X2 coordinates (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    x2: number;
    /** Y1 coordinates (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    y1: number;
    /** Y2 coordinates (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    y2: number;
    /** Z1 coordinates (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    z1: number;
    /** Z2 coordinates (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    z2: number;
}


/** Object returned by GetPoint */
interface GetPointReturn {
    /** Assembly label */
    assembly: number;
    /** Coordinate system */
    csys: number;
    /** If point has been automatically created by PRIMER at the H-point */
    hpt: boolean;
    /** Point label */
    label: number;
    /** Node label (0 if coordinate) */
    node: number;
    /** Point restrained rotationally in X */
    rx: boolean;
    /** Point restrained rotationally in Y */
    ry: boolean;
    /** Point restrained rotationally in Z */
    rz: boolean;
    /** Point title */
    title: string;
    /** Point restrained translationally in X */
    tx: boolean;
    /** Point restrained translationally in Y */
    ty: boolean;
    /** Point restrained translationally in Z */
    tz: boolean;
    /** Node/point x coordinate */
    x: number;
    /** Node/point y coordinate */
    y: number;
    /** Node/point z coordinate */
    z: number;
}


/** Object function argument in SetConnection */
interface SetConnectionArgument_data {
    /** Current angle in degrees (for Mechanism.LINE and Mechanism.HINGE) */
    angle?: number;
    /** Assembly 1 label (required for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    assembly1?: number;
    /** Assembly 2 label (required for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    assembly2?: number;
    /** Assembly 3 label (required for Mechanism.LINE) */
    assembly3: number;
    /** Coefficient for linear coupler equation for connection 1 (for Mechanism.COUPLER) */
    coefficient1?: number;
    /** Coefficient for linear coupler equation for connection 2 (for Mechanism.COUPLER) */
    coefficient2?: number;
    /** Coefficient for linear coupler equation for connection 3 (for Mechanism.COUPLER) */
    coefficient3?: number;
    /** Connection 1 label (for Mechanism.COUPLER) */
    connection1?: number;
    /** Connection 2 label (for Mechanism.COUPLER) */
    connection2?: number;
    /** Connection 3 label (for Mechanism.COUPLER) */
    connection3?: number;
    /** Current distance (for Mechanism.LINE) */
    distance?: number;
    /** Factor 1 on Assembly 3 (Mechanism.LINE only) */
    factor1?: number;
    /** Factor 2 on Assembly 3 (Mechanism.LINE only) */
    factor2?: number;
    /** 1 if locked (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE) */
    locked?: number;
    /** Coupling mode for connection 1. 0 = translational coupling, 1 = rotational coupling (for Mechanism.COUPLER) */
    mode1?: number;
    /** Coupling mode for connection 2. 0 = translational coupling, 1 = rotational coupling (for Mechanism.COUPLER) */
    mode2?: number;
    /** Coupling mode for connection 3. 0 = translational coupling, 1 = rotational coupling (for Mechanism.COUPLER) */
    mode3?: number;
    /** Node 1 label (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE, not required if using x1, y1 and z1) */
    node1?: number;
    /** Node 2 label (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE, not required if using x2, y2 and z2) */
    node2?: number;
    /** -ve rotation limit in degrees (for Mechanism.LINE and Mechanism.HINGE) */
    nrotation?: number;
    /** -ve slide translation (for Mechanism.LINE) */
    nslide?: number;
    /** +ve rotation limit in degrees (for Mechanism.LINE and Mechanism.HINGE) */
    protation?: number;
    /** +ve slide translation (for Mechanism.LINE) */
    pslide?: number;
    /** Title */
    title?: string;
    /** Connection type. Can be one of: Mechanism.PIN, Mechanism.LINE, Mechanism.HINGE or Mechanism.COUPLER] */
    type: number;
    /** x1 coordinate (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE, not required if using node1) */
    x1?: number;
    /** x2 coordinate (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE, not required if using node2) */
    x2?: number;
    /** y1 coordinate (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE, not required if using node1) */
    y1?: number;
    /** y2 coordinate (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE, not required if using node2) */
    y2?: number;
    /** z1 coordinate (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE, not required if using node1) */
    z1?: number;
    /** z2 coordinate (for Mechanism.LINE, Mechanism.PIN and Mechanism.HINGE, not required if using node2) */
    z2?: number;
}


/** Object function argument in SetPoint */
interface SetPointArgument_data {
    /** Assembly label */
    assembly: number;
    /** Coordinate system label */
    csys?: number;
    /** Node label (not required if using x, y and z) */
    node?: number;
    /** Point restrained rotationally in X */
    rx?: boolean;
    /** Point restrained rotationally in Y */
    ry?: boolean;
    /** Point restrained rotationally in Z */
    rz?: boolean;
    /** Point title */
    title?: string;
    /** Point restrained translationally in X */
    tx?: boolean;
    /** Point restrained translationally in Y */
    ty?: boolean;
    /** Point restrained translationally in Z */
    tz?: boolean;
    /** x coordinate (not required if using node) */
    x?: number;
    /** y coordinate (not required if using node) */
    y?: number;
    /** z coordinate (not required if using node) */
    z?: number;
}

declare class Mechanism {
/**
 * Add node set to assembly
 * @param index The index of the assembly in which you want to add node set. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies
 * @param nsid The node set ID that you want to add.
 */
    AddNodeSetToAssembly(index: number, nsid: number): void;

/**
 * Add part set to assembly
 * @param index The index of the assembly in which you want to add part set. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies
 * @param psid The part set ID that you want to add.
 */
    AddPartSetToAssembly(index: number, psid: number): void;

/**
 * Add part to assembly
 * @param index The index of the assembly in which you want to add part. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies
 * @param pid The part ID that you want to add.
 */
    AddPartToAssembly(index: number, pid: number): void;

/**
 * Blanks the mechanism
 */
    Blank(): void;

/**
 * Blanks all of the mechanisms in the model.
 * @param Model Model that all mechanisms will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged mechanisms in the model.
 * @param Model Model that all the flagged mechanisms will be blanked in
 * @param flag Flag set on the mechanisms that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the mechanism is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the mechanism.
 * @param flag Flag to clear on the mechanism
 */
    ClearFlag(flag: number): void;

/**
 * Copies the mechanism.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Mechanism;

/**
 * Adds an error for mechanism. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first mechanism in the model.
 * @param Model Model to get first mechanism in
 */
    static First(Model: Model): Mechanism;

/**
 * Returns the first free mechanism label in the model. Also see Mechanism.LastFreeLabel(), Mechanism.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free mechanism label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the mechanisms in the model with a defined flag.
 * @param Model Model that all mechanisms will be flagged in
 * @param flag Flag to set on the mechanisms
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the mechanism is flagged or not.
 * @param flag Flag to test on the mechanism
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each mechanism in the model. Note that ForEach has been designed to make looping over mechanisms as fast as possible and so has some limitations. Firstly, a single temporary Mechanism object is created and on each function call it is updated with the current mechanism data. This means that you should not try to store the Mechanism object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new mechanisms inside a ForEach loop. 
 * @param Model Model that all mechanisms are in
 * @param func Function to call for each mechanism
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Mechanism objects for all of the mechanisms in a model in Primer
 * @param Model Model to get mechanisms from
 */
    static GetAll(Model: Model): Mechanism[];

/**
 * Returns the information for an assembly
 * @param index The index of the assembly you want the coordinates for. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies
 */
    GetAssembly(index: number): GetAssemblyReturn;

/**
 * Returns the information for a connection
 * @param index The index of the connection you want the information for. Note that connections start at 0, not 1. 0 &lt;= index &lt; connections
 */
    GetConnection(index: number): GetConnectionReturn;

/**
 * Returns an array of Mechanism objects for all of the flagged mechanisms in a model in Primer
 * @param Model Model to get mechanisms from
 * @param flag Flag set on the mechanisms that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Mechanism[];

/**
 * Returns the Mechanism object for a mechanism ID.
 * @param Model Model to find the mechanism in
 * @param number number of the mechanism you want the Mechanism object for
 */
    static GetFromID(Model: Model, number: number): Mechanism;

/**
 * Checks if a Mechanism property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Mechanism.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop mechanism property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the information for a reference point
 * @param index The index of the reference point you want the information for. Note that reference points start at 0, not 1. 0 &lt;= index &lt; points
 */
    GetPoint(index: number): GetPointReturn;

/**
 * Returns the coordinates of a reference point
 * @param rpt The reference point you want the coordinates for. Note that reference points start at 0, not 1.
 */
    GetPointData(rpt: number): number[];

/**
 * Returns the title of a reference point
 * @param rpt The reference point you want the title for. Note that reference points start at 0, not 1.
 */
    GetPointTitle(rpt: number): number;

/**
 * Returns the last mechanism in the model.
 * @param Model Model to get last mechanism in
 */
    static Last(Model: Model): Mechanism;

/**
 * Returns the last free mechanism label in the model. Also see Mechanism.FirstFreeLabel(), Mechanism.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free mechanism label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next mechanism in the model.
 */
    Next(): Mechanism;

/**
 * Returns the next free (highest+1) mechanism label in the model. Also see Mechanism.FirstFreeLabel(), Mechanism.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free mechanism label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a mechanism.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only mechanisms from that model can be picked. If the argument is a Flag then only mechanisms that are flagged with limit can be selected. If omitted, or null, any mechanisms from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Mechanism;

/**
 * Returns the previous mechanism in the model.
 */
    Previous(): Mechanism;

/**
 * Removes a connection from a mechanism
 * @param index The index of the connection you want to remove. Note that connections start at 0, not 1. 0 &lt;= index &lt; connections
 */
    RemoveConnection(index: number): void;

/**
 * Remove node set from assembly
 * @param index The index of the assembly from which you want to remove the node set. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies
 * @param nsid The node set ID that you want to remove.
 */
    RemoveNodeSetFromAssembly(index: number, nsid: number): void;

/**
 * Remove part from assembly
 * @param index The index of the assembly from which you want to remove the part. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies
 * @param pid The part ID that you want to remove.
 */
    RemovePartFromAssembly(index: number, pid: number): void;

/**
 * Remove part set from assembly
 * @param index The index of the assembly from which you want to remove the part set. Note that reference points start at 0, not 1. 0 &lt;= index &lt; assemblies
 * @param psid The part set ID that you want to remove.
 */
    RemovePartSetFromAssembly(index: number, psid: number): void;

/**
 * Removes a reference point from a mechanism
 * @param index The index of the reference point you want to remove. Note that reference points start at 0, not 1. 0 &lt;= index &lt; points
 */
    RemovePoint(index: number): void;

/**
 * Renumbers all of the mechanisms in the model.
 * @param Model Model that all mechanisms will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged mechanisms in the model.
 * @param Model Model that all the flagged mechanisms will be renumbered in
 * @param flag Flag set on the mechanisms that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select mechanisms using standard PRIMER object menus.
 * @param flag Flag to use when selecting mechanisms
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only mechanisms from that model can be selected. If the argument is a Flag then only mechanisms that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any mechanisms can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets the data for a connection in a mechanism
 * @param index The index of the connection you want to set. Note that connections start at 0, not 1. To add a new connection use index connections
 * @param data Object containing the connection data. The properties can be:
 */
    SetConnection(index: number, data: SetConnectionArgument_data): void;

/**
 * Sets a flag on the mechanism.
 * @param flag Flag to set on the mechanism
 */
    SetFlag(flag: number): void;

/**
 * Sets the data for a reference point in a mechanism
 * @param index The index of the reference point you want to set. Note that reference points start at 0, not 1. To add a new point use index points
 * @param data Object containing the reference point data. The properties can be:
 */
    SetPoint(index: number, data: SetPointArgument_data): void;

/**
 * Sketches the mechanism. The mechanism will be sketched until you either call Mechanism.Unsketch(), Mechanism.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the mechanism is sketched. If omitted redraw is true. If you want to sketch several mechanisms and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged mechanisms in the model. The mechanisms will be sketched until you either call Mechanism.Unsketch(), Mechanism.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged mechanisms will be sketched in
 * @param flag Flag set on the mechanisms that you want to sketch
 * @param redraw If model should be redrawn or not after the mechanisms are sketched. If omitted redraw is true. If you want to sketch flagged mechanisms several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of mechanisms in the model.
 * @param Model Model to get total for
 * @param exists true if only existing mechanisms should be counted. If false or omitted referenced but undefined mechanisms will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the mechanism
 */
    Unblank(): void;

/**
 * Unblanks all of the mechanisms in the model.
 * @param Model Model that all mechanisms will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged mechanisms in the model.
 * @param Model Model that the flagged mechanisms will be unblanked in
 * @param flag Flag set on the mechanisms that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the mechanisms in the model.
 * @param Model Model that the defined flag for all mechanisms will be unset in
 * @param flag Flag to unset on the mechanisms
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the mechanism.
 * @param redraw If model should be redrawn or not after the mechanism is unsketched. If omitted redraw is true. If you want to unsketch several mechanisms and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all mechanisms.
 * @param Model Model that all mechanisms will be unblanked in
 * @param redraw If model should be redrawn or not after the mechanisms are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged mechanisms in the model.
 * @param Model Model that all mechanisms will be unsketched in
 * @param flag Flag set on the mechanisms that you want to unsketch
 * @param redraw If model should be redrawn or not after the mechanisms are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Mechanism;

/**
 * Adds a warning for mechanism. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this mechanism.
 */
    Xrefs(): Xrefs;

/** Number of assemblies defined. (read only) */
    readonly assemblies: number;
/** Number of connections defined. (read only) */
    readonly connections: number;
/** true if mechanism exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Mechanism number. Also see the label property which is an alternative name for this. (read only) */
    readonly id: number;
/** The Include file number that the mechanism is in. */
    include: number;
/** Mechanism number. Also see the id property which is an alternative name for this. (read only) */
    readonly label: number;
/** The Model number that the mechanism is in. */
    model: number;
/** Number of reference points defined. (read only) */
    readonly points: number;
/** Mechanism title. */
    title: string;
/** Coupler mechanism connection */
    static COUPLER: number;
/** Hinge mechanism connection */
    static HINGE: number;
/** Line mechanism connection */
    static LINE: number;
/** Pin mechanism connection */
    static PIN: number;
/** Rotational coupling on mechanism coupler */
    static ROTATION: number;
/** Translational coupling on mechanism coupler */
    static TRANSLATION: number;
}


/** Object returned by AreaVolumeFlagged */
interface AreaVolumeFlaggedReturn {
    /** Area of flagged items */
    area: number;
    /** Volume of flagged items */
    volume: number;
}


/** Object returned by GetIncludeTransformOffsets */
interface GetIncludeTransformOffsetsReturn {
    /** Offset to define id */
    iddoff: number;
    /** Offset to element id */
    ideoff: number;
    /** Offset to function id */
    idfoff: number;
    /** Offset to material id */
    idmoff: number;
    /** Offset to node id */
    idnoff: number;
    /** Offset to part id */
    idpoff: number;
    /** Offset to section, hourglass, EOS id */
    idroff: number;
    /** Offset to set id */
    idsoff: number;
}


/** Object returned by MassPropCalc */
interface MassPropCalcReturn {
    /** X coordinate of centre of gravity */
    cofgx: number;
    /** Y coordinate of centre of gravity */
    cofgy: number;
    /** Z coordinate of centre of gravity */
    cofgz: number;
    /** XX inertia */
    inerxx: number;
    /** XY inertia */
    inerxy: number;
    /** XZ inertia */
    inerxz: number;
    /** YY inertia */
    ineryy: number;
    /** YZ inertia */
    ineryz: number;
    /** ZZ inertia */
    inerzz: number;
    /** Mass */
    mass: number;
}


/** Object function argument in Write */
interface WriteArgument_options {
    /** If true then the output file will be written out in binary. If false (default) then an ascii file will be written. */
    binary?: boolean;
    /** If true then the output file will be compressed. If false (default) then an uncompressed file will be written. */
    compress?: boolean;
    /** Compression level for .gz and .zip files. Must be in the range 1 to 9 with 1 being the least compression (fastest speed) to 9 being the greatest compression (slowest speed) */
    compressLevel?: number;
    /** This option can be used to specify the mode of compression. Can be Include.KEEP_ORIGINAL or Include.INDIVIDUAL_GZIP or Include.INDIVIDUAL_ZIP */
    compressMode?: number;
    /** If true then the begining of the file (*CONTROL etc) file is written out in ascii. If false (default) then the entire file is converted to binary. */
    fileStartAscii?: boolean;
    /** If true then i10 format will be used to write the file. If false (default) then the normal LS-DYNA format will be used. */
    i10?: boolean;
    /** If true then a binary format output file will be given the extension .kby, replacing the existing extension. */
    kbyExt?: boolean;
    /** If true then large format will be used to write the file. If false (default) then the normal LS-DYNA format will be used. Note that large format is only available from version R7.1 and above. */
    large?: boolean;
    /** If true then the whole master file is written out in ascii. If false (default) then the master file is also converted to binary. */
    masterAscii?: boolean;
    /** The method used to write include files. Can be Include.MASTER_ONLY, Include.MERGE, Include.NOT_WRITTEN, Include.SUBDIR (default) or Include.SAME_DIR */
    method?: number;
    /** If true then the underlying values of any parameters will be written when they are used in data fields rather than '&amp;name'. If false then '&amp;name' will be written. See also Options.keyout_parameter_values */
    parametersAsValues?: boolean;
    /** The method used to write include paths. Can be Include.ABSOLUTE (default) or Include.RELATIVE */
    path?: number;
    /** The directory separator used when writing include files. Can be Include.NATIVE (default), Include.UNIX or Include.WINDOWS */
    separator?: number;
    /** The LS-DYNA version used to write the file. Can be "971R5", "971R4", "971R3", "970v6763" etc (see the version popup in Model-&gt;Write '&gt;&gt;&gt; LS-Dyna output options' for a full list). See also Options.dyna_version */
    version?: string;
}

declare class Model {
/**
 * Calculates the Area/Volume of the selected items. Note: The area calculation is based only on shell elements, and the volume calculation is based only on solid elements.
 * @param flag Flag set on entities you wish to calculate area/volume for
 */
    AreaVolumeFlagged(flag: number): AreaVolumeFlaggedReturn;

/**
 * Finds attached items to flagged items. The attached items are flagged with the same flag.
 * @param flag Flag set on items that you want to find attached to
 * @param redraw If true, the display will be updated to display only the original flagged items and the attached items.
 */
    Attached(flag: number, redraw?: boolean): void;

/**
 * Autofix option does a model check and autofixes all the fixable errors in the model
 */
    Autofix(): void;

/**
 * Blanks a model in PRIMER
 */
    Blank(): void;

/**
 * Blanks all models
 */
    static BlankAll(): void;

/**
 * Blanks all of the flagged items in the model.
 * @param flag Flag set on items that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    BlankFlagged(flag: number, redraw?: boolean): void;

/**
 * Returns the centre of gravity for a model
 */
    CentreOfGravity(): number[];

/**
 * Checks a model, writing any errors to file.
 * @param filename Name of file to write errors to
 * @param detailed If set to "true", detailed error messages are given.
 * @param json If set, output in filename will be written in JSON format. If omitted json will be set to false. If JSON format is written then detailed will automatically be set. Note that when writing JSON format the labels produced can be strings instead of integers in some rare cases. If you are writing a script to read a JSON file, it must be able to cope with this. Specifically if the item is a character label the label will be a string. For child collect sets the label will be a string of the format 'X_Y' where X is the parent set label and Y will be the child set number (1, 2, 3 ...). In this case use Set.GetCollectChild() to get the object.
 * @param include If set, error messages will be written in include by include layout. This option is not applicable if JSON is set.
 */
    Check(filename: string, detailed?: boolean, json?: boolean, include?: boolean): void;

/**
 * Clears the flagging for a model in PRIMER. See also Model.PropagateFlag(), Model.SetFlag(), global.AllocateFlag() and global.ReturnFlag().
 * @param flag Flag to clear
 */
    ClearFlag(flag: number): void;

/**
 * Copy model to the next free model in PRIMER
 * @param update If the graphics should be updated after the model is copied. If omitted update will be set to false
 */
    Copy(update?: boolean): Model;

/**
 * Copy flagged items in a model to the next free model in PRIMER
 * @param flag Flag set on items that you want to copy
 * @param update If the graphics should be updated after the model is copied. If omitted update will be set to false
 */
    CopyFlagged(flag: number, update?: boolean): Model;

/**
 * Deletes a model in PRIMERDo not use the Model object after calling this method.
 */
    Delete(): void;

/**
 * Deletes all existing models from PRIMER
 */
    static DeleteAll(): void;

/**
 * Deletes all of the flagged items in the model. Note that this may not actually delete all of the items. For example if a node is flagged but the node is used in a shell which is not flagged then the node will not be deleted.
 * @param flag Flag set on items that you want to delete
 * @param recursive If deletion is recursive (for example, if a shell is deleted with recursion on the shell nodes will be deleted if possible). If omitted recursive will be set to true.
 */
    DeleteFlagged(flag: number, recursive?: boolean): void;

/**
 * Tries to delete an include file from the model. Note that this may not actually delete the include file. For example if some of the items in the include file are required by other things in different includes then the include file will not be deleted.
 * @param Include_label label of include file that you want to delete
 * @param method Method for deleting items. Must be Model.REMOVE_FROM_SETS (default), Model.REMOVE_JUNIOR or Model.REMOVE_INCLUDE_ONLY. Model.REMOVE_FROM_SETS will only delete items within the include selected but may remove items from sets in other includes. Model.REMOVE_JUNIOR may delete items in other includes - this will happen if they 'belong' to items in this include and are considered 'junior' Model.REMOVE_INCLUDE_ONLY does the same as Model.REMOVE_FROM_SETS but will not remove items from sets in other includes.
 * @param force Forcible deletion option (for example, a node is deleted even when it is referenced by a shell which is not deleted). This will remove the include file (not just the contents) from the model. If this argument is omitted, force will be set to false.
 */
    DeleteInclude(Include_label: number, method?: number, force?: boolean): boolean;

/**
 * Tidy memory allocation incurred by function which finds elements within a box. See also Model.FindElemInit()
 */
    FindElemEnd(): void;

/**
 * Initialize setup so that all flagged beams, shells, solids, tshells in model can be tested to see if they are within box. See also Shell.FindShellInBox() Tshell.FindTshellInBox() Solid.FindSolidInBox() Beam.FindBeamInBox() To return memory Model.FindElemEnd()
 * @param flag If omitted all shells, solids, tshells, beams will be considered.
 */
    FindElemInit(flag?: number): void;

/**
 * Returns the Model object for the first model in PRIMER (or null if there are no models)
 */
    static First(): Model;

/**
 * Returns the first free label for an item type in the model. Also see Model.LastFreeItemLabel() and Model.NextFreeItemLabel().
 * @param type The type of the item (for a list of types see Appendix I of the PRIMER manual).
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeItemLabel(type: string, layer?: number): number;

/**
 * Flag all nodes referenced in two different includes
 * @param flag Flag which will be used to flag the "duplicate" nodes
 */
    FlagDuplicate(flag: number): void;

/**
 * Returns an array of Model objects for all the models in PRIMER
 */
    static GetAll(): Model[];

/**
 * Returns the Model object for a model ID or null if model does not exist
 * @param model_number number of the model you want the Model object for
 */
    static GetFromID(model_number: number): Model;

/**
 * Looks at all of the items in the model and determines values for IDNOFF, IDEOFF, IDPOFF etc that could be used with Model.ImportIncludeTransform to guarantee that there would not be any clashes with existing items in the model.
 */
    GetIncludeTransformOffsets(): GetIncludeTransformOffsetsReturn;

/**
 * Hides a model in PRIMER
 */
    Hide(): void;

/**
 * Imports a file into model m. The model can already contain items. However, note that if the file cannot be imported because of a label clash or other problem PRIMER may delete the model and the script will terminate. Note prior to v17 of PRIMER imported data would always be imported to the master model, irrespective of the current layer. From v17 onwards this has been corrected and the current layer is used to determine the destination of imported data.
 * @param filename Filename of the LS-Dyna keyword file you want to import
 */
    Import(filename: string): number;

/**
 * Imports a keyword file or an Include object from different model as a new include or into an existing include file for model m. The labels of any items in the imported include contents that clash with existing labels will automatically be renumbered with one exception. The behaviour for *SET_COLLECT cards can be controlled with Options.merge_set_collect.
 * @param source Can either be a Filename of the LS-Dyna include file you want to import, OR Include object of another model you want to import
 * @param target Include file object of current model if the Import has to be done in an existing include .
 */
    ImportInclude(source: string, target?: Include): Include;

/**
 * Imports a file as an include transform file for model m. The labels of any items in the include file will be renumbered by idnoff, ideoff etc.
 * @param filename Filename of the LS-Dyna include file you want to import
 * @param idnoff Offset for nodes in the file
 * @param ideoff Offset for elements in the file
 * @param idpoff Offset for parts in the file
 * @param idmoff Offset for materials in the file
 * @param idsoff Offset for sets in the file
 * @param idfoff Offset for functions and tables in the file
 * @param iddoff Offset for defines in the file
 * @param idroff Offset for other labels in the file
 */
    ImportIncludeTransform(filename: string, idnoff: number, ideoff: number, idpoff: number, idmoff: number, idsoff: number, idfoff: number, iddoff: number, idroff: number): Include;

/**
 * Returns the Model object for the last model in PRIMER (or null if there are no models)
 */
    static Last(): Model;

/**
 * Returns the last free label for an item type in the model. Also see Model.FirstFreeItemLabel() and Model.NextFreeItemLabel().
 * @param type The type of the item (for a list of types see Appendix I of the PRIMER manual).
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeItemLabel(type: string, layer?: number): number;

/**
 * Returns the mass for a model
 */
    Mass(): number;

/**
 * Calculates the Mass, CoG, and Intertia Tensor of the flagged items and returns an object with the above properties.
 * @param flag Calculate mass propetries of flagged items
 */
    MassPropCalc(flag: number): MassPropCalcReturn;

/**
 * Merge 2 models together to make a new model.
 * @param Master_Model Master Model for merge.
 * @param Slave_Model Slave Model for merge.
 * @param Option_to_fix_clashes Type of fix. Can be Model.INCREASE_SLAVE_ALWAYS, Model.INCREASE_SLAVE_CLASH, Model.DISCARD_SLAVE_CLASH, Model.INCREASE_MASTER_ALWAYS, Model.INCREASE_MASTER_CLASH or Model.DISCARD_MASTER_CLASH
 * @param Merge_nodes_flag If this flag is set to true, Primer will merge nodes after the model merge.
 * @param dist_required_if_merge_nodes_flag_used Nodes closer than dist will be potentially merged.
 * @param label Label to keep after merge. If &gt; 0 then highest label kept. If &lt;= 0 then lowest kept. If omitted the lowest label will be kept.
 * @param position Position to merge at. If &gt; 0 then merged at highest label position. If &lt; 0 then merged at lowest label position. If 0 then merged at midpoint. If omitted the merge will be done at the lowest label.
 */
    static Merge(Master_Model: Model, Slave_Model: Model, Option_to_fix_clashes?: number, Merge_nodes_flag?: boolean, dist_required_if_merge_nodes_flag_used?: number, label?: number, position?: number): Model;

/**
 * Attempts to merge nodes on items flagged with flag for this model in PRIMER. Merging nodes on *AIRBAG_SHELL_REFERENCE_GEOMETRY can be controlled by using Options.node_replace_asrg. Also see Node.Merge().
 * @param flag Flag set on items to merge nodes
 * @param dist Nodes closer than dist will be potentially merged.
 * @param label Label to keep after merge. If &gt; 0 then highest label kept. If &lt;= 0 then lowest kept. If omitted the lowest label will be kept.
 * @param position Position to merge at. If &gt; 0 then merged at highest label position. If &lt; 0 then merged at lowest label position. If 0 then merged at midpoint. If omitted the merge will be done at the lowest label.
 */
    MergeNodes(flag: number, dist: number, label?: number, position?: number): number;

/**
 * Returns the next free label for an item type in the model. Also see Model.FirstFreeItemLabel() and Model.LastFreeItemLabel().
 * @param type The type of the item (for a list of types see Appendix I of the PRIMER manual).
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeItemLabel(type: string, layer?: number): number;

/**
 * Populate the initial velocity field (nvels) for all nodes of the model
 */
    PopulateInitialVelocities(): void;

/**
 * Propagates the flagging for a model in PRIMER. For example if a part in the model is flagged, this will flag the elements in the part, the nodes on those elements... See also Model.ClearFlag(), Model.SetFlag(), global.AllocateFlag() and global.ReturnFlag().
 * @param flag Flag to propagate
 */
    PropagateFlag(flag: number): void;

/**
 * Reads a file into the first free model in PRIMER
 * @param filename Filename you want to read
 * @param filetype Filetype you want to read. Can be Model.LSDYNA, Model.ABAQUS, Model.NASTRAN, Model.RADIOSS or Model.IGES. If omitted the file is assumed to be a DYNA3D file. For Model.NASTRAN there are options that change how the model is read. See Options for details.
 * @param number Model number to read file into. If omitted the next free model number will be used.
 */
    static Read(filename: string, filetype?: number, number?: number): Model;

/**
 * Renumbers all of the items in the model.
 * @param start Start point for renumbering
 */
    RenumberAll(start: number): void;

/**
 * Renumbers all of the flagged items in the model.
 * @param flag Flag set on items that you want to renumber
 * @param start Start point for renumbering
 * @param mode Renumber mode. Can be Model.IGNORE_CLASH, Model.MOVE_CLASH_UP, Model.SHIFT_ALL_UP, or Model.RENUMBER_TO_FREE(Default),
 */
    RenumberFlagged(flag: number, start: number, mode?: number): void;

/**
 * Allows the user to select a model using standard PRIMER object menus. If there are no models in memory then Select returns null. If only one model is present then the model object is returned. If there is more than one model in memory then an object menu is mapped allowing the user to choose a model.
 * @param prompt Text to display as a prompt to the user
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(prompt: string, modal?: boolean): Model;

/**
 * Sets the colour of the model.
 * @param colour The colour you want to set the model to
 */
    SetColour(colour: number): void;

/**
 * Sets the flagging for a model in PRIMER. See also Model.PropagateFlag(), Model.ClearFlag(), global.AllocateFlag() and global.ReturnFlag().
 * @param flag Flag to set
 */
    SetFlag(flag: number): void;

/**
 * Shows a model in PRIMER
 */
    Show(): void;

/**
 * Returns the total number of models.
 */
    static Total(): number;

/**
 * Unblanks a model in PRIMER
 */
    Unblank(): void;

/**
 * Unblanks all models
 */
    static UnblankAll(): void;

/**
 * Unblanks all of the flagged items in the model.
 * @param flag Flag set on items that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    UnblankFlagged(flag: number, redraw?: boolean): void;

/**
 * Unsketches all of the sketched items in the model.
 * @param redraw If model should be redrawn or not after the items are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    UnsketchAll(redraw?: boolean): void;

/**
 * Updates the graphics for a model in PRIMER
 */
    UpdateGraphics(): void;

/**
 * Checks to see if a model uses large labels
 */
    UsesLargeLabels(): boolean;

/**
 * Writes a model in PRIMER to file
 * @param filename Filename of the LS-Dyna keyword file you want to write
 * @param options Options specifying how the file should be written out. If omitted the default values below will be used. The properties available are:
 */
    Write(filename: string, options?: WriteArgument_options): void;

/**
 * Create a new model in PRIMER
 * @param number Model number to create. If omitted the next free model number will be used.
 */
    constructor(number?: number);

/** If model is in binary then it will be 1(true) else 0(false). */
    readonly binary: boolean;
/** Comments stored at the top of the master model file. */
    comments: string;
/** If model is compressed then it will be 1(true) else 0(false). */
    readonly compress: boolean;
/** This option can be used to know the mode of compression. Can be Model.INDIVIDUAL_GZIP or Model.INDIVIDUAL_ZIP or Model.PACKAGED_ZIP */
    readonly compressMode: number;
/** Control cards for model. See Control for more details. */
    readonly control: Control;
/** Damping cards for model. See Damping for more details. */
    readonly damping: Damping;
/** Database cards for model. See Database for more details. */
    readonly database: Database;
/** If the beginning of the master file (*CONTROL etc) is in ascii then 1(true) else 0(false)(NOTE: If master file is ascii then fileStartAscii won't be checked and show 0(false)). */
    readonly fileStartAscii: boolean;
/** Name of file that model was read from (blank if model created) */
    readonly filename: string;
/** If ID flag set for *KEYWORD card */
    id: boolean;
/** The current layer for the model. This is the label of the Include file or 0 for the main file. See also Include.MakeCurrentLayer() */
    layer: number;
/** LoadBody cards for model. See LoadBody for more details. */
    readonly loadBody: LoadBody;
/** If master file is in ascii then 1(true) else 0(false). */
    readonly masterAscii: boolean;
/** Model num (for _ID) */
    num: string;
/** Model number */
    number: number;
/** Path that model was read from (blank if model created) */
    readonly path: string;
/** Model project (for _ID) */
    project: string;
/** Full path of the readlog file */
    readlog: string;
/** Model stage (for _ID) */
    stage: string;
/** Model title */
    title: string;
/** Model visibility flag */
    visible: boolean;
/** ABAQUS input file */
    static ABAQUS: number;
/** Uses the centre at centre of gravity in calculation of inertia properties. */
    static CENTRE_AT_COFG: number;
/** Keeps the keyout compression format same as that of what was read in. */
    static COMPRESS_KEEP: number;
/** Switches off compression during keyout. */
    static COMPRESS_OFF: number;
/** Switches on compression during keyout. */
    static COMPRESS_ON: number;
/** Merge option - discard master items only on clash */
    static DISCARD_MASTER_CLASH: number;
/** Merge option - discard slave items only on clash */
    static DISCARD_SLAVE_CLASH: number;
/** GLOBAL AXES */
    static GLOBAL_AXES: number;
/** IGES 5.3 geometry file */
    static IGES: number;
/** Renumber option - Ignore clashes. */
    static IGNORE_CLASH: number;
/** Merge option - increase master items always */
    static INCREASE_MASTER_ALWAYS: number;
/** Merge option - increase master items only on clash */
    static INCREASE_MASTER_CLASH: number;
/** Merge option - increase slave items always */
    static INCREASE_SLAVE_ALWAYS: number;
/** Merge option - increase slave items only on clash */
    static INCREASE_SLAVE_CLASH: number;
/** Each file 'name.key' is 'gzipped' to become the individual file 'name.key.gz' */
    static INDIVIDUAL_GZIP: number;
/** Each file 'name.key' is 'zipped' to become the individual file 'name.key.zip' */
    static INDIVIDUAL_ZIP: number;
/** Each file 'name.key' is written using its original compression: uncompressed, '.gz. or '.zip' format */
    static KEEP_ORIGINAL: number;
/** LOCAL AXES */
    static LOCAL_AXES: number;
/** LS-DYNA keyword file */
    static LSDYNA: number;
/** Renumber option - Move clashing &gt; higest label. */
    static MOVE_CLASH_UP: number;
/** NASTRAN bulk data file */
    static NASTRAN: number;
/** Suitable for models with include files where the entire model is packed into a single .zip file, preserving its directory structure. */
    static PACKAGED_ZIP: number;
/** PRINCIPAL AXES */
    static PRINCIPAL_AXES: number;
/** RADIOSS block format file */
    static RADIOSS: number;
/** Only deletes items within the include selected but may remove items from sets in other includes. */
    static REMOVE_FROM_SETS: number;
/** Only deletes items within the include selected without removing items from sets in other includes. */
    static REMOVE_INCLUDE_ONLY: number;
/** Delete items in other includes if they 'belong' to items in this include file but are considered to be 'junior' in the standard PRIMER hierarchy. */
    static REMOVE_JUNIOR: number;
/** Renumber option - Renumber to next free label. */
    static RENUMBER_TO_FREE: number;
/** Renumber option - Shift upwards to make space. */
    static SHIFT_ALL_UP: number;
/** Uses the user defined centre in calculation of inertia properties. */
    static USER_DEFINED_CENTRE: number;
}


/** Object function argument in MorphBox constructor */
interface MorphBox_constructor_Argument_options {
    /** Coordinate system for local coordinates. Leave undefined if using global coordinates or if local coordinate system defined with n1, n2 and n3. */
    csys?: number;
    /** Node 1 label for local coordinate. Leave undefined if using global coordinates or if local coordinate system defined with csys. */
    n1?: number;
    /** Node 2 label for local coordinate. Leave undefined if using global coordinates or if local coordinate system defined with csys. */
    n2?: number;
    /** Node 3 label for local coordinate. Leave undefined if using global coordinates or if local coordinate system defined with csys. */
    n3?: number;
    /** Number of points in X direction of box (assumed to be 2 for linear box if omitted) */
    nx?: number;
    /** Number of points in Y direction of box (assumed to be 2 for linear box if omitted) */
    ny?: number;
    /** Number of points in Z direction of box (assumed to be 2 for linear box if omitted) */
    nz?: number;
    /** Array of integers of depth 3 containing the morph point IDs. This should be omitted in the (default) case of also creating new morph points together with the morph box at the locations based on the bounding box of the flagged items. If this array contains 'nx' by 'ny' by 'nz' existing morph points, the morph box is attached to these points, and 'csys', 'n1', 'n2', 'n3' will be irrelevant. Each 'points[i][j][k]' should contain the morph point ID to be added at index i in local X direction, index j in local Y direction and index k in local Z direction. The box will then still contain flagged nodes only, but nodes geometrically outside the volume of the morph points will not be included either. */
    points?: number[];
}

declare class MorphBox {
/**
 * Recalculates the X, Y and Z coordinates of all nodes linked to the morph box by the *SET_NODE_COLUMN. This should be called when coordinates of morph points have changed and you wish to apply the morphing. If several morph point positions on the same box change, then it is more speed-efficient to call this function only once for the box.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to apply the morphing to several boxes and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using Model.UpdateGraphics().
 */
    ApplyMorphing(redraw?: boolean): void;

/**
 * Blanks the box
 */
    Blank(): void;

/**
 * Blanks all of the boxs in the model.
 * @param Model Model that all boxs will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged boxs in the model.
 * @param Model Model that all the flagged boxs will be blanked in
 * @param flag Flag set on the boxs that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the box is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the box.
 * @param flag Flag to clear on the box
 */
    ClearFlag(flag: number): void;

/**
 * Copies the box.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): MorphBox;

/**
 * Adds an error for box. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first box in the model.
 * @param Model Model to get first box in
 */
    static First(Model: Model): MorphBox;

/**
 * Returns the first free box label in the model. Also see MorphBox.LastFreeLabel(), MorphBox.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free box label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the boxs in the model with a defined flag.
 * @param Model Model that all boxs will be flagged in
 * @param flag Flag to set on the boxs
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Flags all connections, in a given model, that have been morphed since their last remake. This includes connections that have been morphed by a morph box that has since been deleted.
 * @param model Model containing desired connections.
 * @param flag Flag to mark morphed connections.
 */
    static FlagAllMorphedConnections(model: Model, flag: number): boolean;

/**
 * Flags all connections that have been morphed, by a givine morph box, since their last remake. A connection could be morphed by one morph box and not another, therefore calling this function on two boxes that share a connection may produce different results depending on which box the function is called for. E.g. morb1 and morb2 share conx1, morb1 gets morphed whereas morb2 remains unchanged. Calling this function for morb1 will flag conx1, however calling the function for morb2 won't flag conx1.
 * @param flag Flag to mark morphed connections.
 */
    FlagMorphedConnections(flag: number): boolean;

/**
 * Checks if the box is flagged or not.
 * @param flag Flag to test on the box
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each box in the model. Note that ForEach has been designed to make looping over boxs as fast as possible and so has some limitations. Firstly, a single temporary MorphBox object is created and on each function call it is updated with the current box data. This means that you should not try to store the MorphBox object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boxs inside a ForEach loop. 
 * @param Model Model that all boxs are in
 * @param func Function to call for each box
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of MorphBox objects for all of the boxs in a model in Primer
 * @param Model Model to get boxs from
 */
    static GetAll(Model: Model): MorphBox[];

/**
 * Returns an array of MorphBox objects for all of the flagged boxs in a model in Primer
 * @param Model Model to get boxs from
 * @param flag Flag set on the boxs that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): MorphBox[];

/**
 * Returns the MorphBox object for a box ID.
 * @param Model Model to find the box in
 * @param number number of the box you want the MorphBox object for
 */
    static GetFromID(Model: Model, number: number): MorphBox;

/**
 * Checks if a MorphBox property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the MorphBox.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop box property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the morph point ID on the morph box at indices in X, Y and Z directions.
 * @param xindex Index of the point in X direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric X coordinate and box.nx-1 for the points with the highest X.
 * @param yindex Index of the point in Y direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric Y coordinate and box.ny-1 for the points with the highest Y.
 * @param zindex Index of the point in Z direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric Z coordinate and box.nz-1 for the points with the highest Z.
 */
    GetPoint(xindex: number, yindex: number, zindex: number): number;

/**
 * Returns the keyword for this morph box (*MORPH_BOX or *MORPH_BOX_HIGH_ORDER). Note that a carriage return is not added. See also MorphBox.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the morph box. Note that a carriage return is not added. See also MorphBox.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last box in the model.
 * @param Model Model to get last box in
 */
    static Last(Model: Model): MorphBox;

/**
 * Returns the last free box label in the model. Also see MorphBox.FirstFreeLabel(), MorphBox.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free box label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next box in the model.
 */
    Next(): MorphBox;

/**
 * Returns the next free (highest+1) box label in the model. Also see MorphBox.FirstFreeLabel(), MorphBox.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free box label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a box.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boxs from that model can be picked. If the argument is a Flag then only boxs that are flagged with limit can be selected. If omitted, or null, any boxs from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): MorphBox;

/**
 * Returns the previous box in the model.
 */
    Previous(): MorphBox;

/**
 * Renumbers all of the boxs in the model.
 * @param Model Model that all boxs will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged boxs in the model.
 * @param Model Model that all the flagged boxs will be renumbered in
 * @param flag Flag set on the boxs that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Resets the morph box to its initial position and updates the coordinates of all its nodes.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to reset several boxes and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using Model.UpdateGraphics().
 */
    Reset(redraw?: boolean): void;

/**
 * Allows the user to select boxs using standard PRIMER object menus.
 * @param flag Flag to use when selecting boxs
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boxs from that model can be selected. If the argument is a Flag then only boxs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boxs can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the box.
 * @param flag Flag to set on the box
 */
    SetFlag(flag: number): void;

/**
 * Turns Morph Connections on/off.
 * @param status true turns Morph Connections on. false turns Morph Connections off.
 */
    static SetMorphConnections(status: boolean): void;

/**
 * Replaces the morph point ID on the array, whose size depends on the orders in X, Y and Z directions, with the given new ID.
 * @param xindex Index of the point in X direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric X coordinate and box.nx-1 for the points with the highest X.
 * @param yindex Index of the point in Y direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric Y coordinate and box.ny-1 for the points with the highest Y.
 * @param zindex Index of the point in Z direction. Note that indices start at 0, so it should be 0 for the points with the smallest parameteric Z coordinate and box.nz-1 for the points with the highest Z.
 * @param id New MorphPoint id.
 */
    SetPointID(xindex: number, yindex: number, zindex: number, id: number): void;

/**
 * Sketches the box. The box will be sketched until you either call MorphBox.Unsketch(), MorphBox.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the box is sketched. If omitted redraw is true. If you want to sketch several boxs and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged boxs in the model. The boxs will be sketched until you either call MorphBox.Unsketch(), MorphBox.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged boxs will be sketched in
 * @param flag Flag set on the boxs that you want to sketch
 * @param redraw If model should be redrawn or not after the boxs are sketched. If omitted redraw is true. If you want to sketch flagged boxs several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of boxs in the model.
 * @param Model Model to get total for
 * @param exists true if only existing boxs should be counted. If false or omitted referenced but undefined boxs will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the box
 */
    Unblank(): void;

/**
 * Unblanks all of the boxs in the model.
 * @param Model Model that all boxs will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged boxs in the model.
 * @param Model Model that the flagged boxs will be unblanked in
 * @param flag Flag set on the boxs that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the boxs in the model.
 * @param Model Model that the defined flag for all boxs will be unset in
 * @param flag Flag to unset on the boxs
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the box.
 * @param redraw If model should be redrawn or not after the box is unsketched. If omitted redraw is true. If you want to unsketch several boxs and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all boxs.
 * @param Model Model that all boxs will be unblanked in
 * @param redraw If model should be redrawn or not after the boxs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged boxs in the model.
 * @param Model Model that all boxs will be unsketched in
 * @param flag Flag set on the boxs that you want to unsketch
 * @param redraw If model should be redrawn or not after the boxs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Recalculates parametric X, Y, Z coordinates for each node in the *SET_NODE_COLUMN associated with the morph box. This needs to be called whenever morph points on the box or their coordinates have been changed manually and you wish to keep all nodes at their intrinsic global X, Y, Z coordinates. Provided Morph Connections is on (see MorphBox.SetMorphConnections()), this will also force PRIMER to recalculate the parametric coordinates for any connections in the morph box next time one of its morph points is moved.
 */
    UpdateParametricCoordinates(): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): MorphBox;

/**
 * Adds a warning for box. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this box.
 */
    Xrefs(): Xrefs;

/**
 * Create a new MorphBox object around flagged items.
 * @param Model Model that morph box will be created in
 * @param label MorphBox number
 * @param flag Flag set on the entities (for example nodes, elements and/or parts) that you want to create the box around
 * @param options Options to create the box. Currently the only available properties are:
 */
    constructor(Model: Model, label: number, flag: number, options?: MorphBox_constructor_Argument_options);

/**
 * Creates a string containing the morph box data in keyword format. Note that this contains the keyword header and the keyword cards. See also MorphBox.Keyword() and MorphBox.KeywordCards().
 */
    toString(): string;

/** true if morph box exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the morph box is in. */
    include: number;
/** MorphBox number. */
    label: number;
/** The Model number that the box is in. */
    model: number;
/** Number of morph points in parametric X direction (read only) */
    readonly nx: number;
/** Number of morph points in parametric Y direction (read only) */
    readonly ny: number;
/** Number of morph points in parametric Z direction (read only) */
    readonly nz: number;
/** ID for node set of nodes dragged with the box (read only). This will be a *SET_NODE_COLUMN containing the nodes together with their parametric coordinates in X, Y, Z. It is strongly discouraged to edit the contents of this set or the column data manually. */
    readonly setid: number;
}

declare class MorphFlow {
/**
 * Blanks the flow
 */
    Blank(): void;

/**
 * Blanks all of the flows in the model.
 * @param Model Model that all flows will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged flows in the model.
 * @param Model Model that all the flagged flows will be blanked in
 * @param flag Flag set on the flows that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the flow is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the flow.
 * @param flag Flag to clear on the flow
 */
    ClearFlag(flag: number): void;

/**
 * Copies the flow.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): MorphFlow;

/**
 * Starts an interactive editing panel to create a morph flow card.
 * @param Model Model that the morph flow card will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): MorphFlow;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for flow. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first flow in the model.
 * @param Model Model to get first flow in
 */
    static First(Model: Model): MorphFlow;

/**
 * Flags all of the flows in the model with a defined flag.
 * @param Model Model that all flows will be flagged in
 * @param flag Flag to set on the flows
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the flow is flagged or not.
 * @param flag Flag to test on the flow
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each flow in the model. Note that ForEach has been designed to make looping over flows as fast as possible and so has some limitations. Firstly, a single temporary MorphFlow object is created and on each function call it is updated with the current flow data. This means that you should not try to store the MorphFlow object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new flows inside a ForEach loop. 
 * @param Model Model that all flows are in
 * @param func Function to call for each flow
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of MorphFlow objects for all of the flows in a model in Primer
 * @param Model Model to get flows from
 */
    static GetAll(Model: Model): MorphFlow[];

/**
 * Returns an array of MorphFlow objects for all of the flagged flows in a model in Primer
 * @param Model Model to get flows from
 * @param flag Flag set on the flows that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): MorphFlow[];

/**
 * Returns the MorphFlow object for a flow ID.
 * @param Model Model to find the flow in
 * @param number number of the flow you want the MorphFlow object for
 */
    static GetFromID(Model: Model, number: number): MorphFlow;

/**
 * Returns the stored MorphFlow object for a morph flow name. WARNING: This assumes that there is at most one morph flow with a given name. Otherwise this function only returns the first occurrence.
 * @param Model Model to find the morph flow in
 * @param morph_flow_name name of the morph flow you want the MorphFlow object for
 */
    static GetFromName(Model: Model, morph_flow_name: string): MorphFlow;

/**
 * Checks if a MorphFlow property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the MorphFlow.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop flow property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the data for a row in the morph flow.
 * @param row The row you want the data for. Note row indices start at 0.
 */
    GetRow(row: number): number[];

/**
 * Get the value at given index on the morph flow with type "DISCRETE".
 * @param index The index where you are extracting the value. Note row indices start at 0.
 */
    GetValue(index: number): number;

/**
 * Returns the keyword for this morph flow (*MORPH_FLOW). Note that a carriage return is not added. See also MorphFlow.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the morph flow. Note that a carriage return is not added. See also MorphFlow.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last flow in the model.
 * @param Model Model to get last flow in
 */
    static Last(Model: Model): MorphFlow;

/**
 * Returns the next flow in the model.
 */
    Next(): MorphFlow;

/**
 * Allows the user to pick a flow.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only flows from that model can be picked. If the argument is a Flag then only flows that are flagged with limit can be selected. If omitted, or null, any flows from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): MorphFlow;

/**
 * Returns the previous flow in the model.
 */
    Previous(): MorphFlow;

/**
 * Removes the data (a morph point ID and its three vector components) for a row in *MORPH_FLOW.
 * @param row The row you want to remove the data for. Note that row indices start at 0.
 */
    RemoveRow(row: number): void;

/**
 * Removes the value at given index in *MORPH_FLOW with type "DISCRETE".
 * @param index The index where you are removing the value. Note that indices start at 0.
 */
    RemoveValue(index: number): void;

/**
 * Allows the user to select flows using standard PRIMER object menus.
 * @param flag Flag to use when selecting flows
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only flows from that model can be selected. If the argument is a Flag then only flows that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any flows can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the flow.
 * @param flag Flag to set on the flow
 */
    SetFlag(flag: number): void;

/**
 * Sets the data for a row in *MORPH_FLOW.
 * @param row The row you want to set the data for. Note that row indices start at 0.
 * @param data The data you want to set the row to. It should be of length 4 having the morph point ID at index 0, and the vector components at indices 1, 2, 3.
 */
    SetRow(row: number, data: number[]): void;

/**
 * Sets the value at given index in a *MORPH_FLOW with type "DISCRETE".
 * @param index The row you want to set the data for. Note that row indices start at 0.
 * @param value The new value to insert into the list.
 */
    SetValue(index: number, value: number): void;

/**
 * Sketches the flow. The flow will be sketched until you either call MorphFlow.Unsketch(), MorphFlow.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the flow is sketched. If omitted redraw is true. If you want to sketch several flows and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged flows in the model. The flows will be sketched until you either call MorphFlow.Unsketch(), MorphFlow.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged flows will be sketched in
 * @param flag Flag set on the flows that you want to sketch
 * @param redraw If model should be redrawn or not after the flows are sketched. If omitted redraw is true. If you want to sketch flagged flows several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of flows in the model.
 * @param Model Model to get total for
 * @param exists true if only existing flows should be counted. If false or omitted referenced but undefined flows will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the flow
 */
    Unblank(): void;

/**
 * Unblanks all of the flows in the model.
 * @param Model Model that all flows will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged flows in the model.
 * @param Model Model that the flagged flows will be unblanked in
 * @param flag Flag set on the flows that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the flows in the model.
 * @param Model Model that the defined flag for all flows will be unset in
 * @param flag Flag to unset on the flows
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the flow.
 * @param redraw If model should be redrawn or not after the flow is unsketched. If omitted redraw is true. If you want to unsketch several flows and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all flows.
 * @param Model Model that all flows will be unblanked in
 * @param redraw If model should be redrawn or not after the flows are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged flows in the model.
 * @param Model Model that all flows will be unsketched in
 * @param flag Flag set on the flows that you want to unsketch
 * @param redraw If model should be redrawn or not after the flows are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): MorphFlow;

/**
 * Adds a warning for flow. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this flow.
 */
    Xrefs(): Xrefs;

/**
 * Create a new MorphFlow object.
 * @param Model Model that morph flow will be created in
 * @param name MorphFlow name
 */
    constructor(Model: Model, name: string);

/**
 * Creates a string containing the morph flow data in keyword format. Note that this contains the keyword header and the keyword cards. See also MorphFlow.Keyword() and MorphFlow.KeywordCards().
 */
    toString(): string;

/** true if morph flow exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the morph flow is in. */
    include: number;
/** Maximum value for type set to "CONTINUOUS" or "STEP" when written as design variable for LS-OPT. */
    max: number;
/** Minimum value for type set to "CONTINUOUS" or "STEP" when written as design variable for LS-OPT. */
    min: number;
/** The Model number that the flow is in. */
    model: number;
/** Name of the morph flow. If the flow is used for applying LS-OPT variables, this should match the variable name in the listing file written by LS-OPT. */
    name: string;
/** Number of morph points referenced by the flow. (read only) */
    readonly npoints: number;
/** Number of values in the list when type is set to "DISCRETE". (read only) */
    readonly nvals: number;
/** Step size for type set to "STEP" when written as design variable for LS-OPT. */
    step: number;
/** Range type for the morph flow. This should be "CONTINUOUS", "STEP" or "DISCRETE" and may be used for LS-OPT when writing design variable files from morph flows. */
    type: string;
}

declare class MorphPoint {
/**
 * Blanks the point
 */
    Blank(): void;

/**
 * Blanks all of the points in the model.
 * @param Model Model that all points will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged points in the model.
 * @param Model Model that all the flagged points will be blanked in
 * @param flag Flag set on the points that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the point is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the point.
 * @param flag Flag to clear on the point
 */
    ClearFlag(flag: number): void;

/**
 * Copies the point.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): number;

/**
 * Adds an error for point. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first point in the model.
 * @param Model Model to get first point in
 */
    static First(Model: Model): number;

/**
 * Returns the first free point label in the model. Also see MorphPoint.LastFreeLabel(), MorphPoint.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free point label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the points in the model with a defined flag.
 * @param Model Model that all points will be flagged in
 * @param flag Flag to set on the points
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the point is flagged or not.
 * @param flag Flag to test on the point
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each point in the model. Note that ForEach has been designed to make looping over points as fast as possible and so has some limitations. Firstly, a single temporary MorphPoint object is created and on each function call it is updated with the current point data. This means that you should not try to store the MorphPoint object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new points inside a ForEach loop. 
 * @param Model Model that all points are in
 * @param func Function to call for each point
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of MorphPoint objects for all of the points in a model in Primer
 * @param Model Model to get points from
 */
    static GetAll(Model: Model): number[];

/**
 * Returns an array of MorphPoint objects for all of the flagged points in a model in Primer
 * @param Model Model to get points from
 * @param flag Flag set on the points that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): number[];

/**
 * Returns the MorphPoint object for a point ID.
 * @param Model Model to find the point in
 * @param number number of the point you want the MorphPoint object for
 */
    static GetFromID(Model: Model, number: number): number;

/**
 * Checks if a MorphPoint property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the MorphPoint.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop point property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this morph point (*MORPH_POINT). Note that a carriage return is not added. See also MorphPoint.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the morph point. Note that a carriage return is not added. See also MorphPoint.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last point in the model.
 * @param Model Model to get last point in
 */
    static Last(Model: Model): number;

/**
 * Returns the last free point label in the model. Also see MorphPoint.FirstFreeLabel(), MorphPoint.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free point label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * This function moves a selection of flagged morph points by a given vector and interpolates the movement of other morph points in the same way as this happens on the interactive morph panel. Note that the interpolation depends on the settings which can be switched on the interactive morph panel or by preferences. To apply the movement to the nodes in the box(es), you will need to call MorphBox.ApplyMorphing() at least for all relevant boxes or (if that is easier) for all morph boxes in the model.
 * @param Model Model that the flagged morph points are in
 * @param flag Flag set on the morph points explicitly selected to move
 * @param dx X component of vector to be moved along
 * @param dy Y component of vector to be moved along
 * @param dz Z component of vector to be moved along
 */
    static MoveFlagged(Model: Model, flag: number, dx: number, dy: number, dz: number): void;

/**
 * Returns the next point in the model.
 */
    Next(): number;

/**
 * Returns the next free (highest+1) point label in the model. Also see MorphPoint.FirstFreeLabel(), MorphPoint.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free point label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a point.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only points from that model can be picked. If the argument is a Flag then only points that are flagged with limit can be selected. If omitted, or null, any points from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): number;

/**
 * Returns the previous point in the model.
 */
    Previous(): number;

/**
 * Renumbers all of the points in the model.
 * @param Model Model that all points will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged points in the model.
 * @param Model Model that all the flagged points will be renumbered in
 * @param flag Flag set on the points that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select points using standard PRIMER object menus.
 * @param flag Flag to use when selecting points
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only points from that model can be selected. If the argument is a Flag then only points that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any points can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the point.
 * @param flag Flag to set on the point
 */
    SetFlag(flag: number): void;

/**
 * Sketches the point. The point will be sketched until you either call MorphPoint.Unsketch(), MorphPoint.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the point is sketched. If omitted redraw is true. If you want to sketch several points and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged points in the model. The points will be sketched until you either call MorphPoint.Unsketch(), MorphPoint.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged points will be sketched in
 * @param flag Flag set on the points that you want to sketch
 * @param redraw If model should be redrawn or not after the points are sketched. If omitted redraw is true. If you want to sketch flagged points several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of points in the model.
 * @param Model Model to get total for
 * @param exists true if only existing points should be counted. If false or omitted referenced but undefined points will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the point
 */
    Unblank(): void;

/**
 * Unblanks all of the points in the model.
 * @param Model Model that all points will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged points in the model.
 * @param Model Model that the flagged points will be unblanked in
 * @param flag Flag set on the points that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the points in the model.
 * @param Model Model that the defined flag for all points will be unset in
 * @param flag Flag to unset on the points
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the point.
 * @param redraw If model should be redrawn or not after the point is unsketched. If omitted redraw is true. If you want to unsketch several points and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all points.
 * @param Model Model that all points will be unblanked in
 * @param redraw If model should be redrawn or not after the points are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged points in the model.
 * @param Model Model that all points will be unsketched in
 * @param flag Flag set on the points that you want to unsketch
 * @param redraw If model should be redrawn or not after the points are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): number;

/**
 * Adds a warning for point. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this point.
 */
    Xrefs(): Xrefs;

/**
 * Create a new MorphPoint object.
 * @param Model Model that morph point will be created in
 * @param label MorphPoint number
 * @param x X coordinate
 * @param y Y coordinate
 * @param z Z coordinate
 */
    constructor(Model: Model, label: number, x: number, y: number, z: number);

/**
 * Creates a string containing the morph point data in keyword format. Note that this contains the keyword header and the keyword cards. See also MorphPoint.Keyword() and MorphPoint.KeywordCards().
 */
    toString(): string;

/** true if morph point exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the morph point is in. */
    include: number;
/** MorphPoint number. */
    label: number;
/** The Model number that the point is in. */
    model: number;
/** X coordinate */
    x: number;
/** Y coordinate */
    y: number;
/** Z coordinate */
    z: number;
}

declare class NodalForceGroup {
/**
 * Blanks the nodal force group
 */
    Blank(): void;

/**
 * Blanks all of the nodal force groups in the model.
 * @param Model Model that all nodal force groups will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged nodal force groups in the model.
 * @param Model Model that all the flagged nodal force groups will be blanked in
 * @param flag Flag set on the nodal force groups that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the nodal force group is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the nodal force group.
 * @param flag Flag to clear on the nodal force group
 */
    ClearFlag(flag: number): void;

/**
 * Copies the nodal force group.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): NodalForceGroup;

/**
 * Adds an error for nodal force group. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first nodal force group in the model.
 * @param Model Model to get first nodal force group in
 */
    static First(Model: Model): NodalForceGroup;

/**
 * Flags all of the nodal force groups in the model with a defined flag.
 * @param Model Model that all nodal force groups will be flagged in
 * @param flag Flag to set on the nodal force groups
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the nodal force group is flagged or not.
 * @param flag Flag to test on the nodal force group
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each nodal force group in the model. Note that ForEach has been designed to make looping over nodal force groups as fast as possible and so has some limitations. Firstly, a single temporary NodalForceGroup object is created and on each function call it is updated with the current nodal force group data. This means that you should not try to store the NodalForceGroup object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new nodal force groups inside a ForEach loop. 
 * @param Model Model that all nodal force groups are in
 * @param func Function to call for each nodal force group
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of NodalForceGroup objects for all of the nodal force groups in a model in Primer
 * @param Model Model to get nodal force groups from
 */
    static GetAll(Model: Model): NodalForceGroup[];

/**
 * Returns an array of NodalForceGroup objects for all of the flagged nodal force groups in a model in Primer
 * @param Model Model to get nodal force groups from
 * @param flag Flag set on the nodal force groups that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): NodalForceGroup[];

/**
 * Returns the NodalForceGroup object for a nodal force group ID.
 * @param Model Model to find the nodal force group in
 * @param number number of the nodal force group you want the NodalForceGroup object for
 */
    static GetFromID(Model: Model, number: number): NodalForceGroup;

/**
 * Checks if a NodalForceGroup property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the NodalForceGroup.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop nodal force group property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this nodal force group. Note that a carriage return is not added. See also NodalForceGroup.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the nodal force group. Note that a carriage return is not added. See also NodalForceGroup.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last nodal force group in the model.
 * @param Model Model to get last nodal force group in
 */
    static Last(Model: Model): NodalForceGroup;

/**
 * Returns the next nodal force group in the model.
 */
    Next(): NodalForceGroup;

/**
 * Allows the user to pick a nodal force group.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only nodal force groups from that model can be picked. If the argument is a Flag then only nodal force groups that are flagged with limit can be selected. If omitted, or null, any nodal force groups from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): NodalForceGroup;

/**
 * Returns the previous nodal force group in the model.
 */
    Previous(): NodalForceGroup;

/**
 * Allows the user to select nodal force groups using standard PRIMER object menus.
 * @param flag Flag to use when selecting nodal force groups
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only nodal force groups from that model can be selected. If the argument is a Flag then only nodal force groups that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any nodal force groups can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the nodal force group.
 * @param flag Flag to set on the nodal force group
 */
    SetFlag(flag: number): void;

/**
 * Sketches the nodal force group. The nodal force group will be sketched until you either call NodalForceGroup.Unsketch(), NodalForceGroup.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the nodal force group is sketched. If omitted redraw is true. If you want to sketch several nodal force groups and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged nodal force groups in the model. The nodal force groups will be sketched until you either call NodalForceGroup.Unsketch(), NodalForceGroup.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged nodal force groups will be sketched in
 * @param flag Flag set on the nodal force groups that you want to sketch
 * @param redraw If model should be redrawn or not after the nodal force groups are sketched. If omitted redraw is true. If you want to sketch flagged nodal force groups several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of nodal force groups in the model.
 * @param Model Model to get total for
 * @param exists true if only existing nodal force groups should be counted. If false or omitted referenced but undefined nodal force groups will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the nodal force group
 */
    Unblank(): void;

/**
 * Unblanks all of the nodal force groups in the model.
 * @param Model Model that all nodal force groups will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged nodal force groups in the model.
 * @param Model Model that the flagged nodal force groups will be unblanked in
 * @param flag Flag set on the nodal force groups that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the nodal force groups in the model.
 * @param Model Model that the defined flag for all nodal force groups will be unset in
 * @param flag Flag to unset on the nodal force groups
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the nodal force group.
 * @param redraw If model should be redrawn or not after the nodal force group is unsketched. If omitted redraw is true. If you want to unsketch several nodal force groups and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all nodal force groups.
 * @param Model Model that all nodal force groups will be unblanked in
 * @param redraw If model should be redrawn or not after the nodal force groups are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged nodal force groups in the model.
 * @param Model Model that all nodal force groups will be unsketched in
 * @param flag Flag set on the nodal force groups that you want to unsketch
 * @param redraw If model should be redrawn or not after the nodal force groups are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): NodalForceGroup;

/**
 * Adds a warning for nodal force group. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this nodal force group.
 */
    Xrefs(): Xrefs;

/**
 * Create a new NodalForceGroup object.
 * @param Model Model that nodal force group will be created in
 * @param nsid Set Node Set ID.
 * @param cid Coordinate System ID.
 */
    constructor(Model: Model, nsid: number, cid?: number);

/**
 * Creates a string containing the nodal force group data in keyword format. Note that this contains the keyword header and the keyword cards. See also NodalForceGroup.Keyword() and NodalForceGroup.KeywordCards().
 */
    toString(): string;

/** Coordinate System ID. */
    cid: number;
/** true if Nodal Force Group exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Database Nodal Force Group number (identical to label). */
    id: number;
/** The Include file number that the Nodal Force Group is in. */
    include: number;
/** Database Nodal Force Group number. */
    label: number;
/** The Model number that the nodal force group is in. */
    model: number;
/** Set Node Set ID. */
    nsid: number;
}

declare class NodalRigidBody {
/**
 * Blanks the nodal rigid body
 */
    Blank(): void;

/**
 * Blanks all of the nodal rigid bodys in the model.
 * @param Model Model that all nodal rigid bodys will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged nodal rigid bodys in the model.
 * @param Model Model that all the flagged nodal rigid bodys will be blanked in
 * @param flag Flag set on the nodal rigid bodys that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the nodal rigid body is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the nodal rigid body.
 * @param flag Flag to clear on the nodal rigid body
 */
    ClearFlag(flag: number): void;

/**
 * Copies the nodal rigid body.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): NodalRigidBody;

/**
 * Starts an interactive editing panel to create a nrb.
 * @param Model Model that the nrb will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): NodalRigidBody;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for nodal rigid body. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first nodal rigid body in the model.
 * @param Model Model to get first nodal rigid body in
 */
    static First(Model: Model): NodalRigidBody;

/**
 * Returns the first free nodal rigid body label in the model. Also see NodalRigidBody.LastFreeLabel(), NodalRigidBody.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free nodal rigid body label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the nodal rigid bodys in the model with a defined flag.
 * @param Model Model that all nodal rigid bodys will be flagged in
 * @param flag Flag to set on the nodal rigid bodys
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the nodal rigid body is flagged or not.
 * @param flag Flag to test on the nodal rigid body
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each nodal rigid body in the model. Note that ForEach has been designed to make looping over nodal rigid bodys as fast as possible and so has some limitations. Firstly, a single temporary NodalRigidBody object is created and on each function call it is updated with the current nodal rigid body data. This means that you should not try to store the NodalRigidBody object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new nodal rigid bodys inside a ForEach loop. 
 * @param Model Model that all nodal rigid bodys are in
 * @param func Function to call for each nodal rigid body
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of NodalRigidBody objects for all of the nodal rigid bodys in a model in Primer
 * @param Model Model to get nodal rigid bodys from
 */
    static GetAll(Model: Model): NodalRigidBody[];

/**
 * Returns an array of NodalRigidBody objects for all of the flagged nodal rigid bodys in a model in Primer
 * @param Model Model to get nodal rigid bodys from
 * @param flag Flag set on the nodal rigid bodys that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): NodalRigidBody[];

/**
 * Returns the NodalRigidBody object for a nodal rigid body ID.
 * @param Model Model to find the nodal rigid body in
 * @param number number of the nodal rigid body you want the NodalRigidBody object for
 */
    static GetFromID(Model: Model, number: number): NodalRigidBody;

/**
 * Checks if a NodalRigidBody property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the NodalRigidBody.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop nodal rigid body property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this nrb (*CONSTRAINED_NODAL_RIGID_BODY_xxxx). Note that a carriage return is not added. See also NodalRigidBody.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the nrb. Note that a carriage return is not added. See also NodalRigidBody.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last nodal rigid body in the model.
 * @param Model Model to get last nodal rigid body in
 */
    static Last(Model: Model): NodalRigidBody;

/**
 * Returns the last free nodal rigid body label in the model. Also see NodalRigidBody.FirstFreeLabel(), NodalRigidBody.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free nodal rigid body label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next nodal rigid body in the model.
 */
    Next(): NodalRigidBody;

/**
 * Returns the next free (highest+1) nodal rigid body label in the model. Also see NodalRigidBody.FirstFreeLabel(), NodalRigidBody.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free nodal rigid body label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a nodal rigid body.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only nodal rigid bodys from that model can be picked. If the argument is a Flag then only nodal rigid bodys that are flagged with limit can be selected. If omitted, or null, any nodal rigid bodys from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): NodalRigidBody;

/**
 * Returns the previous nodal rigid body in the model.
 */
    Previous(): NodalRigidBody;

/**
 * Renumbers all of the nodal rigid bodys in the model.
 * @param Model Model that all nodal rigid bodys will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged nodal rigid bodys in the model.
 * @param Model Model that all the flagged nodal rigid bodys will be renumbered in
 * @param flag Flag set on the nodal rigid bodys that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select nodal rigid bodys using standard PRIMER object menus.
 * @param flag Flag to use when selecting nodal rigid bodys
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only nodal rigid bodys from that model can be selected. If the argument is a Flag then only nodal rigid bodys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any nodal rigid bodys can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the nodal rigid body.
 * @param flag Flag to set on the nodal rigid body
 */
    SetFlag(flag: number): void;

/**
 * Sketches the nodal rigid body. The nodal rigid body will be sketched until you either call NodalRigidBody.Unsketch(), NodalRigidBody.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the nodal rigid body is sketched. If omitted redraw is true. If you want to sketch several nodal rigid bodys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged nodal rigid bodys in the model. The nodal rigid bodys will be sketched until you either call NodalRigidBody.Unsketch(), NodalRigidBody.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged nodal rigid bodys will be sketched in
 * @param flag Flag set on the nodal rigid bodys that you want to sketch
 * @param redraw If model should be redrawn or not after the nodal rigid bodys are sketched. If omitted redraw is true. If you want to sketch flagged nodal rigid bodys several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of nodal rigid bodys in the model.
 * @param Model Model to get total for
 * @param exists true if only existing nodal rigid bodys should be counted. If false or omitted referenced but undefined nodal rigid bodys will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the nodal rigid body
 */
    Unblank(): void;

/**
 * Unblanks all of the nodal rigid bodys in the model.
 * @param Model Model that all nodal rigid bodys will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged nodal rigid bodys in the model.
 * @param Model Model that the flagged nodal rigid bodys will be unblanked in
 * @param flag Flag set on the nodal rigid bodys that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the nodal rigid bodys in the model.
 * @param Model Model that the defined flag for all nodal rigid bodys will be unset in
 * @param flag Flag to unset on the nodal rigid bodys
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the nodal rigid body.
 * @param redraw If model should be redrawn or not after the nodal rigid body is unsketched. If omitted redraw is true. If you want to unsketch several nodal rigid bodys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all nodal rigid bodys.
 * @param Model Model that all nodal rigid bodys will be unblanked in
 * @param redraw If model should be redrawn or not after the nodal rigid bodys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged nodal rigid bodys in the model.
 * @param Model Model that all nodal rigid bodys will be unsketched in
 * @param flag Flag set on the nodal rigid bodys that you want to unsketch
 * @param redraw If model should be redrawn or not after the nodal rigid bodys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): NodalRigidBody;

/**
 * Adds a warning for nodal rigid body. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this nodal rigid body.
 */
    Xrefs(): Xrefs;

/**
 * Create a new NodalRigidBody object.
 * @param Model Model that nrb will be created in
 * @param nsid Nodal set ID
 * @param pid NodalRigidBody ID of the NRB. Also see the label property which is an alternative name for this.
 * @param cid Coordinate system ID
 * @param pnode Optional nodal point
 * @param iprt Print flag
 * @param drflag Displacement release flag
 * @param rrflag Rotation release flag
 */
    constructor(Model: Model, nsid: number, pid?: number, cid?: number, pnode?: number, iprt?: number, drflag?: number, rrflag?: number);

/**
 * Creates a string containing the nrb data in keyword format. Note that this contains the keyword header and the keyword cards. See also NodalRigidBody.Keyword() and NodalRigidBody.KeywordCards().
 */
    toString(): string;

/** Coordinate system ID */
    cid: number;
/** Centre of mass option */
    cmo: number;
/** First retraint parameter */
    con1: number;
/** Second retraint parameter */
    con2: number;
/** Displacement release flag */
    drflag: number;
/** true if nrb exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the nrb is in. */
    include: number;
/** Flag to turn on or off _INERTIA option */
    inertia: boolean;
/** Print flag */
    iprt: number;
/** Ixx component of inertia tensor */
    ixx: number;
/** Ixy component of inertia tensor */
    ixy: number;
/** Ixz component of inertia tensor */
    ixz: number;
/** Iyy component of inertia tensor */
    iyy: number;
/** Iyz component of inertia tensor */
    iyz: number;
/** Izz component of inertia tensor */
    izz: number;
/** NodalRigidBody ID of the NRB. Also see the pid property which is an alternative name for this. */
    label: number;
/** The Model number that the nodal rigid body is in. */
    model: number;
/** Optional node point */
    nodeid: number;
/** Nodal set ID */
    nsid: number;
/** NodalRigidBody ID of the NRB. Also see the label property which is an alternative name for this. */
    pid: number;
/** Optional nodal point */
    pnode: number;
/** Rotation release flag */
    rrflag: number;
/** Flag to turn on or off _SPC option */
    spc: boolean;
/** Translational mass */
    tm: number;
/** X rigid body rotational velocity */
    vrx: number;
/** Y rigid body rotational velocity */
    vry: number;
/** Z rigid body rotational velocity */
    vrz: number;
/** X rigid body translational velocity */
    vtx: number;
/** Y rigid body translational velocity */
    vty: number;
/** Z rigid body translational velocity */
    vtz: number;
/** X coordinate centre of mass */
    xc: number;
/** X coordinate of local x axis */
    xl: number;
/** X coordinate of local in plane vector */
    xlip: number;
/** Y coordinate centre of mass */
    yc: number;
/** Y coordinate of local x axis */
    yl: number;
/** Y coordinate of local in plane vector */
    ylip: number;
/** Z coordinate centre of mass */
    zc: number;
/** Z coordinate of local x axis */
    zl: number;
/** Z coordinate of local in plane vector */
    zlip: number;
}

declare class Node {
/**
 * Blanks the node
 */
    Blank(): void;

/**
 * Blanks all of the nodes in the model.
 * @param Model Model that all nodes will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged nodes in the model.
 * @param Model Model that all the flagged nodes will be blanked in
 * @param flag Flag set on the nodes that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the node is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the node.
 * @param flag Flag to clear on the node
 */
    ClearFlag(flag: number): void;

/**
 * Copies the node.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Node;

/**
 * Starts an interactive editing panel to create a node.
 * @param Model Model that the node will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Node;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for node. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for node. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the node colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the node.
 */
    ExtractColour(): number;

/**
 * Returns the first node in the model.
 * @param Model Model to get first node in
 */
    static First(Model: Model): Node;

/**
 * Returns the first free node label in the model. Also see Node.LastFreeLabel(), Node.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free node label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the nodes in the model with a defined flag.
 * @param Model Model that all nodes will be flagged in
 * @param flag Flag to set on the nodes
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the node is flagged or not.
 * @param flag Flag to test on the node
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each node in the model. Note that ForEach has been designed to make looping over nodes as fast as possible and so has some limitations. Firstly, a single temporary Node object is created and on each function call it is updated with the current node data. This means that you should not try to store the Node object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new nodes inside a ForEach loop. 
 * @param Model Model that all nodes are in
 * @param func Function to call for each node
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Node objects for all of the nodes in a model in Primer
 * @param Model Model to get nodes from
 */
    static GetAll(Model: Model): Node[];

/**
 * Returns the shells that are attached to the node.
 * @param recursive If recursive is false then only the shells actually attached to the node will be returned (this could also be done by using the Xrefs class but this method is provided for convenience. If recursive is true then PRIMER will keep finding attached shells until no more can be found. If omitted recursive will be false.
 */
    GetAttachedShells(recursive?: boolean): Shell[];

/**
 * Returns an array of Node objects for all of the flagged nodes in a model in Primer
 * @param Model Model to get nodes from
 * @param flag Flag set on the nodes that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Node[];

/**
 * If the node is on a shell free edge and that edge forms a loop like the boundary of a hole, then GetFreeEdgeNodes returns all of the nodes on the hole/boundary in order. Note that a free edge is a shell edge which is only used by one shell, whereas edges in the middle of a shell part will have got more than one adjacent shell and are therefore not free edges. If every node on a boundary belongs to exactly two free edges, then this function returns the array as described. In more involved combinatorics of shells, for example multiple parts sharing nodes along their boundaries, there can be one, three or more free edges at a node, and this function should not be used. If you only need to know whether or not a node is on a free edge, you should find the shells attached to it by cross references with Xrefs.GetItemID and see whether these shells have got other nodes in common as well. If nodes along an edge of a shell only appear in that one shell, this is a free edge.
 */
    GetFreeEdgeNodes(): Node[];

/**
 * Returns the Node object for a node ID.
 * @param Model Model to find the node in
 * @param number number of the node you want the Node object for
 */
    static GetFromID(Model: Model, number: number): Node;

/**
 * Returns the initial velocity of the node. You need to be sure the field nvels of the node is populate before to use GetInitialVelocities. To do so you can use  Model.PopNodeVels .
 */
    GetInitialVelocities(): number[];

/**
 * Checks if a Node property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Node.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop node property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the airbag reference geometry of the node
 */
    GetReferenceGeometry(): number;

/**
 * Returns the keyword for this node (*NODE, *NODE_SCALAR or *NODE_SCALAR_VALUE). Note that a carriage return is not added. See also Node.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the node. Note that a carriage return is not added. See also Node.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last node in the model.
 * @param Model Model to get last node in
 */
    static Last(Model: Model): Node;

/**
 * Returns the last free node label in the model. Also see Node.FirstFreeLabel(), Node.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free node label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Attempts to merge nodes flagged with flag for a model in PRIMER. Merging nodes on *AIRBAG_SHELL_REFERENCE_GEOMETRY can be controlled by using Options.node_replace_asrg. Also see Model.MergeNodes().
 * @param Model Model that the nodes will be merged in
 * @param flag Flag set on nodes to nodes
 * @param dist Nodes closer than dist will be potentially merged.
 * @param label Label to keep after merge. If &gt; 0 then highest label kept. If &lt;= 0 then lowest kept. If omitted the lowest label will be kept.
 * @param position Position to merge at. If &gt; 0 then merged at highest label position. If &lt; 0 then merged at lowest label position. If 0 then merged at midpoint. If omitted the merge will be done at the lowest label.
 */
    static Merge(Model: Model, flag: number, dist: number, label?: number, position?: number): number;

/**
 * Returns the next node in the model.
 */
    Next(): Node;

/**
 * Returns the next free (highest+1) node label in the model. Also see Node.FirstFreeLabel(), Node.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free node label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Get the mass of a node. This will be the sum of the structural element mass attached to the node plus any lumped mass. If called on the node of a PART_INERTIA or NRBC_INERTIA, this function will return the mass of the part/nrbc, as 'nodal mass' has no meaning in this context.
 */
    NodalMass(): number;

/**
 * Allows the user to pick a node.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only nodes from that model can be picked. If the argument is a Flag then only nodes that are flagged with limit can be selected. If omitted, or null, any nodes from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Node;

/**
 * Returns the previous node in the model.
 */
    Previous(): Node;

/**
 * Renumbers all of the nodes in the model.
 * @param Model Model that all nodes will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged nodes in the model.
 * @param Model Model that all the flagged nodes will be renumbered in
 * @param flag Flag set on the nodes that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select nodes using standard PRIMER object menus.
 * @param flag Flag to use when selecting nodes
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only nodes from that model can be selected. If the argument is a Flag then only nodes that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any nodes can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the node.
 * @param flag Flag to set on the node
 */
    SetFlag(flag: number): void;

/**
 * Sketches the node. The node will be sketched until you either call Node.Unsketch(), Node.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the node is sketched. If omitted redraw is true. If you want to sketch several nodes and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged nodes in the model. The nodes will be sketched until you either call Node.Unsketch(), Node.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged nodes will be sketched in
 * @param flag Flag set on the nodes that you want to sketch
 * @param redraw If model should be redrawn or not after the nodes are sketched. If omitted redraw is true. If you want to sketch flagged nodes several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of nodes in the model.
 * @param Model Model to get total for
 * @param exists true if only existing nodes should be counted. If false or omitted referenced but undefined nodes will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the node
 */
    Unblank(): void;

/**
 * Unblanks all of the nodes in the model.
 * @param Model Model that all nodes will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged nodes in the model.
 * @param Model Model that the flagged nodes will be unblanked in
 * @param flag Flag set on the nodes that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the nodes in the model.
 * @param Model Model that the defined flag for all nodes will be unset in
 * @param flag Flag to unset on the nodes
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the node.
 * @param redraw If model should be redrawn or not after the node is unsketched. If omitted redraw is true. If you want to unsketch several nodes and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all nodes.
 * @param Model Model that all nodes will be unblanked in
 * @param redraw If model should be redrawn or not after the nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged nodes in the model.
 * @param Model Model that all nodes will be unsketched in
 * @param flag Flag set on the nodes that you want to unsketch
 * @param redraw If model should be redrawn or not after the nodes are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Node;

/**
 * Adds a warning for node. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this node.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Node object.
 * @param Model Model that node will be created in
 * @param nid Node number
 * @param x X coordinate
 * @param y Y coordinate
 * @param z Z coordinate
 * @param tc Translational constraint (0-7). If omitted tc will be set to 0.
 * @param rc Rotational constraint (0-7). If omitted rc will be set to 0.
 */
    constructor(Model: Model, nid: number, x: number, y: number, z: number, tc?: number, rc?: number);

/**
 * Creates a string containing the node data in keyword format. Note that this contains the keyword header and the keyword cards. See also Node.Keyword() and Node.KeywordCards().
 */
    toString(): string;

/** The colour of the node */
    colour: Colour;
/** true if node exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the node is in. */
    include: number;
/** Node number. Also see the nid property which is an alternative name for this. */
    label: number;
/** The Model number that the node is in. */
    model: number;
/** Number of degrees of freedom (SCALAR and SCALAR_VALUE only). */
    ndof: number;
/** Node number. Also see the label property which is an alternative name for this. */
    nid: number;
/** Rotational constraint (0-7) */
    rc: number;
/** The type of the node. Can be false (*NODE), Node.SCALAR (*NODE_SCALAR) or Node.SCALAR_VALUE (*NODE_SCALAR_VALUE) */
    scalar: number;
/** Translational constraint (0-7) */
    tc: number;
/** X coordinate */
    x: number;
/** Initial value of 1st degree of freedom (SCALAR_VALUE only). */
    x1: number;
/** Initial value of 2nd degree of freedom (SCALAR_VALUE only). */
    x2: number;
/** Initial value of 3rd degree of freedom (SCALAR_VALUE only). */
    x3: number;
/** Y coordinate */
    y: number;
/** Z coordinate */
    z: number;
/** Node is *NODE_SCALAR. */
    static SCALAR: number;
/** Node is *NODE_SCALAR_VALUE. */
    static SCALAR_VALUE: number;
}

declare class NodeSet {
/**
 * Blanks the node set
 */
    Blank(): void;

/**
 * Blanks all of the node sets in the model.
 * @param Model Model that all node sets will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged node sets in the model.
 * @param Model Model that all the flagged node sets will be blanked in
 * @param flag Flag set on the node sets that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the node set is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the node set.
 * @param flag Flag to clear on the node set
 */
    ClearFlag(flag: number): void;

/**
 * Copies the node set.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): NodeSet;

/**
 * Starts an interactive editing panel to create a node_set.
 * @param Model Model that the node_set will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): NodeSet;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for node set. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first node set in the model.
 * @param Model Model to get first node set in
 */
    static First(Model: Model): NodeSet;

/**
 * Returns the first free node set label in the model. Also see NodeSet.LastFreeLabel(), NodeSet.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free node set label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the node sets in the model with a defined flag.
 * @param Model Model that all node sets will be flagged in
 * @param flag Flag to set on the node sets
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the node set is flagged or not.
 * @param flag Flag to test on the node set
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each node set in the model. Note that ForEach has been designed to make looping over node sets as fast as possible and so has some limitations. Firstly, a single temporary NodeSet object is created and on each function call it is updated with the current node set data. This means that you should not try to store the NodeSet object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new node sets inside a ForEach loop. 
 * @param Model Model that all node sets are in
 * @param func Function to call for each node set
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of NodeSet objects for all of the node sets in a model in Primer
 * @param Model Model to get node sets from
 */
    static GetAll(Model: Model): NodeSet[];

/**
 * Returns an array of NodeSet objects for all of the flagged node sets in a model in Primer
 * @param Model Model to get node sets from
 * @param flag Flag set on the node sets that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): NodeSet[];

/**
 * Returns the NodeSet object for a node set ID.
 * @param Model Model to find the node set in
 * @param number number of the node set you want the NodeSet object for
 */
    static GetFromID(Model: Model, number: number): NodeSet;

/**
 * Checks if a NodeSet property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the NodeSet.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop node set property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this node_set (*CONSTRAINED_NODE_SET). Note that a carriage return is not added. See also NodeSet.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the node_set. Note that a carriage return is not added. See also NodeSet.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last node set in the model.
 * @param Model Model to get last node set in
 */
    static Last(Model: Model): NodeSet;

/**
 * Returns the last free node set label in the model. Also see NodeSet.FirstFreeLabel(), NodeSet.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free node set label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next node set in the model.
 */
    Next(): NodeSet;

/**
 * Returns the next free (highest+1) node set label in the model. Also see NodeSet.FirstFreeLabel(), NodeSet.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free node set label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a node set.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only node sets from that model can be picked. If the argument is a Flag then only node sets that are flagged with limit can be selected. If omitted, or null, any node sets from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): NodeSet;

/**
 * Returns the previous node set in the model.
 */
    Previous(): NodeSet;

/**
 * Renumbers all of the node sets in the model.
 * @param Model Model that all node sets will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged node sets in the model.
 * @param Model Model that all the flagged node sets will be renumbered in
 * @param flag Flag set on the node sets that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select node sets using standard PRIMER object menus.
 * @param flag Flag to use when selecting node sets
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only node sets from that model can be selected. If the argument is a Flag then only node sets that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any node sets can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the node set.
 * @param flag Flag to set on the node set
 */
    SetFlag(flag: number): void;

/**
 * Sketches the node set. The node set will be sketched until you either call NodeSet.Unsketch(), NodeSet.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the node set is sketched. If omitted redraw is true. If you want to sketch several node sets and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged node sets in the model. The node sets will be sketched until you either call NodeSet.Unsketch(), NodeSet.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged node sets will be sketched in
 * @param flag Flag set on the node sets that you want to sketch
 * @param redraw If model should be redrawn or not after the node sets are sketched. If omitted redraw is true. If you want to sketch flagged node sets several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of node sets in the model.
 * @param Model Model to get total for
 * @param exists true if only existing node sets should be counted. If false or omitted referenced but undefined node sets will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the node set
 */
    Unblank(): void;

/**
 * Unblanks all of the node sets in the model.
 * @param Model Model that all node sets will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged node sets in the model.
 * @param Model Model that the flagged node sets will be unblanked in
 * @param flag Flag set on the node sets that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the node sets in the model.
 * @param Model Model that the defined flag for all node sets will be unset in
 * @param flag Flag to unset on the node sets
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the node set.
 * @param redraw If model should be redrawn or not after the node set is unsketched. If omitted redraw is true. If you want to unsketch several node sets and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all node sets.
 * @param Model Model that all node sets will be unblanked in
 * @param redraw If model should be redrawn or not after the node sets are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged node sets in the model.
 * @param Model Model that all node sets will be unsketched in
 * @param flag Flag set on the node sets that you want to unsketch
 * @param redraw If model should be redrawn or not after the node sets are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): NodeSet;

/**
 * Adds a warning for node set. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this node set.
 */
    Xrefs(): Xrefs;

/**
 * Create a new NodeSet object.
 * @param Model Model that constrained node set will be created in
 * @param nsid Set Node ID.
 * @param dof Degree of freedom.
 * @param tf Failure time.
 * @param label Constrained node set number.
 */
    constructor(Model: Model, nsid: number, dof: number, tf: number, label?: number);

/**
 * Creates a string containing the node_set data in keyword format. Note that this contains the keyword header and the keyword cards. See also NodeSet.Keyword() and NodeSet.KeywordCards().
 */
    toString(): string;

/** Constrained node set number (identical to label). */
    cnsid: number;
/** Degree of freedom. */
    dof: number;
/** true if constrained node set exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** true if _ID option is set, false if not */
    id: boolean;
/** The Include file number that the constrained node set is in. */
    include: number;
/** Constrained node set number. */
    label: number;
/** The Model number that the node set is in. */
    model: number;
/** Set Node ID. */
    nsid: number;
/** Failure time. */
    tf: number;
}

declare class Options {
/** Airbag symbol colour */
    static airbag_colour: number;
/** If true then ${Program} will automatically confirm (i.e. press the OK button) on (most) message boxes that are mapped. If false (default) then the message boxes will be shown and wait for the user to press a button. This option may be useful to help automate an operation where ${Program} would normally show a message box and wait for the user to press a button. */
    static auto_confirm: boolean;
/** Colour of the background */
    static background_colour: number;
/** If true (default) then PRIMER will popup a "BROWSE MISSING INCLUDE FILE" panel while reading the model. If false then it will throw an 'missing include file error' and continue reading the model. */
    static browse_missing_include_file: boolean;
/** The angle tolerance used for spotwelds in the connections algorithm */
    static connection_angle_tol: number;
/** The edge distance used in the connections algorithm */
    static connection_edge_dist: number;
/** The connection file to read/write */
    static connection_file: string;
/** The maximum thickness used in the connections algorithm */
    static connection_max_thickness: number;
/** The model number selected to make connections in */
    static connection_model: number;
/** The part ID selected for connections */
    static connection_part: number;
/** Flag that will be set on selected connections when writing. This can be used in the user JavaScript to write connections to find which are selected. */
    static readonly connection_write_flag: number;
/** Contact surface colour */
    static contacts_colour: number;
/** Contour bar text size */
    static contour_text_size: number;
/** Convert all RBE2s to *CONSTRAINED_NODAL_RIGID_BODY */
    static convert_rbe2_cnrb: boolean;
/** Size of date (clock) display */
    static date_size: number;
/** The LS-DYNA version used to write keyword files. Can be "971R5", "971R4", "971R3", "970v6763" etc (see the version popup in Model-&gt;Write '&gt;&gt;&gt; LS-Dyna output options' for a full list). See also Model.Write and Include.Write */
    static dyna_version: string;
/** Feature edge critical angle */
    static edge_angle: number;
/** Option for choosing how to draw free edges (can be set to TRUE or FALSE) */
    static edges_ign_pt: number;
/** If true edit panels created from the Edit() or Create() methods will be kept on top of other windows. If false (default) then they can be lowered. */
    static edit_keep_on_top: boolean;
/** If true (default) error messages will be printed to the dialogue box/stdout when an exception occurs in the API. If false they will not be printed. This option may be useful if you are using try/catch to manage exceptions and you do not want any error messages to be printed. */
    static exception_messages: boolean;
/** Constrained extra nodes colour */
    static extra_nodes_colour: number;
/** Switch ON/OFF feature line (can be set to TRUE or FALSE) */
    static feature_line: number;
/** Nodal force/moment colour */
    static for_mom_colour: number;
/** Graticule text size */
    static graticule_text_size: number;
/** If true then the output file will be written out in binary. If false (default) then an ascii file will be written. */
    static keyout_binary: boolean;
/** This option can be used to specify the mode of compression. Can be Model.INDIVIDUAL_GZIP, Model.INDIVIDUAL_ZIP or Model.PACKAGED_ZIP */
    static keyout_compress_format: number;
/** Compression level for .gz and .zip files. Must be in the range 1 to 9 with 1 being the least compression (fastest speed) to 9 being the greatest compression (slowest speed) */
    static keyout_compress_level: number;
/** Switch to set the compression during keyout. Can be Model.COMPRESS_KEEP (default), Model.COMPRESS_OFF or Model.COMPRESS_ON */
    static keyout_compress_switch: number;
/** If true then i10 format will be used to write the file. If false (default) then the normal LS-DYNA format will be used. */
    static keyout_i10: boolean;
/** If true then large format will be used to write the file. If false (default) then the normal LS-DYNA format will be used. Note that large format is only available from version R7.1 and above. */
    static keyout_large: boolean;
/** The method used to write include files. Can be Include.MASTER_ONLY, Include.MERGE, Include.NOT_WRITTEN, Include.SUBDIR (default) or Include.SAME_DIR  */
    static keyout_method: number;
/** This option can be used to specify how parameters are written. If true then the underlying values of any parameters will be written when they are used in data fields rather than '&amp;name'. If false (default) then '&amp;name' will be written. */
    static keyout_parameter_values: boolean;
/** The method used to write include paths. Can be Include.ABSOLUTE (default) or Include.RELATIVE  */
    static keyout_path_type: number;
/** The directory separator used when writing include files. Can be Include.NATIVE (default), Include.UNIX or Include.WINDOWS  */
    static keyout_separator: number;
/** Colour of the label */
    static label_colour: number;
/** Label size */
    static label_size: number;
/** X-coordinate of user defined centre. */
    static mass_properties_centre_x: number;
/** Y-coordinate of user defined centre. */
    static mass_properties_centre_y: number;
/** Z-coordinate of user defined centre. */
    static mass_properties_centre_z: number;
/** Coordinate system selection: Model.GLOBAL_AXES, Model.LOCAL_AXES, Model.PRINCIPAL_AXES. */
    static mass_properties_coordinate_system_type: number;
/** Option to include lumped mass attached to the nodes of deformable elements. Default is OFF. */
    static mass_properties_include_attached_mass_deformable_elems: boolean;
/** Option to include lumped mass attached to the nodes of rigid elements. Default is OFF. */
    static mass_properties_include_attached_mass_rigid_elems: boolean;
/** Option to set the centre used in inertia properties calculation. By default Centre at CofG is used. Available options are: Model.CENTRE_AT_COFG, Model.USER_DEFINED_CENTRE. */
    static mass_properties_inertia_center: number;
/** CSYS ID when using local axes. */
    static mass_properties_local_axes: number;
/** Option to switch on/off mass of *CONSTRAINED_EXTRA_NODES associated with a rigid part. Default is ON. */
    static mass_properties_rigid_part_extra_nodes: boolean;
/** Option to switch on/off mass of *CONSTRAINED_RIGID_BODIES associated with a rigid part. Default is ON . */
    static mass_properties_rigid_part_slave_parts: boolean;
/** The maximum number of Widgets that can be made for one Window. The default value is 1000 */
    static max_widgets: number;
/** The maximum number of lines that can be made for a Window.Error(), Window.Information(), Window.Message(), Window.Question() or Window.Warning() window. The default value is 25 */
    static max_window_lines: number;
/** Merge duplicate RBE dependent nodes */
    static merge_rbe_nodes: boolean;
/** If true then when merging models PRIMER will merge *SET_COLLECT cards which have the same label. If false (default) then they will be renumbered. This is also used with Model.ImportInclude. The default for this can be set using the primer*merge_set_collect preference. */
    static merge_set_collect: boolean;
/** If true (default) then Primer will show model tabs in the object selection menu. If false then Primer will hide model tabs in object selection menu. */
    static model_tabs_active: boolean;
/** Nodes colour */
    static node_colour: number;
/** If true nodes in *AIRBAG_SHELL_REFERENCE_GEOMETRY can be replaced by node merge/replace. If false they will not be considered. */
    static node_replace_asrg: boolean;
/** Nodal rigid body colour */
    static nrb_colour: number;
/** Colour of the overlay */
    static overlay_colour: number;
/** Option for setting the overlay edges value (can be set to 0,1 or 2) */
    static overlay_edges: number;
/** Position that the pick window will be shown on the screen. It can be any combination (bitwise OR) of Window.LEFT, Window.CENTRE, Window.RIGHT, Window.TOP, Window.MIDDLE and Window.BOTTOM or a Window object. If a window obect is used the pick window will be shown in the middle of that window. The default is Window.RIGHT|Window.TOP. */
    static pick_window_position: number;
/** If true object properties which are parameters will be returned as parameter names. If false object properties which are parameters will be returned as parameter values. */
    static property_parameter_names: boolean;
/** If true then the current working directory will not be changed after selecting a file. If false (default) then the current working directory will be changed after selecting a file. This option only applies to Windows machines. */
    static reset_cwd: boolean;
/** Retain mid-side nodes for higher order elements */
    static retain_mid_nodes: boolean;
/** Constrained rigid body colour */
    static rigid_bodies_colour: number;
/** Rotational velocity colour */
    static rot_vels_colour: number;
/** Colour of the sketch */
    static sketch_colour: number;
/** The default diameter of solid spotwelds. */
    static solid_spotweld_diameter: number;
/** The default type of spotweld to make. can be: Conx.SPOTWELD_BEAM, Conx.SPOTWELD_SOLID1, Conx.SPOTWELD_SOLID4, Conx.SPOTWELD_SOLID8, Conx.SPOTWELD_SOLID12 or Conx.SPOTWELD_SOLID16 */
    static spotweld_element_type: number;
/** Spotweld beam/solid colour */
    static spotweldbeam_colour_from_panels: number;
/** Constrained SPR/SPR2/SPR3 colour */
    static spr_colour_from_node_sets: number;
/** Colour of the text */
    static text_colour: number;
/** Time history block colour */
    static timehist_blks_colour: number;
/** Tracer particle colour */
    static tracer_partl_colour: number;
/** Translational velocity colour */
    static trans_vels_colour: number;
/** Cross-section colour */
    static x_sections_colour: number;
}

declare class Parameter {
/**
 * Auto Reorders all the parameters in the model.
 * @param Model Model that contains all parameters that will be re-ordered
 */
    static AutoReorder(Model: Model): void;

/**
 * Clears a flag on the parameter.
 * @param flag Flag to clear on the parameter
 */
    ClearFlag(flag: number): void;

/**
 * Flags all of the parameters in the model with a defined flag.
 * @param Model Model that all parameters will be flagged in
 * @param flag Flag to set on the parameters
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the parameter is flagged or not.
 * @param flag Flag to test on the parameter
 */
    Flagged(flag: number): boolean;

/**
 * Returns an array of Parameter objects for all of the parameters in a model in Primer
 * @param Model Model to get parameters from
 */
    static GetAll(Model: Model): Parameter[];

/**
 * Returns an array of Parameter objects for all parameters in a model matching Name. If none are found that match it will return NULL. (Multiple parameters of the same name may exist if they use the _LOCAL or _MUTABLE suffices. PRIMER will also store multiple illegal instances of parameter name, using the instance as determined by the PARAMETER_DUPLICATION card.)
 * @param Model Model to get parameters from
 */
    static GetAllOfName(Model: Model): Parameter[];

/**
 * Returns the stored Parameter object for a parameter name. WARNING: if more than one parameter Name exists (eg _LOCAL, _MUTABLE) then only the first occurrence is returned. To return all parameters matching Name use GetAllOfName() instead.
 * @param Model Model to find the parameter in
 * @param parameter_name name of the parameter you want the Parameter object for
 */
    static GetFromName(Model: Model, parameter_name: string): Parameter;

/**
 * Returns the keyword for this parameter (*PARAMETER, *PARAMETER_EXPRESSION). Note that a carriage return is not added. See also Parameter.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the parameter. Note that a carriage return is not added. See also Parameter.Keyword()
 */
    KeywordCards(): string;

/**
 * Sets a flag on the parameter.
 * @param flag Flag to set on the parameter
 */
    SetFlag(flag: number): void;

/**
 * Unsets a defined flag on all of the parameters in the model.
 * @param Model Model that the defined flag for all parameters will be unset in
 * @param flag Flag to unset on the parameters
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Returns the cross references for this parameter.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Parameter object.
 * @param Model Model that parameter will be created in
 * @param name Parameter name
 * @param type Can be Parameter.INTEGER, Parameter.REAL or Parameter.CHARACTER.
 * @param expression true if *PARAMETER_EXPRESSION, false otherwise.
 * @param value Parameter value. The value will be a string for character parameters or parameter expressions, or a number for integer or real parameters.
 * @param suffix Keyword suffix Can be Parameter.LOCAL for *PARAMETER_..._LOCAL, Parameter.MUTABLE for *PARAMETER_..._MUTABLE. These may be bitwise ORed together, ie Parameter.LOCAL | Parameter.MUTABLE. If omitted the parameter will not be local or mutable.
 */
    constructor(Model: Model, name: string, type: number, expression: boolean, value: number, suffix?: number);

/**
 * Creates a string containing the parameter data in keyword format. Note that this contains the keyword header and the keyword cards. See also Parameter.Keyword() and Parameter.KeywordCards().
 */
    toString(): string;

/** true if this parameter is a *PARAMETER_EXPRESSION, false otherwise. */
    readonly expression: boolean;
/** The Include file number that the parameter is in. */
    include: number;
/** true if this parameter is a *PARAMETER_... _LOCAL, false otherwise. */
    local: boolean;
/** The Model number that the parameter is in. */
    model: number;
/** true if this parameter is a *PARAMETER_... _MUTABLE, false otherwise. */
    mutable: boolean;
/** Parameter name. */
    readonly name: string;
/** Can be Parameter.INTEGER, Parameter.REAL or Parameter.CHARACTER. */
    readonly type: number;
/** Parameter value. The value will be a string for parameter expressions, or a number for normal parameters. */
    value: number;
/** Parameter is a character. */
    static CHARACTER: number;
/** Parameter is an integer. */
    static INTEGER: number;
/** Parameter has _LOCAL suffix (used in suffix argument for constructor). */
    static LOCAL: number;
/** Parameter has _MUTABLE suffix (used in suffix argument for constructor). */
    static MUTABLE: number;
/** Parameter is a real. */
    static REAL: number;
}


/** Object function argument in CentreOfGravity */
interface CentreOfGravityArgument_options {
    /** Lumped mass is included for deformable parts. Off by default. */
    lumpedmass?: boolean;
    /** NRB mass is included for deformable parts. Off by default. (tranfermass:true required for this option) */
    nrbmass?: boolean;
    /** Plot CofG. */
    plot?: boolean;
    /** Slave rigid part is assigned zero mass (if slaveparts = true). On by default. */
    skipslave?: boolean;
    /** Mass of rigid master part includes mass of its slave parts. On by default. */
    slaveparts?: boolean;
    /** Timestep added mass is included for deformable parts. Off by default. */
    timestepmass?: boolean;
    /** Mass of deformable nodes attached to rigid part/nrb is transferred. On by default. */
    transfermass?: boolean;
}


/** Object returned by Mass */
interface MassReturn {
    /** Assign mass */
    Assign_Mass: number;
    /** Component mass */
    Component_Mass: number;
    /** Dyna added mass */
    Dyna_Added_Mass: number;
    /** Dyna part mass */
    Dyna_Part_Mass: number;
    /** Lumped mass */
    Lumped_Mass: number;
    /** NRB mass */
    NRB_Mass: number;
    /** Non-structural mass */
    NS_Mass: number;
    /** Structural mass */
    Struct_Mass: number;
    /** Transferred mass when deformable meshed to rigid */
    Transferrd_Mass: number;
}


/** Object returned by MeasurePartToPart */
interface MeasurePartToPartReturn {
    /** Distance between the two parts */
    distance: number;
    /** Components of distance vector */
    vector: number[];
}

declare class Part {
/**
 * Returns all of the properties available in the part table for the parts. The table values are returned in an array of objects (an object for each part). The object property names are the same as the table headers but spaces are replaced with underscore characters and characters other than 0-9, a-z and A-Z are removed to ensure that the property name is valid in JavaScript. If a table value is undefined the property value will be the JavaScript undefined value. If the table value is a valid number it will be a number, otherwise the value will returned as a string.
 * @param Model Model that the flagged parts are in
 */
    static AllTableProperties(Model: Model): object[];

/**
 * Blanks the part
 */
    Blank(): void;

/**
 * Blanks all of the parts in the model.
 * @param Model Model that all parts will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged parts in the model.
 * @param Model Model that all the flagged parts will be blanked in
 * @param flag Flag set on the parts that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the part is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Returns the centre of gravity for a part.
 * @param options Options specifying how the mass calculation should be done.
 */
    CentreOfGravity(options?: CentreOfGravityArgument_options): number[];

/**
 * Clears a flag on the part.
 * @param flag Flag to clear on the part
 */
    ClearFlag(flag: number): void;

/**
 * Finds the Node on the part closest to a coordinate.
 * @param x X coordinate of point
 * @param y Y coordinate of point
 * @param z Z coordinate of point
 */
    ClosestNode(x: number, y: number, z: number): number;

/**
 * Copies the part.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Part;

/**
 * Starts an interactive editing panel to create a part.
 * @param Model Model that the part will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Part;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for part. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for part. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the part colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the part.
 */
    ExtractColour(): number;

/**
 * Returns the first part in the model.
 * @param Model Model to get first part in
 */
    static First(Model: Model): Part;

/**
 * Returns the first free part label in the model. Also see Part.LastFreeLabel(), Part.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free part label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the parts in the model with a defined flag.
 * @param Model Model that all parts will be flagged in
 * @param flag Flag to set on the parts
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Flags all the unblanked parts in the model.
 * @param Model Model for which all unblanked parts will be flagged in
 * @param flag Flag to set on the unblanked parts
 */
    static FlagVisible(Model: Model, flag: number): void;

/**
 * Checks if the part is flagged or not.
 * @param flag Flag to test on the part
 */
    Flagged(flag: number): boolean;

/**
 * Returns all of the properties available in the part table for the flagged parts. The table values are returned in an array of objects (an object for each part). The object property names are the same as the table headers but spaces are replaced with underscore characters and characters other than 0-9, a-z and A-Z are removed to ensure that the property name is valid in JavaScript. If a table value is undefined the property value will be the JavaScript undefined value. If the table value is a valid number it will be a number, otherwise the value will returned as a string.
 * @param Model Model that the flagged parts are in
 * @param flag Flag set on the parts that you want properties for
 */
    static FlaggedTableProperties(Model: Model, flag: number): object[];

/**
 * Calls a function for each part in the model. Note that ForEach has been designed to make looping over parts as fast as possible and so has some limitations. Firstly, a single temporary Part object is created and on each function call it is updated with the current part data. This means that you should not try to store the Part object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new parts inside a ForEach loop. 
 * @param Model Model that all parts are in
 * @param func Function to call for each part
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Part objects for all of the parts in a model in Primer
 * @param Model Model to get parts from
 */
    static GetAll(Model: Model): Part[];

/**
 * Returns the composite data for an integration point in *PART_COMPOSITE.
 * @param ipt The integration point you want the data for. Note that integration points start at 0, not 1.
 */
    GetCompositeData(ipt: number): number[];

/**
 * Returns an array of Part objects for all of the flagged parts in a model in Primer
 * @param Model Model to get parts from
 * @param flag Flag set on the parts that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Part[];

/**
 * Returns the Part object for a part ID.
 * @param Model Model to find the part in
 * @param number number of the part you want the Part object for
 */
    static GetFromID(Model: Model, number: number): Part;

/**
 * Checks if a Part property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Part.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop part property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this part (*PART, *PART_SCALAR or *PART_SCALAR_VALUE). Note that a carriage return is not added. See also Part.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the part. Note that a carriage return is not added. See also Part.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last part in the model.
 * @param Model Model to get last part in
 */
    static Last(Model: Model): Part;

/**
 * Returns the last free part label in the model. Also see Part.FirstFreeLabel(), Part.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free part label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the mass properties for a part.
 */
    Mass(): MassReturn;

/**
 * Returns the max and min boundas of a part
 */
    MaxMin(): number[];

/**
 * This static method measures the distance between two part objects contained in the same model or in two different models
 * @param part1 Part to measure from
 * @param part2 Part to measure to
 */
    static MeasurePartToPart(part1: Part, part2: Part): MeasurePartToPartReturn;

/**
 * Returns the next part in the model.
 */
    Next(): Part;

/**
 * Returns the next free (highest+1) part label in the model. Also see Part.FirstFreeLabel(), Part.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free part label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a part.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only parts from that model can be picked. If the argument is a Flag then only parts that are flagged with limit can be selected. If omitted, or null, any parts from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Part;

/**
 * Returns the previous part in the model.
 */
    Previous(): Part;

/**
 * Removes the composite data for an integration point in *PART_COMPOSITE.
 * @param ipt The integration point you want to remove. Note that integration points start at 0, not 1.
 */
    RemoveCompositeData(ipt: number): void;

/**
 * Renumbers all of the parts in the model.
 * @param Model Model that all parts will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged parts in the model.
 * @param Model Model that all the flagged parts will be renumbered in
 * @param flag Flag set on the parts that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select parts using standard PRIMER object menus.
 * @param flag Flag to use when selecting parts
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only parts from that model can be selected. If the argument is a Flag then only parts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any parts can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets the composite data for an integration point in *PART_COMPOSITE.
 * @param ipt The integration point you want to set the data for. Note that integration points start at 0, not 1.
 * @param mid Material ID for the integration point.
 * @param thick Thickness of the integration point.
 * @param beta Material angle of the integration point.
 * @param tmid_optinal Thermal material ID for the integration point.
 * @param plyid Ply ID for the integration point. This should be used if the _COMPOSITE_LONG option is set for the part.
 * @param shrfac Transverse shear stress scale factor.
 */
    SetCompositeData(ipt: number, mid: number, thick: number, beta: number, tmid_optinal: number, plyid?: number, shrfac: number): void;

/**
 * Sets a flag on the part.
 * @param flag Flag to set on the part
 */
    SetFlag(flag: number): void;

/**
 * Sketches the part. The part will be sketched until you either call Part.Unsketch(), Part.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the part is sketched. If omitted redraw is true. If you want to sketch several parts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged parts in the model. The parts will be sketched until you either call Part.Unsketch(), Part.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged parts will be sketched in
 * @param flag Flag set on the parts that you want to sketch
 * @param redraw If model should be redrawn or not after the parts are sketched. If omitted redraw is true. If you want to sketch flagged parts several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns all of the properties available for the part in the part table. The table values are returned in an object. The object property names are the same as the table headers but spaces are replaced with underscore characters and characters other than 0-9, a-z and A-Z are removed to ensure that the property name is valid in JavaScript. If a table value is undefined the property value will be the JavaScript undefined value. If the table value is a valid number it will be a number, otherwise the value will returned as a string.
 */
    TableProperties(): object;

/**
 * Returns the total number of parts in the model.
 * @param Model Model to get total for
 * @param exists true if only existing parts should be counted. If false or omitted referenced but undefined parts will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the part
 */
    Unblank(): void;

/**
 * Unblanks all of the parts in the model.
 * @param Model Model that all parts will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged parts in the model.
 * @param Model Model that the flagged parts will be unblanked in
 * @param flag Flag set on the parts that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the parts in the model.
 * @param Model Model that the defined flag for all parts will be unset in
 * @param flag Flag to unset on the parts
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the part.
 * @param redraw If model should be redrawn or not after the part is unsketched. If omitted redraw is true. If you want to unsketch several parts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all parts.
 * @param Model Model that all parts will be unblanked in
 * @param redraw If model should be redrawn or not after the parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged parts in the model.
 * @param Model Model that all parts will be unsketched in
 * @param flag Flag set on the parts that you want to unsketch
 * @param redraw If model should be redrawn or not after the parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Part;

/**
 * Adds a warning for part. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this part.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Part object.
 * @param Model Model that part will be created in
 * @param pid Part number
 * @param secid Section number or character label
 * @param mid Material number or character label
 * @param heading Title for the part
 */
    constructor(Model: Model, pid: number, secid: number, mid: number, heading?: string);

/**
 * Creates a string containing the part data in keyword format. Note that this contains the keyword header and the keyword cards. See also Part.Keyword() and Part.KeywordCards().
 */
    toString(): string;

/** Adaptivity flag */
    adpopt: number;
/** Attachment node set ID */
    ansid: number;
/** If _ATTACHMENT_NODES option is set. Can be true or false */
    attachment_nodes: boolean;
/** If _AVERAGED option is set. Can be true or false */
    averaged: boolean;
/** CAD name stored for Part (or null if doesn't exist). This property is only used by PRIMER. */
    cadname: string;
/** Coordinate system number */
    cid: number;
/** CAL3D/MADYMO number */
    cmsn: number;
/** The colour of the part */
    colour: Colour;
/** If _COMPOSITE option is set. Can be true or false */
    composite: boolean;
/** If _COMPOSITE_LONG option is set. Can be true or false */
    composite_long: boolean;
/** If _CONTACT option is set. Can be true or false */
    contact: boolean;
/** Exponential decay coefficient */
    dc: number;
/** The type of elements the Part contains. e.g. "SHELL", "SOLID" or null if empty/no section (read only). */
    readonly element_type: string;
/** Element formulation */
    elform: number;
/** Equation of state number/string */
    eosid: number|string;
/** true if part exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Dynamic coefficient of friction */
    fd: number;
/** Static coefficient of friction */
    fs: number;
/** Gravity loading */
    grav: number;
/** Part heading */
    heading: string;
/** Hourglass number/string */
    hgid: number|string;
/** Hypermesh comment read from keyword file for Part (or null if doesn't exist). */
    hmname: string;
/** The Include file number that the part is in. */
    include: number;
/** If _INERTIA option is set. Can be true or false */
    inertia: boolean;
/** Flag for inertia tensor reference coordinate system */
    ircs: number;
/** Ixx component of inertia tensor */
    ixx: number;
/** Ixy component of inertia tensor */
    ixy: number;
/** Ixz component of inertia tensor */
    ixz: number;
/** Iyy component of inertia tensor */
    iyy: number;
/** Iyz component of inertia tensor */
    iyz: number;
/** Izz component of inertia tensor */
    izz: number;
/** Part number. Also see the pid property which is an alternative name for this. */
    label: number;
/** Non structural mass per unit area */
    marea: number;
/** MADYMO ellipse/plane number */
    mdep: number;
/** Material number/string */
    mid: number|string;
/** The Model number that the part is in. */
    model: number;
/** Flag to deactivate moving for merged rigid bodies */
    movopt: number;
/** Number of integration points (layers) present for _COMPOSITE parts */
    nip: number;
/** Location of reference surface */
    nloc: number;
/** Node ID for centre of rigid body */
    nodeid: number;
/** Contact thickness */
    optt: number;
/** Part number. Also see the label property which is an alternative name for this. */
    pid: number;
/** Print flag for RBDOUT and MATSUM files */
    prbf: number;
/** If _PRINT option is set. Can be true or false */
    print: boolean;
/** If _REPOSITION option is set. Can be true or false */
    reposition: boolean;
/** true if part is rigid, false if deformable. (read only) */
    readonly rigid: boolean;
/** Section number/string */
    secid: number|string;
/** Thickness scale factor */
    sft: number;
/** Shear correction factor */
    shrf: number;
/** Scale factor on default slave penalty stiffness */
    ssf: number;
/** Thermal shell formulation */
    thshel: number;
/** total mass */
    tm: number;
/** Thermal material number/string */
    tmid: number|string;
/** The transparency of the part (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Flag for transverse shear strain distribution */
    tshear: number;
/** If _COMPOSITE_TSHELL option is set. Can be true or false */
    tshell: boolean;
/** Coefficient for viscous friction */
    vc: number;
/** x rotational velocity */
    vrx: number;
/** y rotational velocity */
    vry: number;
/** z rotational velocity */
    vrz: number;
/** x translational velocity */
    vtx: number;
/** y translational velocity */
    vty: number;
/** z translational velocity */
    vtz: number;
/** x coordinate of centre of mass */
    xc: number;
/** x coordinate of local x axis */
    xl: number;
/** x coordinate of vector in local xy plane */
    xlip: number;
/** y coordinate of centre of mass */
    yc: number;
/** y coordinate of local x axis */
    yl: number;
/** y coordinate of vector in local xy plane */
    ylip: number;
/** z coordinate of centre of mass */
    zc: number;
/** z coordinate of local x axis */
    zl: number;
/** z coordinate of vector in local xy plane */
    zlip: number;
}

declare class PopupWindow {
/**
 * Hides (unmaps) the popup window.
 */
    Hide(): void;

/**
 * Create a new PopupWindow object.
 */
    constructor();

/** If the popup window will remain mapped when a button is pressed in it. By default (false) when a button is pressed in the popup window the popup will be unmapped. If set to true then the popup will remain mapped until the user clicks out of the window or hides it by calling Hide() */
    persistent: boolean;
}

declare class PrescribedAccelerometerRigid {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the prescribed accelerometer rigid.
 * @param flag Flag to clear on the prescribed accelerometer rigid
 */
    ClearFlag(flag: number): void;

/**
 * Copies the prescribed accelerometer rigid.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): PrescribedAccelerometerRigid;

/**
 * Starts an interactive editing panel to create a boundary prescribed accelerometer rigid definition.
 * @param Model Model that the prescribed accelerometer rigid will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): PrescribedAccelerometerRigid;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for prescribed accelerometer rigid. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first prescribed accelerometer rigid in the model.
 * @param Model Model to get first prescribed accelerometer rigid in
 */
    static First(Model: Model): PrescribedAccelerometerRigid;

/**
 * Flags all of the prescribed accelerometer rigids in the model with a defined flag.
 * @param Model Model that all prescribed accelerometer rigids will be flagged in
 * @param flag Flag to set on the prescribed accelerometer rigids
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the prescribed accelerometer rigid is flagged or not.
 * @param flag Flag to test on the prescribed accelerometer rigid
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each prescribed accelerometer rigid in the model. Note that ForEach has been designed to make looping over prescribed accelerometer rigids as fast as possible and so has some limitations. Firstly, a single temporary PrescribedAccelerometerRigid object is created and on each function call it is updated with the current prescribed accelerometer rigid data. This means that you should not try to store the PrescribedAccelerometerRigid object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new prescribed accelerometer rigids inside a ForEach loop. 
 * @param Model Model that all prescribed accelerometer rigids are in
 * @param func Function to call for each prescribed accelerometer rigid
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of PrescribedAccelerometerRigid objects for all of the prescribed accelerometer rigids in a model in Primer
 * @param Model Model to get prescribed accelerometer rigids from
 */
    static GetAll(Model: Model): PrescribedAccelerometerRigid[];

/**
 * Returns an array of PrescribedAccelerometerRigid objects for all of the flagged prescribed accelerometer rigids in a model in Primer
 * @param Model Model to get prescribed accelerometer rigids from
 * @param flag Flag set on the prescribed accelerometer rigids that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): PrescribedAccelerometerRigid[];

/**
 * Returns the PrescribedAccelerometerRigid object for a prescribed accelerometer rigid ID.
 * @param Model Model to find the prescribed accelerometer rigid in
 * @param number number of the prescribed accelerometer rigid you want the PrescribedAccelerometerRigid object for
 */
    static GetFromID(Model: Model, number: number): PrescribedAccelerometerRigid;

/**
 * Checks if a PrescribedAccelerometerRigid property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the PrescribedAccelerometerRigid.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop prescribed accelerometer rigid property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the data for a row in the prescribed accelerometer rigid.
 * @param row The row you want the data for. Note row indices start at 0.
 */
    GetRow(row: number): number[];

/**
 * Returns the keyword for this prescribed accelerometer rigid. Note that a carriage return is not added. See also PrescribedAccelerometerRigid.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the prescribed accelerometer rigid. Note that a carriage return is not added. See also PrescribedAccelerometerRigid.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last prescribed accelerometer rigid in the model.
 * @param Model Model to get last prescribed accelerometer rigid in
 */
    static Last(Model: Model): PrescribedAccelerometerRigid;

/**
 * Returns the next prescribed accelerometer rigid in the model.
 */
    Next(): PrescribedAccelerometerRigid;

/**
 * Returns the previous prescribed accelerometer rigid in the model.
 */
    Previous(): PrescribedAccelerometerRigid;

/**
 * Removes the data for a row in *BOUNDARY_PRESCRIBED_ACCELEROMETER_RIGID.
 * @param row The row you want to remove the data for. Note that row indices start at 0.
 */
    RemoveRow(row: number): void;

/**
 * Allows the user to select prescribed accelerometer rigids using standard PRIMER object menus.
 * @param flag Flag to use when selecting prescribed accelerometer rigids
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only prescribed accelerometer rigids from that model can be selected. If the argument is a Flag then only prescribed accelerometer rigids that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any prescribed accelerometer rigids can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the prescribed accelerometer rigid.
 * @param flag Flag to set on the prescribed accelerometer rigid
 */
    SetFlag(flag: number): void;

/**
 * Sets the data for a row in *BOUNDARY_PRESCRIBED_ACCELEROMETER_RIGID.
 * @param row The row you want to set the data for. Note that row indices start at 0.
 * @param data The data you want to set the row to
 */
    SetRow(row: number, data: number[]): void;

/**
 * Returns the total number of prescribed accelerometer rigids in the model.
 * @param Model Model to get total for
 * @param exists true if only existing prescribed accelerometer rigids should be counted. If false or omitted referenced but undefined prescribed accelerometer rigids will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the prescribed accelerometer rigids in the model.
 * @param Model Model that the defined flag for all prescribed accelerometer rigids will be unset in
 * @param flag Flag to unset on the prescribed accelerometer rigids
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): PrescribedAccelerometerRigid;

/**
 * Adds a warning for prescribed accelerometer rigid. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this prescribed accelerometer rigid.
 */
    Xrefs(): Xrefs;

/**
 * Create a new PrescribedAccelerometerRigid object.
 * @param Model Model that prescribed accelerometer rigid will be created in
 * @param pid Part ID for rigid body whose motion is prescribed.
 * @param solv Solver type
 */
    constructor(Model: Model, pid: number, solv?: number);

/**
 * Creates a string containing the prescribed accelerometer rigid data in keyword format. Note that this contains the keyword header and the keyword cards. See also PrescribedAccelerometerRigid.Keyword() and PrescribedAccelerometerRigid.KeywordCards().
 */
    toString(): string;

/** true if prescribed accelerometer rigid exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the prescribed accelerometer rigid is in. */
    include: number;
/** The Model number that the prescribed accelerometer rigid is in. */
    model: number;
/** Number of accelerometer cards. (read only) */
    readonly nrow: number;
/** Part ID for rigid body whose motion is prescribed. */
    pid: number;
/** Solver type: 1 for Gaussian elimination or 2 for linear regression. */
    solv: number;
}

declare class PrescribedFinalGeometry {
/**
 * Blanks the boundary prescribed final geometry
 */
    Blank(): void;

/**
 * Blanks all of the boundary prescribed final geometrys in the model.
 * @param Model Model that all boundary prescribed final geometrys will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged boundary prescribed final geometrys in the model.
 * @param Model Model that all the flagged boundary prescribed final geometrys will be blanked in
 * @param flag Flag set on the boundary prescribed final geometrys that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the boundary prescribed final geometry is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the boundary prescribed final geometry.
 * @param flag Flag to clear on the boundary prescribed final geometry
 */
    ClearFlag(flag: number): void;

/**
 * Copies the boundary prescribed final geometry.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): PrescribedFinalGeometry;

/**
 * Starts an interactive editing panel to create a bpfg.
 * @param Model Model that the bpfg will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): PrescribedFinalGeometry;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for boundary prescribed final geometry. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first boundary prescribed final geometry in the model.
 * @param Model Model to get first boundary prescribed final geometry in
 */
    static First(Model: Model): PrescribedFinalGeometry;

/**
 * Returns the first free boundary prescribed final geometry label in the model. Also see PrescribedFinalGeometry.LastFreeLabel(), PrescribedFinalGeometry.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free boundary prescribed final geometry label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the boundary prescribed final geometrys in the model with a defined flag.
 * @param Model Model that all boundary prescribed final geometrys will be flagged in
 * @param flag Flag to set on the boundary prescribed final geometrys
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the boundary prescribed final geometry is flagged or not.
 * @param flag Flag to test on the boundary prescribed final geometry
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each boundary prescribed final geometry in the model. Note that ForEach has been designed to make looping over boundary prescribed final geometrys as fast as possible and so has some limitations. Firstly, a single temporary PrescribedFinalGeometry object is created and on each function call it is updated with the current boundary prescribed final geometry data. This means that you should not try to store the PrescribedFinalGeometry object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boundary prescribed final geometrys inside a ForEach loop. 
 * @param Model Model that all boundary prescribed final geometrys are in
 * @param func Function to call for each boundary prescribed final geometry
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of PrescribedFinalGeometry objects for all of the boundary prescribed final geometrys in a model in Primer
 * @param Model Model to get boundary prescribed final geometrys from
 */
    static GetAll(Model: Model): PrescribedFinalGeometry[];

/**
 * Returns data for open-ended cards for a given row number in *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY.
 * @param index Index of open-ended card you want the data for. Note that indices start at 0, not 1. 0 &lt;= index &lt; lines
 */
    GetData(index: number): number[];

/**
 * Returns an array of PrescribedFinalGeometry objects for all of the flagged boundary prescribed final geometrys in a model in Primer
 * @param Model Model to get boundary prescribed final geometrys from
 * @param flag Flag set on the boundary prescribed final geometrys that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): PrescribedFinalGeometry[];

/**
 * Returns the PrescribedFinalGeometry object for a boundary prescribed final geometry ID.
 * @param Model Model to find the boundary prescribed final geometry in
 * @param number number of the boundary prescribed final geometry you want the PrescribedFinalGeometry object for
 */
    static GetFromID(Model: Model, number: number): PrescribedFinalGeometry;

/**
 * Checks if a PrescribedFinalGeometry property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the PrescribedFinalGeometry.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop boundary prescribed final geometry property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this PrescribedFinalGeometry (*BOUNDARY_PRESCRIBED_FINAL_GEOMETRY). Note that a carriage return is not added. See also PrescribedFinalGeometry.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the PrescribedFinalGeometry. Note that a carriage return is not added. See also PrescribedFinalGeometry.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last boundary prescribed final geometry in the model.
 * @param Model Model to get last boundary prescribed final geometry in
 */
    static Last(Model: Model): PrescribedFinalGeometry;

/**
 * Returns the last free boundary prescribed final geometry label in the model. Also see PrescribedFinalGeometry.FirstFreeLabel(), PrescribedFinalGeometry.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free boundary prescribed final geometry label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next boundary prescribed final geometry in the model.
 */
    Next(): PrescribedFinalGeometry;

/**
 * Returns the next free (highest+1) boundary prescribed final geometry label in the model. Also see PrescribedFinalGeometry.FirstFreeLabel(), PrescribedFinalGeometry.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free boundary prescribed final geometry label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a boundary prescribed final geometry.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boundary prescribed final geometrys from that model can be picked. If the argument is a Flag then only boundary prescribed final geometrys that are flagged with limit can be selected. If omitted, or null, any boundary prescribed final geometrys from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): PrescribedFinalGeometry;

/**
 * Returns the previous boundary prescribed final geometry in the model.
 */
    Previous(): PrescribedFinalGeometry;

/**
 * Removes a line of data for a *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY.
 * @param index The index of the *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY data to remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; lines
 */
    RemoveData(index: number): void;

/**
 * Renumbers all of the boundary prescribed final geometrys in the model.
 * @param Model Model that all boundary prescribed final geometrys will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged boundary prescribed final geometrys in the model.
 * @param Model Model that all the flagged boundary prescribed final geometrys will be renumbered in
 * @param flag Flag set on the boundary prescribed final geometrys that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select boundary prescribed final geometrys using standard PRIMER object menus.
 * @param flag Flag to use when selecting boundary prescribed final geometrys
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boundary prescribed final geometrys from that model can be selected. If the argument is a Flag then only boundary prescribed final geometrys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boundary prescribed final geometrys can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a line of data for a *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY.
 * @param index The index of the *BOUNDARY_PRESCRIBED_FINAL_GEOMETRY data to set. Note that indices start at 0, not 1. 0 &lt;= index &lt;= lines
 * @param nid Node or negative node set number.
 * @param x X coordinates of final geometry.
 * @param y Y coordinates of final geometry.
 * @param z Z coordinates of final geometry.
 * @param lcid Loadcurve number.
 * @param death Death time.
 */
    SetData(index: number, nid: number, x: number, y: number, z: number, lcid?: number, death?: number): void;

/**
 * Sets a flag on the boundary prescribed final geometry.
 * @param flag Flag to set on the boundary prescribed final geometry
 */
    SetFlag(flag: number): void;

/**
 * Sketches the boundary prescribed final geometry. The boundary prescribed final geometry will be sketched until you either call PrescribedFinalGeometry.Unsketch(), PrescribedFinalGeometry.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the boundary prescribed final geometry is sketched. If omitted redraw is true. If you want to sketch several boundary prescribed final geometrys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged boundary prescribed final geometrys in the model. The boundary prescribed final geometrys will be sketched until you either call PrescribedFinalGeometry.Unsketch(), PrescribedFinalGeometry.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged boundary prescribed final geometrys will be sketched in
 * @param flag Flag set on the boundary prescribed final geometrys that you want to sketch
 * @param redraw If model should be redrawn or not after the boundary prescribed final geometrys are sketched. If omitted redraw is true. If you want to sketch flagged boundary prescribed final geometrys several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of boundary prescribed final geometrys in the model.
 * @param Model Model to get total for
 * @param exists true if only existing boundary prescribed final geometrys should be counted. If false or omitted referenced but undefined boundary prescribed final geometrys will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the boundary prescribed final geometry
 */
    Unblank(): void;

/**
 * Unblanks all of the boundary prescribed final geometrys in the model.
 * @param Model Model that all boundary prescribed final geometrys will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged boundary prescribed final geometrys in the model.
 * @param Model Model that the flagged boundary prescribed final geometrys will be unblanked in
 * @param flag Flag set on the boundary prescribed final geometrys that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the boundary prescribed final geometrys in the model.
 * @param Model Model that the defined flag for all boundary prescribed final geometrys will be unset in
 * @param flag Flag to unset on the boundary prescribed final geometrys
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the boundary prescribed final geometry.
 * @param redraw If model should be redrawn or not after the boundary prescribed final geometry is unsketched. If omitted redraw is true. If you want to unsketch several boundary prescribed final geometrys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all boundary prescribed final geometrys.
 * @param Model Model that all boundary prescribed final geometrys will be unblanked in
 * @param redraw If model should be redrawn or not after the boundary prescribed final geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged boundary prescribed final geometrys in the model.
 * @param Model Model that all boundary prescribed final geometrys will be unsketched in
 * @param flag Flag set on the boundary prescribed final geometrys that you want to unsketch
 * @param redraw If model should be redrawn or not after the boundary prescribed final geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): PrescribedFinalGeometry;

/**
 * Adds a warning for boundary prescribed final geometry. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this boundary prescribed final geometry.
 */
    Xrefs(): Xrefs;

/**
 * Create a new PrescribedFinalGeometry object.
 * @param Model Model that PrescribedFinalGeometry will be created in
 * @param bpfgid PrescribedFinalGeometry number.
 */
    constructor(Model: Model, bpfgid: PrescribedFinalGeometry);

/**
 * Creates a string containing the PrescribedFinalGeometry data in keyword format. Note that this contains the keyword header and the keyword cards. See also PrescribedFinalGeometry.Keyword() and PrescribedFinalGeometry.KeywordCards().
 */
    toString(): string;

/** PrescribedFinalGeometry number. Also see the label property which is an alternative name for this. */
    bpfgid: number;
/** Default death time. */
    deathd: number;
/** true if boundary prescribed final_geometry exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** PrescribedFinalGeometry number. Also see the label property which is an alternative name for this. */
    id: number;
/** The Include file number that the boundary prescribed final_geometry is in. */
    include: number;
/** PrescribedFinalGeometry number. Also see the bpfgid property which is an alternative name for this. */
    label: number;
/** Default loadcurve number. */
    lcidf: number;
/** Number of lines of nodal data on the card. */
    readonly lines: number;
/** The Model number that the boundary prescribed final geometry is in. */
    model: number;
}


/** Object returned by AnimationBegin */
interface AnimationBeginReturn {
    /** End time */
    end: number;
    /** Current frame */
    frame: number;
    /** Number of frames */
    frames: number;
    /** Animation speed in fps */
    rate: number;
    /** Animation repeat (0=off, 1=on) */
    repeat: number;
    /** Start time */
    start: number;
    /** Current time */
    time: number;
}


/** Object returned by AnimationGetData */
interface AnimationGetDataReturn {
    /** End time */
    end: number;
    /** Current frame */
    frame: number;
    /** Number of frames */
    frames: number;
    /** Animation speed in fps */
    rate: number;
    /** Animation repeat (0=off, 1=on) */
    repeat: number;
    /** Start time */
    start: number;
    /** Current time */
    time: number;
}


/** Object function argument in AnimationSetData */
interface AnimationSetDataArgument_data {
    /** End time */
    end: number;
    /** Current frame */
    frame: number;
    /** Number of frames */
    frames: number;
    /** Animation speed in fps */
    rate: number;
    /** Animation repeat (0=off, 1=on) */
    repeat: number;
    /** Start time */
    start: number;
    /** Current time */
    time: number;
}

declare class PrescribedMotion {
/**
 * Moves backward one frame of a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.
 */
    static AnimationBackward(): void;

/**
 * Begins a PrescribedMotion animation. This MUST be called before any of the other Animation methods. Also see the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.
 * @param Model Model that PrescribedMotions are in
 * @param flag Flag set on the PrescribedMotions that you want to animate
 */
    static AnimationBegin(Model: Model, flag: number): AnimationBeginReturn;

/**
 * Finishes a PrescribedMotion animation. This MUST be called to finish animating. This will restore nodal coordinates but will not perform a graphics update. Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating.
 */
    static AnimationFinish(): void;

/**
 * Moves forward one frame of a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.
 */
    static AnimationForward(): void;

/**
 * Returns the animation data (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.
 */
    static AnimationGetData(): AnimationGetDataReturn;

/**
 * Pauses playback of a PrescribedMotion animation. Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.
 */
    static AnimationPause(): void;

/**
 * Starts playback of a PrescribedMotion animation. Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.This method should only be used from a script which implements a user interface so you can actually stop the animation! Don't forget to add a pause/stop button that calls PrescribedMotion.AnimationPause()!
 */
    static AnimationPlay(): void;

/**
 * Sets the current animation data (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.
 * @param data data returned from PrescribedMotion.AnimationBegin() or PrescribedMotion.AnimationGetData()
 */
    static AnimationSetData(data: AnimationSetDataArgument_data): void;

/**
 * Moves to the end of a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.
 */
    static AnimationToEnd(): void;

/**
 * Moves to the start of a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.
 */
    static AnimationToStart(): void;

/**
 * Moves to a specific time in a PrescribedMotion animation (pausing animation first if required). Also see the PrescribedMotion.AnimationBegin() method which MUST be called before you start animating and the PrescribedMotion.AnimationFinish() method which MUST be called after you have finished animating.
 */
    static AnimationToTime(): void;

/**
 * Blanks the boundary prescribed motion
 */
    Blank(): void;

/**
 * Blanks all of the boundary prescribed motions in the model.
 * @param Model Model that all boundary prescribed motions will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged boundary prescribed motions in the model.
 * @param Model Model that all the flagged boundary prescribed motions will be blanked in
 * @param flag Flag set on the boundary prescribed motions that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the boundary prescribed motion is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the boundary prescribed motion.
 * @param flag Flag to clear on the boundary prescribed motion
 */
    ClearFlag(flag: number): void;

/**
 * Copies the boundary prescribed motion.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): PrescribedMotion;

/**
 * Adds an error for boundary prescribed motion. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first boundary prescribed motion in the model.
 * @param Model Model to get first boundary prescribed motion in
 */
    static First(Model: Model): PrescribedMotion;

/**
 * Returns the first free boundary prescribed motion label in the model. Also see PrescribedMotion.LastFreeLabel(), PrescribedMotion.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free boundary prescribed motion label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the boundary prescribed motions in the model with a defined flag.
 * @param Model Model that all boundary prescribed motions will be flagged in
 * @param flag Flag to set on the boundary prescribed motions
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the boundary prescribed motion is flagged or not.
 * @param flag Flag to test on the boundary prescribed motion
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each boundary prescribed motion in the model. Note that ForEach has been designed to make looping over boundary prescribed motions as fast as possible and so has some limitations. Firstly, a single temporary PrescribedMotion object is created and on each function call it is updated with the current boundary prescribed motion data. This means that you should not try to store the PrescribedMotion object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boundary prescribed motions inside a ForEach loop. 
 * @param Model Model that all boundary prescribed motions are in
 * @param func Function to call for each boundary prescribed motion
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of PrescribedMotion objects for all of the boundary prescribed motions in a model in Primer
 * @param Model Model to get boundary prescribed motions from
 */
    static GetAll(Model: Model): PrescribedMotion[];

/**
 * Returns an array of PrescribedMotion objects for all of the flagged boundary prescribed motions in a model in Primer
 * @param Model Model to get boundary prescribed motions from
 * @param flag Flag set on the boundary prescribed motions that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): PrescribedMotion[];

/**
 * Returns the PrescribedMotion object for a boundary prescribed motion ID.
 * @param Model Model to find the boundary prescribed motion in
 * @param number number of the boundary prescribed motion you want the PrescribedMotion object for
 */
    static GetFromID(Model: Model, number: number): PrescribedMotion;

/**
 * Checks if a PrescribedMotion property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the PrescribedMotion.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop boundary prescribed motion property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this PrescribedMotion (*BOUNDARY_PRESCRIBED_MOTION_xxxx). Note that a carriage return is not added. See also PrescribedMotion.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the PrescribedMotion. Note that a carriage return is not added. See also PrescribedMotion.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last boundary prescribed motion in the model.
 * @param Model Model to get last boundary prescribed motion in
 */
    static Last(Model: Model): PrescribedMotion;

/**
 * Returns the last free boundary prescribed motion label in the model. Also see PrescribedMotion.FirstFreeLabel(), PrescribedMotion.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free boundary prescribed motion label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next boundary prescribed motion in the model.
 */
    Next(): PrescribedMotion;

/**
 * Returns the next free (highest+1) boundary prescribed motion label in the model. Also see PrescribedMotion.FirstFreeLabel(), PrescribedMotion.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free boundary prescribed motion label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a boundary prescribed motion.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boundary prescribed motions from that model can be picked. If the argument is a Flag then only boundary prescribed motions that are flagged with limit can be selected. If omitted, or null, any boundary prescribed motions from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): PrescribedMotion;

/**
 * Returns the previous boundary prescribed motion in the model.
 */
    Previous(): PrescribedMotion;

/**
 * Renumbers all of the boundary prescribed motions in the model.
 * @param Model Model that all boundary prescribed motions will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged boundary prescribed motions in the model.
 * @param Model Model that all the flagged boundary prescribed motions will be renumbered in
 * @param flag Flag set on the boundary prescribed motions that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select boundary prescribed motions using standard PRIMER object menus.
 * @param flag Flag to use when selecting boundary prescribed motions
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boundary prescribed motions from that model can be selected. If the argument is a Flag then only boundary prescribed motions that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boundary prescribed motions can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the boundary prescribed motion.
 * @param flag Flag to set on the boundary prescribed motion
 */
    SetFlag(flag: number): void;

/**
 * Sketches the boundary prescribed motion. The boundary prescribed motion will be sketched until you either call PrescribedMotion.Unsketch(), PrescribedMotion.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the boundary prescribed motion is sketched. If omitted redraw is true. If you want to sketch several boundary prescribed motions and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged boundary prescribed motions in the model. The boundary prescribed motions will be sketched until you either call PrescribedMotion.Unsketch(), PrescribedMotion.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged boundary prescribed motions will be sketched in
 * @param flag Flag set on the boundary prescribed motions that you want to sketch
 * @param redraw If model should be redrawn or not after the boundary prescribed motions are sketched. If omitted redraw is true. If you want to sketch flagged boundary prescribed motions several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of boundary prescribed motions in the model.
 * @param Model Model to get total for
 * @param exists true if only existing boundary prescribed motions should be counted. If false or omitted referenced but undefined boundary prescribed motions will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the boundary prescribed motion
 */
    Unblank(): void;

/**
 * Unblanks all of the boundary prescribed motions in the model.
 * @param Model Model that all boundary prescribed motions will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged boundary prescribed motions in the model.
 * @param Model Model that the flagged boundary prescribed motions will be unblanked in
 * @param flag Flag set on the boundary prescribed motions that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the boundary prescribed motions in the model.
 * @param Model Model that the defined flag for all boundary prescribed motions will be unset in
 * @param flag Flag to unset on the boundary prescribed motions
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the boundary prescribed motion.
 * @param redraw If model should be redrawn or not after the boundary prescribed motion is unsketched. If omitted redraw is true. If you want to unsketch several boundary prescribed motions and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all boundary prescribed motions.
 * @param Model Model that all boundary prescribed motions will be unblanked in
 * @param redraw If model should be redrawn or not after the boundary prescribed motions are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged boundary prescribed motions in the model.
 * @param Model Model that all boundary prescribed motions will be unsketched in
 * @param flag Flag set on the boundary prescribed motions that you want to unsketch
 * @param redraw If model should be redrawn or not after the boundary prescribed motions are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): PrescribedMotion;

/**
 * Adds a warning for boundary prescribed motion. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this boundary prescribed motion.
 */
    Xrefs(): Xrefs;

/**
 * Create a new PrescribedMotion object.
 * @param Model Model that PrescribedMotion will be created in
 * @param typeid Node ID, node set ID or part ID
 * @param dof Degree of freedom
 * @param vad Velocity/acceleration/displacement flag
 * @param lcid Load curve for motion
 * @param type Specify the type of prescribed motion (Can be PrescribedMotion.NODE, PrescribedMotion.SET, PrescribedMotion.RIGID, PrescribedMotion.RIGID_LOCAL, PrescribedMotion.NRBC, PrescribedMotion.NRBC_LOCAL, PrescribedMotion.SET_SEGMENT or PrescribedMotion.SET_LINE)
 * @param label PrescribedMotion number
 * @param heading Title for the PrescribedMotion
 */
    constructor(Model: Model, typeid: number, dof: number, vad: number, lcid: number, type: number, label?: number, heading?: string);

/**
 * Creates a string containing the PrescribedMotion data in keyword format. Note that this contains the keyword header and the keyword cards. See also PrescribedMotion.Keyword() and PrescribedMotion.KeywordCards().
 */
    toString(): string;

/** Birth time */
    birth: number;
/** true if _BNDOUT2DYNAIN option is set, false if not */
    bndout2dynain: boolean;
/** Death time */
    death: number;
/** Degree of freedom */
    dof: number;
/** true if boundary prescribed motion exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** PrescribedMotion heading */
    heading: string;
/** true if _ID option is set, false if not */
    id: boolean;
/** The Include file number that the boundary prescribed motion is in. */
    include: number;
/** PrescribedMotion number. */
    label: number;
/** Load curve of motion vs. time */
    lcid: number;
/** The Model number that the boundary prescribed motion is in. */
    model: number;
/** Master rigid body for measuring relative displacement */
    mrb: number;
/** Node ID of a starting node. Used for PrescribedMotion.SET_LINE */
    nbeg: number;
/** Node ID of a ending node. Used for PrescribedMotion.SET_LINE */
    nend: number;
/** Optional orientation node for relative displacement */
    node1: number;
/** Optional orientation node for relative displacement */
    node2: number;
/** Offset 1 for types 9-11 */
    offset1: number;
/** Offset 2 for types 9-11 */
    offset2: number;
/** String representing the name of the parameter to be output to the dynain file. Used when PrescribedMotion.bndout2dynain is set to true. */
    prmr: string;
/** Load curve scale factor */
    sf: number;
/** The Prescribed motion type. Can be PrescribedMotion.NODE, PrescribedMotion.SET, PrescribedMotion.RIGID, PrescribedMotion.RIGID_LOCAL, PrescribedMotion.NRBC, PrescribedMotion.NRBC_LOCAL, PrescribedMotion.SET_SEGMENT or PrescribedMotion.SET_LINE */
    type: number;
/** Node ID, node set ID, part ID or NRB */
    typeid: number;
/** Velocity/acceleration/displacement flag */
    vad: number;
/** Vector ID */
    vid: number;
/** Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_NODE. */
    static NODE: number;
/** Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_RIGID, with an NRB, not a part. */
    static NRBC: number;
/** Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_RIGID_LOCAL, with an NRB, not a part. */
    static NRBC_LOCAL: number;
/** Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_RIGID. */
    static RIGID: number;
/** Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_RIGID_LOCAL. */
    static RIGID_LOCAL: number;
/** Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_SET. */
    static SET: number;
/** Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_SET_LINE. */
    static SET_LINE: number;
/** Prescribed motion is *BOUNDARY_PRESCRIBED_MOTION_SET_SEGMENT. */
    static SET_SEGMENT: number;
}

declare class PrescribedOrientationRigid {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the prescribed orientation rigid.
 * @param flag Flag to clear on the prescribed orientation rigid
 */
    ClearFlag(flag: number): void;

/**
 * Copies the prescribed orientation rigid.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): PrescribedOrientationRigid;

/**
 * Starts an interactive editing panel to create a boundary prescribed orientation rigid definition.
 * @param Model Model that the prescribed orientation rigid will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): PrescribedOrientationRigid;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for prescribed orientation rigid. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first prescribed orientation rigid in the model.
 * @param Model Model to get first prescribed orientation rigid in
 */
    static First(Model: Model): PrescribedOrientationRigid;

/**
 * Flags all of the prescribed orientation rigids in the model with a defined flag.
 * @param Model Model that all prescribed orientation rigids will be flagged in
 * @param flag Flag to set on the prescribed orientation rigids
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the prescribed orientation rigid is flagged or not.
 * @param flag Flag to test on the prescribed orientation rigid
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each prescribed orientation rigid in the model. Note that ForEach has been designed to make looping over prescribed orientation rigids as fast as possible and so has some limitations. Firstly, a single temporary PrescribedOrientationRigid object is created and on each function call it is updated with the current prescribed orientation rigid data. This means that you should not try to store the PrescribedOrientationRigid object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new prescribed orientation rigids inside a ForEach loop. 
 * @param Model Model that all prescribed orientation rigids are in
 * @param func Function to call for each prescribed orientation rigid
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of PrescribedOrientationRigid objects for all of the prescribed orientation rigids in a model in Primer
 * @param Model Model to get prescribed orientation rigids from
 */
    static GetAll(Model: Model): PrescribedOrientationRigid[];

/**
 * Returns an array of PrescribedOrientationRigid objects for all of the flagged prescribed orientation rigids in a model in Primer
 * @param Model Model to get prescribed orientation rigids from
 * @param flag Flag set on the prescribed orientation rigids that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): PrescribedOrientationRigid[];

/**
 * Returns the PrescribedOrientationRigid object for a prescribed orientation rigid ID.
 * @param Model Model to find the prescribed orientation rigid in
 * @param number number of the prescribed orientation rigid you want the PrescribedOrientationRigid object for
 */
    static GetFromID(Model: Model, number: number): PrescribedOrientationRigid;

/**
 * Checks if a PrescribedOrientationRigid property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the PrescribedOrientationRigid.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop prescribed orientation rigid property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this prescribed orientation rigid. Note that a carriage return is not added. See also PrescribedOrientationRigid.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the prescribed orientation rigid. Note that a carriage return is not added. See also PrescribedOrientationRigid.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last prescribed orientation rigid in the model.
 * @param Model Model to get last prescribed orientation rigid in
 */
    static Last(Model: Model): PrescribedOrientationRigid;

/**
 * Returns the next prescribed orientation rigid in the model.
 */
    Next(): PrescribedOrientationRigid;

/**
 * Returns the previous prescribed orientation rigid in the model.
 */
    Previous(): PrescribedOrientationRigid;

/**
 * Allows the user to select prescribed orientation rigids using standard PRIMER object menus.
 * @param flag Flag to use when selecting prescribed orientation rigids
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only prescribed orientation rigids from that model can be selected. If the argument is a Flag then only prescribed orientation rigids that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any prescribed orientation rigids can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the prescribed orientation rigid.
 * @param flag Flag to set on the prescribed orientation rigid
 */
    SetFlag(flag: number): void;

/**
 * Sketches the prescribed orientation rigid. The prescribed orientation rigid will be sketched until you either call PrescribedOrientationRigid.Unsketch(), PrescribedOrientationRigid.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the prescribed orientation rigid is sketched. If omitted redraw is true. If you want to sketch several prescribed orientation rigids and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged prescribed orientation rigids in the model. The prescribed orientation rigids will be sketched until you either call PrescribedOrientationRigid.Unsketch(), PrescribedOrientationRigid.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged prescribed orientation rigids will be sketched in
 * @param flag Flag set on the prescribed orientation rigids that you want to sketch
 * @param redraw If model should be redrawn or not after the prescribed orientation rigids are sketched. If omitted redraw is true. If you want to sketch flagged prescribed orientation rigids several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of prescribed orientation rigids in the model.
 * @param Model Model to get total for
 * @param exists true if only existing prescribed orientation rigids should be counted. If false or omitted referenced but undefined prescribed orientation rigids will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the prescribed orientation rigids in the model.
 * @param Model Model that the defined flag for all prescribed orientation rigids will be unset in
 * @param flag Flag to unset on the prescribed orientation rigids
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the prescribed orientation rigid.
 * @param redraw If model should be redrawn or not after the prescribed orientation rigid is unsketched. If omitted redraw is true. If you want to unsketch several prescribed orientation rigids and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all prescribed orientation rigids.
 * @param Model Model that all prescribed orientation rigids will be unblanked in
 * @param redraw If model should be redrawn or not after the prescribed orientation rigids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged prescribed orientation rigids in the model.
 * @param Model Model that all prescribed orientation rigids will be unsketched in
 * @param flag Flag set on the prescribed orientation rigids that you want to unsketch
 * @param redraw If model should be redrawn or not after the prescribed orientation rigids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): PrescribedOrientationRigid;

/**
 * Adds a warning for prescribed orientation rigid. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this prescribed orientation rigid.
 */
    Xrefs(): Xrefs;

/**
 * Create a new PrescribedOrientationRigid object.
 * @param Model Model that prescribed orientation rigid will be created in
 * @param option Suffix for boundary prescribed orientation rigid. Can be PrescribedOrientationRigid.DIRCOS PrescribedOrientationRigid.ANGLES PrescribedOrientationRigid.EULERP PrescribedOrientationRigid.VECTOR
 * @param pidb Part ID for rigid body B whose orientation is prescribed.
 * @param label PrescribedOrientationRigid number
 * @param heading Title for the PrescribedOrientationRigid
 */
    constructor(Model: Model, option: number, pidb: number, label?: number, heading?: string);

/**
 * Creates a string containing the prescribed orientation rigid data in keyword format. Note that this contains the keyword header and the keyword cards. See also PrescribedOrientationRigid.Keyword() and PrescribedOrientationRigid.KeywordCards().
 */
    toString(): string;

/** Time prior to which the body moves freely under the action of other agents. */
    birth: number;
/** Reference axes: 0 for rotations about axes fixed in PIDA or 1 for those fixed in PIDB. */
    body: number;
/** Time when the body is freed from the restriction. */
    death: number;
/** true if prescribed orientation rigid exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** PrescribedOrientationRigid heading */
    heading: string;
/** true if _ID option is set, false if not. */
    id: boolean;
/** The Include file number that the prescribed orientation rigid is in. */
    include: number;
/** Interpolation method: 1 for linear interpolation or 2 for cubic spline interpolation. */
    intrp: number;
/** Interpolation method: 1 for linear interpolation or 2 for cubic spline interpolation. */
    intrp_1: number;
/** Specifies the sequence in which the rotations are performed. */
    iseq: number;
/** Angle shift: 1 for unaltered angle curves or 2 for angle data shift in LCIDQi curves eliminating discontinuities. */
    ishft: number;
/** Load curve ID specifying direction cosine C11 as function of time. */
    lcidc11: number;
/** Load curve ID specifying direction cosine C12 as function of time. */
    lcidc12: number;
/** Load curve ID specifying direction cosine C13 as function of time. */
    lcidc13: number;
/** Load curve ID specifying direction cosine C21 as function of time. */
    lcidc21: number;
/** Load curve ID specifying direction cosine C22 as function of time. */
    lcidc22: number;
/** Load curve ID specifying direction cosine C23 as function of time. */
    lcidc23: number;
/** Load curve ID specifying direction cosine C31 as function of time. */
    lcidc31: number;
/** Load curve ID specifying direction cosine C32 as function of time. */
    lcidc32: number;
/** Load curve ID specifying direction cosine C33 as function of time. */
    lcidc33: number;
/** Load curve ID specifying Euler parameter e1 as function of time. */
    lcide1: number;
/** Load curve ID specifying Euler parameter e2 as function of time. */
    lcide2: number;
/** Load curve ID specifying Euler parameter e3 as function of time. */
    lcide3: number;
/** Load curve ID specifying Euler parameter e4 as function of time. */
    lcide4: number;
/** Load curve ID specifying orientation angle q1 as function of time. */
    lcidq1: number;
/** Load curve ID specifying orientation angle q2 as function of time. */
    lcidq2: number;
/** Load curve ID specifying orientation angle q3 as function of time. */
    lcidq3: number;
/** Load curve ID specifying spin speed of PIDB about axis parallel to vector. */
    lcids: number;
/** Load curve ID specifying vector measure number v1 as function of time. */
    lcidv1: number;
/** Load curve ID specifying vector measure number v2 as function of time. */
    lcidv2: number;
/** Load curve ID specifying vector measure number v3 as function of time. */
    lcidv3: number;
/** The Model number that the prescribed orientation rigid is in. */
    model: number;
/** The Boundary Prescribed Orientation Rigid option. Can be PrescribedOrientationRigid.DIRCOS, PrescribedOrientationRigid.ANGLES, PrescribedOrientationRigid.EULERP or PrescribedOrientationRigid.VECTOR. */
    option: number;
/** Part ID for rigid body A. */
    pida: number;
/** Part ID for rigid body B whose orientation is prescribed. */
    pidb: number;
/** Time offset flag. */
    toffset: number;
/** Constant value for spin speed of PIDB about axis parallel to vector. Used when LCIDS is 0. */
    valspin: number;
/** Boundary is *BOUNDARY_PRESCRIBED_ORIENTATION_RIGID_ANGLES. */
    static ANGLES: number;
/** Boundary is *BOUNDARY_PRESCRIBED_ORIENTATION_RIGID_DIRCOS. */
    static DIRCOS: number;
/** Boundary is *BOUNDARY_PRESCRIBED_ORIENTATION_RIGID_EULERP. */
    static EULERP: number;
/** Boundary is *BOUNDARY_PRESCRIBED_ORIENTATION_RIGID_VECTOR. */
    static VECTOR: number;
}

declare class Pretensioner {
/**
 * Blanks the pretensioner
 */
    Blank(): void;

/**
 * Blanks all of the pretensioners in the model.
 * @param Model Model that all pretensioners will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged pretensioners in the model.
 * @param Model Model that all the flagged pretensioners will be blanked in
 * @param flag Flag set on the pretensioners that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the pretensioner is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the pretensioner.
 * @param flag Flag to clear on the pretensioner
 */
    ClearFlag(flag: number): void;

/**
 * Copies the pretensioner.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Pretensioner;

/**
 * Starts an interactive editing panel to create a pretensioner.
 * @param Model Model that the pretensioner will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Pretensioner;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for pretensioner. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for pretensioner. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the pretensioner colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the pretensioner.
 */
    ExtractColour(): number;

/**
 * Returns the first pretensioner in the model.
 * @param Model Model to get first pretensioner in
 */
    static First(Model: Model): Pretensioner;

/**
 * Returns the first free pretensioner label in the model. Also see Pretensioner.LastFreeLabel(), Pretensioner.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free pretensioner label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the pretensioners in the model with a defined flag.
 * @param Model Model that all pretensioners will be flagged in
 * @param flag Flag to set on the pretensioners
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the pretensioner is flagged or not.
 * @param flag Flag to test on the pretensioner
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each pretensioner in the model. Note that ForEach has been designed to make looping over pretensioners as fast as possible and so has some limitations. Firstly, a single temporary Pretensioner object is created and on each function call it is updated with the current pretensioner data. This means that you should not try to store the Pretensioner object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new pretensioners inside a ForEach loop. 
 * @param Model Model that all pretensioners are in
 * @param func Function to call for each pretensioner
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Pretensioner objects for all of the pretensioners in a model in Primer
 * @param Model Model to get pretensioners from
 */
    static GetAll(Model: Model): Pretensioner[];

/**
 * Returns an array of Pretensioner objects for all of the flagged pretensioners in a model in Primer
 * @param Model Model to get pretensioners from
 * @param flag Flag set on the pretensioners that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Pretensioner[];

/**
 * Returns the Pretensioner object for a pretensioner ID.
 * @param Model Model to find the pretensioner in
 * @param number number of the pretensioner you want the Pretensioner object for
 */
    static GetFromID(Model: Model, number: number): Pretensioner;

/**
 * Checks if a Pretensioner property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Pretensioner.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop pretensioner property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this pretensioner (*ELEMENT_SEATBELT_PRETEROMETER) Note that a carriage return is not added. See also Pretensioner.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the pretensioner. Note that a carriage return is not added. See also Pretensioner.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last pretensioner in the model.
 * @param Model Model to get last pretensioner in
 */
    static Last(Model: Model): Pretensioner;

/**
 * Returns the last free pretensioner label in the model. Also see Pretensioner.FirstFreeLabel(), Pretensioner.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free pretensioner label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next pretensioner in the model.
 */
    Next(): Pretensioner;

/**
 * Returns the next free (highest+1) pretensioner label in the model. Also see Pretensioner.FirstFreeLabel(), Pretensioner.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free pretensioner label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a pretensioner.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only pretensioners from that model can be picked. If the argument is a Flag then only pretensioners that are flagged with limit can be selected. If omitted, or null, any pretensioners from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Pretensioner;

/**
 * Returns the previous pretensioner in the model.
 */
    Previous(): Pretensioner;

/**
 * Renumbers all of the pretensioners in the model.
 * @param Model Model that all pretensioners will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged pretensioners in the model.
 * @param Model Model that all the flagged pretensioners will be renumbered in
 * @param flag Flag set on the pretensioners that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select pretensioners using standard PRIMER object menus.
 * @param flag Flag to use when selecting pretensioners
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only pretensioners from that model can be selected. If the argument is a Flag then only pretensioners that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any pretensioners can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the pretensioner.
 * @param flag Flag to set on the pretensioner
 */
    SetFlag(flag: number): void;

/**
 * Sketches the pretensioner. The pretensioner will be sketched until you either call Pretensioner.Unsketch(), Pretensioner.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the pretensioner is sketched. If omitted redraw is true. If you want to sketch several pretensioners and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged pretensioners in the model. The pretensioners will be sketched until you either call Pretensioner.Unsketch(), Pretensioner.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged pretensioners will be sketched in
 * @param flag Flag set on the pretensioners that you want to sketch
 * @param redraw If model should be redrawn or not after the pretensioners are sketched. If omitted redraw is true. If you want to sketch flagged pretensioners several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of pretensioners in the model.
 * @param Model Model to get total for
 * @param exists true if only existing pretensioners should be counted. If false or omitted referenced but undefined pretensioners will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the pretensioner
 */
    Unblank(): void;

/**
 * Unblanks all of the pretensioners in the model.
 * @param Model Model that all pretensioners will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged pretensioners in the model.
 * @param Model Model that the flagged pretensioners will be unblanked in
 * @param flag Flag set on the pretensioners that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the pretensioners in the model.
 * @param Model Model that the defined flag for all pretensioners will be unset in
 * @param flag Flag to unset on the pretensioners
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the pretensioner.
 * @param redraw If model should be redrawn or not after the pretensioner is unsketched. If omitted redraw is true. If you want to unsketch several pretensioners and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all pretensioners.
 * @param Model Model that all pretensioners will be unblanked in
 * @param redraw If model should be redrawn or not after the pretensioners are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged pretensioners in the model.
 * @param Model Model that all pretensioners will be unsketched in
 * @param flag Flag set on the pretensioners that you want to unsketch
 * @param redraw If model should be redrawn or not after the pretensioners are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Pretensioner;

/**
 * Adds a warning for pretensioner. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this pretensioner.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Seatbelt Pretensioner object.
 * @param Model Model that pretensioner will be created in
 * @param sbprid Pretensioner number.
 * @param sbprty Pretensioner type.
 * @param sbrid Retractor number.
 * @param ptlcid Loadcurve of pull-in vs time
 * @param sbsid1 Sensor number 1
 * @param sbsid2 Sensor number 2
 * @param sbsid3 Sensor number 3
 * @param sbsid4 Sensor number 4
 * @param time Time between sensor triggering and pretensioner acting.
 * @param lmtfrc Limiting force
 */
    constructor(Model: Model, sbprid: number, sbprty: number, sbrid: number, ptlcid: number, sbsid1: number, sbsid2?: number, sbsid3?: number, sbsid4?: number, time?: number, lmtfrc?: number);

/**
 * Creates a string containing the pretensioner data in keyword format. Note that this contains the keyword header and the keyword cards. See also Pretensioner.Keyword() and Pretensioner.KeywordCards().
 */
    toString(): string;

/** The colour of the pretensioner */
    colour: Colour;
/** true if pretensioner exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the pretensioner is in. */
    include: number;
/** Pretensioner number. Also see the sbprid property which is an alternative name for this. */
    label: number;
/** Limiting force */
    lmtfrc: number;
/** The Model number that the pretensioner is in. */
    model: number;
/** Loadcurve of pull-in vs time */
    ptlcid: number;
/** Pretensioner number. Also see the label property which is an alternative name for this. */
    sbprid: number;
/** Pretensioner type. */
    sbprty: number;
/** Retractor number. */
    sbrid: number;
/** Sensor number 1 */
    sbsid1: number;
/** Sensor number 2 */
    sbsid2: number;
/** Sensor number 3 */
    sbsid3: number;
/** Sensor number 4 */
    sbsid4: number;
/** Time between sensor triggering and pretensioner acting. */
    time: number;
/** The transparency of the pretensioner (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
}

declare class ReferenceGeometry {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the airbag reference geometry.
 * @param flag Flag to clear on the airbag reference geometry
 */
    ClearFlag(flag: number): void;

/**
 * Copies the airbag reference geometry.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): ReferenceGeometry;

/**
 * Starts an interactive editing panel to create an ardt.
 * @param Model Model that the ardt will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): ReferenceGeometry;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for airbag reference geometry. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first airbag reference geometry in the model.
 * @param Model Model to get first airbag reference geometry in
 */
    static First(Model: Model): ReferenceGeometry;

/**
 * Returns the first free airbag reference geometry label in the model. Also see ReferenceGeometry.LastFreeLabel(), ReferenceGeometry.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free airbag reference geometry label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the airbag reference geometrys in the model with a defined flag.
 * @param Model Model that all airbag reference geometrys will be flagged in
 * @param flag Flag to set on the airbag reference geometrys
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the airbag reference geometry is flagged or not.
 * @param flag Flag to test on the airbag reference geometry
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each airbag reference geometry in the model. Note that ForEach has been designed to make looping over airbag reference geometrys as fast as possible and so has some limitations. Firstly, a single temporary ReferenceGeometry object is created and on each function call it is updated with the current airbag reference geometry data. This means that you should not try to store the ReferenceGeometry object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new airbag reference geometrys inside a ForEach loop. 
 * @param Model Model that all airbag reference geometrys are in
 * @param func Function to call for each airbag reference geometry
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of ReferenceGeometry objects for all of the airbag reference geometrys in a model in Primer
 * @param Model Model to get airbag reference geometrys from
 */
    static GetAll(Model: Model): ReferenceGeometry[];

/**
 * Returns an array of ReferenceGeometry objects for all of the flagged airbag reference geometrys in a model in Primer
 * @param Model Model to get airbag reference geometrys from
 * @param flag Flag set on the airbag reference geometrys that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): ReferenceGeometry[];

/**
 * Returns the ReferenceGeometry object for a airbag reference geometry ID.
 * @param Model Model to find the airbag reference geometry in
 * @param number number of the airbag reference geometry you want the ReferenceGeometry object for
 */
    static GetFromID(Model: Model, number: number): ReferenceGeometry;

/**
 * Returns the reference geometry coordinates for the node
 * @param nid Node ID
 */
    GetNode(nid: number): number[];

/**
 * Checks if a ReferenceGeometry property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ReferenceGeometry.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop airbag reference geometry property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this reference_geometry (*AIRBAG_REFERENCE_GEOMETRY). Note that a carriage return is not added. See also ReferenceGeometry.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the reference_geometry. Note that a carriage return is not added. See also ReferenceGeometry.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last airbag reference geometry in the model.
 * @param Model Model to get last airbag reference geometry in
 */
    static Last(Model: Model): ReferenceGeometry;

/**
 * Returns the last free airbag reference geometry label in the model. Also see ReferenceGeometry.FirstFreeLabel(), ReferenceGeometry.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free airbag reference geometry label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next airbag reference geometry in the model.
 */
    Next(): ReferenceGeometry;

/**
 * Returns the next free (highest+1) airbag reference geometry label in the model. Also see ReferenceGeometry.FirstFreeLabel(), ReferenceGeometry.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free airbag reference geometry label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a airbag reference geometry.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only airbag reference geometrys from that model can be picked. If the argument is a Flag then only airbag reference geometrys that are flagged with limit can be selected. If omitted, or null, any airbag reference geometrys from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): ReferenceGeometry;

/**
 * Returns the previous airbag reference geometry in the model.
 */
    Previous(): ReferenceGeometry;

/**
 * Removes a node from the reference geometry if it is on it
 * @param nid Node ID
 */
    RemoveNode(nid: number): void;

/**
 * Renumbers all of the airbag reference geometrys in the model.
 * @param Model Model that all airbag reference geometrys will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged airbag reference geometrys in the model.
 * @param Model Model that all the flagged airbag reference geometrys will be renumbered in
 * @param flag Flag set on the airbag reference geometrys that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select airbag reference geometrys using standard PRIMER object menus.
 * @param flag Flag to use when selecting airbag reference geometrys
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only airbag reference geometrys from that model can be selected. If the argument is a Flag then only airbag reference geometrys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any airbag reference geometrys can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the airbag reference geometry.
 * @param flag Flag to set on the airbag reference geometry
 */
    SetFlag(flag: number): void;

/**
 * Adds a node to the reference geometry if not already there, otherwise just changes the coordinates
 * @param nid Node ID
 * @param x X reference coordinate
 * @param y Y reference coordinate
 * @param z Z reference coordinate
 */
    SetNode(nid: number, x: number, y: number, z: number): void;

/**
 * Sketches the airbag reference geometry. The airbag reference geometry will be sketched until you either call ReferenceGeometry.Unsketch(), ReferenceGeometry.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the airbag reference geometry is sketched. If omitted redraw is true. If you want to sketch several airbag reference geometrys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged airbag reference geometrys in the model. The airbag reference geometrys will be sketched until you either call ReferenceGeometry.Unsketch(), ReferenceGeometry.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged airbag reference geometrys will be sketched in
 * @param flag Flag set on the airbag reference geometrys that you want to sketch
 * @param redraw If model should be redrawn or not after the airbag reference geometrys are sketched. If omitted redraw is true. If you want to sketch flagged airbag reference geometrys several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Spools a reference geometry, entry by entry. See also ReferenceGeometry.StartSpool
 */
    Spool(): number[];

/**
 * Starts a reference geometry spooling operation. See also ReferenceGeometry.Spool
 */
    StartSpool(): void;

/**
 * Returns the total number of airbag reference geometrys in the model.
 * @param Model Model to get total for
 * @param exists true if only existing airbag reference geometrys should be counted. If false or omitted referenced but undefined airbag reference geometrys will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the airbag reference geometrys in the model.
 * @param Model Model that the defined flag for all airbag reference geometrys will be unset in
 * @param flag Flag to unset on the airbag reference geometrys
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the airbag reference geometry.
 * @param redraw If model should be redrawn or not after the airbag reference geometry is unsketched. If omitted redraw is true. If you want to unsketch several airbag reference geometrys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all airbag reference geometrys.
 * @param Model Model that all airbag reference geometrys will be unblanked in
 * @param redraw If model should be redrawn or not after the airbag reference geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged airbag reference geometrys in the model.
 * @param Model Model that all airbag reference geometrys will be unsketched in
 * @param flag Flag set on the airbag reference geometrys that you want to unsketch
 * @param redraw If model should be redrawn or not after the airbag reference geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): ReferenceGeometry;

/**
 * Adds a warning for airbag reference geometry. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this airbag reference geometry.
 */
    Xrefs(): Xrefs;

/**
 * Create a new ReferenceGeometry object.
 * @param Model Model that ReferenceGeometry will be created in
 * @param aid ReferenceGeometry number to set _ID suffix
 */
    constructor(Model: Model, aid?: number);

/**
 * Creates a string containing the ReferenceGeometry data in keyword format. Note that this contains the keyword header and the keyword cards. See also ReferenceGeometry.Keyword() and ReferenceGeometry.KeywordCards().
 */
    toString(): string;

/** ReferenceGeometry number. Also see the label property which is an alternative name for this. */
    aid: number;
/** Turns _BIRTH on or off */
    birth: boolean;
/** Birth time */
    birth_time: number;
/** true if airbag reference geometry exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Turns _ID on or OFF */
    id: boolean;
/** The Include file number that the airbag reference geometry is in. */
    include: number;
/** ReferenceGeometry number. Also see the label property which is an alternative name for this. */
    label: number;
/** The Model number that the airbag reference geometry is in. */
    model: number;
/** Node number for origin */
    nido: number;
/** Turns _RDT on or OFF */
    rdt: boolean;
/** Scale factor in X direction */
    sx: number;
/** Scale factor in Y direction */
    sy: number;
/** Scale factor in Z direction */
    sz: number;
}

declare class Retractor {
/**
 * Blanks the retractor
 */
    Blank(): void;

/**
 * Blanks all of the retractors in the model.
 * @param Model Model that all retractors will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged retractors in the model.
 * @param Model Model that all the flagged retractors will be blanked in
 * @param flag Flag set on the retractors that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the retractor is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the retractor.
 * @param flag Flag to clear on the retractor
 */
    ClearFlag(flag: number): void;

/**
 * Copies the retractor.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Retractor;

/**
 * Starts an interactive editing panel to create a retractor.
 * @param Model Model that the retractor will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Retractor;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for retractor. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for retractor. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the retractor colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the retractor.
 */
    ExtractColour(): number;

/**
 * Returns the first retractor in the model.
 * @param Model Model to get first retractor in
 */
    static First(Model: Model): Retractor;

/**
 * Returns the first free retractor label in the model. Also see Retractor.LastFreeLabel(), Retractor.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free retractor label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the retractors in the model with a defined flag.
 * @param Model Model that all retractors will be flagged in
 * @param flag Flag to set on the retractors
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the retractor is flagged or not.
 * @param flag Flag to test on the retractor
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each retractor in the model. Note that ForEach has been designed to make looping over retractors as fast as possible and so has some limitations. Firstly, a single temporary Retractor object is created and on each function call it is updated with the current retractor data. This means that you should not try to store the Retractor object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new retractors inside a ForEach loop. 
 * @param Model Model that all retractors are in
 * @param func Function to call for each retractor
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Retractor objects for all of the retractors in a model in Primer
 * @param Model Model to get retractors from
 */
    static GetAll(Model: Model): Retractor[];

/**
 * Returns an array of Retractor objects for all of the flagged retractors in a model in Primer
 * @param Model Model to get retractors from
 * @param flag Flag set on the retractors that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Retractor[];

/**
 * Returns the Retractor object for a retractor ID.
 * @param Model Model to find the retractor in
 * @param number number of the retractor you want the Retractor object for
 */
    static GetFromID(Model: Model, number: number): Retractor;

/**
 * Checks if a Retractor property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Retractor.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop retractor property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this retractor (*ELEMENT_SEATBELT_RETREROMETER) Note that a carriage return is not added. See also Retractor.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the retractor. Note that a carriage return is not added. See also Retractor.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last retractor in the model.
 * @param Model Model to get last retractor in
 */
    static Last(Model: Model): Retractor;

/**
 * Returns the last free retractor label in the model. Also see Retractor.FirstFreeLabel(), Retractor.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free retractor label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next retractor in the model.
 */
    Next(): Retractor;

/**
 * Returns the next free (highest+1) retractor label in the model. Also see Retractor.FirstFreeLabel(), Retractor.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free retractor label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a retractor.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only retractors from that model can be picked. If the argument is a Flag then only retractors that are flagged with limit can be selected. If omitted, or null, any retractors from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Retractor;

/**
 * Returns the previous retractor in the model.
 */
    Previous(): Retractor;

/**
 * Renumbers all of the retractors in the model.
 * @param Model Model that all retractors will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged retractors in the model.
 * @param Model Model that all the flagged retractors will be renumbered in
 * @param flag Flag set on the retractors that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select retractors using standard PRIMER object menus.
 * @param flag Flag to use when selecting retractors
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only retractors from that model can be selected. If the argument is a Flag then only retractors that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any retractors can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the retractor.
 * @param flag Flag to set on the retractor
 */
    SetFlag(flag: number): void;

/**
 * Sketches the retractor. The retractor will be sketched until you either call Retractor.Unsketch(), Retractor.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the retractor is sketched. If omitted redraw is true. If you want to sketch several retractors and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged retractors in the model. The retractors will be sketched until you either call Retractor.Unsketch(), Retractor.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged retractors will be sketched in
 * @param flag Flag set on the retractors that you want to sketch
 * @param redraw If model should be redrawn or not after the retractors are sketched. If omitted redraw is true. If you want to sketch flagged retractors several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of retractors in the model.
 * @param Model Model to get total for
 * @param exists true if only existing retractors should be counted. If false or omitted referenced but undefined retractors will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the retractor
 */
    Unblank(): void;

/**
 * Unblanks all of the retractors in the model.
 * @param Model Model that all retractors will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged retractors in the model.
 * @param Model Model that the flagged retractors will be unblanked in
 * @param flag Flag set on the retractors that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the retractors in the model.
 * @param Model Model that the defined flag for all retractors will be unset in
 * @param flag Flag to unset on the retractors
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the retractor.
 * @param redraw If model should be redrawn or not after the retractor is unsketched. If omitted redraw is true. If you want to unsketch several retractors and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all retractors.
 * @param Model Model that all retractors will be unblanked in
 * @param redraw If model should be redrawn or not after the retractors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged retractors in the model.
 * @param Model Model that all retractors will be unsketched in
 * @param flag Flag set on the retractors that you want to unsketch
 * @param redraw If model should be redrawn or not after the retractors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Retractor;

/**
 * Adds a warning for retractor. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this retractor.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Seatbelt Retractor object.
 * @param Model Model that retractor will be created in
 * @param sbrid Retractor number.
 * @param sbrnid Node number (or Set Node number if negative).
 * @param sbid Seatbelt number. (or Set Shell number if sbrnid is negative)
 * @param llcid Loadcurve for loading (pull-out vs force)
 * @param sid1 Sensor number 1
 * @param sid2 Sensor number 2
 * @param sid3 Sensor number 3
 * @param sid4 Sensor number 4
 * @param tdel Time delay after sensor triggers.
 * @param pull Amount of pull out between time delay ending and retractor locking.
 * @param ulcid Loadcurve for unloading (pull-out vs force)
 * @param lfed Fed length
 */
    constructor(Model: Model, sbrid: number, sbrnid: number, sbid: number, llcid: number, sid1: number, sid2?: number, sid3?: number, sid4?: number, tdel?: number, pull?: number, ulcid?: number, lfed?: number);

/**
 * Creates a string containing the retractor data in keyword format. Note that this contains the keyword header and the keyword cards. See also Retractor.Keyword() and Retractor.KeywordCards().
 */
    toString(): string;

/** The colour of the retractor */
    colour: Colour;
/** Retractor deactivation Sensor */
    dsid: number;
/** true if retractor exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the retractor is in. */
    include: number;
/** Retractor number. Also see the sbrid property which is an alternative name for this. */
    label: number;
/** Fed length */
    lfed: number;
/** Loadcurve for loading (pull-out vs force) */
    llcid: number;
/** The Model number that the retractor is in. */
    model: number;
/** Amount of pull out between time delay ending and retractor locking */
    pull: number;
/** Seatbelt1D number (or Set Shell number if sbrnid is negative). */
    sbid: number;
/** Retractor number. Also see the label property which is an alternative name for this. */
    sbrid: number;
/** Node number (or Set Node number if negative). */
    sbrnid: number;
/** true if retractor is used for shell (2D) seatbelt elements. (read only) */
    readonly shell_seatbelt: boolean;
/** Sensor number 1 */
    sid1: number;
/** Sensor number 2 */
    sid2: number;
/** Sensor number 3 */
    sid3: number;
/** Sensor number 4 */
    sid4: number;
/** Time delay after sensor triggers */
    tdel: number;
/** The transparency of the retractor (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Loadcurve for unloading (pull-out vs force) */
    ulcid: number;
}

declare class RigidBodies {
/**
 * Blanks the rigid body merge
 */
    Blank(): void;

/**
 * Blanks all of the rigid body merges in the model.
 * @param Model Model that all rigid body merges will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged rigid body merges in the model.
 * @param Model Model that all the flagged rigid body merges will be blanked in
 * @param flag Flag set on the rigid body merges that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the rigid body merge is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the rigid body merge.
 * @param flag Flag to clear on the rigid body merge
 */
    ClearFlag(flag: number): void;

/**
 * Copies the rigid body merge.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): RigidBodies;

/**
 * Starts an interactive editing panel to create a constrained rigid bodies definition.
 * @param Model Model that the constrained rigid bodies definition will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): RigidBodies;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for rigid body merge. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first rigid body merge in the model.
 * @param Model Model to get first rigid body merge in
 */
    static First(Model: Model): RigidBodies;

/**
 * Flags all of the rigid body merges in the model with a defined flag.
 * @param Model Model that all rigid body merges will be flagged in
 * @param flag Flag to set on the rigid body merges
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the rigid body merge is flagged or not.
 * @param flag Flag to test on the rigid body merge
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each rigid body merge in the model. Note that ForEach has been designed to make looping over rigid body merges as fast as possible and so has some limitations. Firstly, a single temporary RigidBodies object is created and on each function call it is updated with the current rigid body merge data. This means that you should not try to store the RigidBodies object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new rigid body merges inside a ForEach loop. 
 * @param Model Model that all rigid body merges are in
 * @param func Function to call for each rigid body merge
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of RigidBodies objects for all of the rigid body merges in a model in Primer
 * @param Model Model to get rigid body merges from
 */
    static GetAll(Model: Model): RigidBodies[];

/**
 * Returns an array of RigidBodies objects for all of the flagged rigid body merges in a model in Primer
 * @param Model Model to get rigid body merges from
 * @param flag Flag set on the rigid body merges that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): RigidBodies[];

/**
 * Returns the RigidBodies object for a rigid body merge ID.
 * @param Model Model to find the rigid body merge in
 * @param number number of the rigid body merge you want the RigidBodies object for
 */
    static GetFromID(Model: Model, number: number): RigidBodies;

/**
 * Checks if a RigidBodies property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the RigidBodies.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop rigid body merge property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this constrained rigid bodies (*CONSTRAINED_RIGID_BODIES). Note that a carriage return is not added. See also RigidBodies.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the constrained rigid bodies. Note that a carriage return is not added. See also RigidBodies.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last rigid body merge in the model.
 * @param Model Model to get last rigid body merge in
 */
    static Last(Model: Model): RigidBodies;

/**
 * Returns the next rigid body merge in the model.
 */
    Next(): RigidBodies;

/**
 * Allows the user to pick a rigid body merge.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only rigid body merges from that model can be picked. If the argument is a Flag then only rigid body merges that are flagged with limit can be selected. If omitted, or null, any rigid body merges from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): RigidBodies;

/**
 * Returns the previous rigid body merge in the model.
 */
    Previous(): RigidBodies;

/**
 * Allows the user to select rigid body merges using standard PRIMER object menus.
 * @param flag Flag to use when selecting rigid body merges
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only rigid body merges from that model can be selected. If the argument is a Flag then only rigid body merges that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any rigid body merges can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the rigid body merge.
 * @param flag Flag to set on the rigid body merge
 */
    SetFlag(flag: number): void;

/**
 * Sketches the rigid body merge. The rigid body merge will be sketched until you either call RigidBodies.Unsketch(), RigidBodies.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the rigid body merge is sketched. If omitted redraw is true. If you want to sketch several rigid body merges and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged rigid body merges in the model. The rigid body merges will be sketched until you either call RigidBodies.Unsketch(), RigidBodies.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged rigid body merges will be sketched in
 * @param flag Flag set on the rigid body merges that you want to sketch
 * @param redraw If model should be redrawn or not after the rigid body merges are sketched. If omitted redraw is true. If you want to sketch flagged rigid body merges several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of rigid body merges in the model.
 * @param Model Model to get total for
 * @param exists true if only existing rigid body merges should be counted. If false or omitted referenced but undefined rigid body merges will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the rigid body merge
 */
    Unblank(): void;

/**
 * Unblanks all of the rigid body merges in the model.
 * @param Model Model that all rigid body merges will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged rigid body merges in the model.
 * @param Model Model that the flagged rigid body merges will be unblanked in
 * @param flag Flag set on the rigid body merges that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the rigid body merges in the model.
 * @param Model Model that the defined flag for all rigid body merges will be unset in
 * @param flag Flag to unset on the rigid body merges
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the rigid body merge.
 * @param redraw If model should be redrawn or not after the rigid body merge is unsketched. If omitted redraw is true. If you want to unsketch several rigid body merges and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all rigid body merges.
 * @param Model Model that all rigid body merges will be unblanked in
 * @param redraw If model should be redrawn or not after the rigid body merges are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged rigid body merges in the model.
 * @param Model Model that all rigid body merges will be unsketched in
 * @param flag Flag set on the rigid body merges that you want to unsketch
 * @param redraw If model should be redrawn or not after the rigid body merges are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): RigidBodies;

/**
 * Adds a warning for rigid body merge. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this rigid body merge.
 */
    Xrefs(): Xrefs;

/**
 * Create a new RigidBodies object.
 * @param Model Model that constrained rigid bodies will be created in
 * @param pidm Master rigid body part ID.
 * @param pids Slave rigid body part ID.
 * @param iflag Flag for adding slave mass properties to part inertia.
 */
    constructor(Model: Model, pidm: number, pids: number, iflag: number);

/**
 * Creates a string containing the constrained rigid bodies data in keyword format. Note that this contains the keyword header and the keyword cards. See also RigidBodies.Keyword() and RigidBodies.KeywordCards().
 */
    toString(): string;

/** true if constrained rigid bodies exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Flag for adding slave mass properties to part inertia. */
    iflag: number;
/** The Include file number that the constrained rigid bodies is in. */
    include: number;
/** The label the constrained rigid bodies has in PRIMER (read only) */
    readonly label: number;
/** The Model number that the rigid body merge is in. */
    model: number;
/** Master rigid body part ID. */
    pidm: number;
/** Slave rigid body part ID. */
    pids: number;
}

declare class Rigidwall {
/**
 * Blanks the rigidwall
 */
    Blank(): void;

/**
 * Blanks all of the rigidwalls in the model.
 * @param Model Model that all rigidwalls will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged rigidwalls in the model.
 * @param Model Model that all the flagged rigidwalls will be blanked in
 * @param flag Flag set on the rigidwalls that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the rigidwall is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the rigidwall.
 * @param flag Flag to clear on the rigidwall
 */
    ClearFlag(flag: number): void;

/**
 * Copies the rigidwall.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Rigidwall;

/**
 * Starts an interactive editing panel to create a rigidwall.
 * @param Model Model that the rigidwall will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Rigidwall;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for rigidwall. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Flags nodes that are behind a rigidwall
 * @param flag Flag to be set on nodes behind rigidwall.
 */
    FindNodesBehind(flag: number): number;

/**
 * Returns the first rigidwall in the model.
 * @param Model Model to get first rigidwall in
 */
    static First(Model: Model): Rigidwall;

/**
 * Returns the first free rigidwall label in the model. Also see Rigidwall.LastFreeLabel(), Rigidwall.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free rigidwall label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the rigidwalls in the model with a defined flag.
 * @param Model Model that all rigidwalls will be flagged in
 * @param flag Flag to set on the rigidwalls
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the rigidwall is flagged or not.
 * @param flag Flag to test on the rigidwall
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each rigidwall in the model. Note that ForEach has been designed to make looping over rigidwalls as fast as possible and so has some limitations. Firstly, a single temporary Rigidwall object is created and on each function call it is updated with the current rigidwall data. This means that you should not try to store the Rigidwall object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new rigidwalls inside a ForEach loop. 
 * @param Model Model that all rigidwalls are in
 * @param func Function to call for each rigidwall
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Rigidwall objects for all of the rigidwalls in a model in Primer
 * @param Model Model to get rigidwalls from
 */
    static GetAll(Model: Model): Rigidwall[];

/**
 * Returns an array of Rigidwall objects for all of the flagged rigidwalls in a model in Primer
 * @param Model Model to get rigidwalls from
 * @param flag Flag set on the rigidwalls that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Rigidwall[];

/**
 * Returns the Rigidwall object for a rigidwall ID.
 * @param Model Model to find the rigidwall in
 * @param number number of the rigidwall you want the Rigidwall object for
 */
    static GetFromID(Model: Model, number: number): Rigidwall;

/**
 * Checks if a Rigidwall property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Rigidwall.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop rigidwall property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the data for an NSEGS card row in the rigidwall.
 * @param row The row you want the data for. Note row indices start at 0.
 */
    GetRow(row: number): number[];

/**
 * Returns the keyword for this Rigidwall (*RIGIDWALL). Note that a carriage return is not added. See also Rigidwall.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the Rigidwall. Note that a carriage return is not added. See also Rigidwall.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last rigidwall in the model.
 * @param Model Model to get last rigidwall in
 */
    static Last(Model: Model): Rigidwall;

/**
 * Returns the last free rigidwall label in the model. Also see Rigidwall.FirstFreeLabel(), Rigidwall.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free rigidwall label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next rigidwall in the model.
 */
    Next(): Rigidwall;

/**
 * Returns the next free (highest+1) rigidwall label in the model. Also see Rigidwall.FirstFreeLabel(), Rigidwall.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free rigidwall label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a rigidwall.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only rigidwalls from that model can be picked. If the argument is a Flag then only rigidwalls that are flagged with limit can be selected. If omitted, or null, any rigidwalls from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Rigidwall;

/**
 * Returns the previous rigidwall in the model.
 */
    Previous(): Rigidwall;

/**
 * Removes an NSEGS card row in the *RIGIDWALL.
 * @param row The row you want to remove the data for. Note that row indices start at 0.
 */
    RemoveRow(row: number): void;

/**
 * Renumbers all of the rigidwalls in the model.
 * @param Model Model that all rigidwalls will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged rigidwalls in the model.
 * @param Model Model that all the flagged rigidwalls will be renumbered in
 * @param flag Flag set on the rigidwalls that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select rigidwalls using standard PRIMER object menus.
 * @param flag Flag to use when selecting rigidwalls
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only rigidwalls from that model can be selected. If the argument is a Flag then only rigidwalls that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any rigidwalls can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the rigidwall.
 * @param flag Flag to set on the rigidwall
 */
    SetFlag(flag: number): void;

/**
 * Sets the data for an NSEGS card row in the *RIGIDWALL.
 * @param row The row you want to set the data for. Note that row indices start at 0.
 * @param data The data you want to set the row to
 */
    SetRow(row: number, data: number[]): void;

/**
 * Sketches the rigidwall. The rigidwall will be sketched until you either call Rigidwall.Unsketch(), Rigidwall.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the rigidwall is sketched. If omitted redraw is true. If you want to sketch several rigidwalls and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged rigidwalls in the model. The rigidwalls will be sketched until you either call Rigidwall.Unsketch(), Rigidwall.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged rigidwalls will be sketched in
 * @param flag Flag set on the rigidwalls that you want to sketch
 * @param redraw If model should be redrawn or not after the rigidwalls are sketched. If omitted redraw is true. If you want to sketch flagged rigidwalls several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of rigidwalls in the model.
 * @param Model Model to get total for
 * @param exists true if only existing rigidwalls should be counted. If false or omitted referenced but undefined rigidwalls will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the rigidwall
 */
    Unblank(): void;

/**
 * Unblanks all of the rigidwalls in the model.
 * @param Model Model that all rigidwalls will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged rigidwalls in the model.
 * @param Model Model that the flagged rigidwalls will be unblanked in
 * @param flag Flag set on the rigidwalls that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the rigidwalls in the model.
 * @param Model Model that the defined flag for all rigidwalls will be unset in
 * @param flag Flag to unset on the rigidwalls
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the rigidwall.
 * @param redraw If model should be redrawn or not after the rigidwall is unsketched. If omitted redraw is true. If you want to unsketch several rigidwalls and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all rigidwalls.
 * @param Model Model that all rigidwalls will be unblanked in
 * @param redraw If model should be redrawn or not after the rigidwalls are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged rigidwalls in the model.
 * @param Model Model that all rigidwalls will be unsketched in
 * @param flag Flag set on the rigidwalls that you want to unsketch
 * @param redraw If model should be redrawn or not after the rigidwalls are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Rigidwall;

/**
 * Adds a warning for rigidwall. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this rigidwall.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Rigidwall object.
 * @param Model Model that Rigidwall will be created in
 * @param type Specify the type of rigidwall (Can be Rigidwall.FLAT, Rigidwall.PRISM, Rigidwall.CYLINDER, Rigidwall.SPHERE, Rigidwall.PLANAR)
 * @param nsid Node set number.
 * @param rwid Rigidwall number
 * @param heading Title for the Rigidwall
 */
    constructor(Model: Model, type: number, nsid?: number, rwid?: number, heading?: string);

/**
 * Creates a string containing the Rigidwall data in keyword format. Note that this contains the keyword header and the keyword cards. See also Rigidwall.Keyword() and Rigidwall.KeywordCards().
 */
    toString(): string;

/** Birth time. */
    birth: number;
/** Box for nodes. */
    boxid: number;
/** X component of vector defn. */
    d1: number;
/** Y component of vector defn. */
    d2: number;
/** Z component of vector defn. */
    d3: number;
/** Death time. */
    death: number;
/** Friction decay const in local A dir. */
    decaya: number;
/** Friction decay const in local B dir. */
    decayb: number;
/** Dynamic friction coeff in local A dir. */
    dfrica: number;
/** Dynamic friction coeff in local B dir. */
    dfricb: number;
/** DISPLAY flag. */
    display: boolean;
/** Young's modulus of rigidwall (for _DISPLAY option). */
    e: number;
/** true if rigidwall exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Finite flag. */
    finite: boolean;
/** Forces flag. */
    forces: boolean;
/** Friction coefficient. */
    fric: number;
/** Rigidwall heading */
    heading: string;
/** true if _ID option is set, false if not */
    id: boolean;
/** The Include file number that the rigidwall is in. */
    include: number;
/** Rigidwall number. */
    label: number;
/** Vel/disp vs time curve number. */
    lcid: number;
/** Length of cylinder. */
    lencyl: number;
/** Length of L edge. */
    lenl: number;
/** Length of M edge. */
    lenm: number;
/** Length of prism in -ve N. */
    lenp: number;
/** Mass of moving wall. */
    mass: number;
/** The Model number that the rigidwall is in. */
    model: number;
/** Motion flag. */
    motion: boolean;
/** Moving flag. */
    moving: boolean;
/** 1st node for visualisation. */
    n1: number;
/** 2nd node for visualisation. */
    n2: number;
/** 3rd node for visualisation. */
    n3: number;
/** 4th node for visualisation. */
    n4: number;
/** Node 1 for vector defn. */
    node1: number;
/** Node 2 for vector defn. */
    node2: number;
/** Number of subsections. */
    nsegs: number;
/** Slave node set included in wall. */
    nsid: number;
/** Slave node set exempted from wall. */
    nsidex: number;
/** Offset for planar option. */
    offset: number;
/** Motion type. */
    opt: number;
/** Ortho flag. */
    ortho: boolean;
/** Part ID for display of geometric rigidwall (for _DISPLAY option). */
    pid: number;
/** Poisson's ratio of rigidwall (for _DISPLAY option). */
    pr: number;
/** Radius of cylinder. */
    radcyl: number;
/** Radius of sphere. */
    radsph: number;
/** Density of rigidwall (for _DISPLAY option). */
    ro: number;
/** Rigidwall number (identical to label). */
    rwid: number;
/** Stiffness scaling factor. */
    rwksf: number;
/** Static friction coeff in local A dir. */
    sfrica: number;
/** Static friction coeff in local B dir. */
    sfricb: number;
/** No. of cycles to zero relative velocity. */
    soft: number;
/** Segment set number. */
    ssid: number;
/** The rigidwall type. Can be Rigidwall.FLAT, Rigidwall.PRISM, Rigidwall.CYLINDER, Rigidwall.SPHERE, Rigidwall.PLANAR, */
    type: number;
/** Initial velocity. */
    v0: number;
/** X component of motion vector. */
    vx: number;
/** Y component of motion vector. */
    vy: number;
/** Z component of motion vector. */
    vz: number;
/** Velocity at which nodes weld to wall. */
    wvel: number;
/** Head X coord of outward normal. */
    xh: number;
/** Head X coord of edge I vector. */
    xhev: number;
/** Tail X coord of outward normal. */
    xt: number;
/** Head Y coord of outward normal. */
    yh: number;
/** Head Y coord of edge I vector. */
    yhev: number;
/** Tail Y coord of outward normal. */
    yt: number;
/** Head Z coord of outward normal. */
    zh: number;
/** Head Z coord of edge I vector. */
    zhev: number;
/** Tail Z coord of outward normal. */
    zt: number;
/** Rigidwall is *RIGIDWALL_GEOMETRIC_CYLINDER. */
    static CYLINDER: number;
/** Rigidwall is *RIGIDWALL_GEOMETRIC_FLAT. */
    static FLAT: number;
/** Rigidwall is *RIGIDWALL_PLANAR. */
    static PLANAR: number;
/** Rigidwall is *RIGIDWALL_GEOMETRIC_PRISM. */
    static PRISM: number;
/** Rigidwall is *RIGIDWALL_GEOMETRIC_SPHERE. */
    static SPHERE: number;
}

declare class Seatbelt1D {
/**
 * Blanks the seatbelt
 */
    Blank(): void;

/**
 * Blanks all of the seatbelts in the model.
 * @param Model Model that all seatbelts will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged seatbelts in the model.
 * @param Model Model that all the flagged seatbelts will be blanked in
 * @param flag Flag set on the seatbelts that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the seatbelt is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the seatbelt.
 * @param flag Flag to clear on the seatbelt
 */
    ClearFlag(flag: number): void;

/**
 * Copies the seatbelt.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Seatbelt1D;

/**
 * Starts an interactive editing panel to create a 2 noded seatbelt.
 * @param Model Model that the seatbelt will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Seatbelt1D;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for seatbelt. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for seatbelt. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the seatbelt colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the seatbelt.
 */
    ExtractColour(): number;

/**
 * Returns the first seatbelt in the model.
 * @param Model Model to get first seatbelt in
 */
    static First(Model: Model): Seatbelt1D;

/**
 * Returns the first free seatbelt label in the model. Also see Seatbelt1D.LastFreeLabel(), Seatbelt1D.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free seatbelt label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the seatbelts in the model with a defined flag.
 * @param Model Model that all seatbelts will be flagged in
 * @param flag Flag to set on the seatbelts
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the seatbelt is flagged or not.
 * @param flag Flag to test on the seatbelt
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each seatbelt in the model. Note that ForEach has been designed to make looping over seatbelts as fast as possible and so has some limitations. Firstly, a single temporary Seatbelt1D object is created and on each function call it is updated with the current seatbelt data. This means that you should not try to store the Seatbelt1D object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new seatbelts inside a ForEach loop. 
 * @param Model Model that all seatbelts are in
 * @param func Function to call for each seatbelt
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Seatbelt1D objects for all of the seatbelts in a model in Primer
 * @param Model Model to get seatbelts from
 */
    static GetAll(Model: Model): Seatbelt1D[];

/**
 * Returns an array of Seatbelt1D objects for all of the flagged seatbelts in a model in Primer
 * @param Model Model to get seatbelts from
 * @param flag Flag set on the seatbelts that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Seatbelt1D[];

/**
 * Returns the Seatbelt1D object for a seatbelt ID.
 * @param Model Model to find the seatbelt in
 * @param number number of the seatbelt you want the Seatbelt1D object for
 */
    static GetFromID(Model: Model, number: number): Seatbelt1D;

/**
 * Checks if a Seatbelt1D property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Seatbelt1D.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop seatbelt property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this seatbelt (*ELEMENT_SEATBELT) Note that a carriage return is not added. See also Seatbelt1D.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the seatbelt. Note that a carriage return is not added. See also Seatbelt1D.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last seatbelt in the model.
 * @param Model Model to get last seatbelt in
 */
    static Last(Model: Model): Seatbelt1D;

/**
 * Returns the last free seatbelt label in the model. Also see Seatbelt1D.FirstFreeLabel(), Seatbelt1D.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free seatbelt label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next seatbelt in the model.
 */
    Next(): Seatbelt1D;

/**
 * Returns the next free (highest+1) seatbelt label in the model. Also see Seatbelt1D.FirstFreeLabel(), Seatbelt1D.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free seatbelt label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a seatbelt.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only seatbelts from that model can be picked. If the argument is a Flag then only seatbelts that are flagged with limit can be selected. If omitted, or null, any seatbelts from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Seatbelt1D;

/**
 * Returns the previous seatbelt in the model.
 */
    Previous(): Seatbelt1D;

/**
 * Renumbers all of the seatbelts in the model.
 * @param Model Model that all seatbelts will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged seatbelts in the model.
 * @param Model Model that all the flagged seatbelts will be renumbered in
 * @param flag Flag set on the seatbelts that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select seatbelts using standard PRIMER object menus.
 * @param flag Flag to use when selecting seatbelts
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only seatbelts from that model can be selected. If the argument is a Flag then only seatbelts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any seatbelts can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the seatbelt.
 * @param flag Flag to set on the seatbelt
 */
    SetFlag(flag: number): void;

/**
 * Sketches the seatbelt. The seatbelt will be sketched until you either call Seatbelt1D.Unsketch(), Seatbelt1D.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the seatbelt is sketched. If omitted redraw is true. If you want to sketch several seatbelts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged seatbelts in the model. The seatbelts will be sketched until you either call Seatbelt1D.Unsketch(), Seatbelt1D.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged seatbelts will be sketched in
 * @param flag Flag set on the seatbelts that you want to sketch
 * @param redraw If model should be redrawn or not after the seatbelts are sketched. If omitted redraw is true. If you want to sketch flagged seatbelts several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Calculates the timestep for the seatbelt
 */
    Timestep(): number;

/**
 * Returns the total number of seatbelts in the model.
 * @param Model Model to get total for
 * @param exists true if only existing seatbelts should be counted. If false or omitted referenced but undefined seatbelts will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the seatbelt
 */
    Unblank(): void;

/**
 * Unblanks all of the seatbelts in the model.
 * @param Model Model that all seatbelts will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged seatbelts in the model.
 * @param Model Model that the flagged seatbelts will be unblanked in
 * @param flag Flag set on the seatbelts that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the seatbelts in the model.
 * @param Model Model that the defined flag for all seatbelts will be unset in
 * @param flag Flag to unset on the seatbelts
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the seatbelt.
 * @param redraw If model should be redrawn or not after the seatbelt is unsketched. If omitted redraw is true. If you want to unsketch several seatbelts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all seatbelts.
 * @param Model Model that all seatbelts will be unblanked in
 * @param redraw If model should be redrawn or not after the seatbelts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged seatbelts in the model.
 * @param Model Model that all seatbelts will be unsketched in
 * @param flag Flag set on the seatbelts that you want to unsketch
 * @param redraw If model should be redrawn or not after the seatbelts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Seatbelt1D;

/**
 * Adds a warning for seatbelt. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this seatbelt.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Seatbelt1D object.
 * @param Model Model that seatbelt will be created in
 * @param eid Seatbelt ID.
 * @param pid Part number.
 * @param n1 Node 1 ID
 * @param n2 Node 2 ID
 */
    constructor(Model: Model, eid: number, pid: number, n1: number, n2: number);

/**
 * Creates a string containing the seatbelt data in keyword format. Note that this contains the keyword header and the keyword cards. See also Seatbelt1D.Keyword() and Seatbelt1D.KeywordCards().
 */
    toString(): string;

/** The colour of the seatbelt */
    colour: Colour;
/** Seatbelt1D number. Also see the label property which is an alternative name for this. */
    eid: number;
/** true if seatbelt exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the seatbelt is in. */
    include: number;
/** Seatbelt1D number. Also see the eid property which is an alternative name for this. */
    label: number;
/** The Model number that the seatbelt is in. */
    model: number;
/** Node 1 ID */
    n1: number;
/** Node 2 ID */
    n2: number;
/** Part ID */
    pid: number;
/** Retractor ID */
    sbrid: number;
/** Initial slack length */
    slen: number;
/** The transparency of the seatbelt (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
}

declare class Seatbelt2D {
/**
 * Blanks the seatbelt
 */
    Blank(): void;

/**
 * Blanks all of the seatbelts in the model.
 * @param Model Model that all seatbelts will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged seatbelts in the model.
 * @param Model Model that all the flagged seatbelts will be blanked in
 * @param flag Flag set on the seatbelts that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the seatbelt is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the seatbelt.
 * @param flag Flag to clear on the seatbelt
 */
    ClearFlag(flag: number): void;

/**
 * Copies the seatbelt.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Seatbelt2D;

/**
 * Starts an interactive editing panel to create a 2 noded seatbelt.
 * @param Model Model that the seatbelt will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Seatbelt2D;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for seatbelt. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for seatbelt. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the seatbelt colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the seatbelt.
 */
    ExtractColour(): number;

/**
 * Returns the first seatbelt in the model.
 * @param Model Model to get first seatbelt in
 */
    static First(Model: Model): Seatbelt2D;

/**
 * Returns the first free seatbelt label in the model. Also see Seatbelt2D.LastFreeLabel(), Seatbelt2D.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free seatbelt label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the seatbelts in the model with a defined flag.
 * @param Model Model that all seatbelts will be flagged in
 * @param flag Flag to set on the seatbelts
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the seatbelt is flagged or not.
 * @param flag Flag to test on the seatbelt
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each seatbelt in the model. Note that ForEach has been designed to make looping over seatbelts as fast as possible and so has some limitations. Firstly, a single temporary Seatbelt2D object is created and on each function call it is updated with the current seatbelt data. This means that you should not try to store the Seatbelt2D object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new seatbelts inside a ForEach loop. 
 * @param Model Model that all seatbelts are in
 * @param func Function to call for each seatbelt
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Seatbelt2D objects for all of the seatbelts in a model in Primer
 * @param Model Model to get seatbelts from
 */
    static GetAll(Model: Model): Seatbelt2D[];

/**
 * Returns an array of Seatbelt2D objects for all of the flagged seatbelts in a model in Primer
 * @param Model Model to get seatbelts from
 * @param flag Flag set on the seatbelts that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Seatbelt2D[];

/**
 * Returns the Seatbelt2D object for a seatbelt ID.
 * @param Model Model to find the seatbelt in
 * @param number number of the seatbelt you want the Seatbelt2D object for
 */
    static GetFromID(Model: Model, number: number): Seatbelt2D;

/**
 * Checks if a Seatbelt2D property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Seatbelt2D.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop seatbelt property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this seatbelt (*ELEMENT_SEATBELT) Note that a carriage return is not added. See also Seatbelt2D.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the seatbelt. Note that a carriage return is not added. See also Seatbelt2D.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last seatbelt in the model.
 * @param Model Model to get last seatbelt in
 */
    static Last(Model: Model): Seatbelt2D;

/**
 * Returns the last free seatbelt label in the model. Also see Seatbelt2D.FirstFreeLabel(), Seatbelt2D.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free seatbelt label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next seatbelt in the model.
 */
    Next(): Seatbelt2D;

/**
 * Returns the next free (highest+1) seatbelt label in the model. Also see Seatbelt2D.FirstFreeLabel(), Seatbelt2D.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free seatbelt label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a seatbelt.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only seatbelts from that model can be picked. If the argument is a Flag then only seatbelts that are flagged with limit can be selected. If omitted, or null, any seatbelts from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Seatbelt2D;

/**
 * Returns the previous seatbelt in the model.
 */
    Previous(): Seatbelt2D;

/**
 * Allows the user to select seatbelts using standard PRIMER object menus.
 * @param flag Flag to use when selecting seatbelts
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only seatbelts from that model can be selected. If the argument is a Flag then only seatbelts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any seatbelts can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the seatbelt.
 * @param flag Flag to set on the seatbelt
 */
    SetFlag(flag: number): void;

/**
 * Sketches the seatbelt. The seatbelt will be sketched until you either call Seatbelt2D.Unsketch(), Seatbelt2D.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the seatbelt is sketched. If omitted redraw is true. If you want to sketch several seatbelts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged seatbelts in the model. The seatbelts will be sketched until you either call Seatbelt2D.Unsketch(), Seatbelt2D.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged seatbelts will be sketched in
 * @param flag Flag set on the seatbelts that you want to sketch
 * @param redraw If model should be redrawn or not after the seatbelts are sketched. If omitted redraw is true. If you want to sketch flagged seatbelts several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of seatbelts in the model.
 * @param Model Model to get total for
 * @param exists true if only existing seatbelts should be counted. If false or omitted referenced but undefined seatbelts will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the seatbelt
 */
    Unblank(): void;

/**
 * Unblanks all of the seatbelts in the model.
 * @param Model Model that all seatbelts will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged seatbelts in the model.
 * @param Model Model that the flagged seatbelts will be unblanked in
 * @param flag Flag set on the seatbelts that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the seatbelts in the model.
 * @param Model Model that the defined flag for all seatbelts will be unset in
 * @param flag Flag to unset on the seatbelts
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the seatbelt.
 * @param redraw If model should be redrawn or not after the seatbelt is unsketched. If omitted redraw is true. If you want to unsketch several seatbelts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all seatbelts.
 * @param Model Model that all seatbelts will be unblanked in
 * @param redraw If model should be redrawn or not after the seatbelts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged seatbelts in the model.
 * @param Model Model that all seatbelts will be unsketched in
 * @param flag Flag set on the seatbelts that you want to unsketch
 * @param redraw If model should be redrawn or not after the seatbelts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Seatbelt2D;

/**
 * Adds a warning for seatbelt. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this seatbelt.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Seatbelt2D object.
 * @param Model Model that seatbelt will be created in
 * @param eid Seatbelt ID.
 * @param pid Part number.
 * @param n1 Node 1 ID
 * @param n2 Node 2 ID
 * @param n3 Node 3 ID
 * @param n4 Node 4 ID
 */
    constructor(Model: Model, eid: number, pid: number, n1: number, n2: number, n3: number, n4: number);

/**
 * Creates a string containing the seatbelt data in keyword format. Note that this contains the keyword header and the keyword cards. See also Seatbelt2D.Keyword() and Seatbelt2D.KeywordCards().
 */
    toString(): string;

/** The colour of the seatbelt */
    colour: Colour;
/** Seatbelt2D number. Also see the label property which is an alternative name for this. */
    eid: number;
/** true if seatbelt exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the seatbelt is in. */
    include: number;
/** Seatbelt2D number. Also see the eid property which is an alternative name for this. */
    label: number;
/** The Model number that the seatbelt is in. */
    model: number;
/** Node 1 ID */
    n1: number;
/** Node 2 ID */
    n2: number;
/** Node 3 ID */
    n3: number;
/** Node 4 ID */
    n4: number;
/** Part ID */
    pid: number;
/** Retractor ID */
    sbrid: number;
/** Initial slack length */
    slen: number;
/** The transparency of the seatbelt (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
}

declare class Section {
/**
 * Blanks the section
 */
    Blank(): void;

/**
 * Blanks all of the sections in the model.
 * @param Model Model that all sections will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged sections in the model.
 * @param Model Model that all the flagged sections will be blanked in
 * @param flag Flag set on the sections that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the section is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the section.
 * @param flag Flag to clear on the section
 */
    ClearFlag(flag: number): void;

/**
 * Copies the section.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Section;

/**
 * Starts an interactive editing panel to create a section.
 * @param Model Model that the sect will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Section;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for section. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for section. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the section colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the section.
 */
    ExtractColour(): number;

/**
 * Returns the first section in the model.
 * @param Model Model to get first section in
 */
    static First(Model: Model): Section;

/**
 * Returns the first free section label in the model. Also see Section.LastFreeLabel(), Section.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free section label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the sections in the model with a defined flag.
 * @param Model Model that all sections will be flagged in
 * @param flag Flag to set on the sections
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the section is flagged or not.
 * @param flag Flag to test on the section
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each section in the model. Note that ForEach has been designed to make looping over sections as fast as possible and so has some limitations. Firstly, a single temporary Section object is created and on each function call it is updated with the current section data. This means that you should not try to store the Section object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new sections inside a ForEach loop. 
 * @param Model Model that all sections are in
 * @param func Function to call for each section
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Section objects for all of the sections in a model in Primer
 * @param Model Model to get sections from
 */
    static GetAll(Model: Model): Section[];

/**
 * Returns the beta angle data for an integration point in *SECTION_SHELL or *SECTION_TSHELL.
 * @param ipt The integration point you want the data for. Note that integration points start at 0, not 1.
 */
    GetBetaData(ipt: number): number;

/**
 * Returns an array of Section objects for all of the flagged sections in a model in Primer
 * @param Model Model to get sections from
 * @param flag Flag set on the sections that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Section[];

/**
 * Returns the Section object for a section ID.
 * @param Model Model to find the section in
 * @param number number of the section you want the Section object for
 */
    static GetFromID(Model: Model, number: number): Section;

/**
 * Returns the LMC property parameter for *SECTION_SHELL or *SECTION_SOLID.
 * @param i The point you want the parameter for. Note that points start at 0, not 1.
 */
    GetLmcData(i: number): number;

/**
 * Checks if a Section property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Section.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop section property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the point data for a single point in *SECTION_POINT_SOURCE.
 * @param ipt The point you want the data for. Note that integration points start at 0, not 1.
 */
    GetPointData(ipt: number): number[];

/**
 * Returns the user defined data for an integration point in *SECTION_SHELL and *SECTION_SOLID.
 * @param ipt The integration point you want the data for. Note that integration points start at 0, not 1.
 */
    GetUserData(ipt: number): number[];

/**
 * Returns the keyword for this section (*SECT, *SECT_SCALAR or *SECT_SCALAR_VALUE). Note that a carriage return is not added. See also Section.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the section. Note that a carriage return is not added. See also Section.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last section in the model.
 * @param Model Model to get last section in
 */
    static Last(Model: Model): Section;

/**
 * Returns the last free section label in the model. Also see Section.FirstFreeLabel(), Section.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free section label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next section in the model.
 */
    Next(): Section;

/**
 * Returns the next free (highest+1) section label in the model. Also see Section.FirstFreeLabel(), Section.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free section label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a section.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sections from that model can be picked. If the argument is a Flag then only sections that are flagged with limit can be selected. If omitted, or null, any sections from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Section;

/**
 * Returns the previous section in the model.
 */
    Previous(): Section;

/**
 * Renumbers all of the sections in the model.
 * @param Model Model that all sections will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged sections in the model.
 * @param Model Model that all the flagged sections will be renumbered in
 * @param flag Flag set on the sections that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select sections using standard PRIMER object menus.
 * @param flag Flag to use when selecting sections
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sections from that model can be selected. If the argument is a Flag then only sections that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sections can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets the beta angle for an integration point in *SECTION_SHELL or *SECTION_TSHELL.
 * @param ipt The integration point you want to set the data for. Note that integration points start at 0, not 1.
 * @param beta Beta angle for the integration point.
 */
    SetBetaData(ipt: number, beta: number): void;

/**
 * Sets a flag on the section.
 * @param flag Flag to set on the section
 */
    SetFlag(flag: number): void;

/**
 * Sets the lmc parameter for a point in *SECTION_SHELL or *SECTION_SOLID.
 * @param ipt The point you want to set the data for. Note that points start at 0, not 1.
 * @param lmc Lmc parameter for the point.
 */
    SetLmcData(ipt: number, lmc: number): void;

/**
 * Sets the data for a single point in *SECTION_POINT_SOURCE.
 * @param ipt The point you want to set the data for. Note that integration points start at 0, not 1.
 * @param nodeid Node ID for the point.
 * @param vecid Vector ID for the point.
 * @param area Orifice area for the point.
 */
    SetPointData(ipt: number, nodeid: number, vecid: number, area: number): void;

/**
 * Sets the user defined data for an integration point in *SECTION_SHELL and *SECTION_SOLID.
 * @param ipt The integration point you want to set the data for. Note that integration points start at 0, not 1.
 * @param xi First isoparametric coordinate.
 * @param eta Second isoparametric coordinate.
 * @param zeta_SOLID_orwgt_SHELL Second isoparametric coordinate (SOLID) orIsoparametric weight (SHELL)
 * @param wgt_SOLID_only Isoparametric weight (SOLID)
 */
    SetUserData(ipt: number, xi: number, eta: number, zeta_SOLID_orwgt_SHELL: number, wgt_SOLID_only: number): void;

/**
 * Sketches the section. The section will be sketched until you either call Section.Unsketch(), Section.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the section is sketched. If omitted redraw is true. If you want to sketch several sections and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged sections in the model. The sections will be sketched until you either call Section.Unsketch(), Section.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged sections will be sketched in
 * @param flag Flag set on the sections that you want to sketch
 * @param redraw If model should be redrawn or not after the sections are sketched. If omitted redraw is true. If you want to sketch flagged sections several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of sections in the model.
 * @param Model Model to get total for
 * @param exists true if only existing sections should be counted. If false or omitted referenced but undefined sections will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the section
 */
    Unblank(): void;

/**
 * Unblanks all of the sections in the model.
 * @param Model Model that all sections will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged sections in the model.
 * @param Model Model that the flagged sections will be unblanked in
 * @param flag Flag set on the sections that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the sections in the model.
 * @param Model Model that the defined flag for all sections will be unset in
 * @param flag Flag to unset on the sections
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the section.
 * @param redraw If model should be redrawn or not after the section is unsketched. If omitted redraw is true. If you want to unsketch several sections and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all sections.
 * @param Model Model that all sections will be unblanked in
 * @param redraw If model should be redrawn or not after the sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged sections in the model.
 * @param Model Model that all sections will be unsketched in
 * @param flag Flag set on the sections that you want to unsketch
 * @param redraw If model should be redrawn or not after the sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Section;

/**
 * Adds a warning for section. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this section.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Section object.
 * @param Model Model that section will be created in
 * @param secid Section number or character label
 * @param type Section type. Can be Section.BEAM, Section.DISCRETE, Section.POINT_SOURCE, Section.SEATBELT, Section.SHELL, Section.SOLID, Section.SPH or Section.TSHELL
 * @param title Title for the section
 */
    constructor(Model: Model, secid: number, type: number, title?: string);

/**
 * Creates a string containing the section data in keyword format. Note that this contains the keyword header and the keyword cards. See also Section.Keyword() and Section.KeywordCards().
 */
    toString(): string;

/** Cross sectional area */
    a: number;
/** ALE advection factor(SHELL, SOLID) */
    aafac: number;
/** Ambient element type (ALE1D, ALE2D, SOLID) */
    aet: number;
/** Smoothing weight factor - Simple average (SHELL, SOLID) */
    afac: number;
/** If _AISC option is set. Can be true or false */
    aisc: boolean;
/** AISC section label */
    aisc_label: string;
/** If _ALE option is set. Can be true or false (SHELL, SOLID) */
    ale: boolean;
/** ALE formulation (ALE1D, ALE2D) */
    aleform: number;
/** Optional cross sectional area used in contact */
    area: number;
/** Base element type for XFEM (SHELL) */
    baselm: number;
/** Smoothing weight factor - Volume weighting (SHELL, SOLID) */
    bfac: number;
/** Cable area */
    ca: number;
/** Deflection limit in compression */
    cdl: number;
/** Smoothing weight factor - Isoparametric (SHELL, SOLID) */
    cfac: number;
/** Coordinate system ID for orientation */
    cid: number;
/** Clearance */
    cl: number;
/** Cohesive material (SHELL, SOLID) */
    cmid: number;
/** The colour of the section */
    colour: Colour;
/** Smoothing length constant */
    cslh: number;
/** Cross section type */
    cst: number;
/** Input parameter 1 for section type */
    d1: number;
/** Input parameter 2 for section type */
    d2: number;
/** Input parameter 3 for section type */
    d3: number;
/** Input parameter 4 for section type */
    d4: number;
/** Input parameter 5 for section type */
    d5: number;
/** Input parameter 6 for section type */
    d6: number;
/** Time imposed SPH approximation is stopped */
    death: number;
/** Smoothing weight factor - Equipotential (SHELL, SOLID) */
    dfac: number;
/** Active degree of freedom at node 1 */
    dofn1: number;
/** Active degree of freedom at node 2 */
    dofn2: number;
/** Domain integration in XFEM (SHELL) */
    domint: number;
/** Displacement/rotation option */
    dro: number;
/** Displacement jump */
    ds: number;
/** Normalized dilation parameter of kernel function in X (SHELL, SOLID) */
    dx: number;
/** Normalized dilation parameter of kernel function in Y (SHELL, SOLID) */
    dy: number;
/** Normalized dilation parameter of kernel function in Z (SOLID) */
    dz: number;
/** Minimum distance to the node that a crack surface can cut to the edge */
    ecut: number;
/** Edge node set */
    edgset: number;
/** Smoothing weight factor - Equilibrium (SHELL) */
    efac: number;
/** If _EFG option is set. Can be true or false (SHELL, SOLID) */
    efg: boolean;
/** Element formulation (ALE1D, ALE2D, BEAM, SHELL, SOLID, TSHELL) */
    elform: number;
/** If _ELLIPSE option is set (was _TENSOR pre R8). Can be true or false */
    ellipse: boolean;
/** End time for smoothing (SHELL, SOLID) */
    end: number;
/** true if section exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Different failure criteria (SHELL) */
    failcr: number;
/** Failure deflection */
    fd: number;
/** SPG Failure strain if IDAM = 1 (SOLID) */
    fs: number;
/** Max smoothing length scale factor */
    hmax: number;
/** Min smoothing length scale factor */
    hmin: number;
/** Constant for smoothing length in X for tensor/ellipse case */
    hxcslh: number;
/** Initial smoothing length in X for tensor/ellipse case */
    hxini: number;
/** Constant for smoothing length in Y for tensor/ellipse case */
    hycslh: number;
/** Initial smoothing length in Y for tensor/ellipse case */
    hyini: number;
/** Constant for smoothing length in Z for tensor/ellipse case */
    hzcslh: number;
/** Initial smoothing length in Z for tensor/ellipse case */
    hzini: number;
/** Branching */
    ibr: number;
/** Composite flag (SHELL, TSHELL) */
    icomp: number;
/** SPG Option of damage mechanism (SOLID) */
    idam: number;
/** Normalized dilation parameter definition (SOLID) */
    idila: number;
/** Domain integration method (SOLID) */
    idim: number;
/** Thickness field value */
    idof: number;
/** Essential boundary condition treatment (SOLID) */
    iebt: number;
/** SPH element formulation */
    iform: number;
/** Flag for using hourglass stabilization (SHELL, SOLID) */
    ihgf: number;
/** approximation */
    iken: number;
/** Coordinate system option (SHELL) */
    iloc: number;
/** The Include file number that the section is in. */
    include: number;
/** Mass moment of inertia */
    iner: number;
/** If _INTERACTION option is set. Can be true or false */
    interaction: boolean;
/** Print flag for the elbow ovalization degrees of freedom (elform 14) */
    iovpr: number;
/** Flag for adding stress due to pressure into the material routine (elform 14) */
    iprstr: number;
/** Pressure smoothing/recovery */
    ips: number;
/** Irr */
    irr: number;
/** EFG kernel function definition (SHELL, SOLID) */
    ispline: number;
/** Iss */
    iss: number;
/** Ist */
    ist: number;
/** Flag for setting up finite element matrices (SHELL, SOLID) */
    itaj: number;
/** SPG Stabilization flag (SOLID) */
    itb: number;
/** THERMAL shell formulation (SHELL) */
    ithelfm: number;
/** Option to specify torsional behaviour for spotwelds */
    itoff: number;
/** Itorm */
    itorm: number;
/** Itt */
    itt: number;
/** Flag for using nodal fibre vectors (SHELL) */
    iunf: number;
/** Warping constant */
    iw: number;
/** Warping constant */
    iwr: number;
/** IYR integral */
    iyr: number;
/** IZR integral */
    izr: number;
/** torsional constant */
    j: number;
/** Dynamic magnification factor */
    kd: number;
/** SPG kernel type approximation (SOLID) */
    kernel: number;
/** Section ID (all types). Also see the secid property which is an alternative name for this. */
    label: number;
/** Temperature loadcurve ID */
    lcidt: number;
/** Inlet flow velocity loadcurve ID */
    lcidvel: number;
/** Relative volume loadcurve ID */
    lcidvolr: number;
/** Mass flowrate loadcurve for gas 1 */
    lcmdot1: number;
/** Mass flowrate loadcurve for gas 2 */
    lcmdot2: number;
/** Mass flowrate loadcurve for gas 3 */
    lcmdot3: number;
/** Mass flowrate loadcurve for gas 4 */
    lcmdot4: number;
/** Mass flowrate loadcurve for gas 5 */
    lcmdot5: number;
/** Mass flowrate loadcurve for gas 6 */
    lcmdot6: number;
/** Mass flowrate loadcurve for gas 7 */
    lcmdot7: number;
/** Mass flowrate loadcurve for gas 8 */
    lcmdot8: number;
/** Number of property parameters (SHELL, SOLID) */
    lmc: number;
/** Debug printout option (SHELL) */
    lprint: number;
/** SPG length scale for displacement regularisation (SOLID) */
    lscale: number;
/** Non structural mass per unit area */
    marea: number;
/** If _MIXTURE option is set. Can be true or false */
    mixture: boolean;
/** The Model number that the section is in. */
    model: number;
/** Number of history variables (SHELL, SOLID) */
    nhsv: number;
/** 1st node ID defining a local coordinate */
    nidlc001: number;
/** 2nd node ID defining a local coordinate */
    nidlc002: number;
/** 3rd node ID defining a local coordinate */
    nidlc003: number;
/** Number of integration points (SHELL, SOLID, TSHELL) */
    nip: number;
/** Number of in-plane integration points (SHELL) */
    nipp: number;
/** Location of reference surface */
    nloc: number;
/** Location of s reference surface */
    nsloc: number;
/** Non structural mass per unit length */
    nsm: number;
/** Location of t reference surface */
    ntloc: number;
/** Number of extra degrees of freedom per node (SHELL, SOLID) */
    nxdof: number;
/** Offset for cable */
    offset: number;
/** Number of point sources */
    points: number;
/** Pressure inside elements (elform 14) */
    pr: number;
/** Output spot force resultants from spotwelds */
    print: number;
/** Not used (SHELL) */
    propcr: number;
/** Printout option (SHELL, TSHELL) */
    propt: number;
/** Quadrature rule (BEAM, SHELL, TSHELL) */
    qr: number;
/** Ramp up time for dynamic relaxation */
    rampt: number;
/** r rotational constraint */
    rrcon: number;
/** Shear area */
    sa: number;
/** Location of triad for discrete beam */
    scoor: number;
/** Section ID (all types). Also see the label property which is an alternative name for this. */
    secid: number;
/** 2D solid element type */
    setyp: number;
/** Failure strain */
    sf: number;
/** Shear correction factor (BEAM, SHELL, TSHELL) */
    shrf: number;
/** SPG Interval of timestep to conduction displ regularisation (SOLID) */
    smstep: number;
/** Optional initial smoothing length */
    sphini: number;
/** s rotational constraint */
    srcon: number;
/** Time imposed SPH approximation is activated (SPH) orStart time for smoothing (SHELL, SOLID) */
    start: number;
/** Time to switch from stabilized EFG to standard EFG formulation */
    stime: number;
/** Initial stress for dynamic relaxation */
    stress: number;
/** SPG stretching parameter if IDAM = 1 (SOLID) */
    stretch: number;
/** Section type */
    stype: string;
/** SPG Time to switch from updated Lagrangian to Eulerian kernel (SOLID) */
    swtime: number;
/** Thickness at Node 1 */
    t1: number;
/** Thickness at Node 2 */
    t2: number;
/** Thickness at Node 3 */
    t3: number;
/** Thickness at Node 4 */
    t4: number;
/** Deflection limit in tension */
    tdl: number;
/** If _TENSOR option is set (_ELLIPSE from R8 onwards). Can be true or false */
    tensor: boolean;
/** If _THERMAL option is set. Can be true or false (SHELL) */
    thermal: boolean;
/** Thickness (ALE1D, SEATBELT) */
    thick: number;
/** Section title (all types) */
    title: string;
/** Deformation tolerance (SOLID) */
    toldef: number;
/** The transparency of the section (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** t rotational constraint */
    trcon: number;
/** s thickness or outer diameter at N1 */
    ts1: number;
/** s thickness or outer diameter at N2 */
    ts2: number;
/** Flag for transverse shear strain or stress distribution */
    tshear: number;
/** t thickness or inner diameter at N1 */
    tt1: number;
/** t thickness or inner diameter at N2 */
    tt2: number;
/** Section type. Can be Section.ALE1D, Section.ALE2D, Section.BEAM, Section.DISCRETE, Section.POINT_SOURCE, Section.SEATBELT, Section.SHELL, Section.SOLID, Section.SPH or Section.TSHELL */
    readonly type: number;
/** If _USER option is set. Can be true or false */
    user: boolean;
/** Test velocity */
    v0: number;
/** Volume of discrete beam */
    vol: number;
/** If _THERMAL option is set. Can be true or false (SHELL) */
    xfem: boolean;
/** s coordinate of shear centre of cross section */
    ys: number;
/** t coordinate of shear centre of cross section */
    zs: number;
/** Section ale1d type */
    static ALE1D: number;
/** Section ale2d type */
    static ALE2D: number;
/** Section beam type */
    static BEAM: number;
/** Section discrete type */
    static DISCRETE: number;
/** Section point source type */
    static POINT_SOURCE: number;
/** Section seatbelt type */
    static SEATBELT: number;
/** Section shell type */
    static SHELL: number;
/** Section solid type */
    static SOLID: number;
/** Section sph type */
    static SPH: number;
/** Section thick shell type */
    static TSHELL: number;
}

declare class Sensor {
/**
 * Blanks the sensor
 */
    Blank(): void;

/**
 * Blanks all of the sensors in the model.
 * @param Model Model that all sensors will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged sensors in the model.
 * @param Model Model that all the flagged sensors will be blanked in
 * @param flag Flag set on the sensors that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the sensor is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the sensor.
 * @param flag Flag to clear on the sensor
 */
    ClearFlag(flag: number): void;

/**
 * Copies the sensor.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Sensor;

/**
 * Starts an interactive editing panel to create a sensor.
 * @param Model Model that the sensor will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Sensor;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for sensor. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for sensor. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the sensor colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the sensor.
 */
    ExtractColour(): number;

/**
 * Returns the first sensor in the model.
 * @param Model Model to get first sensor in
 */
    static First(Model: Model): Sensor;

/**
 * Returns the first free sensor label in the model. Also see Sensor.LastFreeLabel(), Sensor.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free sensor label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the sensors in the model with a defined flag.
 * @param Model Model that all sensors will be flagged in
 * @param flag Flag to set on the sensors
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the sensor is flagged or not.
 * @param flag Flag to test on the sensor
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each sensor in the model. Note that ForEach has been designed to make looping over sensors as fast as possible and so has some limitations. Firstly, a single temporary Sensor object is created and on each function call it is updated with the current sensor data. This means that you should not try to store the Sensor object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new sensors inside a ForEach loop. 
 * @param Model Model that all sensors are in
 * @param func Function to call for each sensor
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Sensor objects for all of the sensors in a model in Primer
 * @param Model Model to get sensors from
 */
    static GetAll(Model: Model): Sensor[];

/**
 * Returns an array of Sensor objects for all of the flagged sensors in a model in Primer
 * @param Model Model to get sensors from
 * @param flag Flag set on the sensors that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Sensor[];

/**
 * Returns the Sensor object for a sensor ID.
 * @param Model Model to find the sensor in
 * @param number number of the sensor you want the Sensor object for
 */
    static GetFromID(Model: Model, number: number): Sensor;

/**
 * Checks if a Sensor property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Sensor.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop sensor property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this sensor (*ELEMENT_SEATBELT_SENSEROMETER) Note that a carriage return is not added. See also Sensor.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the sensor. Note that a carriage return is not added. See also Sensor.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last sensor in the model.
 * @param Model Model to get last sensor in
 */
    static Last(Model: Model): Sensor;

/**
 * Returns the last free sensor label in the model. Also see Sensor.FirstFreeLabel(), Sensor.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free sensor label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next sensor in the model.
 */
    Next(): Sensor;

/**
 * Returns the next free (highest+1) sensor label in the model. Also see Sensor.FirstFreeLabel(), Sensor.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free sensor label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a sensor.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sensors from that model can be picked. If the argument is a Flag then only sensors that are flagged with limit can be selected. If omitted, or null, any sensors from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Sensor;

/**
 * Returns the previous sensor in the model.
 */
    Previous(): Sensor;

/**
 * Renumbers all of the sensors in the model.
 * @param Model Model that all sensors will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged sensors in the model.
 * @param Model Model that all the flagged sensors will be renumbered in
 * @param flag Flag set on the sensors that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select sensors using standard PRIMER object menus.
 * @param flag Flag to use when selecting sensors
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sensors from that model can be selected. If the argument is a Flag then only sensors that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sensors can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the sensor.
 * @param flag Flag to set on the sensor
 */
    SetFlag(flag: number): void;

/**
 * Sketches the sensor. The sensor will be sketched until you either call Sensor.Unsketch(), Sensor.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the sensor is sketched. If omitted redraw is true. If you want to sketch several sensors and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged sensors in the model. The sensors will be sketched until you either call Sensor.Unsketch(), Sensor.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged sensors will be sketched in
 * @param flag Flag set on the sensors that you want to sketch
 * @param redraw If model should be redrawn or not after the sensors are sketched. If omitted redraw is true. If you want to sketch flagged sensors several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of sensors in the model.
 * @param Model Model to get total for
 * @param exists true if only existing sensors should be counted. If false or omitted referenced but undefined sensors will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the sensor
 */
    Unblank(): void;

/**
 * Unblanks all of the sensors in the model.
 * @param Model Model that all sensors will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged sensors in the model.
 * @param Model Model that the flagged sensors will be unblanked in
 * @param flag Flag set on the sensors that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the sensors in the model.
 * @param Model Model that the defined flag for all sensors will be unset in
 * @param flag Flag to unset on the sensors
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the sensor.
 * @param redraw If model should be redrawn or not after the sensor is unsketched. If omitted redraw is true. If you want to unsketch several sensors and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all sensors.
 * @param Model Model that all sensors will be unblanked in
 * @param redraw If model should be redrawn or not after the sensors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged sensors in the model.
 * @param Model Model that all sensors will be unsketched in
 * @param flag Flag set on the sensors that you want to unsketch
 * @param redraw If model should be redrawn or not after the sensors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Sensor;

/**
 * Adds a warning for sensor. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this sensor.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Seatbelt Sensor object.
 * @param Model Model that sensor will be created in
 * @param sbsid Sensor number.
 * @param sbstyp Sensor type
 * @param sbsfl Sensor flag. Default 0.
 * @param nid Optional node ID: Compulsory for types 1 and 4.
 * @param nid2 Optional node ID 2: Compulsory for type 4.
 */
    constructor(Model: Model, sbsid: number, sbstyp: number, sbsfl?: number, nid?: number, nid2?: number);

/**
 * Creates a string containing the sensor data in keyword format. Note that this contains the keyword header and the keyword cards. See also Sensor.Keyword() and Sensor.KeywordCards().
 */
    toString(): string;

/** Activating acceleration. */
    acc: number;
/** Time over which acceleration must be exceeded. */
    atime: number;
/** The colour of the sensor */
    colour: Colour;
/** Minimum distance */
    dmn: number;
/** Maximum distance */
    dmx: number;
/** Degree of freedom. */
    dof: number;
/** true if sensor exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the sensor is in. */
    include: number;
/** Sensor number. Also see the sbacid property which is an alternative name for this. */
    label: number;
/** The Model number that the sensor is in. */
    model: number;
/** Node number. */
    nid: number;
/** Node number 1 */
    nid1: number;
/** Node number 2 */
    nid2: number;
/** Maximum pull-out */
    pulmn: number;
/** Maximum pull-out */
    pulmx: number;
/** Rate of pull-out (length/time units) */
    pulrat: number;
/** Time over which rate of pull#out must be exceeded */
    pultim: number;
/** Retractor number (for sbstyp = 2 OR 5). */
    sbrid: number;
/** Sensor flag. */
    sbsfl: number;
/** Sensor number. Also see the label property which is an alternative name for this. */
    sbsid: number;
/** Sensor type. */
    sbstyp: number;
/** Time at which sensor triggers */
    time: number;
/** The transparency of the sensor (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
}

declare class SensorControl {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the *SENSOR_CONTROL.
 * @param flag Flag to clear on the *SENSOR_CONTROL
 */
    ClearFlag(flag: number): void;

/**
 * Copies the *SENSOR_CONTROL.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): SensorControl;

/**
 * Starts an interactive editing panel to create a *SENSOR_CONTROL.
 * @param Model Model that the *SENSOR_CONTROL will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): SensorControl;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for *SENSOR_CONTROL. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first *SENSOR_CONTROL in the model.
 * @param Model Model to get first *SENSOR_CONTROL in
 */
    static First(Model: Model): SensorControl;

/**
 * Returns the first free *SENSOR_CONTROL label in the model. Also see SensorControl.LastFreeLabel(), SensorControl.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free *SENSOR_CONTROL label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the *SENSOR_CONTROLs in the model with a defined flag.
 * @param Model Model that all *SENSOR_CONTROLs will be flagged in
 * @param flag Flag to set on the *SENSOR_CONTROLs
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the *SENSOR_CONTROL is flagged or not.
 * @param flag Flag to test on the *SENSOR_CONTROL
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each *SENSOR_CONTROL in the model. Note that ForEach has been designed to make looping over *SENSOR_CONTROLs as fast as possible and so has some limitations. Firstly, a single temporary SensorControl object is created and on each function call it is updated with the current *SENSOR_CONTROL data. This means that you should not try to store the SensorControl object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new *SENSOR_CONTROLs inside a ForEach loop. 
 * @param Model Model that all *SENSOR_CONTROLs are in
 * @param func Function to call for each *SENSOR_CONTROL
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of SensorControl objects for all of the *SENSOR_CONTROLs in a model in Primer
 * @param Model Model to get *SENSOR_CONTROLs from
 */
    static GetAll(Model: Model): SensorControl[];

/**
 * Returns an array of SensorControl objects for all of the flagged *SENSOR_CONTROLs in a model in Primer
 * @param Model Model to get *SENSOR_CONTROLs from
 * @param flag Flag set on the *SENSOR_CONTROLs that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): SensorControl[];

/**
 * Returns the SensorControl object for a *SENSOR_CONTROL ID.
 * @param Model Model to find the *SENSOR_CONTROL in
 * @param number number of the *SENSOR_CONTROL you want the SensorControl object for
 */
    static GetFromID(Model: Model, number: number): SensorControl;

/**
 * Checks if a SensorControl property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the SensorControl.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop *SENSOR_CONTROL property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this *SENSOR_CONTROL. Note that a carriage return is not added. See also SensorControl.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the *SENSOR_CONTROL. Note that a carriage return is not added. See also SensorControl.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last *SENSOR_CONTROL in the model.
 * @param Model Model to get last *SENSOR_CONTROL in
 */
    static Last(Model: Model): SensorControl;

/**
 * Returns the last free *SENSOR_CONTROL label in the model. Also see SensorControl.FirstFreeLabel(), SensorControl.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free *SENSOR_CONTROL label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next *SENSOR_CONTROL in the model.
 */
    Next(): SensorControl;

/**
 * Returns the next free (highest+1) *SENSOR_CONTROL label in the model. Also see SensorControl.FirstFreeLabel(), SensorControl.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free *SENSOR_CONTROL label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous *SENSOR_CONTROL in the model.
 */
    Previous(): SensorControl;

/**
 * Renumbers all of the *SENSOR_CONTROLs in the model.
 * @param Model Model that all *SENSOR_CONTROLs will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged *SENSOR_CONTROLs in the model.
 * @param Model Model that all the flagged *SENSOR_CONTROLs will be renumbered in
 * @param flag Flag set on the *SENSOR_CONTROLs that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select *SENSOR_CONTROLs using standard PRIMER object menus.
 * @param flag Flag to use when selecting *SENSOR_CONTROLs
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only *SENSOR_CONTROLs from that model can be selected. If the argument is a Flag then only *SENSOR_CONTROLs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any *SENSOR_CONTROLs can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the *SENSOR_CONTROL.
 * @param flag Flag to set on the *SENSOR_CONTROL
 */
    SetFlag(flag: number): void;

/**
 * Sketches the *SENSOR_CONTROL. The *SENSOR_CONTROL will be sketched until you either call SensorControl.Unsketch(), SensorControl.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the *SENSOR_CONTROL is sketched. If omitted redraw is true. If you want to sketch several *SENSOR_CONTROLs and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged *SENSOR_CONTROLs in the model. The *SENSOR_CONTROLs will be sketched until you either call SensorControl.Unsketch(), SensorControl.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged *SENSOR_CONTROLs will be sketched in
 * @param flag Flag set on the *SENSOR_CONTROLs that you want to sketch
 * @param redraw If model should be redrawn or not after the *SENSOR_CONTROLs are sketched. If omitted redraw is true. If you want to sketch flagged *SENSOR_CONTROLs several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of *SENSOR_CONTROLs in the model.
 * @param Model Model to get total for
 * @param exists true if only existing *SENSOR_CONTROLs should be counted. If false or omitted referenced but undefined *SENSOR_CONTROLs will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the *SENSOR_CONTROLs in the model.
 * @param Model Model that the defined flag for all *SENSOR_CONTROLs will be unset in
 * @param flag Flag to unset on the *SENSOR_CONTROLs
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the *SENSOR_CONTROL.
 * @param redraw If model should be redrawn or not after the *SENSOR_CONTROL is unsketched. If omitted redraw is true. If you want to unsketch several *SENSOR_CONTROLs and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all *SENSOR_CONTROLs.
 * @param Model Model that all *SENSOR_CONTROLs will be unblanked in
 * @param redraw If model should be redrawn or not after the *SENSOR_CONTROLs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged *SENSOR_CONTROLs in the model.
 * @param Model Model that all *SENSOR_CONTROLs will be unsketched in
 * @param flag Flag set on the *SENSOR_CONTROLs that you want to unsketch
 * @param redraw If model should be redrawn or not after the *SENSOR_CONTROLs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): SensorControl;

/**
 * Adds a warning for *SENSOR_CONTROL. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this *SENSOR_CONTROL.
 */
    Xrefs(): Xrefs;

/**
 * Create a new SensorControl object.
 * @param Model Model that *SENSOR_CONTROL will be created in
 * @param Sensor_control_ID SensorControl id.
 * @param Type Entity type to be controlled. Can be "AIRBAG", "BAGVENTPOP", "BELTPRET", "BELTRETRA", "BELTSLIP", "CONTACT", "CONTACT2D", "DEF2RIG", "DISC-ELE", "DISC-ELES", "ELESET", "FUNCTION", "JOINT", "JOINTSTIFF", "M PRESSURE", "RWALL", "SPC", "SPOTWELD".
 * @param Type_ID ID of entity to be controlled if type is not FUNCTION or input value for FUNCTION.
 * @param estyp Element Set Type to be controlled. Can be "BEAM", "DISC", "SHELL", "SOLID", "TSHELL". Required only if Type argument is "ELESET".
 */
    constructor(Model: Model, Sensor_control_ID: number, Type: string, Type_ID?: number, estyp?: string);

/**
 * Creates a string containing the sensor control data in keyword format. Note that this contains the keyword header and the keyword cards. See also SensorControl.Keyword() and SensorControl.KeywordCards().
 */
    toString(): string;

/** SensorControl number. The label property is an alternative name for this. */
    cntlid: number;
/** Element Set Type to be controlled. Can be "BEAM", "DISC", "SHELL", "SOLID", "TSHELL". */
    estyp: string;
/** true if *SENSOR_CONTROL exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the *SENSOR_CONTROL is in. */
    include: number;
/** Initial status. Can be "On" or "Off". */
    initstt: string;
/** SensorControl number. The cntlid property is an alternative name for this. */
    label: number;
/** The Model number that the *SENSOR_CONTROL is in. */
    model: number;
/** Number of repeat of cycle of switches. */
    nrep: number;
/** ID of 1st switch. */
    swit1: number;
/** ID of 2nd switch. */
    swit2: number;
/** ID of 3rd switch. */
    swit3: number;
/** ID of 4th switch. */
    swit4: number;
/** ID of 5th switch. */
    swit5: number;
/** ID of 6th switch. */
    swit6: number;
/** ID of 7th switch. */
    swit7: number;
/** Flag for offset of time in curve. */
    timeoff: number;
/** Entity to be controlled. Can be "AIRBAG", "BAGVENTPOP", "BELTPRET", "BELTRETRA", "BELTSLIP", "CONTACT", "CONTACT2D", "DEF2RIG", "DISC-ELE", "DISC-ELES", "ELESET", "FUNCTION", "JOINT", "JOINTSTIFF", "LOADTHM", "M PRESSURE", "RWALL", "SPC", "SPOTWELD". */
    type: string;
/** ID of entity to be controlled if type is not FUNCTION or input value for FUNCTION. */
    typeid: number;
}

declare class SensorSwitch {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the *SENSOR_SWITCH.
 * @param flag Flag to clear on the *SENSOR_SWITCH
 */
    ClearFlag(flag: number): void;

/**
 * Copies the *SENSOR_SWITCH.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): SensorSwitch;

/**
 * Starts an interactive editing panel to create a *SENSOR_SWITCH.
 * @param Model Model that the *SENSOR_SWITCH will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): SensorSwitch;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for *SENSOR_SWITCH. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first *SENSOR_SWITCH in the model.
 * @param Model Model to get first *SENSOR_SWITCH in
 */
    static First(Model: Model): SensorSwitch;

/**
 * Returns the first free *SENSOR_SWITCH label in the model. Also see SensorSwitch.LastFreeLabel(), SensorSwitch.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free *SENSOR_SWITCH label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the *SENSOR_SWITCHs in the model with a defined flag.
 * @param Model Model that all *SENSOR_SWITCHs will be flagged in
 * @param flag Flag to set on the *SENSOR_SWITCHs
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the *SENSOR_SWITCH is flagged or not.
 * @param flag Flag to test on the *SENSOR_SWITCH
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each *SENSOR_SWITCH in the model. Note that ForEach has been designed to make looping over *SENSOR_SWITCHs as fast as possible and so has some limitations. Firstly, a single temporary SensorSwitch object is created and on each function call it is updated with the current *SENSOR_SWITCH data. This means that you should not try to store the SensorSwitch object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new *SENSOR_SWITCHs inside a ForEach loop. 
 * @param Model Model that all *SENSOR_SWITCHs are in
 * @param func Function to call for each *SENSOR_SWITCH
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of SensorSwitch objects for all of the *SENSOR_SWITCHs in a model in Primer
 * @param Model Model to get *SENSOR_SWITCHs from
 */
    static GetAll(Model: Model): SensorSwitch[];

/**
 * Returns an array of SensorSwitch objects for all of the flagged *SENSOR_SWITCHs in a model in Primer
 * @param Model Model to get *SENSOR_SWITCHs from
 * @param flag Flag set on the *SENSOR_SWITCHs that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): SensorSwitch[];

/**
 * Returns the SensorSwitch object for a *SENSOR_SWITCH ID.
 * @param Model Model to find the *SENSOR_SWITCH in
 * @param number number of the *SENSOR_SWITCH you want the SensorSwitch object for
 */
    static GetFromID(Model: Model, number: number): SensorSwitch;

/**
 * Checks if a SensorSwitch property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the SensorSwitch.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop *SENSOR_SWITCH property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the data for a row in the SENSOR_SWITCH_SHELL_TO_VENT.
 * @param row The row you want the data for. Note row indices start at 0.
 */
    GetRow(row: number): number[];

/**
 * Returns the keyword for this *SENSOR_SWITCH. Note that a carriage return is not added. See also SensorSwitch.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the *SENSOR_SWITCH. Note that a carriage return is not added. See also SensorSwitch.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last *SENSOR_SWITCH in the model.
 * @param Model Model to get last *SENSOR_SWITCH in
 */
    static Last(Model: Model): SensorSwitch;

/**
 * Returns the last free *SENSOR_SWITCH label in the model. Also see SensorSwitch.FirstFreeLabel(), SensorSwitch.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free *SENSOR_SWITCH label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next *SENSOR_SWITCH in the model.
 */
    Next(): SensorSwitch;

/**
 * Returns the next free (highest+1) *SENSOR_SWITCH label in the model. Also see SensorSwitch.FirstFreeLabel(), SensorSwitch.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free *SENSOR_SWITCH label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous *SENSOR_SWITCH in the model.
 */
    Previous(): SensorSwitch;

/**
 * Removes the data for a row in *SENSOR_SWITCH_SHELL_TO_VENT.
 * @param row The row you want to remove the data for. Note that row indices start at 0.
 */
    RemoveRow(row: number): void;

/**
 * Renumbers all of the *SENSOR_SWITCHs in the model.
 * @param Model Model that all *SENSOR_SWITCHs will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged *SENSOR_SWITCHs in the model.
 * @param Model Model that all the flagged *SENSOR_SWITCHs will be renumbered in
 * @param flag Flag set on the *SENSOR_SWITCHs that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select *SENSOR_SWITCHs using standard PRIMER object menus.
 * @param flag Flag to use when selecting *SENSOR_SWITCHs
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only *SENSOR_SWITCHs from that model can be selected. If the argument is a Flag then only *SENSOR_SWITCHs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any *SENSOR_SWITCHs can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the *SENSOR_SWITCH.
 * @param flag Flag to set on the *SENSOR_SWITCH
 */
    SetFlag(flag: number): void;

/**
 * Sets the data for a row in *SENSOR_SWITCH_SHELL_TO_VENT.
 * @param row The row you want to set the data for. Note that row indices start at 0.
 * @param data An array containing the row variables SSID, FTIME and C23V.
 */
    SetRow(row: number, data: number[]): void;

/**
 * Returns the total number of *SENSOR_SWITCHs in the model.
 * @param Model Model to get total for
 * @param exists true if only existing *SENSOR_SWITCHs should be counted. If false or omitted referenced but undefined *SENSOR_SWITCHs will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the *SENSOR_SWITCHs in the model.
 * @param Model Model that the defined flag for all *SENSOR_SWITCHs will be unset in
 * @param flag Flag to unset on the *SENSOR_SWITCHs
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): SensorSwitch;

/**
 * Adds a warning for *SENSOR_SWITCH. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this *SENSOR_SWITCH.
 */
    Xrefs(): Xrefs;

/**
 * Create a new SensorSwitch object.
 * @param Option SENSOR_SWITCH suffix. Can be SensorSwitch.SWITCH, SensorSwitch.SWITCH_CALC_LOGIC or SensorSwitch.SWITCH_SHELL_TO_VENT.
 * @param Model Model that *SENSOR_SWITCH will be created in
 * @param Switch_ID SensorSwitch id. This is required for the SensorSwitch.SWITCH and SensorSwitch.SWITCH_CALC_LOGIC options and ignored for SensorSwitch.SWITCH_SHELL_TO_VENT.
 */
    constructor(Option: number, Model: Model, Switch_ID: number);

/**
 * Creates a string containing the sensor switch data in keyword format. Note that this contains the keyword header and the keyword cards. See also SensorSwitch.Keyword() and SensorSwitch.KeywordCards().
 */
    toString(): string;

/** Vent coefficient if positive or user defined load curve ID if negative. */
    c23: number;
/** true if *SENSOR_SWITCH exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Filter ID. */
    filtrid: number;
/** Part set ID or Part ID. */
    id: number;
/** Turns _TITLE/_ID ON or OFF. Used only for SensorSwitch.SWITCH_SHELL_TO_VENT. */
    id_flag: boolean;
/** The Include file number that the *SENSOR_SWITCH is in. */
    include: number;
/** 0 for Part, 1 for Part Set. */
    itype: number;
/** SensorSwitch number. The switid property is an alternative name for this. */
    label: number;
/** Logic operator. */
    logic: string;
/** The Model number that the *SENSOR_SWITCH is in. */
    model: number;
/** Number of Shell Fail Time Cards. */
    nrow: number;
/** SENSOR_SWITCH suffix. Can be SensorSwitch.SWITCH, SensorSwitch.SWITCH_CALC_LOGIC or SensorSwitch.SWITCH_SHELL_TO_VENT. */
    option: number;
/** ID of the sensor whose value will be compared. */
    sensid: number;
/** Positive sensor switch ID for "AND", negative ID for "OR". */
    swit1: number;
/** Positive sensor switch ID for "AND", negative ID for "OR". */
    swit2: number;
/** Positive sensor switch ID for "AND", negative ID for "OR". */
    swit3: number;
/** Positive sensor switch ID for "AND", negative ID for "OR". */
    swit4: number;
/** Positive sensor switch ID for "AND", negative ID for "OR". */
    swit5: number;
/** Positive sensor switch ID for "AND", negative ID for "OR". */
    swit6: number;
/** Positive sensor switch ID for "AND", negative ID for "OR". */
    swit7: number;
/** SensorSwitch number. The label property is an alternative name for this. */
    switid: number;
/** Trigger status change when the value given by the sensor is less/greater (depending on logic) than value for duration defined by timwin. */
    timwin: number;
/** SensorSwitch title. Used only for SensorSwitch.SWITCH_SHELL_TO_VENT. */
    title: string;
/** Type used for sensor. Can either be "SENSOR" or "TIME" */
    type: string;
/** Critical value. */
    value: number;
/** Sensor switch is *SENSOR_SWITCH. */
    static SWITCH: number;
/** Sensor switch is *SENSOR_SWITCH_CALC-LOGIC. */
    static SWITCH_CALC_LOGIC: number;
/** Sensor switch is *SENSOR_SWITCH_SHELL_TO_VENT. */
    static SWITCH_SHELL_TO_VENT: number;
}

declare class Set {
/**
 * Adds an item to the set. This cannot be used for _COLUMN and _GENERAL sets. For segment sets four nodes must be given to define a segment to add to the set.
 * @param id1 id of the item to add to the set (normal, _ADD or _ADD_ADVANCED sets) orStart ID (_GENERATE sets)
 * @param id2_only_for_SEGMENT,__GENERATE,__GENERATE_INCREMENT_and__ADD_ADVANCED_sets type of the item to add to the set [1-7] (_ADD_ADVANCED sets) orEnd ID (_GENERATE sets)
 * @param id3_only_for_SEGMENT_and__GENERATE_INCREMENT_sets Increment for _GENERATE_INCREMENT sets, otherwise id of the item to add to the set.
 * @param id4_only_for_SEGMENT_sets id of the item to add to the set.
 */
    Add(id1: number, id2_only_for_SEGMENT__GENERATE__GENERATE_INCREMENT_and__ADD_ADVANCED_sets: number, id3_only_for_SEGMENT_and__GENERATE_INCREMENT_sets: number, id4_only_for_SEGMENT_sets: number): void;

/**
 * Adds a child collect set to the set. The child set label will be changed to be the same as the parent set and it will become a child. Also see Set.collect_children and Set.GetCollectChild.
 * @param set Set to be added as a child collect set.
 */
    AddCollectChild(set: Set): void;

/**
 * Adds flagged items to the set. This cannot be used for _GENERAL or _GENERATE sets and cannot be used for segment sets
 * @param flag Flag for items to add to the set
 */
    AddFlagged(flag: number): void;

/**
 * Blanks all of the sets in the model.
 * @param Model Model that all sets will be blanked in
 * @param type Type of sets to blank. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If omitted sets of all types will be blanked.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, type?: number, redraw?: boolean): void;

/**
 * Blanks all of the flagged sets in the model.
 * @param Model Model that all the flagged sets will be blanked in
 * @param flag Flag set on the sets that you want to blank
 * @param type Type of sets to blank. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If set, only flagged sets of this type will be blanked. If omitted flagged sets of all types will be blanked.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, type?: number, redraw?: boolean): void;

/**
 * Checks if the set is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the set.
 * @param flag Flag to clear on the set
 */
    ClearFlag(flag: number): void;

/**
 * Checks if an item is in the set. This cannot be used for ADD_ADVANCED, _GENERAL or _GENERATE sets and cannot be used for segment sets
 * @param id id of the item to check.
 */
    Contains(id: number): boolean;

/**
 * Copies the set.
 * @param range If you want to keep the copied item in the range specified for the current include. To set current include, use  Include.MakeCurrentLayer() .
 */
    Copy(range?: boolean): Set;

/**
 * Starts an interactive editing panel to create a set.
 * @param Model Model that the set will be created in
 * @param type Type of the set that you want to create. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, type: number, modal?: boolean): Set;

/**
 * Starts an interactive editing panel to edit the set.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Removes all items from the set. This cannot be used for _GENERATE sets and cannot be used for segment sets
 */
    Empty(): void;

/**
 * Adds an error for a set. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first set in the model.
 * @param Model Model to get first set in
 * @param type Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 */
    static First(Model: Model, type: number): Set;

/**
 * Returns the first free set label in the model. Also see Set.LastFreeLabel(), Set.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free Set label in
 * @param type Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, type: number, layer?: number): number;

/**
 * Flags all of the sets in the model with a defined flag.
 * @param Model Model that all sets will be flagged in
 * @param flag Flag to set on the sets
 * @param type Type of the set. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If set, only sets of this type will be flagged. If omitted sets of all types will be flagged.
 */
    static FlagAll(Model: Model, flag: number, type?: number): void;

/**
 * Checks if the set is flagged or not.
 * @param flag Flag to clear on the set
 */
    Flagged(flag: number): boolean;

/**
 * Returns an array of Set objects for all of the sets in a models in Primer
 * @param Model Model to get sets from
 * @param type Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 */
    static GetAll(Model: Model, type: number): Set[];

/**
 * Returns a child collect set. Also see Set.collect_children and Set.AddCollectChild.
 * @param number The index of the child collect set to return. Note that indices start at 0, not 1
 */
    GetCollectChild(number: number): Set;

/**
 * Returns an array of Set objects for all of the flagged sets in a models in Primer
 * @param Model Model to get sets from
 * @param flag Flag set on the set that you want to retrieve
 * @param type Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 */
    static GetFlagged(Model: Model, flag: number, type: number): Set[];

/**
 * Returns the Set object for a set ID.
 * @param Model Model to find the set in
 * @param set_number number of the set you want the Set object for
 * @param type Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 */
    static GetFromID(Model: Model, set_number: number, type: number): Set;

/**
 * Returns a line of data for a GENERAL set.
 * @param index The index of the GENERAL data to return. Note that indices start at 0, not 1. 0 &lt;= index &lt; general_lines
 */
    GetGeneralData(index: number): number[];

/**
 * Returns the keyword for this set (*SET_NODE etc). Note that a carriage return is not added. See also Set.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the set. Note that a carriage return is not added. See also Set.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last set in the model.
 * @param Model Model to get last set in
 * @param type Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 */
    static Last(Model: Model, type: number): Set;

/**
 * Returns the last free set label in the model. Also see Set.FirstFreeLabel(), Set.NextFreeLabel() and Model.LastFreeItemLabel().
 * @param Model Model to get last free Set label in
 * @param type Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, type: number, layer?: number): number;

/**
 * Returns the next set in the model.
 */
    Next(): Set;

/**
 * Returns the next free set label in the model. Also see Set.FirstFreeLabel(), Set.LastFreeLabel() and Model.NextFreeItemLabel().
 * @param Model Model to get next free Set label in
 * @param type Type of the set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, type: number, layer?: number): number;

/**
 * Allows the user to pick a set.
 * @param type Type of sets to pick. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sets from that model can be picked. If the argument is a Flag then only sets that are flagged with limit can be selected. If omitted, or null, any sets from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(type: number, prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Set;

/**
 * Returns the previous set in the model.
 */
    Previous(): Set;

/**
 * Rebuilds the cache for a set. As sets can be built using complex combinations of _GENERAL, _ADD, _INTERSECT options etc Primer creates a 'cache' for the set to speed up set drawing and usage. During normal interactive use this cache is rebuilt as necessary but in JavaScript it is possible for the cache to become out of date (e.g. you change a box position in JavaScript that is used by a *SET_GENERAL). Calling this forces the cache to be rebuilt.
 */
    RebuildCache(): void;

/**
 * Removes an item from the set. If the item is not in the set nothing is done. This cannot be used for ADD_ADVANCED, _COLUMN, _GENERAL or _GENERATE sets and cannot be used for segment sets
 * @param id id of the item to remove from the set.
 */
    Remove(id: number): void;

/**
 * Removes flagged items from the set. This cannot be used for _GENERAL or _GENERATE sets and cannot be used for segment sets
 * @param flag Flag for items to remove from the set
 */
    RemoveFlagged(flag: number): void;

/**
 * Removes a line of data from a GENERAL set.
 * @param index The index of the GENERAL data to remove. Note that indices start at 0, not 1. 0 &lt;= index &lt; general_lines
 */
    RemoveGeneralData(index: number): void;

/**
 * Renumbers all of the sets in the model.
 * @param Model Model that all sets will be renumbered in
 * @param start Start point for renumbering
 * @param type Type of sets to renumber. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If omitted sets of all types will be blanked.
 */
    static RenumberAll(Model: Model, start: number, type?: number): void;

/**
 * Renumbers all of the flagged sets in the model.
 * @param Model Model that all the flagged sets will be renumbered in
 * @param flag Flag set on the sets that you want to renumber
 * @param start Start point for renumbering
 * @param type Type of sets to renumber. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If omitted sets of all types will be blanked.
 */
    static RenumberFlagged(Model: Model, flag: number, start: number, type?: number): void;

/**
 * Allows the user to select sets using standard PRIMER object menus.
 * @param type Type of sets to pick. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL.
 * @param flag Flag to use when selecting sets
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sets from that model can be selected. If the argument is a Flag then only sets that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sets from any model can be selected.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(type: number, flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the set.
 * @param flag Flag to set on the set
 */
    SetFlag(flag: number): void;

/**
 * Sets a line of data for a GENERAL set.
 * @param index The index of the GENERAL data to set. Note that indices start at 0, not 1. 0 &lt;= index &lt;= general_lines
 * @param data Array containing GENERAL data to set.
 */
    SetGeneralData(index: number, data: number[]): void;

/**
 * Sketches the set. The set will be sketched until you either call Set.Unsketch(), Set.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the set is sketched. If omitted redraw is true. If you want to sketch several sets and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged sets in the model.
 * @param Model Model that all the flagged sets will be sketched in
 * @param flag Flag set on the sets that you want to sketch
 * @param type Type of sets to sketch. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If set, only flagged sets of this type will be sketched. If omitted flagged sets of all types will be sketched.
 * @param redraw If model should be redrawn or not. If omitted redraw is true. If you want to do several (un)sketches and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, type?: number, redraw?: boolean): void;

/**
 * Spools a set, entry by entry. See also Set.StartSpool
 */
    Spool(): number[];

/**
 * Starts a set spooling operation. See also Set.Spool
 * @param raw If true then the raw data from _GENERATE, _ADD and _INTERSECT sets will be returned instead of expanding the data ranges or child set contents. If omitted raw will be false.
 */
    StartSpool(raw?: boolean): void;

/**
 * Unblanks all of the sets in the model.
 * @param Model Model that all sets will be unblanked in
 * @param type Type of sets to unblank. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If omitted sets of all types will be blanked.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, type?: number, redraw?: boolean): void;

/**
 * Unblanks all of the flagged sets in the model.
 * @param Model Model that the flagged sets will be unblanked in
 * @param flag Flag set on the sets that you want to unblank
 * @param type Type of sets to unblank. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. Set.ALL_TYPES. If set, only flagged sets of this type will be unblanked. If omitted flagged sets of all types will be unblanked.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, type?: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the sets in the model.
 * @param Model Model that the defined flag for all sets will be unset in
 * @param flag Flag to unset on the sets
 * @param type Type of the set. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 */
    static UnflagAll(Model: Model, flag: number, type?: number): void;

/**
 * Unsketches the set.
 * @param redraw If model should be redrawn or not after the set is unsketched. If omitted redraw is true. If you want to unsketch several sets and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all sets.
 * @param Model Model that all sets will be unsketched in
 * @param type Type of sets to unsketch. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If omitted sets of all types will be unsketched.
 * @param redraw If model should be redrawn or not after the sets are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, type?: number, redraw?: boolean): void;

/**
 * Unsketches all flagged sets.
 * @param Model Model that all sets will be unsketched in
 * @param flag Flag set on the sets that you want to unsketch
 * @param type Type of sets to unsketch. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL. If omitted sets of all types will be unsketched.
 * @param redraw If model should be redrawn or not after the sets are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, type?: number, redraw?: boolean): void;

/**
 * Adds a warning for a set. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this set.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Set object.
 * @param Model Model that set will be created in
 * @param sid Set number
 * @param type Type of set. Can be Set.BEAM, Set.BOX, Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL
 * @param title Title for the set
 * @param option Set type. Can be Set.ADD, Set.INTERSECT, Set.GENERAL or Set.GENERATE
 */
    constructor(Model: Model, sid: number, type: number, title?: string, option?: number);

/**
 * Creates a string containing the set data in keyword format. Note that this contains the keyword header and the keyword cards. See also Set.Keyword() and Set.KeywordCards().
 */
    toString(): string;

/** If _ADD option is active. */
    add: boolean;
/** If _ADD_ADVANCED option is active. */
    readonly advanced: boolean;
/** If _COLLECT option is active. To manage _COLLECT sets PRIMER creates a 'parent' set that can be used to sketch/view all of the items from the _COLLECT sets with the same label. PRIMER then manages each _COLLECT set with the same label as a 'child' of this 'parent' set. Also see collect_children and GetCollectChild. If the collect property is unset for a child collect set then a new label will be assigned for the child set. If the collect property is unset for a parent collect set then all of the child sets will be reassigned new labels. */
    collect: boolean;
/** The number of child _COLLECT sets if _COLLECT option is active. */
    readonly collect_children: number;
/** The colour of the set */
    colour: Colour;
/** If _COLUMN option is active. */
    readonly column: boolean;
/** The first default attribute for the set (only valid for Set.NODE, Set.PART, Set.SEGMENT, Set.SEGMENT_2D and Set.SHELL) */
    da1: number;
/** The second default attribute for the set (only valid for Set.NODE, Set.PART, Set.SEGMENT, Set.SEGMENT_2D and Set.SHELL) */
    da2: number;
/** The third default attribute for the set (only valid for Set.NODE, Set.PART, Set.SEGMENT, Set.SEGMENT_2D and Set.SHELL) */
    da3: number;
/** The fourth default attribute for the set (only valid for Set.NODE, Set.PART, Set.SEGMENT, Set.SEGMENT_2D and Set.SHELL) */
    da4: number;
/** true if set exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** If _GENERAL option is active. */
    general: boolean;
/** Number of lines of data for _GENERAL set (if _GENERAL option is active). */
    readonly general_lines: number;
/** If _GENERATE option is active. */
    generate: boolean;
/** The Include file number that the set is in. */
    include: number;
/** If _GENERATE_INCREMENT option is active. */
    readonly increment: boolean;
/** If _INTERSECT option is active. */
    intersect: boolean;
/** Set number. Also see the sid property which is an alternative name for this. */
    label: number;
/** The Model number that the set is in. */
    model: number;
/** Set number. Also see the label property which is an alternative name for this. */
    sid: number;
/** If _LIST_SMOOTH option is active. */
    readonly smooth: boolean;
/** Solver to attach to set. Can be "MECH", "CESE", "EM", "ICFD" or blank (only valid for Set.NODE, Set.PART, Set.SEGMENT and Set.SOLID). */
    solver: string;
/** Set title */
    title: string;
/** The total number of items in the set. Note that for _GENERAL and _GENERATE sets this is expensive to compute. */
    readonly total: number;
/** The transparency of the set (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Set type. Can be Set.BEAM, Set.BOX Set.DISCRETE, Set.MM_GROUP, Set.MODE, Set.NODE, Set.PART, Set.PART_TREE, Set.SEGMENT, Set.SEGMENT_2D, Set.SHELL, Set.SOLID or Set.TSHELL */
    readonly type: number;
/** Set type is *SET_XYZ_ADD. */
    static ADD: number;
/** All set types - used in blanking etc. */
    static ALL_TYPES: number;
/** Set beam type */
    static BEAM: number;
/** Set box type */
    static BOX: number;
/** Set discrete type */
    static DISCRETE: number;
/** Set type is *SET_XYZ_GENERAL. */
    static GENERAL: number;
/** Set type is *SET_XYZ_GENERATE. */
    static GENERATE: number;
/** Set type is *SET_XYZ_INTERSECT. */
    static INTERSECT: number;
/** Set multi-material group type */
    static MM_GROUP: number;
/** Set mode type */
    static MODE: number;
/** Set node type */
    static NODE: number;
/** Set part type */
    static PART: number;
/** Set part tree type */
    static PART_TREE: number;
/** Set segment type */
    static SEGMENT: number;
/** Set segment 2d type */
    static SEGMENT_2D: number;
/** Set shell type */
    static SHELL: number;
/** Set solid type */
    static SOLID: number;
/** Set thick shell type */
    static TSHELL: number;
}

declare class Shell {
/**
 * Calculates the minimum and maximum internal angles (in degrees) for the shell
 */
    Angles(): number[];

/**
 * Calculates the area for the shell
 */
    Area(): number;

/**
 * Calculates the aspect ratio for the shell
 */
    AspectRatio(): number;

/**
 * Blanks the shell
 */
    Blank(): void;

/**
 * Blanks all of the shells in the model.
 * @param Model Model that all shells will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged shells in the model.
 * @param Model Model that all the flagged shells will be blanked in
 * @param flag Flag set on the shells that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the shell is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the shell.
 * @param flag Flag to clear on the shell
 */
    ClearFlag(flag: number): void;

/**
 * Calculates the isoparametric coordinates for a point on the shell.
 * @param x X coordinate of point
 * @param y Y coordinate of point
 * @param z Z coordinate of point
 */
    CoordsToIsoparametric(x: number, y: number, z: number): number[];

/**
 * Copies the shell.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Shell;

/**
 * Starts an interactive editing panel to create a shell.
 * @param Model Model that the shell will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Shell;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Returns coordinates of the intersections between a shell and a database cross section.
 * @param Database_cross_section_label The label of the database cross section.
 */
    ElemCut(Database_cross_section_label: number): number[];

/**
 * Adds an error for shell. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for shell. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the shell colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the shell.
 */
    ExtractColour(): number;

/**
 * Fills in (meshes) a hole attached to the shell.
 * @param pid The Part number that the new shells will be created in.
 * @param size The size for created elements.
 */
    FillAttachedHole(pid: number, size: number): void;

/**
 * Fills multiple holes using flagged shells.
 * @param Model Model that all shells are in.
 * @param Flag flag bit
 * @param RemeshHole TRUE if elements around the hole should be remeshed
 * @param pid Needs to be specified if RemeshHole is FALSE. Specifies the Part id where the mesh is filled
 * @param Max_Hole_Size Maximum size of the hole which is to be filled. If omitted a default size of 20.0 will be set
 * @param Mesh_Element_size Element size of the mesh which fills the hole. If omitted a default size of 10.0 will be set
 * @param planarSurface Needs to be specified if RemeshHole is TRUE. TRUE if we need to Use planar surface
 */
    static FillHolesOnFlagged(Model: Model, Flag: number, RemeshHole: boolean, pid?: number, Max_Hole_Size?: number, Mesh_Element_size?: number, planarSurface?: boolean): void;

/**
 * Returns an array of Shell objects for the shells within a box. This requires a previous (outside loop) call to function FindShellInit(m) or m.FindElemInit() where the process is initialized for flagged shells in the model (typically all shells) and m.FindElemEnd() to close the process. Please note this function provides a list of all shells that could potentially be in the box (using computationally cheap bounding box comparison) it is not a rigorous test of whether the shell is actually in the box. See also Shell.FindShellInit() See also Model.FindElemInit() See also Model.FindElemEnd()
 * @param Model Model designated model
 * @param xmin Minimum bound in global x
 * @param xmax Maximum bound in global x
 * @param ymin Minimum bound in global y
 * @param ymax Maximum bound in global y
 * @param zmin Minimum bound in global z
 * @param zmax Maximum bound in global z
 * @param sflag Optional flag to restrict shells considered
 * @param sthick Optional flag to consider thickness for shells
 */
    static FindShellInBox(Model: Model, xmin: number, xmax: number, ymin: number, ymax: number, zmin: number, zmax: number, sflag?: number, sthick?: number): Shell[];

/**
 * Initialize setup so that all flagged shells in model can be tested to see if they are within box. See also Shell.FindShellInBox() See also Model.FindElemInit() See also Model.FindElemEnd()
 * @param Model Model in which shells have been flagged
 * @param flag Optional flag that has been set on the shells, if unsupplied all shells considered
 */
    static FindShellInit(Model: Model, flag?: number): void;

/**
 * Returns the first shell in the model.
 * @param Model Model to get first shell in
 */
    static First(Model: Model): Shell;

/**
 * Returns the first free shell label in the model. Also see Shell.LastFreeLabel(), Shell.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the shells in the model with a defined flag.
 * @param Model Model that all shells will be flagged in
 * @param flag Flag to set on the shells
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the shell is flagged or not.
 * @param flag Flag to test on the shell
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each shell in the model. Note that ForEach has been designed to make looping over shells as fast as possible and so has some limitations. Firstly, a single temporary Shell object is created and on each function call it is updated with the current shell data. This means that you should not try to store the Shell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new shells inside a ForEach loop. 
 * @param Model Model that all shells are in
 * @param func Function to call for each shell
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Shell objects for all of the shells in a model in Primer
 * @param Model Model to get shells from
 */
    static GetAll(Model: Model): Shell[];

/**
 * Returns the shells that are attached to the shell. Note that 'attached' means that the shells must share 2 nodes.
 * @param tolerance This tolerance can be used to limit the selection to shells whose normal vector is within this tolerance (in degrees) of the original shell. If omitted the tolerance is 180 degrees.
 * @param recursive If recursive is false then only the shells actually attached to the shell will be returned (this could also be done by using the Xrefs class but this method is provided for convenience. If recursive is true then PRIMER will keep finding attached shells until no more can be found. If omitted recursive will be false.
 */
    GetAttachedShells(tolerance?: number, recursive?: boolean): Shell[];

/**
 * Returns the composite data for an integration point in *ELEMENT_SHELL_COMPOSITE.
 * @param ipt The integration point you want the data for. Note that integration points start at 0, not 1.
 */
    GetCompositeData(ipt: number): number[];

/**
 * Returns an array of Shell objects for all of the flagged shells in a model in Primer
 * @param Model Model to get shells from
 * @param flag Flag set on the shells that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Shell[];

/**
 * Returns the Shell object for a shell ID.
 * @param Model Model to find the shell in
 * @param number number of the shell you want the Shell object for
 */
    static GetFromID(Model: Model, number: number): Shell;

/**
 * Returns the labels of the nodes on the shell as an array. See also Shell.GetNodes()
 */
    GetNodeIDs(): number[];

/**
 * Returns the nodes on the shell as an array of Node objects. See also Shell.GetNodeIDs()
 */
    GetNodes(): Node[];

/**
 * Checks if a Shell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Shell.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop shell property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the airbag shell reference geometry of the shell
 */
    GetShellReferenceGeometry(): number;

/**
 * Calculates the coordinates for a point on the shell from the isoparametric coords.
 * @param s First isoparametric coordinate
 * @param t Second isoparametric coordinate
 */
    IsoparametricToCoords(s: number, t: number): number[];

/**
 * Calculates the jacobian for the shell
 */
    Jacobian(): number;

/**
 * Returns the keyword for this shell (*SHELL, *SHELL_SCALAR or *SHELL_SCALAR_VALUE). Note that a carriage return is not added. See also Shell.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the shell. Note that a carriage return is not added. See also Shell.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last shell in the model.
 * @param Model Model to get last shell in
 */
    static Last(Model: Model): Shell;

/**
 * Returns the last free shell label in the model. Also see Shell.FirstFreeLabel(), Shell.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Calculates the minimum length for the shell
 */
    Length(): number;

/**
 * Make all the flagged SHELL normals consistent with a selected one, the Seed Element.
 * @param Model Model that all shells are in.
 * @param Flag flag bit
 * @param Shell_label The label of the seed shell. If omitted, or null, the first flagged shell is used as the seed shell.
 */
    static MakeConsistentNormalsFlagged(Model: Model, Flag: number, Shell_label?: number): number[];

/**
 * Returns the next shell in the model.
 */
    Next(): Shell;

/**
 * Returns the next free (highest+1) shell label in the model. Also see Shell.FirstFreeLabel(), Shell.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Calculates the unit normal vector for the shell.
 */
    NormalVector(): number[];

/**
 * Allows the user to pick a shell.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only shells from that model can be picked. If the argument is a Flag then only shells that are flagged with limit can be selected. If omitted, or null, any shells from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Shell;

/**
 * Allows the user to pick a point on a shell. The isoparametric coordinates of the point picked on the shell are returned as well as the shell picked. These coordinates are suitable for using in the function Shell.IsoparametricToCoords(). See also Shell.Pick()
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only shells from that model can be picked. If the argument is a Flag then only shells that are flagged with limit can be selected. If omitted, or null, any shells from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static PickIsoparametric(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): number[];

/**
 * Returns the previous shell in the model.
 */
    Previous(): Shell;

/**
 * Removes the composite data for an integration point in *ELEMENT_SHELL_COMPOSITE.
 * @param ipt The integration point you want to remove. Note that integration points start at 0, not 1.
 */
    RemoveCompositeData(ipt: number): void;

/**
 * Renumbers all of the shells in the model.
 * @param Model Model that all shells will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged shells in the model.
 * @param Model Model that all the flagged shells will be renumbered in
 * @param flag Flag set on the shells that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Reverse shell normal.
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to reverse several shell normals and only redraw after the last one then use false for all redraws apart from the last one.
 */
    ReverseNormal(redraw?: boolean): void;

/**
 * Reverse all the flagged shell normals
 * @param Model Model that all shells are in.
 * @param Flag flag bit
 */
    static ReverseNormalsFlagged(Model: Model, Flag: number): void;

/**
 * Allows the user to select shells using standard PRIMER object menus.
 * @param flag Flag to use when selecting shells
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only shells from that model can be selected. If the argument is a Flag then only shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any shells can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets the composite data for an integration point in *ELEMENT_SHELL_COMPOSITE.
 * @param ipt The integration point you want to set the data for. Note that integration points start at 0, not 1.
 * @param mid Material ID for the integration point.
 * @param thick Thickness of the integration point.
 * @param beta Material angle of the integration point.
 * @param plyid Ply ID for the integration point. This should be used if the _COMPOSITE_LONG option is set for the shell.
 */
    SetCompositeData(ipt: number, mid: number, thick: number, beta: number, plyid?: number): void;

/**
 * Sets a flag on the shell.
 * @param flag Flag to set on the shell
 */
    SetFlag(flag: number): void;

/**
 * Sketches the shell. The shell will be sketched until you either call Shell.Unsketch(), Shell.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the shell is sketched. If omitted redraw is true. If you want to sketch several shells and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged shells in the model. The shells will be sketched until you either call Shell.Unsketch(), Shell.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged shells will be sketched in
 * @param flag Flag set on the shells that you want to sketch
 * @param redraw If model should be redrawn or not after the shells are sketched. If omitted redraw is true. If you want to sketch flagged shells several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Calculates the skew for the shell
 */
    Skew(): number;

/**
 * Calculates the taper for the shell
 */
    Taper(): number;

/**
 * Checks if nodes of shell are tied by contact or directly attached (non-zero option1).
 * @param Contact_label The label of the tied contact. If zero the tied contact is found for the shell by reverse lookup.
 * @param Flag flag bit
 * @param Option1 Directly tied node (logical OR) 0:NONE 1:NRB/C_EXNO 2:BEAM 4:SHELL 8:SOLID 16:TSHELL
 * @param Option2 0:No action 1: report error if directly attached node (acc. option1) captured by contact
 */
    TiedNodeCheck(Contact_label: number, Flag: number, Option1: number, Option2: number): string;

/**
 * Calculates the timestep for the shell
 */
    Timestep(): number;

/**
 * Returns the total number of shells in the model.
 * @param Model Model to get total for
 * @param exists true if only existing shells should be counted. If false or omitted referenced but undefined shells will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the shell
 */
    Unblank(): void;

/**
 * Unblanks all of the shells in the model.
 * @param Model Model that all shells will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged shells in the model.
 * @param Model Model that the flagged shells will be unblanked in
 * @param flag Flag set on the shells that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the shells in the model.
 * @param Model Model that the defined flag for all shells will be unset in
 * @param flag Flag to unset on the shells
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the shell.
 * @param redraw If model should be redrawn or not after the shell is unsketched. If omitted redraw is true. If you want to unsketch several shells and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all shells.
 * @param Model Model that all shells will be unblanked in
 * @param redraw If model should be redrawn or not after the shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged shells in the model.
 * @param Model Model that all shells will be unsketched in
 * @param flag Flag set on the shells that you want to unsketch
 * @param redraw If model should be redrawn or not after the shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Shell;

/**
 * Adds a warning for shell. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Calculates the warpage for the shell
 */
    Warpage(): number;

/**
 * Calculates the weighting factors for a point on the shell from the isoparametric coords.
 * @param s First isoparametric coordinate
 * @param t Second isoparametric coordinate
 */
    WeightingFactors(s: number, t: number): number[];

/**
 * Returns the cross references for this shell.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Shell object. Use either 3, 4, 6 or 8 nodes when creating a new shell. If you are creating a 3 noded shell either only give 3 nodes or give 4 nodes but make nodes 3 and 4 the same number. Similarly, 6 noded shells can be created with 6 node arguments or with 8 nodes but nodes 3 and 4 the same number and nodes 7 and 8 the same number.
 * @param Model Model that shell will be created in
 * @param eid Shell number
 * @param pid Part number
 * @param n1 Node number 1
 * @param n2 Node number 2
 * @param n3 Node number 3
 * @param n4 Node number 4
 * @param n5 Node number 5
 * @param n6 Node number 6
 * @param n7 Node number 7
 * @param n8 Node number 8
 */
    constructor(Model: Model, eid: number, pid: number, n1: number, n2: number, n3: number, n4?: number, n5?: number, n6?: number, n7?: number, n8?: number);

/**
 * Creates a string containing the shell data in keyword format. Note that this contains the keyword header and the keyword cards. See also Shell.Keyword() and Shell.KeywordCards().
 */
    toString(): string;

/** Offset angle. If non zero then the _BETA option is assumed. Note: If this option is set then mcid should be 0 */
    beta: number;
/** The colour of the shell */
    colour: Colour;
/** If COMPOSITE option is set. Can be true or false */
    composite: boolean;
/** If COMPOSITE_LONG option is set. Can be true or false */
    composite_long: boolean;
/** If DOF option is set. Can be true or false */
    dof: boolean;
/** Bitwise code of Shell.EDGE_1, Shell.EDGE_2, Shell.EDGE_3 and Shell.EDGE_4 representing which edges of the shell are free edges (read only) */
    readonly edges: number;
/** Shell number. Also see the label property which is an alternative name for this. */
    eid: number;
/** true if shell exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the shell is in. */
    include: number;
/** Shell number. Also see the eid property which is an alternative name for this. */
    label: number;
/** Material coordinate system ID. If non zero then the _MCID option is assumed. Note: If this option is set then beta should be 0. */
    mcid: number;
/** The Model number that the shell is in. */
    model: number;
/** Node number 1 */
    n1: number;
/** Node number 2 */
    n2: number;
/** Node number 3 */
    n3: number;
/** Node number 4 */
    n4: number;
/** Node number 5 */
    n5: number;
/** Node number 6 */
    n6: number;
/** Node number 7 */
    n7: number;
/** Node number 8 */
    n8: number;
/** Number of integration points for composite shell */
    nip: boolean;
/** Number of nodes shell has (read only) */
    readonly nodes: number;
/** Scalar Node number 1 */
    ns1: number;
/** Scalar Node number 2 */
    ns2: number;
/** Scalar Node number 3 */
    ns3: number;
/** Scalar Node number 4 */
    ns4: number;
/** Offset distance. If non zero then the _OFFSET option is assumed */
    offset: number;
/** Part number */
    pid: number;
/** If SHL4_TO_SHL8 option is set. Can be true or false */
    shl4_to_shl8: boolean;
/** Thickness at node 1 */
    thic1: number;
/** Thickness at node 2 */
    thic2: number;
/** Thickness at node 3 */
    thic3: number;
/** Thickness at node 4 */
    thic4: number;
/** Thickness at node 5 (if 8 noded shell) */
    thic5: number;
/** Thickness at node 6 (if 8 noded shell) */
    thic6: number;
/** Thickness at node 7 (if 8 noded shell) */
    thic7: number;
/** Thickness at node 8 (if 8 noded shell) */
    thic8: number;
/** If _THICKNESS option is set. Can be true or false */
    thickness: boolean;
/** The transparency of the shell (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Edge 1 of shell */
    static EDGE_1: number;
/** Edge 2 of shell */
    static EDGE_2: number;
/** Edge 3 of shell */
    static EDGE_3: number;
/** Edge 4 of shell */
    static EDGE_4: number;
}

declare class ShellReferenceGeometry {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the airbag shell reference geometry.
 * @param flag Flag to clear on the airbag shell reference geometry
 */
    ClearFlag(flag: number): void;

/**
 * Copies the airbag shell reference geometry.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): ShellReferenceGeometry;

/**
 * Starts an interactive editing panel to create an asrg.
 * @param Model Model that the asrg will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): ShellReferenceGeometry;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for airbag shell reference geometry. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first airbag shell reference geometry in the model.
 * @param Model Model to get first airbag shell reference geometry in
 */
    static First(Model: Model): ShellReferenceGeometry;

/**
 * Returns the first free airbag shell reference geometry label in the model. Also see ShellReferenceGeometry.LastFreeLabel(), ShellReferenceGeometry.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free airbag shell reference geometry label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the airbag shell reference geometrys in the model with a defined flag.
 * @param Model Model that all airbag shell reference geometrys will be flagged in
 * @param flag Flag to set on the airbag shell reference geometrys
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the airbag shell reference geometry is flagged or not.
 * @param flag Flag to test on the airbag shell reference geometry
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each airbag shell reference geometry in the model. Note that ForEach has been designed to make looping over airbag shell reference geometrys as fast as possible and so has some limitations. Firstly, a single temporary ShellReferenceGeometry object is created and on each function call it is updated with the current airbag shell reference geometry data. This means that you should not try to store the ShellReferenceGeometry object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new airbag shell reference geometrys inside a ForEach loop. 
 * @param Model Model that all airbag shell reference geometrys are in
 * @param func Function to call for each airbag shell reference geometry
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of ShellReferenceGeometry objects for all of the airbag shell reference geometrys in a model in Primer
 * @param Model Model to get airbag shell reference geometrys from
 */
    static GetAll(Model: Model): ShellReferenceGeometry[];

/**
 * Returns an array of ShellReferenceGeometry objects for all of the flagged airbag shell reference geometrys in a model in Primer
 * @param Model Model to get airbag shell reference geometrys from
 * @param flag Flag set on the airbag shell reference geometrys that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): ShellReferenceGeometry[];

/**
 * Returns the ShellReferenceGeometry object for a airbag shell reference geometry ID.
 * @param Model Model to find the airbag shell reference geometry in
 * @param number number of the airbag shell reference geometry you want the ShellReferenceGeometry object for
 */
    static GetFromID(Model: Model, number: number): ShellReferenceGeometry;

/**
 * Checks if a ShellReferenceGeometry property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the ShellReferenceGeometry.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop airbag shell reference geometry property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the shell reference geometry nodes and pid for the shell
 * @param eid Shell element ID
 */
    GetShell(eid: number): number[];

/**
 * Returns the keyword for this shell_reference_geometry (*AIRBAG_SHELL_REFERENCE_GEOMETRY). Note that a carriage return is not added. See also ShellReferenceGeometry.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the shell_reference_geometry. Note that a carriage return is not added. See also ShellReferenceGeometry.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last airbag shell reference geometry in the model.
 * @param Model Model to get last airbag shell reference geometry in
 */
    static Last(Model: Model): ShellReferenceGeometry;

/**
 * Returns the last free airbag shell reference geometry label in the model. Also see ShellReferenceGeometry.FirstFreeLabel(), ShellReferenceGeometry.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free airbag shell reference geometry label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next airbag shell reference geometry in the model.
 */
    Next(): ShellReferenceGeometry;

/**
 * Returns the next free (highest+1) airbag shell reference geometry label in the model. Also see ShellReferenceGeometry.FirstFreeLabel(), ShellReferenceGeometry.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free airbag shell reference geometry label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a airbag shell reference geometry.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only airbag shell reference geometrys from that model can be picked. If the argument is a Flag then only airbag shell reference geometrys that are flagged with limit can be selected. If omitted, or null, any airbag shell reference geometrys from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): ShellReferenceGeometry;

/**
 * Returns the previous airbag shell reference geometry in the model.
 */
    Previous(): ShellReferenceGeometry;

/**
 * Removes a shell from the shell reference geometry if it is on it
 * @param eid Element ID
 */
    RemoveShell(eid: number): void;

/**
 * Renumbers all of the airbag shell reference geometrys in the model.
 * @param Model Model that all airbag shell reference geometrys will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged airbag shell reference geometrys in the model.
 * @param Model Model that all the flagged airbag shell reference geometrys will be renumbered in
 * @param flag Flag set on the airbag shell reference geometrys that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select airbag shell reference geometrys using standard PRIMER object menus.
 * @param flag Flag to use when selecting airbag shell reference geometrys
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only airbag shell reference geometrys from that model can be selected. If the argument is a Flag then only airbag shell reference geometrys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any airbag shell reference geometrys can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the airbag shell reference geometry.
 * @param flag Flag to set on the airbag shell reference geometry
 */
    SetFlag(flag: number): void;

/**
 * Adds a shell to the shell reference geometry if not already there, otherwise just changes the reference nodes
 * @param eid Element ID
 * @param n1 Nodal point 1
 * @param n2 Nodal point 2
 * @param n3 Nodal point 3
 * @param n4 Nodal point 4
 * @param pid Part ID (ignored by LS-DYNA). If omitted pid will be zero.
 */
    SetShell(eid: number, n1: number, n2: number, n3: number, n4: number, pid?: number): void;

/**
 * Sketches the airbag shell reference geometry. The airbag shell reference geometry will be sketched until you either call ShellReferenceGeometry.Unsketch(), ShellReferenceGeometry.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the airbag shell reference geometry is sketched. If omitted redraw is true. If you want to sketch several airbag shell reference geometrys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged airbag shell reference geometrys in the model. The airbag shell reference geometrys will be sketched until you either call ShellReferenceGeometry.Unsketch(), ShellReferenceGeometry.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged airbag shell reference geometrys will be sketched in
 * @param flag Flag set on the airbag shell reference geometrys that you want to sketch
 * @param redraw If model should be redrawn or not after the airbag shell reference geometrys are sketched. If omitted redraw is true. If you want to sketch flagged airbag shell reference geometrys several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Spools a shell reference geometry, entry by entry. See also ShellReferenceGeometry.StartSpool
 */
    Spool(): number[];

/**
 * Starts a shell reference geometry spooling operation. See also ShellReferenceGeometry.Spool
 */
    StartSpool(): void;

/**
 * Returns the total number of airbag shell reference geometrys in the model.
 * @param Model Model to get total for
 * @param exists true if only existing airbag shell reference geometrys should be counted. If false or omitted referenced but undefined airbag shell reference geometrys will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the airbag shell reference geometrys in the model.
 * @param Model Model that the defined flag for all airbag shell reference geometrys will be unset in
 * @param flag Flag to unset on the airbag shell reference geometrys
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the airbag shell reference geometry.
 * @param redraw If model should be redrawn or not after the airbag shell reference geometry is unsketched. If omitted redraw is true. If you want to unsketch several airbag shell reference geometrys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all airbag shell reference geometrys.
 * @param Model Model that all airbag shell reference geometrys will be unblanked in
 * @param redraw If model should be redrawn or not after the airbag shell reference geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged airbag shell reference geometrys in the model.
 * @param Model Model that all airbag shell reference geometrys will be unsketched in
 * @param flag Flag set on the airbag shell reference geometrys that you want to unsketch
 * @param redraw If model should be redrawn or not after the airbag shell reference geometrys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): ShellReferenceGeometry;

/**
 * Adds a warning for airbag shell reference geometry. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this airbag shell reference geometry.
 */
    Xrefs(): Xrefs;

/**
 * Create a new ShellReferenceGeometry object.
 * @param Model Model that ShellReferenceGeometry will be created in
 * @param aid ShellReferenceGeometry number to set _ID suffix
 */
    constructor(Model: Model, aid?: number);

/**
 * Creates a string containing the ShellReferenceGeometry data in keyword format. Note that this contains the keyword header and the keyword cards. See also ShellReferenceGeometry.Keyword() and ShellReferenceGeometry.KeywordCards().
 */
    toString(): string;

/** ShellReferenceGeometry number. Also see the label property which is an alternative name for this. */
    aid: number;
/** true if airbag shell reference geometry exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Turns _ID on or OFF */
    id: boolean;
/** The Include file number that the airbag shell reference geometry is in. */
    include: number;
/** ShellReferenceGeometry number. Also see the label property which is an alternative name for this. */
    label: number;
/** The Model number that the airbag shell reference geometry is in. */
    model: number;
/** Node number for origin */
    nid: number;
/** Turns _RDT on or OFF */
    rdt: boolean;
/** Scale factor in X direction */
    sx: number;
/** Scale factor in Y direction */
    sy: number;
/** Scale factor in Z direction */
    sz: number;
}

declare class Slipring {
/**
 * Blanks the slipring
 */
    Blank(): void;

/**
 * Blanks all of the sliprings in the model.
 * @param Model Model that all sliprings will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged sliprings in the model.
 * @param Model Model that all the flagged sliprings will be blanked in
 * @param flag Flag set on the sliprings that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the slipring is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the slipring.
 * @param flag Flag to clear on the slipring
 */
    ClearFlag(flag: number): void;

/**
 * Copies the slipring.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Slipring;

/**
 * Starts an interactive editing panel to create a slipring.
 * @param Model Model that the slipring will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Slipring;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for slipring. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for slipring. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the slipring colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the slipring.
 */
    ExtractColour(): number;

/**
 * Returns the first slipring in the model.
 * @param Model Model to get first slipring in
 */
    static First(Model: Model): Slipring;

/**
 * Returns the first free slipring label in the model. Also see Slipring.LastFreeLabel(), Slipring.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free slipring label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the sliprings in the model with a defined flag.
 * @param Model Model that all sliprings will be flagged in
 * @param flag Flag to set on the sliprings
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the slipring is flagged or not.
 * @param flag Flag to test on the slipring
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each slipring in the model. Note that ForEach has been designed to make looping over sliprings as fast as possible and so has some limitations. Firstly, a single temporary Slipring object is created and on each function call it is updated with the current slipring data. This means that you should not try to store the Slipring object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new sliprings inside a ForEach loop. 
 * @param Model Model that all sliprings are in
 * @param func Function to call for each slipring
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Slipring objects for all of the sliprings in a model in Primer
 * @param Model Model to get sliprings from
 */
    static GetAll(Model: Model): Slipring[];

/**
 * Returns an array of Slipring objects for all of the flagged sliprings in a model in Primer
 * @param Model Model to get sliprings from
 * @param flag Flag set on the sliprings that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Slipring[];

/**
 * Returns the Slipring object for a slipring ID.
 * @param Model Model to find the slipring in
 * @param number number of the slipring you want the Slipring object for
 */
    static GetFromID(Model: Model, number: number): Slipring;

/**
 * Checks if a Slipring property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Slipring.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop slipring property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this slipring (*ELEMENT_SEATBELT_SLIPEROMETER) Note that a carriage return is not added. See also Slipring.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the slipring. Note that a carriage return is not added. See also Slipring.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last slipring in the model.
 * @param Model Model to get last slipring in
 */
    static Last(Model: Model): Slipring;

/**
 * Returns the last free slipring label in the model. Also see Slipring.FirstFreeLabel(), Slipring.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free slipring label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next slipring in the model.
 */
    Next(): Slipring;

/**
 * Returns the next free (highest+1) slipring label in the model. Also see Slipring.FirstFreeLabel(), Slipring.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free slipring label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a slipring.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sliprings from that model can be picked. If the argument is a Flag then only sliprings that are flagged with limit can be selected. If omitted, or null, any sliprings from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Slipring;

/**
 * Returns the previous slipring in the model.
 */
    Previous(): Slipring;

/**
 * Renumbers all of the sliprings in the model.
 * @param Model Model that all sliprings will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged sliprings in the model.
 * @param Model Model that all the flagged sliprings will be renumbered in
 * @param flag Flag set on the sliprings that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select sliprings using standard PRIMER object menus.
 * @param flag Flag to use when selecting sliprings
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sliprings from that model can be selected. If the argument is a Flag then only sliprings that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sliprings can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the slipring.
 * @param flag Flag to set on the slipring
 */
    SetFlag(flag: number): void;

/**
 * Sketches the slipring. The slipring will be sketched until you either call Slipring.Unsketch(), Slipring.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the slipring is sketched. If omitted redraw is true. If you want to sketch several sliprings and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged sliprings in the model. The sliprings will be sketched until you either call Slipring.Unsketch(), Slipring.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged sliprings will be sketched in
 * @param flag Flag set on the sliprings that you want to sketch
 * @param redraw If model should be redrawn or not after the sliprings are sketched. If omitted redraw is true. If you want to sketch flagged sliprings several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of sliprings in the model.
 * @param Model Model to get total for
 * @param exists true if only existing sliprings should be counted. If false or omitted referenced but undefined sliprings will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the slipring
 */
    Unblank(): void;

/**
 * Unblanks all of the sliprings in the model.
 * @param Model Model that all sliprings will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged sliprings in the model.
 * @param Model Model that the flagged sliprings will be unblanked in
 * @param flag Flag set on the sliprings that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the sliprings in the model.
 * @param Model Model that the defined flag for all sliprings will be unset in
 * @param flag Flag to unset on the sliprings
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the slipring.
 * @param redraw If model should be redrawn or not after the slipring is unsketched. If omitted redraw is true. If you want to unsketch several sliprings and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all sliprings.
 * @param Model Model that all sliprings will be unblanked in
 * @param redraw If model should be redrawn or not after the sliprings are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged sliprings in the model.
 * @param Model Model that all sliprings will be unsketched in
 * @param flag Flag set on the sliprings that you want to unsketch
 * @param redraw If model should be redrawn or not after the sliprings are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Slipring;

/**
 * Adds a warning for slipring. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this slipring.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Seatbelt Slipring object.
 * @param Model Model that slipring will be created in
 * @param sbsrid Slipring number.
 * @param sbid1 Seatbelt number 1
 * @param sbid2 Seatbelt number 2
 * @param sbrnid Slipring Node number
 */
    constructor(Model: Model, sbsrid: number, sbid1: number, sbid2: number, sbrnid: number);

/**
 * Creates a string containing the slipring data in keyword format. Note that this contains the keyword header and the keyword cards. See also Slipring.Keyword() and Slipring.KeywordCards().
 */
    toString(): string;

/** The colour of the slipring */
    colour: Colour;
/** Optional decay constant to allow a smooth transition between the static and dynamic friction coefficients. */
    dc: number;
/** Direction of belt movement */
    direct: number;
/** true if slipring exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Coulomb dynamic friction coefficient */
    fc: number;
/** Coulomb static friction coefficient */
    fcs: number;
/** Function ID to determine friction coefficient */
    funcid: number;
/** The Include file number that the slipring is in. */
    include: number;
/** Optional coefficient for determining the Coulomb friction coefficient related to angle alpha */
    k: number;
/** Slipring number. Also see the sbsrid property which is an alternative name for this. */
    label: number;
/** Loadcurve for Coulomb dynamic friction */
    lcnffd: number;
/** Loadcurve for Coulomb static friction */
    lcnffs: number;
/** Slipring lockup time */
    ltime: number;
/** The Model number that the slipring is in. */
    model: number;
/** Orientation Node number */
    onid: number;
/** Seatbelt number 1 (or Set Shell number if sbrnid is negative). */
    sbid1: number;
/** Seatbelt number 2 (or Set Shell number if sbrnid is negative). */
    sbid2: number;
/** Node number (or Set Node number if negative) */
    sbrnid: number;
/** Slipring number. Also see the label property which is an alternative name for this. */
    sbsrid: number;
/** true if slipring is used for shell (2D) seatbelt elements. (read only) */
    readonly shell_seatbelt: boolean;
/** The transparency of the slipring (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
}


/** Object returned by ElemCut */
interface ElemCutReturn {
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 1. Null if no cut on this face. */
    face1: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 2. Null if no cut on this face. */
    face2: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 3. Null if no cut on this face. */
    face3: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 4. Null if no cut on this face. */
    face4: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 5. Null if no cut on this face. */
    face5: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 6. Null if no cut on this face. */
    face6: number[];
}

declare class Solid {
/**
 * Blanks the solid
 */
    Blank(): void;

/**
 * Blanks all of the solids in the model.
 * @param Model Model that all solids will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged solids in the model.
 * @param Model Model that all the flagged solids will be blanked in
 * @param flag Flag set on the solids that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the solid is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the solid.
 * @param flag Flag to clear on the solid
 */
    ClearFlag(flag: number): void;

/**
 * Calculates the isoparametric coordinates for a point on 3 or 4 noded segment
 * @param Model Model designated model
 * @param x X coordinate of point
 * @param y Y coordinate of point
 * @param z Z coordinate of point
 * @param n1 node 1 of segment
 * @param n2 node 2 of segment
 * @param n3 node 3 of segment
 * @param n4 node 4 of segment
 */
    static CoordsToIsoparametric(Model: Model, x: number, y: number, z: number, n1: number, n2: number, n3: number, n4: number): number[];

/**
 * Copies the solid.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Solid;

/**
 * Starts an interactive editing panel to create a solid.
 * @param Model Model that the solid will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Solid;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Returns coordinates of the intersections between a solid and a database cross section.
 * @param Database_cross_section_label The label of the database cross section.
 */
    ElemCut(Database_cross_section_label: number): ElemCutReturn;

/**
 * Adds an error for solid. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for solid. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the solid colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the solid.
 */
    ExtractColour(): number;

/**
 * Returns an array of Solid objects for the solids within a box. This requires a previous (outside loop) call to function FindSolidInit(m) or m.FindElemInit() where the process is initialized for flagged solids in the model (typically all solids) and m.FindElemEnd() to close the process. Please note this function provides a list of all solids that could potentially be in the box (using computationally cheap bounding box comparison) it is not a rigorous test of whether the solid is actually in the box. See also Solid.FindSolidInit() See also Model.FindElemInit() See also Model.FindElemEnd()
 * @param Model Model designated model
 * @param xmin Minimum bound in global x
 * @param xmax Maximum bound in global x
 * @param ymin Minimum bound in global y
 * @param ymax Maximum bound in global y
 * @param zmin Minimum bound in global z
 * @param zmax Maximum bound in global z
 * @param hflag Optional flag to restrict solids considered
 */
    static FindSolidInBox(Model: Model, xmin: number, xmax: number, ymin: number, ymax: number, zmin: number, zmax: number, hflag?: number): Solid[];

/**
 * Initialize setup so that all flagged solids in model can be tested to see if they are within box. See also Solid.FindSolidInBox() See also Model.FindElemInit() See also Model.FindElemEnd()
 * @param Model Model in which solids have been flagged
 * @param flag Optional flag that has been set on the solids, if unsupplied all solids considered
 */
    static FindSolidInit(Model: Model, flag?: number): void;

/**
 * Returns the first solid in the model.
 * @param Model Model to get first solid in
 */
    static First(Model: Model): Solid;

/**
 * Returns the first free solid label in the model. Also see Solid.LastFreeLabel(), Solid.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free solid label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the solids in the model with a defined flag.
 * @param Model Model that all solids will be flagged in
 * @param flag Flag to set on the solids
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the solid is flagged or not.
 * @param flag Flag to test on the solid
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each solid in the model. Note that ForEach has been designed to make looping over solids as fast as possible and so has some limitations. Firstly, a single temporary Solid object is created and on each function call it is updated with the current solid data. This means that you should not try to store the Solid object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new solids inside a ForEach loop. 
 * @param Model Model that all solids are in
 * @param func Function to call for each solid
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Solid objects for all of the solids in a model in Primer
 * @param Model Model to get solids from
 */
    static GetAll(Model: Model): Solid[];

/**
 * Returns an array of Solid objects for all of the flagged solids in a model in Primer
 * @param Model Model to get solids from
 * @param flag Flag set on the solids that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Solid[];

/**
 * Returns the Solid object for a solid ID.
 * @param Model Model to find the solid in
 * @param number number of the solid you want the Solid object for
 */
    static GetFromID(Model: Model, number: number): Solid;

/**
 * Checks if a Solid property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Solid.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop solid property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this solid (*SOLID, *SOLID_SCALAR or *SOLID_SCALAR_VALUE). Note that a carriage return is not added. See also Solid.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the solid. Note that a carriage return is not added. See also Solid.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last solid in the model.
 * @param Model Model to get last solid in
 */
    static Last(Model: Model): Solid;

/**
 * Returns the last free solid label in the model. Also see Solid.FirstFreeLabel(), Solid.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free solid label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next solid in the model.
 */
    Next(): Solid;

/**
 * Returns the next free (highest+1) solid label in the model. Also see Solid.FirstFreeLabel(), Solid.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free solid label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a solid.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only solids from that model can be picked. If the argument is a Flag then only solids that are flagged with limit can be selected. If omitted, or null, any solids from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Solid;

/**
 * Returns the previous solid in the model.
 */
    Previous(): Solid;

/**
 * Renumbers all of the solids in the model.
 * @param Model Model that all solids will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged solids in the model.
 * @param Model Model that all the flagged solids will be renumbered in
 * @param flag Flag set on the solids that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select solids using standard PRIMER object menus.
 * @param flag Flag to use when selecting solids
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only solids from that model can be selected. If the argument is a Flag then only solids that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any solids can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the solid.
 * @param flag Flag to set on the solid
 */
    SetFlag(flag: number): void;

/**
 * Sketches the solid. The solid will be sketched until you either call Solid.Unsketch(), Solid.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the solid is sketched. If omitted redraw is true. If you want to sketch several solids and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged solids in the model. The solids will be sketched until you either call Solid.Unsketch(), Solid.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged solids will be sketched in
 * @param flag Flag set on the solids that you want to sketch
 * @param redraw If model should be redrawn or not after the solids are sketched. If omitted redraw is true. If you want to sketch flagged solids several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Calculates the tetrahedral collapse for the solid
 */
    TetCollapse(): number;

/**
 * Checks if nodes of solid are tied by contact or directly attached (non-zero option1).
 * @param Contact_label The label of the tied contact. If zero the tied contact is found for the solid by reverse lookup.
 * @param Flag flag bit
 * @param Option1 Directly tied node (logical OR) 0:NONE 1:NRB/C_EXNO 2:BEAM 4:SHELL 8:SOLID 16:TSHELL
 * @param Option2 0:No action 1:report error if directly attached node (acc. option1) also captured by contact
 */
    TiedNodeCheck(Contact_label: number, Flag: number, Option1: number, Option2: number): string;

/**
 * Calculates the timestep for the solid
 */
    Timestep(): number;

/**
 * Returns the total number of solids in the model.
 * @param Model Model to get total for
 * @param exists true if only existing solids should be counted. If false or omitted referenced but undefined solids will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the solid
 */
    Unblank(): void;

/**
 * Unblanks all of the solids in the model.
 * @param Model Model that all solids will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged solids in the model.
 * @param Model Model that the flagged solids will be unblanked in
 * @param flag Flag set on the solids that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the solids in the model.
 * @param Model Model that the defined flag for all solids will be unset in
 * @param flag Flag to unset on the solids
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the solid.
 * @param redraw If model should be redrawn or not after the solid is unsketched. If omitted redraw is true. If you want to unsketch several solids and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all solids.
 * @param Model Model that all solids will be unblanked in
 * @param redraw If model should be redrawn or not after the solids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged solids in the model.
 * @param Model Model that all solids will be unsketched in
 * @param flag Flag set on the solids that you want to unsketch
 * @param redraw If model should be redrawn or not after the solids are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Solid;

/**
 * Calculates the volume for the solid
 */
    Volume(): number;

/**
 * Adds a warning for solid. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this solid.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Solid object. Use either 4, 6, 8 or 10 nodes when creating a new solid. If you are creating a 4 noded solid either only give 4 nodes or give 8 nodes but make nodes 4 to 8 the same number. If you are creating a 6 noded solid either only give 6 nodes or give 8 nodes but make nodes 5 and 6 the same number and nodes 7 and 8 the same number.
 * @param Model Model that solid will be created in
 * @param eid Solid number
 * @param pid Part number
 * @param n1 Node number 1
 * @param n2 Node number 2
 * @param n3 Node number 3
 * @param n4 Node number 4
 * @param n5 Node number 5
 * @param n6 Node number 6
 * @param n7 Node number 7
 * @param n8 Node number 8
 * @param n9 Node number 9
 * @param n10 Node number 10
 * @param n11 Node number 11
 * @param n12 Node number 12
 * @param n13 Node number 13
 * @param n14 Node number 14
 * @param n15 Node number 15
 * @param n16 Node number 16
 * @param n17 Node number 17
 * @param n18 Node number 18
 * @param n19 Node number 19
 * @param n20 Node number 20
 * @param n21 Node number 21
 * @param n22 Node number 22
 * @param n23 Node number 23
 * @param n24 Node number 24
 * @param n25 Node number 25
 * @param n26 Node number 26
 * @param n27 Node number 27
 */
    constructor(Model: Model, eid: number, pid: number, n1: number, n2: number, n3: number, n4: number, n5?: number, n6?: number, n7?: number, n8?: number, n9?: number, n10?: number, n11?: number, n12?: number, n13?: number, n14?: number, n15?: number, n16?: number, n17?: number, n18?: number, n19?: number, n20?: number, n21?: number, n22?: number, n23?: number, n24?: number, n25?: number, n26?: number, n27?: number);

/**
 * Creates a string containing the solid data in keyword format. Note that this contains the keyword header and the keyword cards. See also Solid.Keyword() and Solid.KeywordCards().
 */
    toString(): string;

/** x component of material direction a */
    a1: number;
/** y component of material direction a */
    a2: number;
/** z component of material direction a */
    a3: number;
/** The colour of the solid */
    colour: Colour;
/** x component of material in-plane vector */
    d1: number;
/** y component of material in-plane vector */
    d2: number;
/** z component of material in-plane vector */
    d3: number;
/** If DOF option is set. Can be true or false */
    dof: boolean;
/** Bitwise code of Solid.EDGE_1, Solid.EDGE_2, Solid.EDGE_3, Solid.EDGE_4, Solid.EDGE_5, Solid.EDGE_6, Solid.EDGE_7, Solid.EDGE_8, Solid.EDGE_9, Solid.EDGE_10, Solid.EDGE_11 and Solid.EDGE_12 representing which edges of the solid are free faces (read only) */
    readonly edges: number;
/** Solid number. Also see the label property which is an alternative name for this. */
    eid: number;
/** true if solid exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Bitwise code of Solid.FACE_1, Solid.FACE_2, Solid.FACE_3, Solid.FACE_4, Solid.FACE_5 and Solid.FACE_6 representing which faces of the solid are internal faces (read only). Note that this is calculated from the solids that are currently visible so blanking solids will affect this property once graphics have been updated. */
    readonly faces: number;
/** If _H20 option is set. Can be true or false */
    h20: boolean;
/** If _H27 option is set. Can be true or false */
    h27: boolean;
/** If _H64 option is set. Can be true or false */
    h64: boolean;
/** If _H8TOH20 option is set. Can be true or false */
    h8toh20: boolean;
/** If _H8TOH27 option is set. Can be true or false */
    h8toh27: boolean;
/** If _H8TOH64 option is set. Can be true or false */
    h8toh64: boolean;
/** The Include file number that the solid is in. */
    include: number;
/** Solid number. Also see the eid property which is an alternative name for this. */
    label: number;
/** The Model number that the solid is in. */
    model: number;
/** Node number 1 */
    n1: number;
/** Node number 10 */
    n10: number;
/** Node number 11 */
    n11: number;
/** Node number 12 */
    n12: number;
/** Node number 13 */
    n13: number;
/** Node number 14 */
    n14: number;
/** Node number 15 */
    n15: number;
/** Node number 16 */
    n16: number;
/** Node number 17 */
    n17: number;
/** Node number 18 */
    n18: number;
/** Node number 19 */
    n19: number;
/** Node number 2 */
    n2: number;
/** Node number 20 */
    n20: number;
/** Node number 21 */
    n21: number;
/** Node number 22 */
    n22: number;
/** Node number 23 */
    n23: number;
/** Node number 24 */
    n24: number;
/** Node number 25 */
    n25: number;
/** Node number 26 */
    n26: number;
/** Node number 27 */
    n27: number;
/** Node number 28 */
    n28: number;
/** Node number 29 */
    n29: number;
/** Node number 3 */
    n3: number;
/** Node number 30 */
    n30: number;
/** Node number 31 */
    n31: number;
/** Node number 32 */
    n32: number;
/** Node number 33 */
    n33: number;
/** Node number 34 */
    n34: number;
/** Node number 35 */
    n35: number;
/** Node number 36 */
    n36: number;
/** Node number 37 */
    n37: number;
/** Node number 38 */
    n38: number;
/** Node number 39 */
    n39: number;
/** Node number 4 */
    n4: number;
/** Node number 40 */
    n40: number;
/** Node number 41 */
    n41: number;
/** Node number 42 */
    n42: number;
/** Node number 43 */
    n43: number;
/** Node number 44 */
    n44: number;
/** Node number 45 */
    n45: number;
/** Node number 46 */
    n46: number;
/** Node number 47 */
    n47: number;
/** Node number 48 */
    n48: number;
/** Node number 49 */
    n49: number;
/** Node number 5 */
    n5: number;
/** Node number 50 */
    n50: number;
/** Node number 51 */
    n51: number;
/** Node number 52 */
    n52: number;
/** Node number 53 */
    n53: number;
/** Node number 54 */
    n54: number;
/** Node number 55 */
    n55: number;
/** Node number 56 */
    n56: number;
/** Node number 57 */
    n57: number;
/** Node number 58 */
    n58: number;
/** Node number 59 */
    n59: number;
/** Node number 6 */
    n6: number;
/** Node number 60 */
    n60: number;
/** Node number 61 */
    n61: number;
/** Node number 62 */
    n62: number;
/** Node number 63 */
    n63: number;
/** Node number 64 */
    n64: number;
/** Node number 7 */
    n7: number;
/** Node number 8 */
    n8: number;
/** Node number 9 */
    n9: number;
/** Number of nodes solid has (read only) */
    readonly nodes: number;
/** Scalar Node number 1 */
    ns1: number;
/** Scalar Node number 2 */
    ns2: number;
/** Scalar Node number 3 */
    ns3: number;
/** Scalar Node number 4 */
    ns4: number;
/** Scalar Node number 5 */
    ns5: number;
/** Scalar Node number 6 */
    ns6: number;
/** Scalar Node number 7 */
    ns7: number;
/** Scalar Node number 8 */
    ns8: number;
/** If _ORTHO option is set. Can be true or false */
    ortho: boolean;
/** If _P21 option is set. Can be true or false */
    p21: boolean;
/** If _P40 option is set. Can be true or false */
    p40: boolean;
/** Part number */
    pid: number;
/** If _T15 option is set. Can be true or false */
    t15: boolean;
/** If _T20 option is set. Can be true or false */
    t20: boolean;
/** If _TET4TOTET10 option is set. Can be true or false */
    tet4totet10: boolean;
/** The transparency of the solid (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
/** Edge 1 of solid */
    static EDGE_1: number;
/** Edge 10 of solid */
    static EDGE_10: number;
/** Edge 11 of solid */
    static EDGE_11: number;
/** Edge 12 of solid */
    static EDGE_12: number;
/** Edge 2 of solid */
    static EDGE_2: number;
/** Edge 3 of solid */
    static EDGE_3: number;
/** Edge 4 of solid */
    static EDGE_4: number;
/** Edge 5 of solid */
    static EDGE_5: number;
/** Edge 6 of solid */
    static EDGE_6: number;
/** Edge 7 of solid */
    static EDGE_7: number;
/** Edge 8 of solid */
    static EDGE_8: number;
/** Edge 9 of solid */
    static EDGE_9: number;
/** Face 1 of solid */
    static FACE_1: number;
/** Face 2 of solid */
    static FACE_2: number;
/** Face 3 of solid */
    static FACE_3: number;
/** Face 4 of solid */
    static FACE_4: number;
/** Face 5 of solid */
    static FACE_5: number;
/** Face 6 of solid */
    static FACE_6: number;
}

declare class Spc {
/**
 * Blanks the boundary SPC
 */
    Blank(): void;

/**
 * Blanks all of the boundary SPCs in the model.
 * @param Model Model that all boundary SPCs will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged boundary SPCs in the model.
 * @param Model Model that all the flagged boundary SPCs will be blanked in
 * @param flag Flag set on the boundary SPCs that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the boundary SPC is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the boundary SPC.
 * @param flag Flag to clear on the boundary SPC
 */
    ClearFlag(flag: number): void;

/**
 * Copies the boundary SPC.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Spc;

/**
 * Adds an error for boundary SPC. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first boundary SPC in the model.
 * @param Model Model to get first boundary SPC in
 */
    static First(Model: Model): Spc;

/**
 * Returns the first free boundary SPC label in the model. Also see Spc.LastFreeLabel(), Spc.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free boundary SPC label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the boundary SPCs in the model with a defined flag.
 * @param Model Model that all boundary SPCs will be flagged in
 * @param flag Flag to set on the boundary SPCs
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the boundary SPC is flagged or not.
 * @param flag Flag to test on the boundary SPC
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each boundary SPC in the model. Note that ForEach has been designed to make looping over boundary SPCs as fast as possible and so has some limitations. Firstly, a single temporary Spc object is created and on each function call it is updated with the current boundary SPC data. This means that you should not try to store the Spc object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new boundary SPCs inside a ForEach loop. 
 * @param Model Model that all boundary SPCs are in
 * @param func Function to call for each boundary SPC
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Spc objects for all of the boundary SPCs in a model in Primer
 * @param Model Model to get boundary SPCs from
 */
    static GetAll(Model: Model): Spc[];

/**
 * Returns an array of Spc objects for all of the flagged boundary SPCs in a model in Primer
 * @param Model Model to get boundary SPCs from
 * @param flag Flag set on the boundary SPCs that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Spc[];

/**
 * Returns the Spc object for a boundary SPC ID.
 * @param Model Model to find the boundary SPC in
 * @param number number of the boundary SPC you want the Spc object for
 */
    static GetFromID(Model: Model, number: number): Spc;

/**
 * Checks if a Spc property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Spc.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop boundary SPC property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this spc (*BOUNDARY_SPC_xxxx). Note that a carriage return is not added. See also Spc.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the spc. Note that a carriage return is not added. See also Spc.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last boundary SPC in the model.
 * @param Model Model to get last boundary SPC in
 */
    static Last(Model: Model): Spc;

/**
 * Returns the last free boundary SPC label in the model. Also see Spc.FirstFreeLabel(), Spc.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free boundary SPC label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next boundary SPC in the model.
 */
    Next(): Spc;

/**
 * Returns the next free (highest+1) boundary SPC label in the model. Also see Spc.FirstFreeLabel(), Spc.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free boundary SPC label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a boundary SPC.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boundary SPCs from that model can be picked. If the argument is a Flag then only boundary SPCs that are flagged with limit can be selected. If omitted, or null, any boundary SPCs from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Spc;

/**
 * Returns the previous boundary SPC in the model.
 */
    Previous(): Spc;

/**
 * Renumbers all of the boundary SPCs in the model.
 * @param Model Model that all boundary SPCs will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged boundary SPCs in the model.
 * @param Model Model that all the flagged boundary SPCs will be renumbered in
 * @param flag Flag set on the boundary SPCs that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select boundary SPCs using standard PRIMER object menus.
 * @param flag Flag to use when selecting boundary SPCs
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only boundary SPCs from that model can be selected. If the argument is a Flag then only boundary SPCs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any boundary SPCs can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the boundary SPC.
 * @param flag Flag to set on the boundary SPC
 */
    SetFlag(flag: number): void;

/**
 * Sketches the Boundary SPC. The SPC will be sketched until you do a graphics update or delete the model
 * @param type Type of constraints to be drawn. Can be Spc.TRANSLATIONAL or Spc.ROTATIONAL.
 * @param redraw If set to true (or omitted) the plot will be redrawn each time. If sketching a large number of items, efficiency will be gained by setting the argument to false for all but the last item sketched. The final call will redraw.
 */
    Sketch(type: number, redraw?: boolean): void;

/**
 * Sketches all the flagged boundary SPCs in the model and update the plot. The SPCs will be sketched until you do a graphics update or delete the model.
 * @param type Type of constraints to be drawn. Can be Spc.TRANSLATIONAL or Spc.ROTATIONAL.
 * @param Model Model that all the flagged boundary SPCs will be sketched in
 * @param flag Flag set on the boundary SPCs that you want to sketch
 */
    static SketchFlagged(type: number, Model: Model, flag: number): void;

/**
 * Returns the total number of boundary SPCs in the model.
 * @param Model Model to get total for
 * @param exists true if only existing boundary SPCs should be counted. If false or omitted referenced but undefined boundary SPCs will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the boundary SPC
 */
    Unblank(): void;

/**
 * Unblanks all of the boundary SPCs in the model.
 * @param Model Model that all boundary SPCs will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged boundary SPCs in the model.
 * @param Model Model that the flagged boundary SPCs will be unblanked in
 * @param flag Flag set on the boundary SPCs that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the boundary SPCs in the model.
 * @param Model Model that the defined flag for all boundary SPCs will be unset in
 * @param flag Flag to unset on the boundary SPCs
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the Spc.
 * @param redraw If set to true (or omitted) the plot will be redrawn each time. If unsketching a large number of items, efficiency will be gained by setting the argument to false for all but the last item unsketched. The final call will redraw.
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all SPCs.
 * @param Model Model that all SPCs will be unblanked in
 */
    static UnsketchAll(Model: Model): void;

/**
 * Unsketches all flagged SPCs.
 * @param Model Model that all SPCs will be unsketched in
 * @param flag Flag set on the SPCs that you want to unsketch
 */
    static UnsketchFlagged(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Spc;

/**
 * Adds a warning for boundary SPC. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this boundary SPC.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Spc object.
 * @param Model Model that spc will be created in
 * @param nid Node ID or node set ID
 * @param cid Coordinate system ID
 * @param dofx Translational constraint in local x direction
 * @param dofy Translational constraint in local y direction
 * @param dofz Translational constraint in local z direction
 * @param dofrx Rotational constraint in local x direction
 * @param dofry Rotational constraint in local y direction
 * @param dofrz Rotational constraint in local z direction
 * @param type Specify the type of boundary spc (Can be Spc.NODE or Spc.SET)
 * @param label Spc number
 * @param heading Title for the spc
 */
    constructor(Model: Model, nid: number, cid: number, dofx: number, dofy: number, dofz: number, dofrx: number, dofry: number, dofrz: number, type: number, label?: number, heading?: string);

/**
 * Creates a string containing the spc data in keyword format. Note that this contains the keyword header and the keyword cards. See also Spc.Keyword() and Spc.KeywordCards().
 */
    toString(): string;

/** true if _BIRTH_DEATH option is set, false if not */
    bd_flag: boolean;
/** Activation time for constraint */
    birth: number;
/** Coordinate system ID */
    cid: number;
/** Deactivation time for constraint */
    death: number;
/** Rotational constraint in local x direction */
    dofrx: number;
/** Rotational constraint in local y direction */
    dofry: number;
/** Rotational constraint in local z direction */
    dofrz: number;
/** Translational constraint in local x direction */
    dofx: number;
/** Translational constraint in local y direction */
    dofy: number;
/** Translational constraint in local z direction */
    dofz: number;
/** true if spc exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Spc heading */
    heading: string;
/** true if _ID option is set, false if not. */
    id: boolean;
/** The Include file number that the spc is in. */
    include: number;
/** Spc number. */
    label: number;
/** The Model number that the boundary SPC is in. */
    model: number;
/** Node ID or node set ID */
    nid: number;
/** The Spc type. Can be Spc.NODE or Spc.SET. */
    type: number;
/** SPC is *BOUNDARY_SPC_NODE. */
    static NODE: number;
/** Sketch rotational degrees of freedom. */
    static ROTATIONAL: number;
/** SPC is *BOUNDARY_SPC_SET. */
    static SET: number;
/** Sketch translational degrees of freedom. */
    static TRANSLATIONAL: number;
}

declare class Sph {
/**
 * Blanks the sph
 */
    Blank(): void;

/**
 * Blanks all of the sphs in the model.
 * @param Model Model that all sphs will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged sphs in the model.
 * @param Model Model that all the flagged sphs will be blanked in
 * @param flag Flag set on the sphs that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the sph is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the sph.
 * @param flag Flag to clear on the sph
 */
    ClearFlag(flag: number): void;

/**
 * Copies the sph.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Sph;

/**
 * Starts an interactive editing panel to create an sph.
 * @param Model Model that the sph will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Sph;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for sph. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for sph. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the sph colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the sph.
 */
    ExtractColour(): number;

/**
 * Returns the first sph in the model.
 * @param Model Model to get first sph in
 */
    static First(Model: Model): Sph;

/**
 * Returns the first free sph label in the model. Also see Sph.LastFreeLabel(), Sph.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free sph label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the sphs in the model with a defined flag.
 * @param Model Model that all sphs will be flagged in
 * @param flag Flag to set on the sphs
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the sph is flagged or not.
 * @param flag Flag to test on the sph
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each sph in the model. Note that ForEach has been designed to make looping over sphs as fast as possible and so has some limitations. Firstly, a single temporary Sph object is created and on each function call it is updated with the current sph data. This means that you should not try to store the Sph object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new sphs inside a ForEach loop. 
 * @param Model Model that all sphs are in
 * @param func Function to call for each sph
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Sph objects for all of the sphs in a model in Primer
 * @param Model Model to get sphs from
 */
    static GetAll(Model: Model): Sph[];

/**
 * Returns an array of Sph objects for all of the flagged sphs in a model in Primer
 * @param Model Model to get sphs from
 * @param flag Flag set on the sphs that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Sph[];

/**
 * Returns the Sph object for a sph ID.
 * @param Model Model to find the sph in
 * @param number number of the sph you want the Sph object for
 */
    static GetFromID(Model: Model, number: number): Sph;

/**
 * Checks if a Sph property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Sph.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop sph property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this sph (*ELEMENT_SPH) Note that a carriage return is not added. See also Sph.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the sph. Note that a carriage return is not added. See also Sph.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last sph in the model.
 * @param Model Model to get last sph in
 */
    static Last(Model: Model): Sph;

/**
 * Returns the last free sph label in the model. Also see Sph.FirstFreeLabel(), Sph.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free sph label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next sph in the model.
 */
    Next(): Sph;

/**
 * Returns the next free (highest+1) sph label in the model. Also see Sph.FirstFreeLabel(), Sph.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free sph label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a sph.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sphs from that model can be picked. If the argument is a Flag then only sphs that are flagged with limit can be selected. If omitted, or null, any sphs from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Sph;

/**
 * Returns the previous sph in the model.
 */
    Previous(): Sph;

/**
 * Renumbers all of the sphs in the model.
 * @param Model Model that all sphs will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged sphs in the model.
 * @param Model Model that all the flagged sphs will be renumbered in
 * @param flag Flag set on the sphs that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select sphs using standard PRIMER object menus.
 * @param flag Flag to use when selecting sphs
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only sphs from that model can be selected. If the argument is a Flag then only sphs that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any sphs can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the sph.
 * @param flag Flag to set on the sph
 */
    SetFlag(flag: number): void;

/**
 * Sketches the sph. The sph will be sketched until you either call Sph.Unsketch(), Sph.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the sph is sketched. If omitted redraw is true. If you want to sketch several sphs and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged sphs in the model. The sphs will be sketched until you either call Sph.Unsketch(), Sph.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged sphs will be sketched in
 * @param flag Flag set on the sphs that you want to sketch
 * @param redraw If model should be redrawn or not after the sphs are sketched. If omitted redraw is true. If you want to sketch flagged sphs several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of sphs in the model.
 * @param Model Model to get total for
 * @param exists true if only existing sphs should be counted. If false or omitted referenced but undefined sphs will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the sph
 */
    Unblank(): void;

/**
 * Unblanks all of the sphs in the model.
 * @param Model Model that all sphs will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged sphs in the model.
 * @param Model Model that the flagged sphs will be unblanked in
 * @param flag Flag set on the sphs that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the sphs in the model.
 * @param Model Model that the defined flag for all sphs will be unset in
 * @param flag Flag to unset on the sphs
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the sph.
 * @param redraw If model should be redrawn or not after the sph is unsketched. If omitted redraw is true. If you want to unsketch several sphs and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all sphs.
 * @param Model Model that all sphs will be unblanked in
 * @param redraw If model should be redrawn or not after the sphs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged sphs in the model.
 * @param Model Model that all sphs will be unsketched in
 * @param flag Flag set on the sphs that you want to unsketch
 * @param redraw If model should be redrawn or not after the sphs are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Sph;

/**
 * Adds a warning for sph. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this sph.
 */
    Xrefs(): Xrefs;

/**
 * Create a new  object.
 * @param Model Model that sph will be created in
 * @param nid Node ID and Element ID are the same for the SPH option.
 * @param pid Part ID to which this element belongs.
 * @param mass Mass value.
 */
    constructor(Model: Model, nid: number, pid: number, mass: number);

/**
 * Creates a string containing the sph data in keyword format. Note that this contains the keyword header and the keyword cards. See also Sph.Keyword() and Sph.KeywordCards().
 */
    toString(): string;

/** The colour of the sph element. */
    colour: Colour;
/** true if sph exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the sph is in. */
    include: number;
/** Mass value. */
    mass: number;
/** The Model number that the sph is in. */
    model: number;
/** Node ID. */
    nid: number;
/** Part ID to which this element belongs. */
    pid: number;
/** The transparency of the sph (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
}

declare class Spotweld {
/**
 * Blanks the spotweld
 */
    Blank(): void;

/**
 * Blanks all of the spotwelds in the model.
 * @param Model Model that all spotwelds will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged spotwelds in the model.
 * @param Model Model that all the flagged spotwelds will be blanked in
 * @param flag Flag set on the spotwelds that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the spotweld is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the spotweld.
 * @param flag Flag to clear on the spotweld
 */
    ClearFlag(flag: number): void;

/**
 * Copies the spotweld.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Spotweld;

/**
 * Starts an interactive editing panel to create a spotweld.
 * @param Model Model that the spotweld will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Spotweld;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for spotweld. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first spotweld in the model.
 * @param Model Model to get first spotweld in
 */
    static First(Model: Model): Spotweld;

/**
 * Returns the first free spotweld label in the model. Also see Spotweld.LastFreeLabel(), Spotweld.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free spotweld label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the spotwelds in the model with a defined flag.
 * @param Model Model that all spotwelds will be flagged in
 * @param flag Flag to set on the spotwelds
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the spotweld is flagged or not.
 * @param flag Flag to test on the spotweld
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each spotweld in the model. Note that ForEach has been designed to make looping over spotwelds as fast as possible and so has some limitations. Firstly, a single temporary Spotweld object is created and on each function call it is updated with the current spotweld data. This means that you should not try to store the Spotweld object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new spotwelds inside a ForEach loop. 
 * @param Model Model that all spotwelds are in
 * @param func Function to call for each spotweld
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Spotweld objects for all of the spotwelds in a model in Primer
 * @param Model Model to get spotwelds from
 */
    static GetAll(Model: Model): Spotweld[];

/**
 * Returns an array of Spotweld objects for all of the flagged spotwelds in a model in Primer
 * @param Model Model to get spotwelds from
 * @param flag Flag set on the spotwelds that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Spotweld[];

/**
 * Returns the Spotweld object for a spotweld ID.
 * @param Model Model to find the spotweld in
 * @param number number of the spotweld you want the Spotweld object for
 */
    static GetFromID(Model: Model, number: number): Spotweld;

/**
 * Checks if a Spotweld property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Spotweld.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop spotweld property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this spotweld (*CONSTRAINED_SPOTWELD). Note that a carriage return is not added. See also Spotweld.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the spotweld. Note that a carriage return is not added. See also Spotweld.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last spotweld in the model.
 * @param Model Model to get last spotweld in
 */
    static Last(Model: Model): Spotweld;

/**
 * Returns the last free spotweld label in the model. Also see Spotweld.FirstFreeLabel(), Spotweld.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free spotweld label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next spotweld in the model.
 */
    Next(): Spotweld;

/**
 * Returns the next free (highest+1) spotweld label in the model. Also see Spotweld.FirstFreeLabel(), Spotweld.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free spotweld label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a spotweld.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only spotwelds from that model can be picked. If the argument is a Flag then only spotwelds that are flagged with limit can be selected. If omitted, or null, any spotwelds from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Spotweld;

/**
 * Returns the previous spotweld in the model.
 */
    Previous(): Spotweld;

/**
 * Renumbers all of the spotwelds in the model.
 * @param Model Model that all spotwelds will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged spotwelds in the model.
 * @param Model Model that all the flagged spotwelds will be renumbered in
 * @param flag Flag set on the spotwelds that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select spotwelds using standard PRIMER object menus.
 * @param flag Flag to use when selecting spotwelds
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only spotwelds from that model can be selected. If the argument is a Flag then only spotwelds that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any spotwelds can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the spotweld.
 * @param flag Flag to set on the spotweld
 */
    SetFlag(flag: number): void;

/**
 * Sketches the spotweld. The spotweld will be sketched until you either call Spotweld.Unsketch(), Spotweld.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the spotweld is sketched. If omitted redraw is true. If you want to sketch several spotwelds and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged spotwelds in the model. The spotwelds will be sketched until you either call Spotweld.Unsketch(), Spotweld.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged spotwelds will be sketched in
 * @param flag Flag set on the spotwelds that you want to sketch
 * @param redraw If model should be redrawn or not after the spotwelds are sketched. If omitted redraw is true. If you want to sketch flagged spotwelds several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of spotwelds in the model.
 * @param Model Model to get total for
 * @param exists true if only existing spotwelds should be counted. If false or omitted referenced but undefined spotwelds will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the spotweld
 */
    Unblank(): void;

/**
 * Unblanks all of the spotwelds in the model.
 * @param Model Model that all spotwelds will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged spotwelds in the model.
 * @param Model Model that the flagged spotwelds will be unblanked in
 * @param flag Flag set on the spotwelds that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the spotwelds in the model.
 * @param Model Model that the defined flag for all spotwelds will be unset in
 * @param flag Flag to unset on the spotwelds
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the spotweld.
 * @param redraw If model should be redrawn or not after the spotweld is unsketched. If omitted redraw is true. If you want to unsketch several spotwelds and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all spotwelds.
 * @param Model Model that all spotwelds will be unblanked in
 * @param redraw If model should be redrawn or not after the spotwelds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged spotwelds in the model.
 * @param Model Model that all spotwelds will be unsketched in
 * @param flag Flag set on the spotwelds that you want to unsketch
 * @param redraw If model should be redrawn or not after the spotwelds are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Spotweld;

/**
 * Adds a warning for spotweld. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this spotweld.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Spotweld object.
 * @param Model Model that constrained spotweld will be created in
 * @param n1 Node ID 1
 * @param n2 Node ID 2
 * @param label Constrained spotweld number
 */
    constructor(Model: Model, n1: number, n2: number, label?: number);

/**
 * Creates a string containing the spotweld data in keyword format. Note that this contains the keyword header and the keyword cards. See also Spotweld.Keyword() and Spotweld.KeywordCards().
 */
    toString(): string;

/** Effective plastic strain at failure */
    ep: number;
/** true if constrained spotweld exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** true if _FILTERED_FORCE option is set, false if not */
    filtered_force: boolean;
/** true if _ID option is set, false if not */
    id: boolean;
/** The Include file number that the constrained spotweld is in. */
    include: number;
/** Constrained spotweld number */
    label: number;
/** Exponent for shear spotweld force */
    m: number;
/** The Model number that the spotweld is in. */
    model: number;
/** Exponent for normal spotweld force */
    n: number;
/** Node ID */
    n1: number;
/** Node ID */
    n2: number;
/** Number of force vectors stored for filtering */
    nf: number;
/** Normal force at spotweld failure */
    sn: number;
/** Shear force at spotweld failure */
    ss: number;
/** Failure time for nodal constraint set */
    tf: number;
/** Time window for filtering */
    tw: number;
/** Constrained spotweld number (identical to label) */
    wid: number;
}

declare class Spr2 {
/**
 * Blanks the spr2
 */
    Blank(): void;

/**
 * Blanks all of the spr2s in the model.
 * @param Model Model that all spr2s will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged spr2s in the model.
 * @param Model Model that all the flagged spr2s will be blanked in
 * @param flag Flag set on the spr2s that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the spr2 is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the spr2.
 * @param flag Flag to clear on the spr2
 */
    ClearFlag(flag: number): void;

/**
 * Copies the spr2.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Spr2;

/**
 * Adds an error for spr2. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first spr2 in the model.
 * @param Model Model to get first spr2 in
 */
    static First(Model: Model): Spr2;

/**
 * Flags all of the spr2s in the model with a defined flag.
 * @param Model Model that all spr2s will be flagged in
 * @param flag Flag to set on the spr2s
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the spr2 is flagged or not.
 * @param flag Flag to test on the spr2
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each spr2 in the model. Note that ForEach has been designed to make looping over spr2s as fast as possible and so has some limitations. Firstly, a single temporary Spr2 object is created and on each function call it is updated with the current spr2 data. This means that you should not try to store the Spr2 object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new spr2s inside a ForEach loop. 
 * @param Model Model that all spr2s are in
 * @param func Function to call for each spr2
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Spr2 objects for all of the spr2s in a model in Primer
 * @param Model Model to get spr2s from
 */
    static GetAll(Model: Model): Spr2[];

/**
 * Returns an array of Spr2 objects for all of the flagged spr2s in a model in Primer
 * @param Model Model to get spr2s from
 * @param flag Flag set on the spr2s that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Spr2[];

/**
 * Returns the Spr2 object for a spr2 ID.
 * @param Model Model to find the spr2 in
 * @param number number of the spr2 you want the Spr2 object for
 */
    static GetFromID(Model: Model, number: number): Spr2;

/**
 * Checks if a Spr2 property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Spr2.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop spr2 property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this spr2 (*CONSTRAINED_SPR2). Note that a carriage return is not added. See also Spr2.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the spr2. Note that a carriage return is not added. See also Spr2.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last spr2 in the model.
 * @param Model Model to get last spr2 in
 */
    static Last(Model: Model): Spr2;

/**
 * Returns the next spr2 in the model.
 */
    Next(): Spr2;

/**
 * Allows the user to pick a spr2.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only spr2s from that model can be picked. If the argument is a Flag then only spr2s that are flagged with limit can be selected. If omitted, or null, any spr2s from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Spr2;

/**
 * Returns the previous spr2 in the model.
 */
    Previous(): Spr2;

/**
 * Allows the user to select spr2s using standard PRIMER object menus.
 * @param flag Flag to use when selecting spr2s
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only spr2s from that model can be selected. If the argument is a Flag then only spr2s that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any spr2s can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the spr2.
 * @param flag Flag to set on the spr2
 */
    SetFlag(flag: number): void;

/**
 * Sketches the spr2. The spr2 will be sketched until you either call Spr2.Unsketch(), Spr2.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the spr2 is sketched. If omitted redraw is true. If you want to sketch several spr2s and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged spr2s in the model. The spr2s will be sketched until you either call Spr2.Unsketch(), Spr2.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged spr2s will be sketched in
 * @param flag Flag set on the spr2s that you want to sketch
 * @param redraw If model should be redrawn or not after the spr2s are sketched. If omitted redraw is true. If you want to sketch flagged spr2s several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of spr2s in the model.
 * @param Model Model to get total for
 * @param exists true if only existing spr2s should be counted. If false or omitted referenced but undefined spr2s will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the spr2
 */
    Unblank(): void;

/**
 * Unblanks all of the spr2s in the model.
 * @param Model Model that all spr2s will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged spr2s in the model.
 * @param Model Model that the flagged spr2s will be unblanked in
 * @param flag Flag set on the spr2s that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the spr2s in the model.
 * @param Model Model that the defined flag for all spr2s will be unset in
 * @param flag Flag to unset on the spr2s
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the spr2.
 * @param redraw If model should be redrawn or not after the spr2 is unsketched. If omitted redraw is true. If you want to unsketch several spr2s and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all spr2s.
 * @param Model Model that all spr2s will be unblanked in
 * @param redraw If model should be redrawn or not after the spr2s are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged spr2s in the model.
 * @param Model Model that all spr2s will be unsketched in
 * @param flag Flag set on the spr2s that you want to unsketch
 * @param redraw If model should be redrawn or not after the spr2s are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Spr2;

/**
 * Adds a warning for spr2. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this spr2.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Spr2 object.
 * @param Model Model that constrained spr2 will be created in
 * @param mid Master Sheet Part ID.
 * @param sid Slave Sheet Part ID
 * @param nsid Node Set ID of rivet location nodes.
 */
    constructor(Model: Model, mid: number, sid: number, nsid: number);

/**
 * Creates a string containing the spr2 data in keyword format. Note that this contains the keyword header and the keyword cards. See also Spr2.Keyword() and Spr2.KeywordCards().
 */
    toString(): string;

/** Dimensionless parameter scaling the effective displacement. */
    alpha1: number;
/** Dimensionless parameter scaling the effective displacement. */
    alpha2: number;
/** Dimensionless parameter scaling the effective displacement. ( GT.0: incremental update (default), LT.0: total update (recommended) ) */
    alpha3: number;
/** Rivet diameter. */
    d: number;
/** Rivet density (necessary for time step calculation). */
    dens: number;
/** Failure displacement in normal direction. */
    dn: number;
/** Failure displacement in tangential direction. */
    dt: number;
/** true if constrained spr2 exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Exponent value for load function in normal direction. */
    expn: number;
/** Exponent value for load function in tangential direction. */
    expt: number;
/** Rivet strength in tension (pull-out). */
    fn: number;
/** Rivet strength in pure shear. */
    ft: number;
/** The Include file number that the constrained spr2 is in. */
    include: number;
/** Flag for interpolation. Values can be Spr2.LINEAR, Spr2.UNIFORM or Spr2.INVERSE. */
    intp: number;
/** Master Sheet Part ID. */
    mid: number;
/** The Model number that the spr2 is in. */
    model: number;
/** Node Set ID of rivet location nodes. */
    nsid: number;
/** Part ID for visualization beams representing SPR2 in postprocessing. */
    pidvb: number;
/** Slave Sheet Part ID. */
    sid: number;
/** Total thickness of master and slave sheet. */
    thick: number;
/** Fraction of failure displacement at maximum normal force. */
    xin: number;
/** Fraction of failure displacement at maximum tangential force. */
    xit: number;
/** Extra Part ID 1 for multi-sheet connection. */
    xpid1: number;
/** Extra Part ID 2 for multi-sheet connection. */
    xpid2: number;
/** Extra Part ID 3 for multi-sheet connection. */
    xpid3: number;
/** Extra Part ID 4 for multi-sheet connection. */
    xpid4: number;
/** Property INTP value EQ.2.0: Inverse distance weighting. */
    static INVERSE: number;
/** Property INTP value EQ.0.0: Linear (default). */
    static LINEAR: number;
/** Property INTP value EQ.1.0: Uniform. */
    static UNIFORM: number;
}

declare class StagedConstructionPart {
/**
 * Blanks the Define staged construction part
 */
    Blank(): void;

/**
 * Blanks all of the Define staged construction parts in the model.
 * @param Model Model that all Define staged construction parts will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged Define staged construction parts in the model.
 * @param Model Model that all the flagged Define staged construction parts will be blanked in
 * @param flag Flag set on the Define staged construction parts that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the Define staged construction part is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the Define staged construction part.
 * @param flag Flag to clear on the Define staged construction part
 */
    ClearFlag(flag: number): void;

/**
 * Copies the Define staged construction part.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): StagedConstructionPart;

/**
 * Starts an interactive editing panel to create a Define staged construction parts card.
 * @param Model Model that the Define staged construction parts card will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): StagedConstructionPart;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for Define staged construction part. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first Define staged construction part in the model.
 * @param Model Model to get first Define staged construction part in
 */
    static First(Model: Model): StagedConstructionPart;

/**
 * Flags all of the Define staged construction parts in the model with a defined flag.
 * @param Model Model that all Define staged construction parts will be flagged in
 * @param flag Flag to set on the Define staged construction parts
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the Define staged construction part is flagged or not.
 * @param flag Flag to test on the Define staged construction part
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each Define staged construction part in the model. Note that ForEach has been designed to make looping over Define staged construction parts as fast as possible and so has some limitations. Firstly, a single temporary StagedConstructionPart object is created and on each function call it is updated with the current Define staged construction part data. This means that you should not try to store the StagedConstructionPart object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new Define staged construction parts inside a ForEach loop. 
 * @param Model Model that all Define staged construction parts are in
 * @param func Function to call for each Define staged construction part
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of StagedConstructionPart objects for all of the Define staged construction parts in a model in Primer
 * @param Model Model to get Define staged construction parts from
 */
    static GetAll(Model: Model): StagedConstructionPart[];

/**
 * Returns an array of StagedConstructionPart objects for all of the flagged Define staged construction parts in a model in Primer
 * @param Model Model to get Define staged construction parts from
 * @param flag Flag set on the Define staged construction parts that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): StagedConstructionPart[];

/**
 * Returns the StagedConstructionPart object for a Define staged construction part ID.
 * @param Model Model to find the Define staged construction part in
 * @param number number of the Define staged construction part you want the StagedConstructionPart object for
 */
    static GetFromID(Model: Model, number: number): StagedConstructionPart;

/**
 * Checks if a StagedConstructionPart property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the StagedConstructionPart.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop Define staged construction part property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this Define staged construction parts (*Define_staged_construction_part). Note that a carriage return is not added. See also StagedConstructionPart.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the Define staged construction parts. Note that a carriage return is not added. See also StagedConstructionPart.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last Define staged construction part in the model.
 * @param Model Model to get last Define staged construction part in
 */
    static Last(Model: Model): StagedConstructionPart;

/**
 * Returns the next Define staged construction part in the model.
 */
    Next(): StagedConstructionPart;

/**
 * Allows the user to pick a Define staged construction part.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only Define staged construction parts from that model can be picked. If the argument is a Flag then only Define staged construction parts that are flagged with limit can be selected. If omitted, or null, any Define staged construction parts from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): StagedConstructionPart;

/**
 * Returns the previous Define staged construction part in the model.
 */
    Previous(): StagedConstructionPart;

/**
 * Allows the user to select Define staged construction parts using standard PRIMER object menus.
 * @param flag Flag to use when selecting Define staged construction parts
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only Define staged construction parts from that model can be selected. If the argument is a Flag then only Define staged construction parts that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any Define staged construction parts can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the Define staged construction part.
 * @param flag Flag to set on the Define staged construction part
 */
    SetFlag(flag: number): void;

/**
 * Sketches the Define staged construction part. The Define staged construction part will be sketched until you either call StagedConstructionPart.Unsketch(), StagedConstructionPart.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the Define staged construction part is sketched. If omitted redraw is true. If you want to sketch several Define staged construction parts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged Define staged construction parts in the model. The Define staged construction parts will be sketched until you either call StagedConstructionPart.Unsketch(), StagedConstructionPart.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged Define staged construction parts will be sketched in
 * @param flag Flag set on the Define staged construction parts that you want to sketch
 * @param redraw If model should be redrawn or not after the Define staged construction parts are sketched. If omitted redraw is true. If you want to sketch flagged Define staged construction parts several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of Define staged construction parts in the model.
 * @param Model Model to get total for
 * @param exists true if only existing Define staged construction parts should be counted. If false or omitted referenced but undefined Define staged construction parts will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the Define staged construction part
 */
    Unblank(): void;

/**
 * Unblanks all of the Define staged construction parts in the model.
 * @param Model Model that all Define staged construction parts will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged Define staged construction parts in the model.
 * @param Model Model that the flagged Define staged construction parts will be unblanked in
 * @param flag Flag set on the Define staged construction parts that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the Define staged construction parts in the model.
 * @param Model Model that the defined flag for all Define staged construction parts will be unset in
 * @param flag Flag to unset on the Define staged construction parts
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the Define staged construction part.
 * @param redraw If model should be redrawn or not after the Define staged construction part is unsketched. If omitted redraw is true. If you want to unsketch several Define staged construction parts and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all Define staged construction parts.
 * @param Model Model that all Define staged construction parts will be unblanked in
 * @param redraw If model should be redrawn or not after the Define staged construction parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged Define staged construction parts in the model.
 * @param Model Model that all Define staged construction parts will be unsketched in
 * @param flag Flag set on the Define staged construction parts that you want to unsketch
 * @param redraw If model should be redrawn or not after the Define staged construction parts are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): StagedConstructionPart;

/**
 * Adds a warning for Define staged construction part. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this Define staged construction part.
 */
    Xrefs(): Xrefs;

/**
 * Create a new StagedConstructionPart object.
 * @param Model Model that Define staged construction parts will be created in
 * @param option Specify the type of Define staged construction parts. Can be StagedConstructionPart.PART or StagedConstructionPart.SET)
 * @param id Part ID or part set ID
 * @param stga Construction stage at which part is added.
 * @param stgr Construction stage at which part is removed.
 */
    constructor(Model: Model, option: number, id: number, stga: number, stgr: number);

/**
 * Creates a string containing the Define staged construction parts data in keyword format. Note that this contains the keyword header and the keyword cards. See also StagedConstructionPart.Keyword() and StagedConstructionPart.KeywordCards().
 */
    toString(): string;

/** true if Define staged construction parts exists, false if referred to but not defined (read only) */
    readonly exists: boolean;
/** Part ID or part set ID (not internal label) */
    id: number;
/** The Include file number that the Define staged construction parts is in. */
    include: number;
/** The label the Define staged construction parts has in PRIMER (read only) */
    readonly label: number;
/** The Model number that the Define staged construction part is in. */
    model: number;
/** The Define staged construction parts option. Can be StagedConstructionPart.PART or StagedConstructionPart.SET. */
    option: number;
/** Construction stage at which part is added. */
    stga: number;
/** Construction stage at which part is removed. */
    stgr: number;
/** DEFN is *DEFINE_STAGED_CONSTRUCTION_PART. */
    static PART: number;
/** DEFN is *DEFINE_STAGED_CONSTRUCTION_PART_SET. */
    static SET: number;
}

declare class StressSection {
/**
 * Blanks the stress section
 */
    Blank(): void;

/**
 * Blanks all of the stress sections in the model.
 * @param Model Model that all stress sections will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged stress sections in the model.
 * @param Model Model that all the flagged stress sections will be blanked in
 * @param flag Flag set on the stress sections that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the stress section is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the stress section.
 * @param flag Flag to clear on the stress section
 */
    ClearFlag(flag: number): void;

/**
 * Copies the stress section.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): StressSection;

/**
 * Starts an interactive editing panel to create a initial stress section definition.
 * @param Model Model that the stress section will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): StressSection;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for stress section. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first stress section in the model.
 * @param Model Model to get first stress section in
 */
    static First(Model: Model): StressSection;

/**
 * Returns the first free stress section label in the model. Also see StressSection.LastFreeLabel(), StressSection.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free stress section label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the stress sections in the model with a defined flag.
 * @param Model Model that all stress sections will be flagged in
 * @param flag Flag to set on the stress sections
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the stress section is flagged or not.
 * @param flag Flag to test on the stress section
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each stress section in the model. Note that ForEach has been designed to make looping over stress sections as fast as possible and so has some limitations. Firstly, a single temporary StressSection object is created and on each function call it is updated with the current stress section data. This means that you should not try to store the StressSection object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new stress sections inside a ForEach loop. 
 * @param Model Model that all stress sections are in
 * @param func Function to call for each stress section
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of StressSection objects for all of the stress sections in a model in Primer
 * @param Model Model to get stress sections from
 */
    static GetAll(Model: Model): StressSection[];

/**
 * Returns an array of StressSection objects for all of the flagged stress sections in a model in Primer
 * @param Model Model to get stress sections from
 * @param flag Flag set on the stress sections that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): StressSection[];

/**
 * Returns the StressSection object for a stress section ID.
 * @param Model Model to find the stress section in
 * @param number number of the stress section you want the StressSection object for
 */
    static GetFromID(Model: Model, number: number): StressSection;

/**
 * Checks if a StressSection property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the StressSection.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop stress section property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this stress section. Note that a carriage return is not added. See also StressSection.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the stress section. Note that a carriage return is not added. See also StressSection.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last stress section in the model.
 * @param Model Model to get last stress section in
 */
    static Last(Model: Model): StressSection;

/**
 * Returns the last free stress section label in the model. Also see StressSection.FirstFreeLabel(), StressSection.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free stress section label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next stress section in the model.
 */
    Next(): StressSection;

/**
 * Returns the next free (highest+1) stress section label in the model. Also see StressSection.FirstFreeLabel(), StressSection.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free stress section label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous stress section in the model.
 */
    Previous(): StressSection;

/**
 * Renumbers all of the stress sections in the model.
 * @param Model Model that all stress sections will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged stress sections in the model.
 * @param Model Model that all the flagged stress sections will be renumbered in
 * @param flag Flag set on the stress sections that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select stress sections using standard PRIMER object menus.
 * @param flag Flag to use when selecting stress sections
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only stress sections from that model can be selected. If the argument is a Flag then only stress sections that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any stress sections can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the stress section.
 * @param flag Flag to set on the stress section
 */
    SetFlag(flag: number): void;

/**
 * Sketches the stress section. The stress section will be sketched until you either call StressSection.Unsketch(), StressSection.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the stress section is sketched. If omitted redraw is true. If you want to sketch several stress sections and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged stress sections in the model. The stress sections will be sketched until you either call StressSection.Unsketch(), StressSection.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged stress sections will be sketched in
 * @param flag Flag set on the stress sections that you want to sketch
 * @param redraw If model should be redrawn or not after the stress sections are sketched. If omitted redraw is true. If you want to sketch flagged stress sections several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of stress sections in the model.
 * @param Model Model to get total for
 * @param exists true if only existing stress sections should be counted. If false or omitted referenced but undefined stress sections will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the stress section
 */
    Unblank(): void;

/**
 * Unblanks all of the stress sections in the model.
 * @param Model Model that all stress sections will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged stress sections in the model.
 * @param Model Model that the flagged stress sections will be unblanked in
 * @param flag Flag set on the stress sections that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the stress sections in the model.
 * @param Model Model that the defined flag for all stress sections will be unset in
 * @param flag Flag to unset on the stress sections
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the stress section.
 * @param redraw If model should be redrawn or not after the stress section is unsketched. If omitted redraw is true. If you want to unsketch several stress sections and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all stress sections.
 * @param Model Model that all stress sections will be unblanked in
 * @param redraw If model should be redrawn or not after the stress sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged stress sections in the model.
 * @param Model Model that all stress sections will be unsketched in
 * @param flag Flag set on the stress sections that you want to unsketch
 * @param redraw If model should be redrawn or not after the stress sections are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): StressSection;

/**
 * Adds a warning for stress section. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this stress section.
 */
    Xrefs(): Xrefs;

/**
 * Create a new StressSection object.
 * @param Model Model that stress section will be created in
 * @param issid StressSection number.
 * @param csid Cross section ID.
 * @param lcid Load curve ID defining preload stress versus time.
 * @param psid Part set ID.
 * @param vid Vector ID.
 * @param izshear Shear stress flag.
 * @param istiff Load curve ID defining artificial stress fraction versus time.
 */
    constructor(Model: Model, issid: number, csid: number, lcid: number, psid: number, vid: number, izshear: number, istiff?: number);

/**
 * Creates a string containing the stress section data in keyword format. Note that this contains the keyword header and the keyword cards. See also StressSection.Keyword() and StressSection.KeywordCards().
 */
    toString(): string;

/** Cross section ID. */
    csid: number;
/** true if stress section exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the stress section is in. */
    include: number;
/** StressSection number. Also see the label property which is an alternative name for this. */
    issid: number;
/** Load curve ID defining the artificial stress fraction versus time. */
    istiff: number;
/** Shear stress flag. */
    izshear: number;
/** StressSection number. Also see the issid property which is an alternative name for this. */
    label: number;
/** Load curve ID defining preload stress versus time. */
    lcid: number;
/** The Model number that the stress section is in. */
    model: number;
/** Part set ID. */
    psid: number;
/** Vector ID defining the direction normal to the cross section. */
    vid: number;
}

declare class StressShell {
/**
 * Clears a flag on the initial stress shell.
 * @param flag Flag to clear on the initial stress shell
 */
    ClearFlag(flag: number): void;

/**
 * Copies the initial stress shell.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): StressShell;

/**
 * Adds an error for initial stress shell. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first initial stress shell in the model.
 * @param Model Model to get first initial stress shell in
 */
    static First(Model: Model): StressShell;

/**
 * Flags all of the initial stress shells in the model with a defined flag.
 * @param Model Model that all initial stress shells will be flagged in
 * @param flag Flag to set on the initial stress shells
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the initial stress shell is flagged or not.
 * @param flag Flag to test on the initial stress shell
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each initial stress shell in the model. Note that ForEach has been designed to make looping over initial stress shells as fast as possible and so has some limitations. Firstly, a single temporary StressShell object is created and on each function call it is updated with the current initial stress shell data. This means that you should not try to store the StressShell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new initial stress shells inside a ForEach loop. 
 * @param Model Model that all initial stress shells are in
 * @param func Function to call for each initial stress shell
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of StressShell objects for all of the initial stress shells in a model in Primer
 * @param Model Model to get initial stress shells from
 */
    static GetAll(Model: Model): StressShell[];

/**
 * Returns an array of StressShell objects for all of the flagged initial stress shells in a model in Primer
 * @param Model Model to get initial stress shells from
 * @param flag Flag set on the initial stress shells that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): StressShell[];

/**
 * Returns the StressShell object for a initial stress shell ID.
 * @param Model Model to find the initial stress shell in
 * @param number number of the initial stress shell you want the StressShell object for
 */
    static GetFromID(Model: Model, number: number): StressShell;

/**
 * Returns the data for a specific integration point as an array. For each integration point there will be 8 + nhisv + (6 x ntensr) values. There are nplane x nthick integration points.
 * @param index Index you want the integration point data for. Note that indices start at 0.
 */
    GetIntegrationPoint(index: number): number[];

/**
 * Checks if a StressShell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the StressShell.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop initial stress shell property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the thermal data for a specific integration point as an array. For each integration point there will be nthhsv values. There are nthint integration points.
 * @param index Index you want the integration point data for. Note that indices start at 0.
 */
    GetThermalIntegrationPoint(index: number): number[];

/**
 * Returns the keyword for this initial stress shell (*INITIAL_STRESS_SHELL). Note that a carriage return is not added. See also StressShell.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the initial stress shell. Note that a carriage return is not added. See also StressShell.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last initial stress shell in the model.
 * @param Model Model to get last initial stress shell in
 */
    static Last(Model: Model): StressShell;

/**
 * Returns the next initial stress shell in the model.
 */
    Next(): StressShell;

/**
 * Allows the user to pick a initial stress shell.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only initial stress shells from that model can be picked. If the argument is a Flag then only initial stress shells that are flagged with limit can be selected. If omitted, or null, any initial stress shells from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): StressShell;

/**
 * Returns the previous initial stress shell in the model.
 */
    Previous(): StressShell;

/**
 * Allows the user to select initial stress shells using standard PRIMER object menus.
 * @param flag Flag to use when selecting initial stress shells
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only initial stress shells from that model can be selected. If the argument is a Flag then only initial stress shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any initial stress shells can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the initial stress shell.
 * @param flag Flag to set on the initial stress shell
 */
    SetFlag(flag: number): void;

/**
 * Set the data for a specific integration point. For each integration point there will be 8 + nhisv + (6 x ntensr) values. There are nplane x nthick integration points.
 * @param index Index you want the integration point data for. Note that indices start at 0.
 * @param data Array containing the integration point data. The array length should be 8 + nhisv + (6 x ntensr).
 */
    SetIntegrationPoint(index: number, data: number[]): void;

/**
 * Set the thermal data for a specific integration point. For each integration point there will be nthhsv values. There are nthint thermal integration points.
 * @param index Index you want the thermal integration point data for. Note that indices start at 0.
 * @param data Array containing the thermal integration point data. The array length should be nthint.
 */
    SetThermalIntegrationPoint(index: number, data: number[]): void;

/**
 * Sketches the initial stress shell. The initial stress shell will be sketched until you either call StressShell.Unsketch(), StressShell.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the initial stress shell is sketched. If omitted redraw is true. If you want to sketch several initial stress shells and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged initial stress shells in the model. The initial stress shells will be sketched until you either call StressShell.Unsketch(), StressShell.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged initial stress shells will be sketched in
 * @param flag Flag set on the initial stress shells that you want to sketch
 * @param redraw If model should be redrawn or not after the initial stress shells are sketched. If omitted redraw is true. If you want to sketch flagged initial stress shells several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of initial stress shells in the model.
 * @param Model Model to get total for
 * @param exists true if only existing initial stress shells should be counted. If false or omitted referenced but undefined initial stress shells will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the initial stress shells in the model.
 * @param Model Model that the defined flag for all initial stress shells will be unset in
 * @param flag Flag to unset on the initial stress shells
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the initial stress shell.
 * @param redraw If model should be redrawn or not after the initial stress shell is unsketched. If omitted redraw is true. If you want to unsketch several initial stress shells and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all initial stress shells.
 * @param Model Model that all initial stress shells will be unblanked in
 * @param redraw If model should be redrawn or not after the initial stress shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged initial stress shells in the model.
 * @param Model Model that all initial stress shells will be unsketched in
 * @param flag Flag set on the initial stress shells that you want to unsketch
 * @param redraw If model should be redrawn or not after the initial stress shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): StressShell;

/**
 * Adds a warning for initial stress shell. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this initial stress shell.
 */
    Xrefs(): Xrefs;

/**
 * Create a new StressShell object.
 * @param Model Model that stress_shell will be created in
 * @param type Specify the type of initial stress shell (Can be StressShell.SHELL or StressShell.SET)
 * @param eid Node Element ID or shell set ID
 * @param nplane Number of in plane integration points being output
 * @param nthick Number of integration points through the thickness
 * @param nhisv Number of additional history variables
 * @param ntensr Number of components of tensor data taken from the element history variables stored
 */
    constructor(Model: Model, type: number, eid: number, nplane: number, nthick: number, nhisv: number, ntensr: number);

/**
 * Creates a string containing the initial stress shell data in keyword format. Note that this contains the keyword header and the keyword cards. See also StressShell.Keyword() and StressShell.KeywordCards().
 */
    toString(): string;

/** Node Element ID or shell set ID */
    eid: number;
/** true if stress_shell exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the initial stress shell is in. */
    include: number;
/** true if large format, false otherwise */
    large: boolean;
/** The Model number that the initial stress shell is in. */
    model: number;
/** Number of additional history variables */
    nhisv: number;
/** Number of in plane integration points being output */
    nplane: number;
/** Number of components of tensor data taken from the element history variables stored */
    ntensr: number;
/** Number of thermal history variables per thermal integration point */
    nthhsv: number;
/** Number of integration points through the thickness */
    nthick: number;
/** Number of thermal integration points */
    nthint: number;
/** The Intial stress shell type. Can be StressShell.SHELL or StressShell.SET. */
    type: number;
/** Initial is *INITIAL_STRESS_SHELL_SET. */
    static SET: number;
/** Initial is *INITIAL_STRESS_SHELL. */
    static SHELL: number;
}

declare class Termination {
/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the termination.
 * @param flag Flag to clear on the termination
 */
    ClearFlag(flag: number): void;

/**
 * Copies the termination.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Termination;

/**
 * Starts an interactive editing panel to create an Termination definition.
 * @param Model Model that the Termination will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Termination;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for termination. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first termination in the model.
 * @param Model Model to get first termination in
 */
    static First(Model: Model): Termination;

/**
 * Flags all of the terminations in the model with a defined flag.
 * @param Model Model that all terminations will be flagged in
 * @param flag Flag to set on the terminations
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the termination is flagged or not.
 * @param flag Flag to test on the termination
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each termination in the model. Note that ForEach has been designed to make looping over terminations as fast as possible and so has some limitations. Firstly, a single temporary Termination object is created and on each function call it is updated with the current termination data. This means that you should not try to store the Termination object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new terminations inside a ForEach loop. 
 * @param Model Model that all terminations are in
 * @param func Function to call for each termination
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Termination objects for all of the terminations in a model in Primer
 * @param Model Model to get terminations from
 */
    static GetAll(Model: Model): Termination[];

/**
 * Returns an array of Termination objects for all of the flagged terminations in a model in Primer
 * @param Model Model to get terminations from
 * @param flag Flag set on the terminations that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Termination[];

/**
 * Returns the Termination object for a termination ID.
 * @param Model Model to find the termination in
 * @param number number of the termination you want the Termination object for
 */
    static GetFromID(Model: Model, number: number): Termination;

/**
 * Checks if a Termination property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Termination.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop termination property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this Termination (*TERMINATION_xxxx) Note that a carriage return is not added. See also Termination.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the Termination. Note that a carriage return is not added. See also Termination.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last termination in the model.
 * @param Model Model to get last termination in
 */
    static Last(Model: Model): Termination;

/**
 * Returns the next termination in the model.
 */
    Next(): Termination;

/**
 * Returns the previous termination in the model.
 */
    Previous(): Termination;

/**
 * Allows the user to select terminations using standard PRIMER object menus.
 * @param flag Flag to use when selecting terminations
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only terminations from that model can be selected. If the argument is a Flag then only terminations that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any terminations can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the termination.
 * @param flag Flag to set on the termination
 */
    SetFlag(flag: number): void;

/**
 * Returns the total number of terminations in the model.
 * @param Model Model to get total for
 * @param exists true if only existing terminations should be counted. If false or omitted referenced but undefined terminations will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the terminations in the model.
 * @param Model Model that the defined flag for all terminations will be unset in
 * @param flag Flag to unset on the terminations
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Termination;

/**
 * Adds a warning for termination. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this termination.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Termination object.
 * @param Model Model that termination will be created in
 * @param Type Specify the type of Termination (Can be Termination.BODY or Termination.CONTACT or Termination.CURVE or Termination.DELETED_SHELLS or Termination.DELETED_SOLIDS or Termination.NODE or Termination.SENSOR).
 * @param id Can be Part ID for Termination.BODY or Termination.DELETED_SHELLS or Termination.DELETED_SOLIDS, OR Contact ID for Termination.CONTACT, OR Node ID for Termination.NODE, OR Curve ID for Termination.CURVE, OR Part Set ID for Termination.DELETED_SHELLS_SET or Termination.DELETED_SOLIDS_SET, OR Sensor Switch ID for Termination.SENSOR.
 */
    constructor(Model: Model, Type: number, id: number);

/**
 * Creates a string containing the Termination data in keyword format. Note that this contains the keyword header and the keyword cards. See also Termination.Keyword() and Termination.KeywordCards().
 */
    toString(): string;

/** Activation time value. Used for Termination.CONTACT or Termination.CURVE. */
    actTime: number;
/** Directions to consider for Force Magnitude. Valid values are: Termination.DOF_X or Termination.DOF_Y or Termination.DOF_Z. Used for Termination.CONTACT. */
    dof: number;
/** Time duration of null resultant force prior to termination. Used for Termination.CONTACT. */
    duration: number;
/** true if termination exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Can be Part or NRBC ID based on ptype value for Termination.BODY, OR Contact ID for Termination.CONTACT, OR Node ID for Termination.NODE, OR Curve ID for Termination.CURVE, OR Part for Termination.DELETED_SHELLS or Termination.DELETED_SOLIDS, OR Part Set ID for Termination.DELETED_SHELLS_SET or Termination.DELETED_SOLIDS_SET, OR Sensor Switch ID for Termination.SENSOR. */
    id: number;
/** The Include file number that the termination is in. */
    include: number;
/** Maximum (most positive) displacement. If value is 0.0, it is set to 1.0e21. Value should be more than minc. Used for Termination.BODY or Termination.NODE. */
    maxc: number;
/** Minimum (most negative) displacement. If value is 0.0, it is set to -1.0e21. Value should be less than maxc. Used for Termination.BODY or Termination.NODE. */
    minc: number;
/** The Model number that the termination is in. */
    model: number;
/** Number of elements that must be deleted for the specified Part ID's, before an error termination occurs. Used for Termination.DELETED_SHELLS_SET or Termination.DELETED_SOLIDS_SET. */
    numDeletedElems: number;
/** Gives the type of Part for Termination.BODY. Values can be 0 for Part or 1 for NRBC (read only) */
    readonly ptype: number;
/** Stop Criterion. Valid values are: Termination.STOP_X or Termination.STOP_Y or Termination.STOP_Z or Termination.STOP_MAG. Used for Termination.BODY or Termination.NODE. */
    stop: number;
/** Any measured force magnitude below or equal to this specified threshold is taken as a null force. Used for Termination.CONTACT. */
    threshold: number;
/** Gives the type of *TERMINATION keyword (read only). */
    readonly type: number;
/** TERMINATION is *TERMINATION_BODY. */
    static BODY: number;
/** TERMINATION is *TERMINATION_CONTACT. */
    static CONTACT: number;
/** TERMINATION is *TERMINATION_CURVE. */
    static CURVE: number;
/** TERMINATION is *TERMINATION_DELETED_SHELLS. */
    static DELETED_SHELLS: number;
/** TERMINATION is *TERMINATION_DELETED_SHELLS_SET. */
    static DELETED_SHELLS_SET: number;
/** TERMINATION is *TERMINATION_DELETED_SOLIDS. */
    static DELETED_SOLIDS: number;
/** TERMINATION is *TERMINATION_DELETED_SOLIDS_SET. */
    static DELETED_SOLIDS_SET: number;
/** Degree of freedom in X direction for Force magnitude. Used for Termination.CONTACT. */
    static DOF_X: number;
/** Degree of freedom in Y direction for Force magnitude. Used for Termination.CONTACT. */
    static DOF_Y: number;
/** Degree of freedom in Z direction for Force magnitude. Used for Termination.CONTACT. */
    static DOF_Z: number;
/** TERMINATION is *TERMINATION_NODE. */
    static NODE: number;
/** TERMINATION is *TERMINATION_SENSOR. */
    static SENSOR: number;
/** Stop if displacement magnitude is exceeded. Used for Termination.BODY or Termination.NODE. */
    static STOP_MAG: number;
/** Stop criterion is in Global X direction. Used for Termination.BODY or Termination.NODE. */
    static STOP_X: number;
/** Stop criterion is in Global Y direction. Used for Termination.BODY or Termination.NODE. */
    static STOP_Y: number;
/** Stop criterion is in Global X direction. Used for Termination.BODY or Termination.NODE. */
    static STOP_Z: number;
}

declare class TieBreak {
/**
 * Blanks the tie-break
 */
    Blank(): void;

/**
 * Blanks all of the tie-breaks in the model.
 * @param Model Model that all tie-breaks will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged tie-breaks in the model.
 * @param Model Model that all the flagged tie-breaks will be blanked in
 * @param flag Flag set on the tie-breaks that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the tie-break is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the tie-break.
 * @param flag Flag to clear on the tie-break
 */
    ClearFlag(flag: number): void;

/**
 * Copies the tie-break.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): TieBreak;

/**
 * Adds an error for tie-break. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first tie-break in the model.
 * @param Model Model to get first tie-break in
 */
    static First(Model: Model): TieBreak;

/**
 * Flags all of the tie-breaks in the model with a defined flag.
 * @param Model Model that all tie-breaks will be flagged in
 * @param flag Flag to set on the tie-breaks
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the tie-break is flagged or not.
 * @param flag Flag to test on the tie-break
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each tie-break in the model. Note that ForEach has been designed to make looping over tie-breaks as fast as possible and so has some limitations. Firstly, a single temporary TieBreak object is created and on each function call it is updated with the current tie-break data. This means that you should not try to store the TieBreak object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new tie-breaks inside a ForEach loop. 
 * @param Model Model that all tie-breaks are in
 * @param func Function to call for each tie-break
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of TieBreak objects for all of the tie-breaks in a model in Primer
 * @param Model Model to get tie-breaks from
 */
    static GetAll(Model: Model): TieBreak[];

/**
 * Returns an array of TieBreak objects for all of the flagged tie-breaks in a model in Primer
 * @param Model Model to get tie-breaks from
 * @param flag Flag set on the tie-breaks that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): TieBreak[];

/**
 * Returns the TieBreak object for a tie-break ID.
 * @param Model Model to find the tie-break in
 * @param number number of the tie-break you want the TieBreak object for
 */
    static GetFromID(Model: Model, number: number): TieBreak;

/**
 * Checks if a TieBreak property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the TieBreak.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop tie-break property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this tie-break (**CONSTRAINED_TIE_BREAK). Note that a carriage return is not added. See also TieBreak.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the tie-break. Note that a carriage return is not added. See also TieBreak.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last tie-break in the model.
 * @param Model Model to get last tie-break in
 */
    static Last(Model: Model): TieBreak;

/**
 * Returns the next tie-break in the model.
 */
    Next(): TieBreak;

/**
 * Allows the user to pick a tie-break.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only tie-breaks from that model can be picked. If the argument is a Flag then only tie-breaks that are flagged with limit can be selected. If omitted, or null, any tie-breaks from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): TieBreak;

/**
 * Returns the previous tie-break in the model.
 */
    Previous(): TieBreak;

/**
 * Allows the user to select tie-breaks using standard PRIMER object menus.
 * @param flag Flag to use when selecting tie-breaks
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only tie-breaks from that model can be selected. If the argument is a Flag then only tie-breaks that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any tie-breaks can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the tie-break.
 * @param flag Flag to set on the tie-break
 */
    SetFlag(flag: number): void;

/**
 * Sketches the tie-break. The tie-break will be sketched until you either call TieBreak.Unsketch(), TieBreak.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the tie-break is sketched. If omitted redraw is true. If you want to sketch several tie-breaks and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged tie-breaks in the model. The tie-breaks will be sketched until you either call TieBreak.Unsketch(), TieBreak.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged tie-breaks will be sketched in
 * @param flag Flag set on the tie-breaks that you want to sketch
 * @param redraw If model should be redrawn or not after the tie-breaks are sketched. If omitted redraw is true. If you want to sketch flagged tie-breaks several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of tie-breaks in the model.
 * @param Model Model to get total for
 * @param exists true if only existing tie-breaks should be counted. If false or omitted referenced but undefined tie-breaks will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the tie-break
 */
    Unblank(): void;

/**
 * Unblanks all of the tie-breaks in the model.
 * @param Model Model that all tie-breaks will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged tie-breaks in the model.
 * @param Model Model that the flagged tie-breaks will be unblanked in
 * @param flag Flag set on the tie-breaks that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the tie-breaks in the model.
 * @param Model Model that the defined flag for all tie-breaks will be unset in
 * @param flag Flag to unset on the tie-breaks
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the tie-break.
 * @param redraw If model should be redrawn or not after the tie-break is unsketched. If omitted redraw is true. If you want to unsketch several tie-breaks and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all tie-breaks.
 * @param Model Model that all tie-breaks will be unblanked in
 * @param redraw If model should be redrawn or not after the tie-breaks are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged tie-breaks in the model.
 * @param Model Model that all tie-breaks will be unsketched in
 * @param flag Flag set on the tie-breaks that you want to unsketch
 * @param redraw If model should be redrawn or not after the tie-breaks are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): TieBreak;

/**
 * Adds a warning for tie-break. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this tie-break.
 */
    Xrefs(): Xrefs;

/**
 * Create a new TieBreak object.
 * @param Model Model that constrained tie-break will be created in
 * @param snsid Slave Node Set ID.
 * @param mnsid Master Node Set ID.
 * @param eppf Plastic strain at failure.
 */
    constructor(Model: Model, snsid: number, mnsid: number, eppf?: number);

/**
 * Creates a string containing the tie-break data in keyword format. Note that this contains the keyword header and the keyword cards. See also TieBreak.Keyword() and TieBreak.KeywordCards().
 */
    toString(): string;

/** Plastic strain at failure. */
    eppf: number;
/** true if constrained tie-break exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the constrained tie-break is in. */
    include: number;
/** Master Node Set ID. */
    mnsid: number;
/** The Model number that the tie-break is in. */
    model: number;
/** Slave Node Set ID. */
    snsid: number;
}

declare class Transformation {
/**
 * Adds a row of data for a *DEFINE_TRANSFORMATION.
 * @param data The data you want to add
 * @param row The row you want to add the data at. Existing transforms will be shifted. If omitted the data will be added to the end of the existing transforms. Note that row indices start at 0.
 */
    AddRow(data: number[], row?: number): void;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the transformation.
 * @param flag Flag to clear on the transformation
 */
    ClearFlag(flag: number): void;

/**
 * Copies the transformation.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Transformation;

/**
 * Starts an interactive editing panel to create a define transformation definition.
 * @param Model Model that the transformation will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Transformation;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for transformation. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first transformation in the model.
 * @param Model Model to get first transformation in
 */
    static First(Model: Model): Transformation;

/**
 * Returns the first free transformation label in the model. Also see Transformation.LastFreeLabel(), Transformation.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free transformation label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the transformations in the model with a defined flag.
 * @param Model Model that all transformations will be flagged in
 * @param flag Flag to set on the transformations
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the transformation is flagged or not.
 * @param flag Flag to test on the transformation
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each transformation in the model. Note that ForEach has been designed to make looping over transformations as fast as possible and so has some limitations. Firstly, a single temporary Transformation object is created and on each function call it is updated with the current transformation data. This means that you should not try to store the Transformation object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new transformations inside a ForEach loop. 
 * @param Model Model that all transformations are in
 * @param func Function to call for each transformation
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Transformation objects for all of the transformations in a model in Primer
 * @param Model Model to get transformations from
 */
    static GetAll(Model: Model): Transformation[];

/**
 * Returns an array of Transformation objects for all of the flagged transformations in a model in Primer
 * @param Model Model to get transformations from
 * @param flag Flag set on the transformations that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Transformation[];

/**
 * Returns the Transformation object for a transformation ID.
 * @param Model Model to find the transformation in
 * @param number number of the transformation you want the Transformation object for
 */
    static GetFromID(Model: Model, number: number): Transformation;

/**
 * Checks if a Transformation property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Transformation.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop transformation property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the data for a row in the transformation.
 * @param row The row you want the data for. Note row indices start at 0.
 */
    GetRow(row: number): number[];

/**
 * Returns the keyword for this transformation. Note that a carriage return is not added. See also Transformation.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the transformation. Note that a carriage return is not added. See also Transformation.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last transformation in the model.
 * @param Model Model to get last transformation in
 */
    static Last(Model: Model): Transformation;

/**
 * Returns the last free transformation label in the model. Also see Transformation.FirstFreeLabel(), Transformation.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free transformation label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next transformation in the model.
 */
    Next(): Transformation;

/**
 * Returns the next free (highest+1) transformation label in the model. Also see Transformation.FirstFreeLabel(), Transformation.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free transformation label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the previous transformation in the model.
 */
    Previous(): Transformation;

/**
 * Removes the data for a row in *DEFINE_TRANSFORMATION.
 * @param row The row you want to remove the data for. Note that row indices start at 0.
 */
    RemoveRow(row: number): void;

/**
 * Allows the user to select transformations using standard PRIMER object menus.
 * @param flag Flag to use when selecting transformations
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only transformations from that model can be selected. If the argument is a Flag then only transformations that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any transformations can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the transformation.
 * @param flag Flag to set on the transformation
 */
    SetFlag(flag: number): void;

/**
 * Sets the data for a row in *DEFINE_TRANSFORMATION.
 * @param row The row you want to set the data for. Note that row indices start at 0.
 * @param data The data you want to set the row to
 */
    SetRow(row: number, data: number[]): void;

/**
 * Returns the total number of transformations in the model.
 * @param Model Model to get total for
 * @param exists true if only existing transformations should be counted. If false or omitted referenced but undefined transformations will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unsets a defined flag on all of the transformations in the model.
 * @param Model Model that the defined flag for all transformations will be unset in
 * @param flag Flag to unset on the transformations
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Transformation;

/**
 * Adds a warning for transformation. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this transformation.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Transformation object.
 * @param Model Model that transformation will be created in
 * @param tranid Transformation label
 * @param title Transformation title
 */
    constructor(Model: Model, tranid: number, title?: string);

/**
 * Creates a string containing the transformation data in keyword format. Note that this contains the keyword header and the keyword cards. See also Transformation.Keyword() and Transformation.KeywordCards().
 */
    toString(): string;

/** true if transformation exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the transformation is in. */
    include: number;
/** Transformation number. Also see the tranid property which is an alternative name for this. */
    label: number;
/** The Model number that the transformation is in. */
    model: number;
/** Number of rows of transformations */
    readonly nrow: number;
/** The title for the transformation. */
    title: string;
/** Transformation number. Also see the label property which is an alternative name for this. */
    tranid: number;
}


/** Object returned by ElemCut */
interface ElemCutReturn {
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 1. Null if no cut on this face. */
    face1: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 2. Null if no cut on this face. */
    face2: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 3. Null if no cut on this face. */
    face3: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 4. Null if no cut on this face. */
    face4: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 5. Null if no cut on this face. */
    face5: number[];
    /** An array containing the x1,y1,z1,x2,y2,z2 coordinates of the cut line on the face 6. Null if no cut on this face. */
    face6: number[];
}

declare class Tshell {
/**
 * Blanks the thick shell
 */
    Blank(): void;

/**
 * Blanks all of the thick shells in the model.
 * @param Model Model that all thick shells will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged thick shells in the model.
 * @param Model Model that all the flagged thick shells will be blanked in
 * @param flag Flag set on the thick shells that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the thick shell is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the thick shell.
 * @param flag Flag to clear on the thick shell
 */
    ClearFlag(flag: number): void;

/**
 * Copies the thick shell.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Tshell;

/**
 * Starts an interactive editing panel to create a thick shell.
 * @param Model Model that the thick shell will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Tshell;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Returns coordinates of the intersections between a thick shell and a database cross section.
 * @param Database_cross_section_label The label of the database cross section.
 */
    ElemCut(Database_cross_section_label: number): ElemCutReturn;

/**
 * Adds an error for thick shell. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Extracts the actual colour used for thick shell. By default in PRIMER many entities such as elements get their colour automatically from the part that they are in. PRIMER cycles through 13 default colours based on the label of the entity. In this case the thick shell colour property will return the value Colour.PART instead of the actual colour. This method will return the actual colour which is used for drawing the thick shell.
 */
    ExtractColour(): number;

/**
 * Returns an array of Tshell objects for the thick shells within a box. This requires a previous (outside loop) call to function m.FindElemInit() where the process is initialized for flagged thick shells in the model and m.FindElemEnd() to close the process. Please note this function provides a list of all thick shells that could potentially be in the box (using computationally cheap bounding box comparison) it is not a rigorous test of whether the thick shellis actually in the box. See also Model.FindElemInit() See also Model.FindElemEnd()
 * @param Model Model designated model
 * @param xmin Minimum bound in global x
 * @param xmax Maximum bound in global x
 * @param ymin Minimum bound in global y
 * @param ymax Maximum bound in global y
 * @param zmin Minimum bound in global z
 * @param zmax Maximum bound in global z
 * @param hflag Optional flag to restrict thick shells considered
 */
    static FindTshellInBox(Model: Model, xmin: number, xmax: number, ymin: number, ymax: number, zmin: number, zmax: number, hflag?: number): Tshell[];

/**
 * Returns the first thick shell in the model.
 * @param Model Model to get first thick shell in
 */
    static First(Model: Model): Tshell;

/**
 * Returns the first free thick shell label in the model. Also see Tshell.LastFreeLabel(), Tshell.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free thick shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the thick shells in the model with a defined flag.
 * @param Model Model that all thick shells will be flagged in
 * @param flag Flag to set on the thick shells
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the thick shell is flagged or not.
 * @param flag Flag to test on the thick shell
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each thick shell in the model. Note that ForEach has been designed to make looping over thick shells as fast as possible and so has some limitations. Firstly, a single temporary Tshell object is created and on each function call it is updated with the current thick shell data. This means that you should not try to store the Tshell object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new thick shells inside a ForEach loop. 
 * @param Model Model that all thick shells are in
 * @param func Function to call for each thick shell
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Tshell objects for all of the thick shells in a model in Primer
 * @param Model Model to get thick shells from
 */
    static GetAll(Model: Model): Tshell[];

/**
 * Returns the composite data for an integration point in *ELEMENT_TSHELL_COMPOSITE.
 * @param ipt The integration point you want the data for. Note that integration points start at 0, not 1.
 */
    GetCompositeData(ipt: number): number[];

/**
 * Returns an array of Tshell objects for all of the flagged thick shells in a model in Primer
 * @param Model Model to get thick shells from
 * @param flag Flag set on the thick shells that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Tshell[];

/**
 * Returns the Tshell object for a thick shell ID.
 * @param Model Model to find the thick shell in
 * @param number number of the thick shell you want the Tshell object for
 */
    static GetFromID(Model: Model, number: number): Tshell;

/**
 * Returns the labels of the nodes on the thick shell as an array. See also Tshell.GetNodes()
 */
    GetNodeIDs(): number[];

/**
 * Returns the nodes on the thick shell as an array of Node objects. See also Tshell.GetNodeIDs()
 */
    GetNodes(): Node[];

/**
 * Checks if a Tshell property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Tshell.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop thick shell property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this thick shell (*ELEMENT_TSHELL or *ELEMENT_TSHELL_COMPOSITE). Note that a carriage return is not added. See also Tshell.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the thick shell. Note that a carriage return is not added. See also Tshell.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last thick shell in the model.
 * @param Model Model to get last thick shell in
 */
    static Last(Model: Model): Tshell;

/**
 * Returns the last free thick shell label in the model. Also see Tshell.FirstFreeLabel(), Tshell.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free thick shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next thick shell in the model.
 */
    Next(): Tshell;

/**
 * Returns the next free (highest+1) thick shell label in the model. Also see Tshell.FirstFreeLabel(), Tshell.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free thick shell label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a thick shell.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only thick shells from that model can be picked. If the argument is a Flag then only thick shells that are flagged with limit can be selected. If omitted, or null, any thick shells from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Tshell;

/**
 * Returns the previous thick shell in the model.
 */
    Previous(): Tshell;

/**
 * Removes the composite data for an integration point in *ELEMENT_TSHELL_COMPOSITE.
 * @param ipt The integration point you want to remove. Note that integration points start at 0, not 1.
 */
    RemoveCompositeData(ipt: number): void;

/**
 * Renumbers all of the thick shells in the model.
 * @param Model Model that all thick shells will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged thick shells in the model.
 * @param Model Model that all the flagged thick shells will be renumbered in
 * @param flag Flag set on the thick shells that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select thick shells using standard PRIMER object menus.
 * @param flag Flag to use when selecting thick shells
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only thick shells from that model can be selected. If the argument is a Flag then only thick shells that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any thick shells can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets the composite data for an integration point in *ELEMENT_TSHELL_COMPOSITE.
 * @param ipt The integration point you want to set the data for. Note that integration points start at 0, not 1.
 * @param mid Material ID for the integration point.
 * @param thick Thickness of the integration point.
 * @param beta Material angle of the integration point.
 */
    SetCompositeData(ipt: number, mid: number, thick: number, beta: number): void;

/**
 * Sets a flag on the thick shell.
 * @param flag Flag to set on the thick shell
 */
    SetFlag(flag: number): void;

/**
 * Sketches the thick shell. The thick shell will be sketched until you either call Tshell.Unsketch(), Tshell.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the thick shell is sketched. If omitted redraw is true. If you want to sketch several thick shells and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged thick shells in the model. The thick shells will be sketched until you either call Tshell.Unsketch(), Tshell.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged thick shells will be sketched in
 * @param flag Flag set on the thick shells that you want to sketch
 * @param redraw If model should be redrawn or not after the thick shells are sketched. If omitted redraw is true. If you want to sketch flagged thick shells several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Calculates the timestep for the thick shell
 */
    Timestep(): number;

/**
 * Returns the total number of thick shells in the model.
 * @param Model Model to get total for
 * @param exists true if only existing thick shells should be counted. If false or omitted referenced but undefined thick shells will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the thick shell
 */
    Unblank(): void;

/**
 * Unblanks all of the thick shells in the model.
 * @param Model Model that all thick shells will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged thick shells in the model.
 * @param Model Model that the flagged thick shells will be unblanked in
 * @param flag Flag set on the thick shells that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the thick shells in the model.
 * @param Model Model that the defined flag for all thick shells will be unset in
 * @param flag Flag to unset on the thick shells
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the thick shell.
 * @param redraw If model should be redrawn or not after the thick shell is unsketched. If omitted redraw is true. If you want to unsketch several thick shells and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all thick shells.
 * @param Model Model that all thick shells will be unblanked in
 * @param redraw If model should be redrawn or not after the thick shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged thick shells in the model.
 * @param Model Model that all thick shells will be unsketched in
 * @param flag Flag set on the thick shells that you want to unsketch
 * @param redraw If model should be redrawn or not after the thick shells are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Tshell;

/**
 * Adds a warning for thick shell. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this thick shell.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Tshell object. Use either 6 or 8 nodes when creating a new thick shell.
 * @param Model Model that thick shell will be created in
 * @param eid Tshell number
 * @param pid Part number
 * @param n1 Node number 1
 * @param n2 Node number 2
 * @param n3 Node number 3
 * @param n4 Node number 4
 * @param n5 Node number 5
 * @param n6 Node number 6
 * @param n7 Node number 7
 * @param n8 Node number 8
 */
    constructor(Model: Model, eid: number, pid: number, n1: number, n2: number, n3: number, n4: number, n5: number, n6: number, n7?: number, n8?: number);

/**
 * Creates a string containing the thick shell data in keyword format. Note that this contains the keyword header and the keyword cards. See also Tshell.Keyword() and Tshell.KeywordCards().
 */
    toString(): string;

/** If BETA option is set. */
    beta: boolean;
/** Angle for BETA option. */
    beta_angle: number;
/** The colour of the thick shell */
    colour: Colour;
/** If COMPOSITE option is set. Can be true or false */
    composite: boolean;
/** Tshell number. Also see the label property which is an alternative name for this. */
    eid: number;
/** true if thick shell exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** The Include file number that the thick shell is in. */
    include: number;
/** Tshell number. Also see the eid property which is an alternative name for this. */
    label: number;
/** The Model number that the thick shell is in. */
    model: number;
/** Node number 1 */
    n1: number;
/** Node number 2 */
    n2: number;
/** Node number 3 */
    n3: number;
/** Node number 4 */
    n4: number;
/** Node number 5 */
    n5: number;
/** Node number 6 */
    n6: number;
/** Node number 7 */
    n7: number;
/** Node number 8 */
    n8: number;
/** Number of integration points for composite thick shell */
    nip: boolean;
/** Number of nodes thick shell has (read only) */
    readonly nodes: number;
/** Part number */
    pid: number;
/** The transparency of the thick shell (0-100) 0% is opaque, 100% is transparent. */
    transparency: number;
}

declare class Utils {
/**
 * Decodes an ASCII85 encoded string. See Utils.Ascii85Encode() for details on the method.
 * @param encoded An ASCII85 encoded string
 */
    static Ascii85Decode(encoded: string): ArrayBuffer;

/**
 * Encodes an ASCII85 encoded string. This enables binary data to be represented by ASCII characters using five ASCII characters to represent four bytes of binary data (making the encoded size 1/4 larger than the original). By doing this binary data can be stored in JavaScript strings. Note that the method used by PRIMER to encode and decode strings differs from the standard ASCII85 encoding as that uses the ASCII characters ", ' and \ which cannot be used in JavaScript strings as they have special meanings. The method in PRIMER uses 0-84 are !-u (ASCII codes 33-117) (i.e. 33 is added to it) with the following exceptions v is used instead of " (ASCII code 118 instead of 34) w is used instead of ' (ASCII code 119 instead of 39) x is used instead of \ (ASCII code 120 instead of 92) If all five digits are 0 they are represented by a single character z instead of !!!!!
 * @param data ArrayBuffer containing the data
 * @param length Length of data in array buffer to encode. If omitted the whole array buffer will be encoded
 */
    static Ascii85Encode(data: ArrayBuffer, length?: number): string;

/**
 * Returns the build number
 */
    static Build(): number;

/**
 * Checks out a license for a feature
 * @param feature feature to check license for
 */
    static CheckoutLicense(feature: string): boolean;

/**
 * Forces garbage collection to be done. This should not normally need to be called but in exceptional circumstances it can be called to ensure that garbage collection is done to return memory.
 */
    static GarbageCollect(): void;

/**
 * Returns the path to the default HTML browser
 */
    static HTMLBrowser(): string;

/**
 * Returns the path to the executable of the default pdf reader
 */
    static PdfReader(): string;

/**
 * Returns the version number
 */
    static Version(): number;

}

declare class Vector {
/**
 * Blanks the vector
 */
    Blank(): void;

/**
 * Blanks all of the vectors in the model.
 * @param Model Model that all vectors will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged vectors in the model.
 * @param Model Model that all the flagged vectors will be blanked in
 * @param flag Flag set on the vectors that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the vector is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the vector.
 * @param flag Flag to clear on the vector
 */
    ClearFlag(flag: number): void;

/**
 * Copies the vector.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Vector;

/**
 * Starts an interactive editing panel to create a vector.
 * @param Model Model that the vector will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): Vector;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for vector. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first vector in the model.
 * @param Model Model to get first vector in
 */
    static First(Model: Model): Vector;

/**
 * Returns the first free vector label in the model. Also see Vector.LastFreeLabel(), Vector.NextFreeLabel() and Model.FirstFreeItemLabel().
 * @param Model Model to get first free vector label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to First free in layer in editing panels). If omitted the whole model will be used (Equivalent to First free in editing panels).
 */
    static FirstFreeLabel(Model: Model, layer?: number): number;

/**
 * Flags all of the vectors in the model with a defined flag.
 * @param Model Model that all vectors will be flagged in
 * @param flag Flag to set on the vectors
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the vector is flagged or not.
 * @param flag Flag to test on the vector
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each vector in the model. Note that ForEach has been designed to make looping over vectors as fast as possible and so has some limitations. Firstly, a single temporary Vector object is created and on each function call it is updated with the current vector data. This means that you should not try to store the Vector object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new vectors inside a ForEach loop. 
 * @param Model Model that all vectors are in
 * @param func Function to call for each vector
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Vector objects for all of the vectors in a model in Primer
 * @param Model Model to get vectors from
 */
    static GetAll(Model: Model): Vector[];

/**
 * Returns an array of Vector objects for all of the flagged vectors in a model in Primer
 * @param Model Model to get vectors from
 * @param flag Flag set on the vectors that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Vector[];

/**
 * Returns the Vector object for a vector ID.
 * @param Model Model to find the vector in
 * @param number number of the vector you want the Vector object for
 */
    static GetFromID(Model: Model, number: number): Vector;

/**
 * Checks if a Vector property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Vector.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop vector property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this vector (*DEFINE_VECTOR). Note that a carriage return is not added. See also Vector.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the vector. Note that a carriage return is not added. See also Vector.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last vector in the model.
 * @param Model Model to get last vector in
 */
    static Last(Model: Model): Vector;

/**
 * Returns the last free vector label in the model. Also see Vector.FirstFreeLabel(), Vector.NextFreeLabel() and see Model.LastFreeItemLabel()
 * @param Model Model to get last free vector label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest free in layer in editing panels). If omitted the whole model will be used.
 */
    static LastFreeLabel(Model: Model, layer?: number): number;

/**
 * Returns the next vector in the model.
 */
    Next(): Vector;

/**
 * Returns the next free (highest+1) vector label in the model. Also see Vector.FirstFreeLabel(), Vector.LastFreeLabel() and Model.NextFreeItemLabel()
 * @param Model Model to get next free vector label in
 * @param layer Include file (0 for the main file) to search for labels in (Equivalent to Highest+1 in layer in editing panels). If omitted the whole model will be used (Equivalent to Highest+1 in editing panels).
 */
    static NextFreeLabel(Model: Model, layer?: number): number;

/**
 * Allows the user to pick a vector.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only vectors from that model can be picked. If the argument is a Flag then only vectors that are flagged with limit can be selected. If omitted, or null, any vectors from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Vector;

/**
 * Returns the previous vector in the model.
 */
    Previous(): Vector;

/**
 * Renumbers all of the vectors in the model.
 * @param Model Model that all vectors will be renumbered in
 * @param start Start point for renumbering
 */
    static RenumberAll(Model: Model, start: number): void;

/**
 * Renumbers all of the flagged vectors in the model.
 * @param Model Model that all the flagged vectors will be renumbered in
 * @param flag Flag set on the vectors that you want to renumber
 * @param start Start point for renumbering
 */
    static RenumberFlagged(Model: Model, flag: number, start: number): void;

/**
 * Allows the user to select vectors using standard PRIMER object menus.
 * @param flag Flag to use when selecting vectors
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only vectors from that model can be selected. If the argument is a Flag then only vectors that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any vectors can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the vector.
 * @param flag Flag to set on the vector
 */
    SetFlag(flag: number): void;

/**
 * Sketches the vector. The vector will be sketched until you either call Vector.Unsketch(), Vector.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the vector is sketched. If omitted redraw is true. If you want to sketch several vectors and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged vectors in the model. The vectors will be sketched until you either call Vector.Unsketch(), Vector.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged vectors will be sketched in
 * @param flag Flag set on the vectors that you want to sketch
 * @param redraw If model should be redrawn or not after the vectors are sketched. If omitted redraw is true. If you want to sketch flagged vectors several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of vectors in the model.
 * @param Model Model to get total for
 * @param exists true if only existing vectors should be counted. If false or omitted referenced but undefined vectors will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the vector
 */
    Unblank(): void;

/**
 * Unblanks all of the vectors in the model.
 * @param Model Model that all vectors will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged vectors in the model.
 * @param Model Model that the flagged vectors will be unblanked in
 * @param flag Flag set on the vectors that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the vectors in the model.
 * @param Model Model that the defined flag for all vectors will be unset in
 * @param flag Flag to unset on the vectors
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the vector.
 * @param redraw If model should be redrawn or not after the vector is unsketched. If omitted redraw is true. If you want to unsketch several vectors and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all vectors.
 * @param Model Model that all vectors will be unblanked in
 * @param redraw If model should be redrawn or not after the vectors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged vectors in the model.
 * @param Model Model that all vectors will be unsketched in
 * @param flag Flag set on the vectors that you want to unsketch
 * @param redraw If model should be redrawn or not after the vectors are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Vector;

/**
 * Adds a warning for vector. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this vector.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Vector object.
 * @param Model Model that vector will be created in
 * @param vid Vector number
 * @param xt X coordinate of tail of vector
 * @param yt Y coordinate of tail of vector
 * @param zt Z coordinate of tail vector
 * @param xh X coordinate of head of vector
 * @param yh Y coordinate of head of vector
 * @param zh Z coordinate of head of vector
 * @param cid Coordinate system ID
 * @param heading Title for the vector
 */
    constructor(Model: Model, vid: number, xt: number, yt: number, zt: number, xh: number, yh: number, zh: number, cid?: number, heading?: string);

/**
 * Create a new Vector object with _NODES option.
 * @param Model Model that vector will be created in
 * @param vid Vector number
 * @param nodet Node ID for tail of vector
 * @param nodeh Node ID for head of vector
 * @param heading Title for the vector
 */
    constructor(Model: Model, vid: number, nodet: number, nodeh: number, heading?: string);

/**
 * Creates a string containing the vector data in keyword format. Note that this contains the keyword header and the keyword cards. See also Vector.Keyword() and Vector.KeywordCards().
 */
    toString(): string;

/** Coordinate system ID */
    cid: number;
/** true if vector exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Vector heading */
    heading: string;
/** The Include file number that the vector is in. */
    include: number;
/** Vector number. Also see the vid property which is an alternative name for this. */
    label: number;
/** The Model number that the vector is in. */
    model: number;
/** Node ID for head of vector (for _NODES option) */
    nodeh: number;
/** _NODES option */
    nodes: boolean;
/** Node ID for tail of vector (for _NODES option) */
    nodet: number;
/** Vector number. Also see the label property which is an alternative name for this. */
    vid: number;
/** X coordinate of head of vector */
    xh: number;
/** X coordinate of tail of vector */
    xt: number;
/** Y coordinate of head of vector */
    yh: number;
/** Y coordinate of tail of vector */
    yt: number;
/** Z coordinate of head of vector */
    zh: number;
/** Z coordinate of tail vector */
    zt: number;
}

declare class Velocity {
/**
 * Blanks the initial velocity
 */
    Blank(): void;

/**
 * Blanks all of the initial velocitys in the model.
 * @param Model Model that all initial velocitys will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged initial velocitys in the model.
 * @param Model Model that all the flagged initial velocitys will be blanked in
 * @param flag Flag set on the initial velocitys that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the initial velocity is blanked or not.
 */
    Blanked(): boolean;

/**
 * Clears a flag on the initial velocity.
 * @param flag Flag to clear on the initial velocity
 */
    ClearFlag(flag: number): void;

/**
 * Copies the initial velocity.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): Velocity;

/**
 * Adds an error for initial velocity. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first initial velocity in the model.
 * @param Model Model to get first initial velocity in
 */
    static First(Model: Model): Velocity;

/**
 * Flags all of the initial velocitys in the model with a defined flag.
 * @param Model Model that all initial velocitys will be flagged in
 * @param flag Flag to set on the initial velocitys
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the initial velocity is flagged or not.
 * @param flag Flag to test on the initial velocity
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each initial velocity in the model. Note that ForEach has been designed to make looping over initial velocitys as fast as possible and so has some limitations. Firstly, a single temporary Velocity object is created and on each function call it is updated with the current initial velocity data. This means that you should not try to store the Velocity object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new initial velocitys inside a ForEach loop. 
 * @param Model Model that all initial velocitys are in
 * @param func Function to call for each initial velocity
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of Velocity objects for all of the initial velocitys in a model in Primer
 * @param Model Model to get initial velocitys from
 */
    static GetAll(Model: Model): Velocity[];

/**
 * Returns an array of Velocity objects for all of the flagged initial velocitys in a model in Primer
 * @param Model Model to get initial velocitys from
 * @param flag Flag set on the initial velocitys that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): Velocity[];

/**
 * Returns the Velocity object for a initial velocity ID.
 * @param Model Model to find the initial velocity in
 * @param number number of the initial velocity you want the Velocity object for
 */
    static GetFromID(Model: Model, number: number): Velocity;

/**
 * Checks if a Velocity property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the Velocity.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop initial velocity property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this initial velocity (*INITIAL_VELOCITY). Note that a carriage return is not added. See also Velocity.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the initial velocity. Note that a carriage return is not added. See also Velocity.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last initial velocity in the model.
 * @param Model Model to get last initial velocity in
 */
    static Last(Model: Model): Velocity;

/**
 * Returns the next initial velocity in the model.
 */
    Next(): Velocity;

/**
 * Allows the user to pick a initial velocity.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only initial velocitys from that model can be picked. If the argument is a Flag then only initial velocitys that are flagged with limit can be selected. If omitted, or null, any initial velocitys from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): Velocity;

/**
 * Returns the previous initial velocity in the model.
 */
    Previous(): Velocity;

/**
 * Allows the user to select initial velocitys using standard PRIMER object menus.
 * @param flag Flag to use when selecting initial velocitys
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only initial velocitys from that model can be selected. If the argument is a Flag then only initial velocitys that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any initial velocitys can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the initial velocity.
 * @param flag Flag to set on the initial velocity
 */
    SetFlag(flag: number): void;

/**
 * Sketches the initial velocity. The initial velocity will be sketched until you either call Velocity.Unsketch(), Velocity.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the initial velocity is sketched. If omitted redraw is true. If you want to sketch several initial velocitys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged initial velocitys in the model. The initial velocitys will be sketched until you either call Velocity.Unsketch(), Velocity.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged initial velocitys will be sketched in
 * @param flag Flag set on the initial velocitys that you want to sketch
 * @param redraw If model should be redrawn or not after the initial velocitys are sketched. If omitted redraw is true. If you want to sketch flagged initial velocitys several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of initial velocitys in the model.
 * @param Model Model to get total for
 * @param exists true if only existing initial velocitys should be counted. If false or omitted referenced but undefined initial velocitys will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the initial velocity
 */
    Unblank(): void;

/**
 * Unblanks all of the initial velocitys in the model.
 * @param Model Model that all initial velocitys will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged initial velocitys in the model.
 * @param Model Model that the flagged initial velocitys will be unblanked in
 * @param flag Flag set on the initial velocitys that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the initial velocitys in the model.
 * @param Model Model that the defined flag for all initial velocitys will be unset in
 * @param flag Flag to unset on the initial velocitys
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the initial velocity.
 * @param redraw If model should be redrawn or not after the initial velocity is unsketched. If omitted redraw is true. If you want to unsketch several initial velocitys and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all initial velocitys.
 * @param Model Model that all initial velocitys will be unblanked in
 * @param redraw If model should be redrawn or not after the initial velocitys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged initial velocitys in the model.
 * @param Model Model that all initial velocitys will be unsketched in
 * @param flag Flag set on the initial velocitys that you want to unsketch
 * @param redraw If model should be redrawn or not after the initial velocitys are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): Velocity;

/**
 * Adds a warning for initial velocity. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this initial velocity.
 */
    Xrefs(): Xrefs;

/**
 * Create a new Velocity object.
 * @param Model Model that velocity will be created in
 * @param nsid Set Node set ID
 * @param vx Initial velocity in X direction
 * @param vy Initial velocity in Y direction
 * @param vz Initial velocity in Z direction
 * @param vxr Initial rotational velocity about X axis
 * @param vyr Initial rotational velocity about Y axis
 * @param vzr Initial rotational velocity about Z axis
 * @param boxid Define box containing nodes
 * @param irigid IRIGID flag
 * @param nsidex Set Exempted Node set ID
 * @param vxe Initial velocity in X direction of exempted nodes
 * @param vye Initial velocity in Y direction of exempted nodes
 * @param vze Initial velocity in Z direction of exempted nodes
 * @param vxre Initial rotational velocity about X axis of exempted nodes
 * @param vyre Initial rotational velocity about Y axis of exempted nodes
 * @param vzre Initial rotational velocity about Z axis of exempted nodes
 * @param icid Local coordinate system nodes
 */
    constructor(Model: Model, nsid: number, vx: number, vy: number, vz: number, vxr: number, vyr: number, vzr: number, boxid?: number, irigid?: number, nsidex?: number, vxe?: number, vye?: number, vze?: number, vxre?: number, vyre?: number, vzre?: number, icid?: number);

/**
 * Creates a string containing the initial velocity data in keyword format. Note that this contains the keyword header and the keyword cards. See also Velocity.Keyword() and Velocity.KeywordCards().
 */
    toString(): string;

/** Define box containing nodes */
    boxid: number;
/** true if velocity exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Local coordinate system */
    icid: number;
/** The Include file number that the initial velocity is in. */
    include: number;
/** IRIGID flag */
    irigid: number;
/** The Model number that the initial velocity is in. */
    model: number;
/** Set Node set ID */
    nsid: number;
/** Set Exempted Node set ID */
    nsidex: number;
/** Initial velocity in X direction */
    vx: number;
/** Initial velocity in X direction of exempted nodes */
    vxe: number;
/** Initial rotational velocity about X axis */
    vxr: number;
/** Initial rotational velocity about X axis of exempted nodes */
    vxre: number;
/** Initial velocity in Y direction */
    vy: number;
/** Initial velocity in Y direction of exempted nodes */
    vye: number;
/** Initial rotational velocity about Y axis */
    vyr: number;
/** Initial rotational velocity about Y axis of exempted nodes */
    vyre: number;
/** Initial velocity in Z direction */
    vz: number;
/** Initial velocity in Z direction of exempted nodes */
    vze: number;
/** Initial rotational velocity about Z axis */
    vzr: number;
/** Initial rotational velocity about Z axis of exempted nodes */
    vzre: number;
}

declare class VelocityGeneration {
/**
 * Blanks the initial velocity generation
 */
    Blank(): void;

/**
 * Blanks all of the initial velocity generations in the model.
 * @param Model Model that all initial velocity generations will be blanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankAll(Model: Model, redraw?: boolean): void;

/**
 * Blanks all of the flagged initial velocity generations in the model.
 * @param Model Model that all the flagged initial velocity generations will be blanked in
 * @param flag Flag set on the initial velocity generations that you want to blank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static BlankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Checks if the initial velocity generation is blanked or not.
 */
    Blanked(): boolean;

/**
 * Starts an edit panel in Browse mode.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Browse(modal?: boolean): void;

/**
 * Clears a flag on the initial velocity generation.
 * @param flag Flag to clear on the initial velocity generation
 */
    ClearFlag(flag: number): void;

/**
 * Copies the initial velocity generation.
 * @param range If you want to keep the copied item in the range specified for the current include. Default value is false. To set current include, use Include.MakeCurrentLayer().
 */
    Copy(range?: boolean): VelocityGeneration;

/**
 * Starts an interactive editing panel to create an initial velocity generation definition.
 * @param Model Model that the initial velocity generation definition will be created in
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    static Create(Model: Model, modal?: boolean): VelocityGeneration;

/**
 * Starts an interactive editing panel.
 * @param modal If this window is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the window will be modal.
 */
    Edit(modal?: boolean): void;

/**
 * Adds an error for initial velocity generation. For more details on checking see the Check class.
 * @param message The error message to give
 * @param details An optional detailed error message
 */
    Error(message: string, details?: string): void;

/**
 * Returns the first initial velocity generation in the model.
 * @param Model Model to get first initial velocity generation in
 */
    static First(Model: Model): VelocityGeneration;

/**
 * Flags all of the initial velocity generations in the model with a defined flag.
 * @param Model Model that all initial velocity generations will be flagged in
 * @param flag Flag to set on the initial velocity generations
 */
    static FlagAll(Model: Model, flag: number): void;

/**
 * Checks if the initial velocity generation is flagged or not.
 * @param flag Flag to test on the initial velocity generation
 */
    Flagged(flag: number): boolean;

/**
 * Calls a function for each initial velocity generation in the model. Note that ForEach has been designed to make looping over initial velocity generations as fast as possible and so has some limitations. Firstly, a single temporary VelocityGeneration object is created and on each function call it is updated with the current initial velocity generation data. This means that you should not try to store the VelocityGeneration object for later use (e.g. in an array) as it is temporary. Secondly, you cannot create new initial velocity generations inside a ForEach loop. 
 * @param Model Model that all initial velocity generations are in
 * @param func Function to call for each initial velocity generation
 * @param extra An optional extra object/array/string etc that will appended to arguments when calling the function
 */
    static ForEach(Model: Model, func: () => void, extra?: any): void;

/**
 * Returns an array of VelocityGeneration objects for all of the initial velocity generations in a model in Primer
 * @param Model Model to get initial velocity generations from
 */
    static GetAll(Model: Model): VelocityGeneration[];

/**
 * Returns an array of VelocityGeneration objects for all of the flagged initial velocity generations in a model in Primer
 * @param Model Model to get initial velocity generations from
 * @param flag Flag set on the initial velocity generations that you want to retrieve
 */
    static GetFlagged(Model: Model, flag: number): VelocityGeneration[];

/**
 * Returns the VelocityGeneration object for a initial velocity generation ID.
 * @param Model Model to find the initial velocity generation in
 * @param number number of the initial velocity generation you want the VelocityGeneration object for
 */
    static GetFromID(Model: Model, number: number): VelocityGeneration;

/**
 * Checks if a VelocityGeneration property is a parameter or not. Note that object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. For this function to work the JavaScript interpreter must use the parameter name instead of the value. This can be done by setting the Options.property_parameter_names option to true before calling the function and then resetting it to false afterwards.. This behaviour can also temporarily be switched by using the VelocityGeneration.ViewParameters() method and 'method chaining' (see the examples below).
 * @param prop initial velocity generation property to get parameter for
 */
    GetParameter(prop: string): Parameter;

/**
 * Returns the keyword for this initial velocity (*INITIAL_VELOCITY_GENERATION). Note that a carriage return is not added. See also VelocityGeneration.KeywordCards()
 */
    Keyword(): string;

/**
 * Returns the keyword cards for the initial velocity_generation. Note that a carriage return is not added. See also VelocityGeneration.Keyword()
 */
    KeywordCards(): string;

/**
 * Returns the last initial velocity generation in the model.
 * @param Model Model to get last initial velocity generation in
 */
    static Last(Model: Model): VelocityGeneration;

/**
 * Returns the next initial velocity generation in the model.
 */
    Next(): VelocityGeneration;

/**
 * Allows the user to pick a initial velocity generation.
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only initial velocity generations from that model can be picked. If the argument is a Flag then only initial velocity generations that are flagged with limit can be selected. If omitted, or null, any initial velocity generations from any model can be selected. from any model.
 * @param modal If picking is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the pick will be modal.
 * @param button_text By default the window with the prompt will have a button labelled 'Cancel' which if pressed will cancel the pick and return null. If you want to change the text on the button use this argument. If omitted 'Cancel' will be used.
 */
    static Pick(prompt: string, limit?: Model | number, modal?: boolean, button_text?: string): VelocityGeneration;

/**
 * Returns the previous initial velocity generation in the model.
 */
    Previous(): VelocityGeneration;

/**
 * Allows the user to select initial velocity generations using standard PRIMER object menus.
 * @param flag Flag to use when selecting initial velocity generations
 * @param prompt Text to display as a prompt to the user
 * @param limit If the argument is a Model then only initial velocity generations from that model can be selected. If the argument is a Flag then only initial velocity generations that are flagged with limit can be selected (limit should be different to flag). If omitted, or null, any initial velocity generations can be selected. from any model.
 * @param modal If selection is modal (blocks the user from doing anything else in PRIMER until this window is dismissed). If omitted the selection will be modal.
 */
    static Select(flag: number, prompt: string, limit?: Model | number, modal?: boolean): number;

/**
 * Sets a flag on the initial velocity generation.
 * @param flag Flag to set on the initial velocity generation
 */
    SetFlag(flag: number): void;

/**
 * Sketches the initial velocity generation. The initial velocity generation will be sketched until you either call VelocityGeneration.Unsketch(), VelocityGeneration.UnsketchAll(), Model.UnsketchAll(), or delete the model
 * @param redraw If model should be redrawn or not after the initial velocity generation is sketched. If omitted redraw is true. If you want to sketch several initial velocity generations and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Sketch(redraw?: boolean): void;

/**
 * Sketches all of the flagged initial velocity generations in the model. The initial velocity generations will be sketched until you either call VelocityGeneration.Unsketch(), VelocityGeneration.UnsketchFlagged(), Model.UnsketchAll(), or delete the model
 * @param Model Model that all the flagged initial velocity generations will be sketched in
 * @param flag Flag set on the initial velocity generations that you want to sketch
 * @param redraw If model should be redrawn or not after the initial velocity generations are sketched. If omitted redraw is true. If you want to sketch flagged initial velocity generations several times and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static SketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Returns the total number of initial velocity generations in the model.
 * @param Model Model to get total for
 * @param exists true if only existing initial velocity generations should be counted. If false or omitted referenced but undefined initial velocity generations will also be included in the total.
 */
    static Total(Model: Model, exists?: boolean): number;

/**
 * Unblanks the initial velocity generation
 */
    Unblank(): void;

/**
 * Unblanks all of the initial velocity generations in the model.
 * @param Model Model that all initial velocity generations will be unblanked in
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankAll(Model: Model, redraw?: boolean): void;

/**
 * Unblanks all of the flagged initial velocity generations in the model.
 * @param Model Model that the flagged initial velocity generations will be unblanked in
 * @param flag Flag set on the initial velocity generations that you want to unblank
 * @param redraw If model should be redrawn or not. If omitted redraw is false. If you want to do several (un)blanks and only redraw after the last one then use false for all redraws apart from the last one. Alternatively you can redraw using View.Redraw().
 */
    static UnblankFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Unsets a defined flag on all of the initial velocity generations in the model.
 * @param Model Model that the defined flag for all initial velocity generations will be unset in
 * @param flag Flag to unset on the initial velocity generations
 */
    static UnflagAll(Model: Model, flag: number): void;

/**
 * Unsketches the initial velocity generation.
 * @param redraw If model should be redrawn or not after the initial velocity generation is unsketched. If omitted redraw is true. If you want to unsketch several initial velocity generations and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    Unsketch(redraw?: boolean): void;

/**
 * Unsketches all initial velocity generations.
 * @param Model Model that all initial velocity generations will be unblanked in
 * @param redraw If model should be redrawn or not after the initial velocity generations are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchAll(Model: Model, redraw?: boolean): void;

/**
 * Unsketches all flagged initial velocity generations in the model.
 * @param Model Model that all initial velocity generations will be unsketched in
 * @param flag Flag set on the initial velocity generations that you want to unsketch
 * @param redraw If model should be redrawn or not after the initial velocity generations are unsketched. If omitted redraw is true. If you want to unsketch several things and only redraw after the last one then use false for redraw and call View.Redraw().
 */
    static UnsketchFlagged(Model: Model, flag: number, redraw?: boolean): void;

/**
 * Object properties that are parameters are normally returned as the integer or float parameter values as that is virtually always what the user would want. This function temporarily changes the behaviour so that if a property is a parameter the parameter name is returned instead. This can be used with 'method chaining' (see the example below) to make sure a property argument is correct.
 */
    ViewParameters(): VelocityGeneration;

/**
 * Adds a warning for initial velocity generation. For more details on checking see the Check class.
 * @param message The warning message to give
 * @param details An optional detailed warning message
 */
    Warning(message: string, details?: string): void;

/**
 * Returns the cross references for this initial velocity generation.
 */
    Xrefs(): Xrefs;

/**
 * Create a new VelocityGeneration object.
 * @param Model Model that velocity will be created in
 * @param type Specify the type of Velocity generation (Can be VelocityGeneration.PART_SET or VelocityGeneration.PART or VelocityGeneration.NODE_SET)
 * @param id Set Part ID, Part set ID or Node set ID
 * @param omega Angular velocity about the rotational axis
 * @param vx Initial translational velocity in X direction
 * @param vy Initial translational velocity in Y direction
 * @param vz Initial translational velocity in Z direction
 * @param ivatn Slave parts flag
 * @param xc x-coordinate on rotational axis
 * @param yc y-coordinate on rotational axis
 * @param zc z-coordinate on rotational axis
 * @param nx x-direction cosine
 * @param ny y-direction cosine
 * @param nz z-direction cosine
 * @param phase Dynamic relaxation flag
 * @param irigid Overide part inertia flag
 * @param icid Local coordinate system
 */
    constructor(Model: Model, type: number, id: number, omega: number, vx: number, vy: number, vz: number, ivatn: number, xc: number, yc: number, zc: number, nx: number, ny: number, nz: number, phase: number, irigid: number, icid: number);

/**
 * Creates a string containing the initial velocity data in keyword format. Note that this contains the keyword header and the keyword cards. See also VelocityGeneration.Keyword() and VelocityGeneration.KeywordCards().
 */
    toString(): string;

/** true if velocity exists, false if referred to but not defined. (read only) */
    readonly exists: boolean;
/** Local coordinate system */
    icid: number;
/** Set Part ID, Part set ID or Node set ID */
    id: number;
/** The Include file number that the initial velocity is in. */
    include: number;
/** Overide part inertia flag */
    irigid: number;
/** Slave parts flag */
    ivatn: number;
/** The Model number that the initial velocity generation is in. */
    model: number;
/** x-direction cosine */
    nx: number;
/** y-direction cosine */
    ny: number;
/** z-direction cosine */
    nz: number;
/** Angular velocity about the rotational axis */
    omega: number;
/** Dynamic relaxation flag */
    phase: number;
/** Specify the type of Velocity generation (Can be VelocityGeneration.PART_SET or VelocityGeneration.PART or VelocityGeneration.NODE_SET) */
    type: number;
/** Initial translational velocity in X direction */
    vx: number;
/** Initial translational velocity in Y direction */
    vy: number;
/** Initial translational velocity in Z direction */
    vz: number;
/** x-coordinate on rotational axis */
    xc: number;
/** y-coordinate on rotational axis */
    yc: number;
/** z-coordinate on rotational axis */
    zc: number;
/** ID is a NODE_SET */
    static NODE_SET: number;
/** ID is a PART */
    static PART: number;
/** ID is a PART_SET */
    static PART_SET: number;
}

declare class View {
/**
 * Autoscales the view
 */
    static Ac(): void;

/**
 * Does a contour plot
 */
    static Ct(): void;

/**
 * Does a Hidden line plot
 */
    static Hi(): void;

/**
 * Does a line (wireframe) plot
 */
    static Li(): void;

/**
 * Redraws the plot using the current plot mode.
 */
    static Redraw(): void;

/**
 * Sets a contour type (and subtype)
 * @param View_type The type of contour to plot. Can be:  View.TIMESTEP  View.SHELLTHICKNESS  View.SHELLNORMALS  View.LOADSHELLDIRECTION  View.ELEMPROPS  View.ELEMQUAL  View.MASSSCALE  View.MATLPROPS  View.INITVELS  View.PARTMASS
 * @param View_subtype The subtype of contour to plot. Note: This second argument is NOT required for types TIMESTEP and LOADSHELLDIRECTION.  Subtypes for Type TIMESTEP:  No subtypes  Subtypes for Type SHELLTHICKNESS:  View.ABSOLUTE  View.THINNING  View.REMAINING  Subtypes for SHELLNORMALS:  View.CONTOUR  View.VECTOR  Subtypes for Type LOADSHELLDIRECTION:  No subtypes  Subtypes for Type ELEMPROPS:  View.FORMULATION  View.INTPOINTS  View.PLASTICSTRAIN  View.FORM  Subtypes for Type ELEMQUAL:  View.MINLENGTH  View.ASPECTRATIO  View.WARPAGE  View.SKEW  View.MININTANGLE  View.MAXINTANGLE  View.JACOBIAN  View.TAPER  View.TETCOLLAPSE  View.QUALIMPERF  View.FAILEDCRITERIA  Subtypes for Type MASSSCALE:  View.PERCENTADDEDMASS  View.ADDEDMASS  View.PERCENTADDEDMASSPART  View.ADDEDMASSPART  Subtypes for Type MATLPROPS:  View.DENSITY  View.YIELDSTRESS  View.POISSONRATIO  View.YOUNGMODULUS  View.MATERIALNUMBER  Subtypes for Type INITVELS:  View.INITVELX  View.INITVELY  View.INITVELZ  View.INITVELRES  Subtypes for Type PARTMASS:  View.STRUCTMASS  View.EMPSTRUCTMASS  View.EMPNSMASS  View.FINALMASS  View.EMPFINALMASS 
 */
    static SetContourType(View_type: number, View_subtype: number): void;

/**
 * Does a shaded plot
 */
    static Sh(): void;

/**
 * Redraws using one of the standard views
 * @param View_type The view to show. Can be +/-View.XY, +/-View.YZ, +/-View.XZ or +/-View.ISO
 */
    static Show(View_type: number): void;

/**
 * Does a shaded image contour plot
 */
    static Si(): void;

/**
 * Does a vector plot
 */
    static Vec(): void;

/** Subtype Absolute (of type Shell Thickness) */
    static ABSOLUTE: number;
/** Subtype Added Mass (of type Mass Scale) */
    static ADDEDMASS: number;
/** Subtype Added Mass #Part (of type Mass Scale) */
    static ADDEDMASSPART: number;
/** Subtype Aspect Ratio (of type Element Quality) */
    static ASPECTRATIO: number;
/** Subtype Contour (of type Shell Normals) */
    static CONTOUR: number;
/** Subtype Density (of type Material Property) */
    static DENSITY: number;
/** Type Element Properties */
    static ELEMPROPS: number;
/** Type Element Quality */
    static ELEMQUAL: number;
/** Subtype (*)Final Mass (of type (*)EMP Parts Only) */
    static EMPFINALMASS: number;
/** Subtype (*)NS Mass (of type (*)EMP Parts Only) */
    static EMPNSMASS: number;
/** Subtype (*)Struct Mass (of type (*)EMP Parts Only) */
    static EMPSTRUCTMASS: number;
/** Subtype Failed Criteria (of type Element Quality) */
    static FAILEDCRITERIA: number;
/** Subtype Final Mass (of type (*)EMP Parts Only) */
    static FINALMASS: number;
/** Subtype Form (native) (of type Element Property) */
    static FORM: number;
/** Subtype Formulation (of type Element Property) */
    static FORMULATION: number;
/** Subtype Init Vel-Res (of type Init Vel Component) */
    static INITVELRES: number;
/** Type Initial Velocities */
    static INITVELS: number;
/** Subtype Init Vel-X (of type Init Vel Component) */
    static INITVELX: number;
/** Subtype Init Vel-Y (of type Init Vel Component) */
    static INITVELY: number;
/** Subtype Init Vel-Z (of type Init Vel Component) */
    static INITVELZ: number;
/** Subtype Integration Points (of type Element Property) */
    static INTPOINTS: number;
/** Isometric projection */
    static ISO: number;
/** Subtype Jacobian (of type Element Quality) */
    static JACOBIAN: number;
/** Type Load Shell Direction */
    static LOADSHELLDIRECTION: number;
/** Type Mass Scale */
    static MASSSCALE: number;
/** Subtype Material Number (of type Material Property) */
    static MATERIALNUMBER: number;
/** Type Material Properties */
    static MATLPROPS: number;
/** Subtype Max Internal Angle (of type Element Quality) */
    static MAXINTANGLE: number;
/** Subtype Min Internal Angle (of type Element Quality) */
    static MININTANGLE: number;
/** Subtype Min Length (of type Element Quality) */
    static MINLENGTH: number;
/** Type Part Mass */
    static PARTMASS: number;
/** Subtype % Added Mass (of type Mass Scale) */
    static PERCENTADDEDMASS: number;
/** Subtype % Added Mass #Part (of type Mass Scale) */
    static PERCENTADDEDMASSPART: number;
/** Subtype Plastic Strain (of type Element Property) */
    static PLASTICSTRAIN: number;
/** Subtype Poisson's Ratio (of type Material Property) */
    static POISSONRATIO: number;
/** Subtype Tet Collapse (of type Element Quality) */
    static QUALIMPERF: number;
/** Subtype % remaining (of type Shell Thickness) */
    static REMAINING: number;
/** Type Shell Normals */
    static SHELLNORMALS: number;
/** Type Shell Thickness */
    static SHELLTHICKNESS: number;
/** Subtype Skew (native) (of type Element Quality) */
    static SKEW: number;
/** Subtype Struct Mass (of type (*)EMP Parts Only) */
    static STRUCTMASS: number;
/** Subtype Taper (of type Element Quality) */
    static TAPER: number;
/** Subtype Formulation (of type Element Quality) */
    static TETCOLLAPSE: number;
/** Subtype % thinning (of type Shell Thickness) */
    static THINNING: number;
/** Type TimeStep */
    static TIMESTEP: number;
/** Subtype Vector (of type Shell Normals) */
    static VECTOR: number;
/** Subtype Warpage (of type Element Quality) */
    static WARPAGE: number;
/** XY axis projection */
    static XY: number;
/** XZ axis projection */
    static XZ: number;
/** Subtype Yield Stress (of type Material Property) */
    static YIELDSTRESS: number;
/** Subtype Young's Modulus (of type Material Property) */
    static YOUNGMODULUS: number;
/** YZ axis projection */
    static YZ: number;
}

declare class Widget {
/**
 * Adds a WidgetItem to the Widget. Also see Widget.RemoveAllWidgetItems and Widget.RemoveWidgetItem.
 * @param item WidgetItem to add
 * @param position Position on Widget to add the WidgetItem. Any existing WidgetItems will be shifted down as required. If omitted the WidgetItem will be added to the end of the existing ones. Note that positions start at 0.
 */
    AddWidgetItem(item: WidgetItem, position?: number): void;

/**
 * Draws a circle on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The coordinates are local to the Widget, not the Window. See properties xResolution and yResolution for more details. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().
 * @param colour Colour of circle. See foreground for colours.
 * @param fill If circle should be filled or not.
 * @param xc x coordinate of centre of circle.
 * @param yc y coordinate of centre of circle.
 * @param radius radius of circle.
 */
    Circle(colour: number, fill: boolean, xc: number, yc: number, radius: number): void;

/**
 * Clears any graphics on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().
 */
    Clear(): void;

/**
 * Clears selection of any WidgetItems on the widget. Only possible for Widget.COMBOBOX and Widget.LISTBOX widgets.
 */
    ClearSelection(): void;

/**
 * Draws a cross symbol on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets.
 * @param colour Colour of cross symbol. See foreground for colours. If omitted, current foreground colour is used.
 */
    Cross(colour?: number): void;

/**
 * Check to see if the Ctrl key is pressed
 */
    static CtrlPressed(): boolean;

/**
 * Deletes the widget from PRIMER (removing it from the window it is defined in) and returns any memory/resources used for the widget. This function should not normally need to be called. However, sometimes a script may want to recreate widgets in a window many times and unless the old widgets are deleted PRIMER will reach the maximum number of widgets for a window (Options.max_widgets). To avoid this problem this method can be used to force PRIMER to delete and return the resources for a widget. Do not use the Widget object after calling this method.
 */
    Delete(): void;

/**
 * Draws a directory icon on the widget. Only possible for Widget.BUTTON widgets.
 * @param line_colour Colour of lines of folder (only used in the old UI - in the new UI it will be ignored, a standard icon is always used). See foreground for colours.
 * @param fill_colour Colour of fill of folder (only used in the old UI - in the new UI it will be ignored, a standard icon is always used). See foreground for colours.
 */
    DirectoryIcon(line_colour: number, fill_colour: number): void;

/**
 * Dumps a string representation of an image for a widget to a file in a form that can be used by Widget.ReadImageString(). Only possible for Widget.LABEL and Widget.BUTTON widgets.
 * @param filename Filename to dump string representation to
 * @param format Can be Widget.RGB8 or Widget.RGB24. Before version 15 PRIMER only used 8 bits to store RGB (red, green and blue) colour information for widget images. In version 15 widget images have been changed to use 24 bits to store RGB information (8 bits for red, 8 bits for green and 8 bits for blue). Both formats are supported. If omitted the new Widget.RGB24 format will be used. See Widget.ReadImageString() for more details.
 */
    DumpImageString(filename: string, format?: number): void;

/**
 * Hides the widget on the screen
 */
    Hide(): void;

/**
 * Returns the WidgetItem object used at index in this Widget. See also Widget.TotalItems() and Widget.WidgetItems().
 * @param index index to return WidgetItem for. Note that indices start at 0.
 */
    ItemAt(index: number): WidgetItem;

/**
 * Draws a line on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The coordinates are local to the Widget, not the Window. See properties xResolution and yResolution for more details. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().
 * @param colour Colour of line. See foreground for colours.
 * @param x1 x coordinate of start of line.
 * @param y1 y coordinate of start of line.
 * @param x2 x coordinate of end of line.
 * @param y2 y coordinate of end of line.
 */
    Line(colour: number, x1: number, y1: number, x2: number, y2: number): void;

/**
 * Returns the number of pixels per unit coordinate. This will vary depending on the monitor PRIMER is running on.
 */
    static PixelsPerUnit(): number;

/**
 * Draws a polygon on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The coordinates are local to the Widget, not the Window. See properties xResolution and yResolution for more details. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().
 * @param colour Colour of polygon. See foreground for colours.
 * @param fill If polygon should be filled or not.
 * @param x1 x coordinate of point 1.
 * @param y1 y coordinate of point 1.
 * @param x2 x coordinate of point 2.
 * @param y2 y coordinate of point 2.
 * @param ...vars_xn x coordinate of point n.
 * @param ...vars_yn y coordinate of point n.
 */
    Polygon(colour: number, fill: boolean, x1: number, y1: number, x2: number, y2: number, ...vars_xn: number[], ...vars_yn: number[]): void;

/**
 * Reads an image from a file to show on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The image will be shown on the widget underneath any text. Note that due to the way that colours are used for menus in PRIMER only a small number of colours are available for Widget images. Black and white images will display without any issues but colour images will be displayed with a reduced set of colours.
 * @param filename Image file (BMP, GIF, JPEG or PNG) to read. To remove an image use null.
 * @param justify Widget justification. Can be a bitwise or of Widget.LEFT, Widget.RIGHT or Widget.CENTRE and Widget.TOP, Widget.MIDDLE or Widget.BOTTOM. Additionally Widget.SCALE can be used to scale the image (either reducing or enlarging it) so that it fills the widget. If omitted the default is Widget.CENTRE|Widget.MIDDLE without scaling.
 * @param transparent Transparent colour. Must be a colour returned by Colour.RGB() in PRIMER. If given then this colour will be replaced by a transparent colour. i.e. the widget background colour will be shown. If omitted or null no transparency will be used.
 * @param tolerance Tolerance for transparent colour (0-255). Any pixels in the image that have a red, green and blue colour value within tolerance of the transparent colour will be transparent. For example if the transparent colour was given as Colour.RGB(255, 0, 0) and tolerance is 0 only pixels which have red value 255 and green value 0 and blue value 0 will be made transparent. If tolerance is 4, pixels which have red values between 251 and 255 and green values between 0 and 4 and blue values between 0 and 4 will be made transparent. If omitted a value of 8 will be used.
 */
    ReadImageFile(filename: string, justify?: number, transparent?: number, tolerance?: number): void;

/**
 * Reads an image from a JavaScript string previously created by Widget.DumpImageString() to show on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The image will be shown on the widget underneath any text. Note, prior to version 15 of PRIMER only a small number of colours were available for Widget images. In version 14 and earlier the RGB (red, green and blue) information for each pixel in the image was packed into a single byte (8 bits) with 3 bits for red, 3 for green and 2 for blue. Widget.DumpImageString() always returned the string beginning with "RRRGGGBB_RLE" which is this 8 bit format with run length encoding. This is format Widget.RGB8. In version 15 support for Widget images was enhanced to give 24bit support for colours. The RGB information for each pixel has 8 bits for red, 8 bits for green and 8 bits for blue. This is format Widget.RGB24. From version 15 Widget.DumpImageString() can either return the the old 8 bit format Widget.RGB8 (string beginning with "RRRGGGBB_RLE") or return the the new 24bit format Widget.RGB24 (string beginning with "RGB24_Z"). ReadImageString supports both formats.
 * @param string String containing the image data previously created by Widget.DumpImageString(). To remove an image use null.
 * @param justify Widget justification. Can be a bitwise or of Widget.LEFT, Widget.RIGHT or Widget.CENTRE and Widget.TOP, Widget.MIDDLE or Widget.BOTTOM. Additionally Widget.SCALE can be used to scale the image (either reducing or enlarging it) so that it fills the widget. If omitted the default is Widget.CENTRE|Widget.MIDDLE without scaling.
 * @param transparent Transparent colour. Must be a colour returned by Colour.RGB() in PRIMER. If given then this colour will be replaced by a transparent colour. i.e. the widget background colour will be shown. If omitted or null no transparency will be used.
 * @param tolerance Tolerance for transparent colour (0-255). Only used for the new 24bit format Widget.RGB24 (strings beginning with "RGB24_Z"). Ignored for the old 8 bit format Widget.RGB8 (strings beginning with "RRRGGGBB_RLE"). Any pixels in the image that have a red, green and blue colour value within tolerance of the transparent colour will be transparent. For example if the transparent colour was given as Colour.RGB(255, 0, 0) and tolerance is 0 only pixels which have red value 255 and green value 0 and blue value 0 will be made transparent. If tolerance is 4, pixels which have red values between 251 and 255 and green values between 0 and 4 and blue values between 0 and 4 will be made transparent. If omitted a value of 8 will be used.
 */
    ReadImageString(string: string, justify?: number, transparent?: number, tolerance?: number): void;

/**
 * Draws a rectangle on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets. The coordinates are local to the Widget, not the Window. See properties xResolution and yResolution for more details. Note that the widget graphics will only be updated when the widget is redrawn. This is to allow the user to do multiple drawing commands on a widget. To force the widget to be redrawn call Show().
 * @param colour Colour of rectangle. See foreground for colours.
 * @param fill If rectangle should be filled or not.
 * @param x1 x coordinate of first corner of rectangle.
 * @param y1 y coordinate of first corner of rectangle.
 * @param x2 x coordinate of second (opposite) corner of rectangle.
 * @param y2 y coordinate of second (opposite) corner of rectangle.
 */
    Rectangle(colour: number, fill: boolean, x1: number, y1: number, x2: number, y2: number): void;

/**
 * Removes any WidgetItems from the Widget. Also see Widget.AddWidgetItem and Widget.RemoveWidgetItem.
 */
    RemoveAllWidgetItems(): void;

/**
 * Removes a WidgetItem from the Widget. Also see Widget.AddWidgetItem and Widget.RemoveAllWidgetItems.
 * @param item WidgetItem to remove
 */
    RemoveWidgetItem(item: WidgetItem): void;

/**
 * Check to see if the Shift key is pressed
 */
    static ShiftPressed(): boolean;

/**
 * Shows the widget on the screen
 */
    Show(): void;

/**
 * Windows have two different regions for Widgets. A 'normal' region which can be scrolled if required (if the window is made smaller scrollbars will be shown which can be used to scroll the contents) and a 'static' region at the top of the Window which is fixed and does not scroll. For an example of a static region in a Window see any of the keyword editing panels. The 'Dismiss', 'Create', 'Reset' etc buttons are in the static region. By default Widgets are put into the normal region of the Window. This method puts the Widget to the static region of the Window.
 */
    Static(): void;

/**
 * Returns the length of a string in Widget units. This can be used to find what size a Widget must be to be able to display the string.
 * @param text Text to find the width of
 * @param monospace If true then width will be calculated using a monospace font. If false (default) then the normal proportional width font will be used
 * @param fontSize Calculation can be based on a defined font size, at the moment support is added only for font sizes of 6, 7, 8, 10, 12, 14, 18 and 24.
 */
    static StringLength(text: string, monospace?: boolean, fontSize?: number): number;

/**
 * Draws a tick symbol on the widget. Only possible for Widget.LABEL and Widget.BUTTON widgets.
 * @param colour Colour of tick symbol. See foreground for colours. If omitted, current foreground colour is used.
 */
    Tick(colour?: number): void;

/**
 * Returns the number of the WidgetItem objects used in this Widget (or 0 if none used). See also Widget.ItemAt() and Widget.WidgetItems().
 */
    TotalItems(): number;

/**
 * Returns an array of the WidgetItem objects used in this Widget (or null if none used). See also Widget.ItemAt() and Widget.TotalItems().
 */
    WidgetItems(): WidgetItem[];

/**
 * Create a new Widget object.
 * @param window Window or PopupWindow that widget will be created in
 * @param type Widget type. Can be Widget.LABEL, Widget.BUTTON, Widget.CHECKBOX, Widget.COMBOBOX, Widget.LISTBOX, Widget.TEXTBOX or Widget.SLIDER.
 * @param left left coordinate of widget
 * @param right right coordinate of widget
 * @param top top coordinate of widget
 * @param bottom bottom coordinate of widget
 * @param text Text to show on widget (optional for LABEL, BUTTON and TEXTBOX, not required for CHECKBOX, COMBOBOX, LISTBOX and SLIDER)
 */
    constructor(window: Window | PopupWindow, type: number, left: number, right: number, top: number, bottom: number, text?: string);

/** If widget is active (true) or disabled (false) */
    active: boolean;
/** Whether arrows will be shown for a slider (default is true). Slider Widgets only. */
    arrows: boolean;
/** Widget background colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY, Widget.ORANGE, Widget.DEFAULT, Widget.COLOUR_NEUTRAL, Widget.COLOUR_CONTRAST, Widget.COLOUR_CONTRAST_2, Widget.COLOUR_WARNING, Widget.COLOUR_SAFE, Widget.COLOUR_TITLE, Widget.COLOUR_INVERSE, Widget.DARKGREY_NEUTRAL, Widget.LIGHTGREY_NEUTRAL ,or a colour returned by Colour.RGB(). Note, background colours in the Window.THEME_DARK, Window.THEME_LIGHT, and Window.THEME_CLASSIC themes will be determined by the category of the widget not the background colour. To override this behaviour and use this background colour first set the widget category to Widget.NO_CATEGORY. */
    background: number;
/** Widget bottom coordinate */
    bottom: number;
/** The button category which determines the button's appearance when using the new user interface, see Window.Theme() */
    category: number;
/** Widget font size in points. Currently only supports the following sizes: 6, 7, 8, 10, 12, 14, 18, 24. Can be used only with Widget.LABEL and Widget.BUTTON. Both LATIN1 and UTF-8 encoding is supported on Windows but Linux only supports LATIN1 encoding at the moment. */
    fontSize: number;
/** Widget foreground colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY, Widget.ORANGE, Widget.DEFAULT, Widget.COLOUR_NEUTRAL, Widget.COLOUR_CONTRAST, Widget.COLOUR_CONTRAST_2, Widget.COLOUR_WARNING, Widget.COLOUR_SAFE, Widget.COLOUR_TITLE, Widget.COLOUR_LABEL, Widget.COLOUR_INVERSE, Widget.DARKGREY_NEUTRAL, Widget.LIGHTGREY_NEUTRAL ,or a colour returned by Colour.RGB(). */
    foreground: number;
/** Widget hover text */
    hover: string;
/** Height of widget image (pixels) */
    readonly imageHeight: number;
/** Width of widget image (pixels) */
    readonly imageWidth: number;
/** Widget justification. Can be: Widget.LEFT, Widget.RIGHT or Widget.CENTRE (default). */
    justify: number;
/** Widget left coordinate */
    left: number;
/** Width of lines when drawing graphics (initially 1; values 1-255 allowed). */
    lineWidth: number;
/** Tag to use for this widget when recording a macro. If empty then the text property value will be used. */
    macroTag: string;
/** The maximum value allowed for a slider (default is 100). Slider Widgets only. */
    maximum: number;
/** The minimum value allowed for a slider (default is 0). Slider Widgets only. */
    minimum: number;
/** true if the widget uses a monospace font instead of a proportional width font (default). Label and button Widgets only. */
    monospace: boolean;
/** Function to call when the text in a TEXTBOX widget, the selection in a COMBOBOX widget or the value of a SLIDER is changed. The Widget object is accessible in the function using the 'this' keyword (see the example below for more details of how to define the function and how to use the 'this' keyword). To unset the function set the property to null. Note that this function is called when the user actually types something into the textbox, selects an item in the combobox or moves the slider, NOT when the Widget.text or Widget.value property changes. */
    onChange: () => void;
/** Function to call when a BUTTON, LABEL, CHECKBOX or COMBOBOX widget is clicked. The Widget object is accessible in the function using the 'this' keyword (see the example below for more details of how to define the function and how to use the 'this' keyword). To unset the function set the property to null. Note that this function is called when the user actually clicks on the button, NOT when the Widget.pushed property changes. For the COMBOBOX widget the function is called before the list of items is mapped. */
    onClick: () => void;
/** Function to call when a BUTTON, LABEL or TEXTBOX widget is right clicked to map a popup. The Widget object is accessible in the function using the 'this' keyword. The PopupWindow can then be found by using the popupWindow property of the Widget. The function is called before the popup is mapped so you can change the widgets in the popup as required. */
    onPopup: () => void;
/** Function to call for a widget when timerDelay ms have elapsed after setting this. Additionally if timerRepeat is set this function will be called repetitively, every timerDelay ms. The Widget object is accessible in the function using the 'this' keyword. To unset the function set the property to null. Note that as soon as this property is set the timer starts! */
    onTimer: () => void;
/** The orientation of a slider. Can be: Widget.VERTICAL or Widget.HORIZONTAL (default). Slider Widgets only. */
    orientation: number;
/** How PopupWindow will be mapped relative to this widget. Can be Widget.LEFT, Widget.RIGHT, Widget.TOP or Widget.BOTTOM (default). */
    popupDirection: number;
/** TRUE (default) if a symbol will be shown for a PopupWindow. */
    popupSymbol: boolean;
/** PopupWindow for this Widget. Only available for Button, Label and Textbox Widgets. To remove a PopupWindow from a Widget set to null. */
    popupWindow: PopupWindow;
/** If widget is pushed (true) or not (false). This only affects Widget.BUTTON with the Widget.toggle property set, and Widget.CHECKBOX widgets. */
    pushed: boolean;
/** Widget right coordinate */
    right: number;
/** Selection method for ListBox Widgets. Can be: Widget.SELECT_NONE, Widget.SELECT_SINGLE or Widget.SELECT_MULTIPLE or Widget.SELECT_ENHANCED (default). */
    select: number;
/** WidgetItem that is currently selected for a ComboBox Widget. If null no WidgetItem is selected. For a ListBox Widget this property contains the last WidgetItem that was (de)selected. To get a list of all of the selected WidgetItems use WidgetItems() to return all of the WidgetItems and inspect the WidgetItem selected property. */
    selectedItem: WidgetItem;
/** true if the widget is visible. To alter the visibility of a widget use the Show() and Hide() methods. */
    readonly shown: boolean;
/** The step value of a slider (default is 1). Slider Widgets only. */
    step: number;
/** Widget text. For a ComboBox Widget this will be the text for the currently selected WidgetItem */
    text: string;
/** true if the widget text is hidden and replaced by asterisks. This may be used to create textboxes to type passwords in. TextBox Widgets only. */
    textHidden: boolean;
/** Delay in ms before the function set for onTimer will be called. The initial value is 1000 (ms). Also see timerRepeat. */
    timerDelay: number;
/** If the function set for onTimer will be called once (false) or repeatedly (true). The initial value is false. Also see timerDelay. */
    timerRepeat: boolean;
/** If widget can be toggled (true) or not (false). This only affects Widget.BUTTON widgets. */
    toggle: boolean;
/** Widget top coordinate */
    top: number;
/** Type of the widget */
    type: number;
/** The current value of a slider (initially will be the minimum value). Slider Widgets only. */
    value: number;
/** The Window that this widget is defined in */
    readonly window: Window;
/** X resolution of button when drawing lines, circles, polygons and rectangles (initially 100). X coordinates on the Widget can be from 0 (on the left of the widget) to xResolution (on the right of the widget). Available for Widget.LABEL and Widget.BUTTON Widgets. */
    xResolution: number;
/** Y resolution of button when drawing lines, circles, polygons and rectangles (initially 100). Y coordinates on the Widget can be from 0 (on the top of the widget) to yResolution (on the bottom of the widget). Available for Widget.LABEL and Widget.BUTTON Widgets. */
    yResolution: number;
/** Colour black */
    static BLACK: number;
/** Colour blue */
    static BLUE: number;
/** Bottom justification */
    static BOTTOM: number;
/** Button widget */
    static BUTTON: number;
/** Apply buttons */
    static CATEGORY_APPLY: number;
/** A button box panel that contains other widgets */
    static CATEGORY_BUTTON_BOX: number;
/** Buttons which cancel the current operation */
    static CATEGORY_CANCEL: number;
/** Header for data entry cells, e.g. PRIMER create panels */
    static CATEGORY_DATA_ENTRY_HEADER: number;
/** Buttons to close or dismiss panels */
    static CATEGORY_DISMISS: number;
/** Entity types in T/HIS */
    static CATEGORY_ENTITY: number;
/** A generic button that isn't a special category */
    static CATEGORY_GENERIC: number;
/** An alternative to the generic category that has a complementary colour */
    static CATEGORY_GENERIC_2: number;
/** Help buttons */
    static CATEGORY_HELP: number;
/** A PRIMER keyword button */
    static CATEGORY_KEYWORD: number;
/** A text label */
    static CATEGORY_LABEL: number;
/** Text label with a border */
    static CATEGORY_LABEL_BOX: number;
/** Text label with a popup that blends into the background */
    static CATEGORY_LABEL_POPUP: number;
/** A menu box */
    static CATEGORY_MENU_BOX: number;
/** For displaying a temporary warning message */
    static CATEGORY_MESSAGE: number;
/** Operate buttons in T/HIS */
    static CATEGORY_OPERATE: number;
/** A popup box that can contain buttons and plain text */
    static CATEGORY_POPUP_BOX: number;
/** Buttons (usually green) to indicate a safe action */
    static CATEGORY_SAFE_ACTION: number;
/** Select all */
    static CATEGORY_SEL_ALL: number;
/** Tab */
    static CATEGORY_TAB: number;
/** Table (column) header */
    static CATEGORY_TABLE_HEADER: number;
/** Table row */
    static CATEGORY_TABLE_ROW: number;
/** A text box */
    static CATEGORY_TEXT_BOX: number;
/** A tick box */
    static CATEGORY_TICKBOX: number;
/** Title text */
    static CATEGORY_TITLE: number;
/** Buttons that can be toggled, e.g. On/Off */
    static CATEGORY_TOGGLE: number;
/** Buttons within the tools area */
    static CATEGORY_TOOL: number;
/** Buttons which undo the last operation */
    static CATEGORY_UNDO: number;
/** Unselect/deslect all */
    static CATEGORY_UNSEL_ALL: number;
/** Update buttons which update the screen but leave the panel open */
    static CATEGORY_UPDATE: number;
/** Buttons (usually red) to indicate a dangerous action */
    static CATEGORY_WARNING_ACTION: number;
/** Centre (horizontal) justification */
    static CENTRE: number;
/** Checkbox widget */
    static CHECKBOX: number;
/** A contrasting colour in the 3 user interface themes (Green, Purple, and Blue in the Dark, Light, and Classic themes respectively). Blue in the legacy theme. */
    static COLOUR_CONTRAST: number;
/** Another contrasting colour in the 3 user interface themes (Yellow, Red, and Red in the Dark, Light, and Classic themes respectively). Red in the legacy theme. */
    static COLOUR_CONTRAST_2: number;
/** Inverse colour in the 3 user interface themes (Black or white depending on theme). Black in the legacy theme. */
    static COLOUR_INVERSE: number;
/** Label text colour in the 3 user interface themes (Black or white depending on theme). Black in the legacy theme. */
    static COLOUR_LABEL: number;
/** Neutral colour in the 3 user interface themes (Different shade of grey in every theme). Light grey in the legacy theme. */
    static COLOUR_NEUTRAL: number;
/** Safe colour in the 3 user interface themes (Different shade of green in every theme). Dark green in the legacy theme. */
    static COLOUR_SAFE: number;
/** Title colour in the 3 user interface themes (Different shade of grey in every theme). Dark blue in the legacy theme. */
    static COLOUR_TITLE: number;
/** Warning colour in the 3 user interface themes (Different shade of red in every theme). Dark red in the legacy theme. */
    static COLOUR_WARNING: number;
/** Combobox widget */
    static COMBOBOX: number;
/** Colour cyan */
    static CYAN: number;
/** Colour dark blue */
    static DARKBLUE: number;
/** Colour dark green */
    static DARKGREEN: number;
/** Colour dark grey */
    static DARKGREY: number;
/** Only valid in the function 'Line'. Used to keep the 3D effect in the legacy theme and not in the other themes. Neutral colour in the 3 user interface themes (Different shade of grey in every theme). Dark grey in the legacy theme */
    static DARKGREY_NEUTRAL: number;
/** Colour dark red */
    static DARKRED: number;
/** Default colour for widgets */
    static DEFAULT: number;
/** Colour green */
    static GREEN: number;
/** Colour grey */
    static GREY: number;
/** Horizontal orientation (for sliders) */
    static HORIZONTAL: number;
/** Label widget */
    static LABEL: number;
/** Left justification */
    static LEFT: number;
/** Colour light grey */
    static LIGHTGREY: number;
/** Only valid in the function 'Line'. Used to keep the 3D effect in the legacy theme and not in the other themes. Neutral colour in the 3 user interface themes (Different shade of grey in every theme). Light grey in the legacy theme */
    static LIGHTGREY_NEUTRAL: number;
/** Listbox widget */
    static LISTBOX: number;
/** Colour magenta */
    static MAGENTA: number;
/** Middle (vertical) justification */
    static MIDDLE: number;
/** No styling is applied. Widget colour controlled by foreground/background properties and is the same in all themes */
    static NO_CATEGORY: number;
/** Colour orange */
    static ORANGE: number;
/** Colour red */
    static RED: number;
/** 24 bits for RGB data in widget images */
    static RGB24: number;
/** 8 bits for RGB data in widget images */
    static RGB8: number;
/** Right justification */
    static RIGHT: number;
/** Image will be scaled to fit widget */
    static SCALE: number;
/** Multiple WidgetItems in a ListBox Widget can be selected. When the user selects a WidgetItem the selection is cleared and the new WidgetItem selected. However, if the user presses the Ctrl key when clicking on a WidgetItem, the clicked WidgetItem gets toggled and all other WidgetItems are left untouched. If the user presses the Shift key while clicking on a WidgetItem, all WidgetItems between the last selected WidgetItem and the clicked WidgetItem are selected or unselected, depending on the state of the clicked WidgetItem. */
    static SELECT_ENHANCED: number;
/** Multiple WidgetItems in a ListBox Widget can be selected. When the user selects a WidgetItem, the selection status of that WidgetItem is toggled and the other WidgetItems are left alone. */
    static SELECT_MULTIPLE: number;
/** No WidgetItem in a ListBox Widget can be selected */
    static SELECT_NONE: number;
/** A single WidgetItem in a ListBox Widget can be selected. When the user selects a WidgetItem, any already-selected WidgetItem becomes unselected, and the user cannot unselect the selected WidgetItem by clicking on it. */
    static SELECT_SINGLE: number;
/** Slider widget */
    static SLIDER: number;
/** Text input widget */
    static TEXTBOX: number;
/** Top justification */
    static TOP: number;
/** Vertical orientation (for sliders) */
    static VERTICAL: number;
/** Colour white */
    static WHITE: number;
/** Colour yellow */
    static YELLOW: number;
}

declare class WidgetItem {
/**
 * Create a new WidgetItem object.
 * @param widget Widget that widget item will be created in. This can be null in which case the WidgetItem will be created but not assigned to a Widget. It can be assigned later by using Widget.AddWidgetItem().
 * @param text Text to show on widget item
 * @param selectable If the widget item can be selected. If omitted the widget item will be selectable.
 */
    constructor(widget: Widget, text: string, selectable?: boolean);

/** Widget background colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY or Widget.DEFAULT */
    background: number;
/** Widget foreground colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY or Widget.DEFAULT */
    foreground: number;
/** WidgetItem's hover text */
    hover: string;
/** The index of this widgetitem in the parent widget (undefined if widgetitem is not assigned to a widget). */
    readonly index: number;
/** true if the widgetitem uses a monospace font instead of a proportional width font (default). */
    monospace: boolean;
/** Function to call when a widget item in a COMBOBOX or LISTBOX widget is clicked. The Widgetitem object is accessible in the function using the 'this' keyword. */
    onClick: () => void;
/** Function to call when the mouse moves over a widget item in a COMBOBOX or LISTBOX widget. The Widgetitem object is accessible in the function using the 'this' keyword. */
    onMouseOver: () => void;
/** If the widget item can be selected (true) or not (false). */
    selectable: boolean;
/** If the widget item is selected (true) or not (false). */
    selected: boolean;
/** Widget text */
    text: string;
/** The widget that this item is defined for (null if not set) */
    readonly widget: object;
}

declare class Window {
/**
 * Returns the vertical position of the bottom border (in range 0-1). This can be used to help position windows on the screen.
 */
    static BottomBorder(): number;

/**
 * Deletes the window from PRIMER and returns any memory/resources used for the window. This function should not normally need to be called. However, in exceptional circumstances if a script recreates windows many times PRIMER may run out of USER objects on Microsoft Windows because of the way PRIMER creates and shows windows. To avoid this problem this method can be used to force PRIMER to return the resources for a window. Do not use the Window object after calling this method.
 */
    Delete(): void;

/**
 * Show an error message in a window.
 * @param title Title for window.
 * @param error Error message to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.
 * @param buttons The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted an OK button will be used. By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.
 */
    static Error(title: string, error: string, buttons?: number): number;

/**
 * Map the directory selector box native to your machine, allowing you to choose a directory. On Unix this will be a Motif selector. Windows will use the standard windows directory selector.
 * @param initial Initial directory to start from.
 */
    static GetDirectory(initial?: string): string;

/**
 * Map a file selector box allowing you to choose a file. See also Window.GetFiles() and Window.GetFilename().
 * @param extension Extension to filter by.
 * @param save If true the file selector is to be used for saving a file. If false (default) the file selector is for opening a file. Due to native operating system file selector differences, on linux new filenames can only be given when saving a file. On windows it is possible to give new filenames when opening or saving a file.
 * @param initial Initial directory to start from.
 */
    static GetFile(extension?: string, save?: boolean, initial?: string): string;

/**
 * Map a window allowing you to input a filename (or select it using a file selector). OK and Cancel buttons are shown. See also Window.GetFile().
 * @param title Title for window.
 * @param message Message to show in window.
 * @param extension Extension to filter by.
 * @param initial Initial value.
 * @param save If true the file selector is to be used for saving a file. If false (default) the file selector is for opening a file. Due to native operating system file selector differences, on linux new filenames can only be given when saving a file. On windows it is possible to give new filenames when opening or saving a file.
 */
    static GetFilename(title: string, message: string, extension?: string, initial?: string, save?: boolean): string;

/**
 * Map a file selector box allowing you to choose multiple files. See also Window.GetFile() and Window.GetFilename().
 * @param extension Extension to filter by.
 */
    static GetFiles(extension?: string): string[];

/**
 * This function returns the current position of the graphics window.
 */
    static GetGraphicsWindowPosition(): number[];

/**
 * Map a window allowing you to input an integer. OK and Cancel buttons are shown.
 * @param title Title for window.
 * @param message Message to show in window.
 * @param initial Initial value.
 */
    static GetInteger(title: string, message: string, initial?: number): number;

/**
 * Map a window allowing you to input a number. OK and Cancel buttons are shown.
 * @param title Title for window.
 * @param message Message to show in window.
 * @param initial Initial value.
 */
    static GetNumber(title: string, message: string, initial?: number): number;

/**
 * Map a window allowing you to input a string. OK and Cancel buttons are shown.
 * @param title Title for window.
 * @param message Message to show in window.
 * @param initial Initial value.
 */
    static GetString(title: string, message: string, initial?: string): string;

/**
 * Hides (unmaps) the window.
 */
    Hide(): void;

/**
 * Show information in a window.
 * @param title Title for window.
 * @param info Information to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.
 * @param buttons The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted an OK button will be used. By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.
 */
    static Information(title: string, info: string, buttons?: number): number;

/**
 * Returns the resolution of the master programme window in pixels
 */
    static MasterResolution(): number[];

/**
 * Show a message in a window.
 * @param title Title for window.
 * @param message Message to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.
 * @param buttons The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted an OK button will be used By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.
 */
    static Message(title: string, message: string, buttons?: number): number;

/**
 * Returns the vertical position of the middle border (in range 0-1). The middle border is the border between the tools/keywords window and the docked windows. This can be used to help position windows on the screen.
 */
    static MiddleBorder(): number;

/**
 * Show a question in a window.
 * @param title Title for window.
 * @param question Question to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.
 * @param buttons The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted Yes and No button will be used. By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.
 */
    static Question(title: string, question: string, buttons?: number): number;

/**
 * Recomputes the positions of widgets in the window. If you have static widgets and 'normal' widgets in a window and you show and/or hide widgets the window needs to be recomputed to refresh the graphics, scroll bars etc. Calling this method will recompute and redraw the window.
 */
    Recompute(): void;

/**
 * Redraws the window. Sometimes if you show, hide or draw graphics on widgets the window needs to be redrawn to refresh the graphics. Calling this method will redraw the window refreshing the graphics.
 */
    Redraw(): void;

/**
 * Returns the horizontal position of the right border (in range 0-1). This can be used to help position windows on the screen.
 */
    static RightBorder(): number;

/**
 * This function allows you to move or resize the graphics window.
 * @param left left coordinate of graphics window in range 0.0 (left) to 1.0 (right)
 * @param right right coordinate of graphics window in range 0.0 (left) to 1.0 (right)
 * @param bottom bottom coordinate of graphics window in range 0.0 (bottom) to 1.0 (top)
 * @param top top coordinate of graphics window in range 0.0 (bottom) to 1.0 (top)
 */
    static SetGraphicsWindowPosition(left: number, right: number, bottom: number, top: number): void;

/**
 * This function allows you to resize the graphics window.
 * @param width Width of the graphics window in pixels
 * @param height Height of the graphics window in pixels
 */
    static SetGraphicsWindowSize(width: number, height: number): void;

/**
 * Shows (maps) the window and waits for user input.
 * @param modal If this window is modal (true) then the user is blocked from doing anything else in PRIMER until this window is dismissed). If non-modal (false) then the user can still use other functions in PRIMER. If omitted the window will be modal. Note that making a window modal will stop interaction in all other windows and may prevent operations such as picking from working in any macros that are run from scripts.
 */
    Show(modal?: boolean): void;

/**
 * Set or get a user interface theme.
 * @param theme If it is provided it is used to set the current theme. Can be either Window.USE_OLD_UI_JS, Window.THEME_CURRENT, Window.THEME_DARK, Window.THEME_LIGHT, Window.THEME_CLASSIC.
 */
    static Theme(theme?: number): number;

/**
 * Returns the vertical position of the top border (in range 0-1). This can be used to help position windows on the screen. This is no longer used in PRIMER and will always be 1 but is left for backwards compatibility.
 */
    static TopBorder(): number;

/**
 * Force GUI to be updated. This function is not normally needed but if you are doing a computationally expensive operation and want to update the GUI it may be necessary as the GUI update requests are cached until there is spare time to update them. Calling this function forces any outstanding requests to be flushed.
 */
    static UpdateGUI(): void;

/**
 * Show a warning message in a window.
 * @param title Title for window.
 * @param warning Warning message to show in window. The maximum number of lines that can be shown is controlled by the Options.max_window_lines option.
 * @param buttons The buttons to use. Can be bitwise OR of Window.OK, Window.CANCEL, Window.YES or Window.NO. If this is omitted an OK button will be used. By default the window will be modal. If Window.NONMODAL is also given the window will be non-modal instead.
 */
    static Warning(title: string, warning: string, buttons?: number): number;

/**
 * Create a new Window object.
 * @param title Window title to show in title bar
 * @param left left coordinate of window in range 0.0 (left) to 1.0 (right)
 * @param right right coordinate of window in range 0.0 (left) to 1.0 (right)
 * @param bottom bottom coordinate of window in range 0.0 (bottom) to 1.0 (top)
 * @param top top coordinate of window in range 0.0 (bottom) to 1.0 (top)
 */
    constructor(title: string, left: number, right: number, bottom: number, top: number);

/** If true (default) then the window then the window is active and widgets in the window can be used. If false then the window is inactive and the widgets cannot be used. */
    active: boolean;
/** Window background colour. Can be: Widget.BLACK, Widget.WHITE, Widget.RED, Widget.GREEN, Widget.BLUE, Widget.CYAN, Widget.MAGENTA, Widget.YELLOW, Widget.DARKRED, Widget.DARKGREEN, Widget.DARKBLUE, Widget.GREY, Widget.DARKGREY, Widget.LIGHTGREY or Widget.DEFAULT ,or a colour returned by Colour.RGB(). */
    background: number;
/** bottom coordinate of window in range 0.0 (bottom) to 1.0 (top) */
    bottom: number;
/** height of window */
    height: number;
/** If true then the window will be kept "on top" of other windows. If false (default) then the window stacking order can be changed. */
    keepOnTop: boolean;
/** left coordinate of window in range 0.0 (left) to 1.0 (right) */
    left: number;
/** The maximum number of widgets that can be made in this window. This can be changed before the window is created by using Options.max_widgets. Also see totalWidgets */
    readonly maxWidgets: number;
/** Function to call after a Window is shown. The Window object is accessible in the function using the 'this' keyword. This may be useful to ensure that certain actions are done after the window is shown. It can also be used to show another window so this enables multiple windows to be shown. To unset the function set the property to null. */
    onAfterShow: () => void;
/** Function to call before a Window is shown. The Window object is accessible in the function using the 'this' keyword. This may be useful to ensure that buttons are shown/hidden etc before the window is shown. Note that it cannot be used to show another window. Use onAfterShow for that. To unset the function set the property to null. */
    onBeforeShow: () => void;
/** Function to call when a Window is closed by pressing the X on the top right of the window. The Window object is accessible in the function using the 'this' keyword. To unset the function set the property to null. */
    onClose: () => void;
/** Window resizing. By default when a Window is shown it is allowed to resize on all sides (left, right, top and bottom) to try to make enough room to show the Widgets. The behaviour can be changed by using this property. It can be any combination (bitwise OR) of Window.LEFT, Window.RIGHT, Window.TOP or Window.BOTTOM or 0. In addition Window.REDUCE can also be added to allow the window to reduce in size when resizing. Note that when Window.Show is called this property is set to 0 (i.e. not to resize on any side). */
    resize: number;
/** right coordinate of window in range 0.0 (left) to 1.0 (right) */
    right: number;
/** If true (default) then a close (X) button will automatically be added on the top right of the window. If false then no close button will be shown. */
    showClose: boolean;
/** true if window is currently shown, false if not */
    readonly shown: boolean;
/** Window title */
    title: string;
/** top coordinate of window in range 0.0 (bottom) to 1.0 (top) */
    top: number;
/** The total number of widgets that have been made in this window. This can be changed before the window is created by using Options.max_widgets. Also see maxWidgets */
    readonly totalWidgets: number;
/** width of window */
    width: number;
/** Bottom resizing/positioning of window */
    static BOTTOM: number;
/** Show CANCEL button */
    static CANCEL: number;
/** Centre (horizontal) positioning of window */
    static CENTRE: number;
/** Left resizing/positioning of window */
    static LEFT: number;
/** Middle (vertical) positioning of window */
    static MIDDLE: number;
/** Show NO button */
    static NO: number;
/** Allow Window.Error, Window.Question, Window.Warning etc windows to be non modal */
    static NONMODAL: number;
/** Show OK button */
    static OK: number;
/** Window is allowed to reduce in size when resizing */
    static REDUCE: number;
/** Right resizing/positioning of window */
    static RIGHT: number;
/** Use the Classic theme (Note: Not only the script will use this theme, the whole interface of the program will switch to classic) */
    static THEME_CLASSIC: number;
/** Use the current theme */
    static THEME_CURRENT: number;
/** Use the Dark theme (Note: Not only the script will use this theme, the whole interface of the program will switch to dark) */
    static THEME_DARK: number;
/** Use the Light theme (Note: Not only the script will use this theme, the whole interface of the program will switch to light) */
    static THEME_LIGHT: number;
/** Top resizing/positioning of window */
    static TOP: number;
/** Use the original, pre v17, theme (default). (Note:The interface of the program will NOT switch to old) */
    static USE_OLD_UI_JS: number;
/** Show YES button */
    static YES: number;
}

declare class XMLParser {
/**
 * starts parsing an XML file
 * @param filename XML file to parse
 */
    Parse(filename: string): void;

/**
 * Create a new XMLParser object for reading XML files.
 */
    constructor();

/** Function to call when character data is found. The function will be called with 1 argument which is a string containing the character data */
    characterDataHandler: () => void;
/** Function to call when a comment is found. The function will be called with 1 argument which is a string containing the text inside the comment */
    commentHandler: () => void;
/** Function to call at the end of a CDATA section. The function does not have any arguments. */
    endCDATAHandler: () => void;
/** Function to call when an element end tag is found. The function will be called with 1 argument which is a string containing the name of the element */
    endElementHandler: () => void;
/** Function to call at the start of a CDATA section. The function does not have any arguments. */
    startCDATAHandler: () => void;
/** Function to call when an element start tag is found. The function will be called with 2 arguments. Argument 1 is a string containing the name of the element. Argument 2 is an object containing the element attributes */
    startElementHandler: () => void;
}

declare class XlsxWorkbook {
/**
 * Close a Xlsx file
 */
    Close(): void;

/**
 * Create a new XlsxWorkbook object for writing xlsx files.
 * @param filename Filename of the xlsx file you want to write. The file will be overwritten (if it exists).
 */
    constructor(filename: string);

/** Name of the xlsx file */
    readonly filename: string;
}

declare class XlsxWorksheet {
/**
 * Add an image to the Xlsx file. Note that the image will not actually be read/inserted until the workbook is written by calling XlsxWorkbook.Close so you must make sure the image file exists until then.
 * @param row The row in the xlsx file (rows start at zero)
 * @param column The column in the xlsx file (columns start at zero)
 * @param filename Name of the image file you want to add to the xlsx file. The image can be in png or jpeg format.
 */
    AddImage(row: number, column: number, filename: string): void;

/**
 * Add number to the Xlsx file
 * @param row The row in the xlsx file (rows start at zero)
 * @param column The column in the xlsx file (columns start at zero)
 * @param value Number you want to add to the xlsx file
 */
    AddNumber(row: number, column: number, value: number): void;

/**
 * Add text to the Xlsx file
 * @param row The row in the xlsx file (rows start at zero)
 * @param column The column in the xlsx file (columns start at zero)
 * @param text Text you want to add to the xlsx file
 */
    AddText(row: number, column: number, text: string): void;

/**
 * Set the column properties in the worksheet
 * @param column The column in the xlsx file (columns start at zero)
 * @param width Width of the column to set
 */
    SetColumnProperties(column: number, width: number): void;

/**
 * Set the row properties in the worksheet
 * @param row The row in the xlsx file (rows start at zero)
 * @param height Height of the row to set
 */
    SetRowProperties(row: number, height: number): void;

/**
 * Create a new XlsxWorksheet object for writing xlsx files.
 * @param workbook The workbook to create the worksheet in.
 * @param name The name of the worksheet. If omitted the default names 'Sheet1', 'Sheet2' etc will be used.
 */
    constructor(workbook: XlsxWorkbook, name?: string);

}

declare class Xrefs {
/**
 * Returns the ID of the item in the reference list.
 * @param type The type of the item in the reference list (for a list of types see Appendix I of the PRIMER manual).
 * @param pos The position in the list for this item. Note that positions start at 0, not 1
 */
    GetItemID(type: string, pos: number): number;

/**
 * Returns the type of the item in the reference list. This function is only required when trying to look at cross references to *DEFINE_CURVE items. These items are used in a slightly different way in PRIMER (each time a curve is used a 'LOADCURVE REFERENCE' structure is created to store things like the units and descriptions of each axis for the curve). If you try to get the cross references for a curve all the references will be of type 'LOADCURVE REFERENCE' and numtypes will be 1. GetItemID() will correctly return the ID of the item from the 'LOADCURVE REFERENCE' structure but to get the type of the item this function is required.
 * @param type The type of the item in the reference list (for a list of types see Appendix I of the PRIMER manual).
 * @param pos The position in the list for this item. Note that positions start at 0, not 1
 */
    GetItemType(type: string, pos: number): string;

/**
 * Returns the total number of references of a type.
 * @param type The type of the item in the reference list (for a list of types see Appendix I of the PRIMER manual).
 */
    GetTotal(type: string): number;

/**
 * Returns the type for
 * @param n The entry in the reference types that you want the type for. Note that entries start at 0, not 1
 */
    GetType(n: number): string;

/** The number of different types that this item is referenced by. (read only) */
    readonly numtypes: number;
/** The total number of cross references of all types to this item. (read only) */
    readonly total: number;
}


/** Object returned by Information */
interface InformationReturn {
    /** Compressed size */
    compressedSize: number;
    /** Cyclic redundancy check */
    crc: number;
    /** Filename */
    name: string;
    /** Uncompressed size */
    uncompressedSize: number;
}

declare class Zip {
/**
 * Add a file to the Zip file
 * @param filename Name of the file you want to add to the zip file
 * @param zipname Name to give the file in the zip file
 */
    AddFile(filename: string, zipname: string): void;

/**
 * Close a Zip file
 */
    Close(): void;

/**
 * Gets information for the current entry in the Zip file such as name, size etc
 */
    Information(): InformationReturn;

/**
 * Go to the next entry in the Zip file
 */
    Next(): boolean;

/**
 * Reads the current entry to a file from the Zip file
 * @param filename Name of the file you want to create
 */
    ReadFile(filename: string): void;

/**
 * Create a new Zip object for reading/writing zip files.
 * @param filename Filename of the zip file you want to read/write. If reading (Zip.READ) or appending (Zip.APPEND), the file must exist. If writing (Zip.WRITE) the file will be overwritten (if it exists).
 * @param mode The mode to open the file with. Can be Zip.READ, Zip.WRITE or Zip.APPEND.
 */
    constructor(filename: string, mode: number);

/** Name of the zip file */
    readonly filename: string;
/** Mode the zip file was opened with (Zip.READ, Zip.WRITE or Zip.APPEND) */
    readonly mode: number;
/** Flag to open zip file for appending */
    static APPEND: number;
/** Flag to open zip file for reading */
    static READ: number;
/** Flag to open zip file for writing */
    static WRITE: number;
}


/** Object returned by Execute */
interface ExecuteReturn {
    /** The exit code from the program/script */
    status: number;
    /** The standard error output from the program/script */
    stderr: string;
    /** The standard output from the program/script */
    stdout: string;
}


/** Object function argument in Execute */
interface ExecuteArgument_data {
    /** The arguments to pass to program */
    arguments?: string[];
    /** The program you want to run */
    program: string;
}

/**
 * Allocate a flag for use in the script. See also ReturnFlag() and Model.PropagateFlag(). Once allocated the flag is automatically cleared for all the models currently in PRIMER.
 */
declare function AllocateFlag(): number;

/**
 * Check if PRIMER is running in batch mode (i.e. menus are not active)
 */
declare function BatchMode(): boolean;

/**
 * Set the function for dialogue callback. This function can be used to make PRIMER return any dialogue messages that are printed. This may be useful for you to know if a particular dialogue message has been printed or a particular event has taken place. The function will be called with 1 argument which is a string containing the dialogue message. To remove the dialogue function use DialogueFunction(null).
 * @param name The name of the function (or null to remove the function)
 */
declare function DialogueFunction(name: () => void): void;

/**
 * Execute one or more lines of command line dialogue input.
 * @param ...strings The command(s) that are to be executed as if they had been typed into the dialogue box
 */
declare function DialogueInput(...strings: One | string[]): number;

/**
 * Execute one or more lines of command line dialogue input with no echo of commands to dialogue box.
 * @param ...strings The command(s) that are to be executed as if they had been typed into the dialogue box
 */
declare function DialogueInputNoEcho(...strings: One | string[]): number;

/**
 * Print an error message to the dialogue box adding a carriage return.
 * @param string The string/item that you want to print
 */
declare function ErrorMessage(string: any): void;

/**
 * Execute a program or script outside PRIMER and get the standard output and error streams.
 * @param data Execute data
 */
declare function Execute(data: ExecuteArgument_data): ExecuteReturn;

/**
 * Exit script
 */
declare function Exit(): void;

/**
 * Number of flags available to be used for AllocateFlag()
 */
declare function FlagsAvailable(): number;

/**
 * Get the current working directory
 */
declare function GetCurrentDirectory(): string;

/**
 * Get the directory in which executables are installed. This is the OA_INSTALL environment variable, or if that is not set the directory in which the current executable is installed. Returns NULL if not found
 */
declare function GetInstallDirectory(): string;

/**
 * Get the Preference value with the given string in the any of admin ("OA_ADMIN") or install ("OA_INSTALL") or home ("OA_HOME") directory oa_pref
 * @param program The program name string : Valid values are 'All', 'D3Plot', 'Primer', 'Reporter', 'Shell','T/His'
 * @param name The preference name string
 */
declare function GetPreferenceValue(program: string, name: string): string;

/**
 * Get the directory passed to PRIMER by the -start_in command line argument
 */
declare function GetStartInDirectory(): string;

/**
 * Get the value of an environment variable
 * @param name The environment variable name
 */
declare function Getenv(name: string): string;

/**
 * Set or get labelling of items in PRIMER
 * @param type The type of the item (for a list of types see Appendix I of the PRIMER manual). Additionally, to change the visibility of attached or unattached nodes you can use the types "ATTACHED_NODE" and "UNATTACHED_NODE".
 * @param state If it is provided it is used to set the labelling status of entity. "true" to make items labelled and "false" to make them not labelled.
 */
declare function Labels(type: string, state?: boolean): boolean;

/**
 * Set the function for macro callback. This function can be used to make PRIMER return the macro command that would be recorded if macro recording was active for every button press etc. This may be useful for you to know if a particular action has been done by the user. The function will be called with 1 argument which is a string containing the macro command. To remove the macro function use MacroFunction(null).
 * @param name The name of the function (or null to remove a function)
 */
declare function MacroFunction(name: () => void): void;

/**
 * Print a message to the dialogue box adding a carriage return.
 * @param string The string/item that you want to print. If '\r' is added to the end of the string then instead of automatically adding a carriage return in the dialogue box, the next message will overwrite the current one. This may be useful for giving feedback to the dialogue box when doing an operation.
 */
declare function Message(string: any): void;

/**
 * Pause execution of the script for time milliseconds. See also Sleep()
 * @param time Number of milliseconds to pause for
 */
declare function MilliSleep(time: number): void;

/**
 * Formats a number to a string with the specified width.
 * @param number The number you want to format.
 * @param width The width of the string you want to format it to (must be less than 80).
 * @param pref_int By default only integer values inside the single precision 32 bit signed integer limit of approximately +/-2e9 are formatted as integers, all other numeric values are formatted as floats. With this argument set to TRUE then integer values up to the mantissa precision of a 64 bit float, approximately +/-9e15, will also be formatted as integers.
 */
declare function NumberToString(number: number, width: number, pref_int?: boolean): string;

/**
 * Play a macro in PRIMER
 * @param filename The name of the macro file to play
 * @param options Options specifying how the macro file should be replayed. If omitted the default values below will be used. The properties available are: pick [logical] If picks/drags from the macro file should be replayed. If omitted the current value from macro window will be used. view [logical] If views encoded in the macro file for picks/drags should be replayed. If omitted the current value from macro window will be used. delay [integer] Delay in ms between commands when replaying. If omitted the current value from macro window will be used. variables [object] Object containing names and values for variables in the macro. If null or omitted no variables are used. terminate [logical] If the script should be terminated if an error occurs when playing the macro. If omitted the script will be terminated. utf8 [logical] If the script is UTF-8 encoded. If omitted or false the script is assumed to be ASCII text.
 */
declare function PlayMacro(filename: string, options?: object): boolean;

/**
 * Print a string to stdout. Note that a carriage return is not added.
 * @param string The string/item that you want to print
 */
declare function Print(string: any): void;

/**
 * Print a string to stdout adding a carriage return.
 * @param string The string/item that you want to print
 */
declare function Println(string: any): void;

/**
 * Checks to see if the build number of PRIMER is high enough to run this script. If your script requires features that are only present in builds of PRIMER greater than a certain value Require can test this and only run the script if the build is high enough.
 * @param build The minimum build number that is required.
 */
declare function Requires(build: number): void;

/**
 * Return a flag used in the script. See also AllocateFlag() and Model.PropagateFlag().
 * @param flag The flag to return.
 */
declare function ReturnFlag(flag: number): void;

/**
 * Run a script
 * @param filename The name of the script file to run. If the filename is relative then the file will be searched for relative to this script. If not found then the script_directory preference will be used.
 * @param separate If the script will use separate memory from the current script. If it uses separate memory (true) then the 'child' script is completely separated from this script and knows nothing about variables in this script. If it does not use separate memory (false) then the 'child' script will have access to all of the variables in the current script and hence variables must not clash. It is strongly recommended that you use namespaces to stop variable names from clashing. If omitted the script will use separate memory.
 */
declare function RunScript(filename: string, separate?: boolean): void;

/**
 * Sets the current working directory.
 * @param directory_path Path to the directory you would like to change into.
 */
declare function SetCurrentDirectory(directory_path: string): boolean;

/**
 * Save the preference string and its value into oa_pref of home directory. If the preference is locked in admin ("OA_ADMIN") or install ("OA_INSTALL") oa_pref, then API is unsuccessful. Home directory is defined by environment variable OA_HOME. If OA_HOME is not defined then API is unsuccessful.
 * @param program The program name string : Valid values are 'All', 'D3Plot', 'Primer', 'Reporter', 'Shell','T/His'
 * @param name The preference name string
 * @param value The preference value string. If "value" is of zero length, then the option is simply removed from the file if present, and no new entry is made.This argument cannot be null.
 * @param refresh If the saved preference should be refreshed. If omitted, the preference will NOT be refreshed. This argument is currently only available in Primer JS API and ignored in D3PLOT and T/HIS.
 */
declare function SetPreferenceValue(program: string, name: string, value: string, refresh?: boolean): number;

/**
 * Pause execution of the script for time seconds. See also MilliSleep()
 * @param time Number of seconds to pause for
 */
declare function Sleep(time: number): void;

/**
 * Do a system command outside PRIMER. To run an external command and get the output then please use Execute() instead.
 * @param string The system command that you want to do
 */
declare function System(string: any): number;

/**
 * Test whether script is running on a Unix/Linux operating system. See also Windows()
 */
declare function Unix(): boolean;

/**
 * Use script from a separate file
 * @param filename Use allows you to include a script from a separate file. This may be useful if your script is very large and you want to split it up to help with maintenance. Alternatively you may have a 'library' of common functions which you always want to include in your scripts. Including the 'library' with Use means that any changes only have to be done in one place. Primer will look for the file in the same directory as the main script. If that fails then it will look in $OA_INSTALL/primer_library/scripts directory and the script directory specified by the primer*script_directory preference. Note that the file is included when the script is compiled, NOT at runtime.
 */
declare function Use(filename: string): void;

/**
 * Create a UUID (Universally unique ID)
 */
declare function UuidCreate(): string;

/**
 * Set or get visibility of items in PRIMER
 * @param type The type of the item (for a list of types see Appendix I of the PRIMER manual). Additionally, to change the visibility of attached or unattached nodes you can use the types "ATTACHED_NODE" and "UNATTACHED_NODE".
 * @param state If it is provided it is used to set the visibility. "true" to make items visible and "false" to make them not visible.
 */
declare function Visibility(type: string, state?: boolean): boolean;

/**
 * Print a warning message to the dialogue box adding a carriage return.
 * @param string The string/item that you want to print
 */
declare function WarningMessage(string: any): void;

/**
 * Test whether script is running on a Windows operating system. See also Unix()
 */
declare function Windows(): boolean;

